[
{"description": "This class provides default implementations for the JFC Action interface.Standard behaviors like the get and set methods for Action object properties (icon, text, and enabled) are defined here.The developer need only subclass this abstract class and define the actionPerformed method.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The AccessibleTableModelChange interface describes a change to the table model.The attributes of the model change can be obtained by the following methods: public int getType() public int getFirstRow(); public int getLastRow(); public int getFirstColumnThe model change type returned by getType() will be one of: INSERT - one or more rows and/or columns have been inserted UPDATE - some of the table data has changed DELETE - one or more rows and/or columns have been deleted The affected area of the table can be determined by the other four methods which specify ranges of rows and columns"},
{"description": "Class AccessibleTable describes a user-interface component that presents data in a two-dimensional table format."},
{"description": "The AccessibleValue interface should be supported by any object that supports a numerical value (e.g., a scroll bar).This interface provides the standard mechanism for an assistive technology to determine and set the numerical value as well as get the minimum and maximum values.Applications can determine if an object supports the AccessibleValue interface by first obtaining its AccessibleContext (see Accessible) and then calling the AccessibleContext.getAccessibleValue() method.If the return value is not null, the object supports this interface."},
{"description": "The AccessibleStreamable interface should be implemented by the AccessibleContext of any component that presents the raw stream behind a component on the display screen.Examples of such components are HTML, bitmap images and MathML.AccessibleStreamable provides two things: a list of MIME types supported by the object and a streaming interface for each MIME type to get the data."},
{"description": "This exception is thrown by LoginModules when they determine that an account has expired.For example, a LoginModule, after successfully authenticating a user, may determine that the user's account has expired.In this case the LoginModule throws this exception to notify the application.The application can then take the appropriate steps to notify the user."},
{"description": "The AccessibleText interface should be implemented by all classes that present textual information on the display.This interface provides the standard mechanism for an assistive technology to access that text via its content, attributes, and spatial location.Applications can determine if an object supports the AccessibleText interface by first obtaining its AccessibleContext (see Accessible) and then calling the AccessibleContext.getAccessibleText() method of AccessibleContext.If the return value is not null, the object supports this interface."},
{"description": "This exception may be thrown by a LoginModule if it determines that authentication is being attempted on a locked account."},
{"description": "This class collects together key details of a span of text.It is used by implementors of the class AccessibleExtendedText in order to return the requested triplet of a String, and the start and end indicies/offsets into a larger body of text that the String comes from."},
{"description": "Class AccessibleStateSet determines a component's state set.The state set of a component is a set of AccessibleState objects and descriptions.E.G., The current overall state of the object, such as whether it is enabled, has focus, etc."},
{"description": "This AccessibleSelection interface provides the standard mechanism for an assistive technology to determine what the current selected children are, as well as modify the selection set.Any object that has children that can be selected should support the AccessibleSelection interface.Applications can determine if an object supports the AccessibleSelection interface by first obtaining its AccessibleContext (see Accessible) and then calling the AccessibleContext.getAccessibleSelection() method.If the return value is not null, the object supports this interface."},
{"description": "Class AccessibleState describes a component's particular state.The actual state of the component is defined as an AccessibleStateSet, which is a composed set of AccessibleStates.The toDisplayString method allows you to obtain the localized string for a locale independent key from a predefined ResourceBundle for the keys defined in this class.The constants in this class present a strongly typed enumeration of common object roles.A public constructor for this class has been purposely omitted and applications should use one of the constants from this class.If the constants in this class are not sufficient to describe the role of an object, a subclass should be generated from this class and it should provide constants in a similar manner."},
{"description": "Class AccessibleRole determines the role of a component.The role of a component describes its generic function.The toDisplayString method allows you to obtain the localized string for a locale independent key from a predefined ResourceBundle for the keys defined in this class.The constants in this class present a strongly typed enumeration of common object roles.A public constructor for this class has been purposely omitted and applications should use one of the constants from this class.If the constants in this class are not sufficient to describe the role of an object, a subclass should be generated from this class and it should provide constants in a similar manner."},
{"description": "This class is deprecated as of version 1.3 of the Java Platform."},
{"description": "Unchecked exception thrown when an attempt is made to register a channel with a selector that was not created by the provider that created the channel."},
{"description": "Focus traversal is done in response to a Component's focus traversal keys, and using a Container's FocusTraversalPolicy."},
{"description": "This often means that the data is invalid in and of itself, from the perspective of the MIDI specification.An example would be an undefined status byte.However, the exception might simply mean that the data was invalid in the context it was used, or that the object to which the data was given was unable to parse or use it.For example, a file reader might not be able to parse a Type 2 MIDI file, even though that format is defined in the MIDI specification."},
{"description": "Arc2D is the abstract superclass for all objects that store a 2D arc defined by a framing rectangle, start angle, angular extent (length of the arc), and a closure type (OPEN, CHORD, or PIE).The arc is a partial section of a full ellipse which inscribes the framing rectangle of its parent RectangularShape.The angles are specified relative to the non-square framing rectangle such that 45 degrees always falls on the line from the center of the ellipse to the upper right corner of the framing rectangle.As a result, if the framing rectangle is noticeably longer along one axis than the other, the angles to the start and end of the arc segment will be skewed farther along the longer axis of the frame.The actual storage representation of the coordinates is left to the subclass."},
{"description": "The abstract class MenuComponent is the superclass of all menu-related components.In this respect, the class MenuComponent is analogous to the abstract superclass Component for AWT components.Menu components receive and process AWT events, just as components do, through the method processEvent."},
{"description": "A MethodDescriptor describes a particular method that a Java Bean supports for external access from other components."},
{"description": "The MenuBar class encapsulates the platform's concept of a menu bar bound to a frame.This is what a menu bar might look like: A menu bar handles keyboard shortcuts for menu items, passing them along to its child menus.(Keyboard shortcuts, which are optional, provide the user with an alternative to the mouse for invoking a menu item and the action that is associated with it.)Each menu item can maintain an instance of MenuShortcut.The MenuBar class defines several methods, shortcuts() and getShortcutMenuItem(java.awt.that retrieve information about the shortcuts a given menu bar is managing."},
{"description": "A Menu object is a pull-down menu component that is deployed from a menu bar.A menu can optionally be a tear-off menu.A tear-off menu can be opened and dragged away from its parent menu bar or menu.It remains on the screen after the mouse button has been released.The mechanism for tearing off a menu is platform dependent, since the look and feel of the tear-off menu is determined by its peer.On platforms that do not support tear-off menus, the tear-off property is ignored.Each item in a menu must belong to the MenuItem class.It can be an instance of MenuItem, a submenu (an instance of Menu), or a check box (an instance of CheckboxMenuItem)."},
{"description": "A MemoryUsage object represents a snapshot of memory usage.Instances of the MemoryUsage class are usually constructed by methods that are used to obtain memory usage information about individual memory pool of the Java virtual machine or the heap or non-heap memory of the Java virtual machine as a whole.A MemoryUsage object contains four values: init represents the initial amount of memory (in bytes) that the Java virtual machine requests from the operating system for memory management during startup.The Java virtual machine may request additional memory from the operating system and may also release memory to the system over time.The value of init may be undefined.used represents the amount of memory currently used (in bytes).committed represents the amount of memory (in bytes) that is guaranteed to be available for use by the Java virtual machine.The amount of committed memory may change over time (increase or decrease).The Java virtual machine may release memory to the system and committed could be less than init.max represents the maximum amount of memory (in bytes) that can be used for memory management.The maximum amount of memory may change over time if defined.The amount of used and committed memory will always be less than or equal to max if max is defined.A memory allocation may fail if it attempts to increase the used memory such that used > committed even if used <=max would still be true (for example, when the system is low on virtual memory).Below is a picture showing an example of a memory pool:+----------------------------------------------+ |--------| init |---------------| used |---------------------------| committed |----------------------------------------------| max MXBean Mapping MemoryUsage is mapped to a CompositeData with attributes as specified in the from method."},
{"description": "This exception is thrown by methods to indicate that a binding cannot be added because the name is already bound to another object.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "This interface provides methods for getting the local and namespace-qualified names and also for getting the prefix associated with the namespace for the name.It is also possible to get the URI of the namespace.The following is an example of a namespace declaration in an element.(\"xmlns\" stands for \"XML namespace\".)The following shows what the methods in the Name interface will return.getQualifiedName will return \"prefix:LocalName\" =:GetLastTradePrice\" getURI will return \"http://www.wombat.org/trader\" getLocalName will return \"GetLastTracePrice\" getPrefix will return \"WOMBAT\" XML namespaces are used to disambiguate SOAP identifiers from application-specific identifiers.Name objects are created using the method SOAPEnvelope.createName, which has two versions.One method creates Name objects with a local name, a namespace prefix, and a namespace URI.and the second creates Name objects with just a local name.The following line of code, in which se is a SOAPEnvelope object, creates a new Name object with all three.The following line of code gives an example of how a Name object can be used.The variable element is a SOAPElement object.This code creates a new SOAPElement object with the given name and adds it to element.element.addChildElement(name); The Name interface may be deprecated in a future release of SAAJ in favor of javax.xml.namespace.QName"},
{"description": "The Name interface represents a generic name -- an ordered sequence of components.It can be a composite name (names that span multiple namespaces), or a compound name (names that are used within individual hierarchical naming systems).There can be different implementations of Name; for example, composite names, URLs, or namespace-specific compound names.The components of a name are numbered.The indexes of a name with N components range from 0 up to, but not including, N. This range may be written as [0,N).The most significant component is at index 0.An empty name has no components.None of the methods in this interface accept null as a valid value for a parameter that is a name or a name component.Likewise, methods that return a name or name component never return null.An instance of a Name may not be synchronized against concurrent multithreaded access if that access is not read-only."},
{"description": "When created by the same implementation, objects implementing this interface must obey the general equals contract when compared with each other.Therefore, Name objects from the same implementation are usable in collections while Names from different implementations may not work properly in collections.An empty Name has a length of zero.In the context of annotation processing, the guarantees for \"the same\" implementation must include contexts where the API mediated side effects of processors could be visible to each other, including successive annotation processing rounds."},
{"description": "By default, an interface is an MXBean interface if it is public and its name ends with MXBean, as in SomethingMXBean.The following interfaces are MXBean interfaces: public interface WhatsitMXBean {} @MXBean public interface Whatsit1Interface {} @MXBean(true)The following interfaces are not MXBean interfaces: interface NonPublicInterfaceNotMXBean{} public interface Whatsit3Interface{} @MXBean(false)The MXBean concept provides a simple way to code an MBean that only references a predefined set of types, the ones defined by javax.management.openmbean.In this way, you can be sure that your MBean will be usable by any client, including remote clients, without any requirement that the client have access to model-specific classes representing the types of your MBeans.The concepts are easier to understand by comparison with the Standard MBean concept.Here is how a managed object might be represented as a Standard MBean, and as an MXBean:The only difference is that the convention for naming the interface is to use SomethingMXBean for MXBeans, rather than SomethingMBean for Standard MBeans.In this managed object, there is an attribute called Usage of type MemoryUsage.The point of an attribute like this is that it gives a coherent snapshot of a set of data items.For example, it might include the current amount of used memory in the memory pool, and the current maximum of the memory pool.If these were separate items, obtained with separate getAttribute calls, then we could get values seen at different times that were not consistent.We might get a used value that was greater than the max value.So, we might define MemoryUsage like this: Standard MBeanMXBean public class MemoryUsage implements Serializable { // standard JavaBean conventions with getters public MemoryUsage(long init, long used, long committed, long max) {...} long getInit() {...} long getUsed() {...}} The definitions are the same in the two cases, except that with the MXBean, MemoryUsage no longer needs to be marked Serializable (though it can be).On the other hand, we have added a @ConstructorProperties annotation to link the constructor parameters to the corresponding getters.We will see more about this below.MemoryUsage is a model-specific class.With Standard MBeans, a client of the MBean Server cannot access the Usage attribute if it does not know the class MemoryUsage.Suppose the client is a generic console based on JMX technology.Then the console would have to be configured with the model-specific classes of every application it might connect to.The problem is even worse for clients that are not written in the Java language.Then there may not be any way to tell the client what a MemoryUsage looks like.This is where MXBeans differ from Standard MBeans.Although we define the management interface in almost exactly the same way, the MXBean framework converts model-specific classes into standard classes from the Java platform.Using arrays and the CompositeData and TabularData classes from the standard javax.management.openmbean package, it is possible to build data structures of arbitrary complexity using only standard classes.This becomes clearer if we compare what the clients of the two models might look like:(Long) usage.get(\"used\"); For attributes with simple types like String, the code is the same.But for attributes with complex types, the Standard MBean code requires the client to know the model-specific class MemoryUsage, while the MXBean code requires no non-standard classes.The client code shown here is slightly more complicated for the MXBean client.But, if the client does in fact know the model, here the interface MemoryPoolMXBean and the class MemoryUsage, then it can construct a proxy.This is the recommended way to interact with managed objects when you know the model beforehand, regardless of whether you are using Standard MBeans or MXBeans:(); Implementing the MemoryPool object works similarly for both Standard MBeans and MXBeans.MemoryPoolMXBean { public String getName() {...} public MemoryUsage getUsage() {...} // ...} Registering the MBean in the MBean Server works in the same way in both cases:An MXBean is a kind of MBean.An MXBean object can be registered directly in the MBean Server, or it can be used as an argument to StandardMBean and the resultant MBean registered in the MBean Server.When an object is registered in the MBean Server using the registerMBean or createMBean methods of the MBeanServer interface, the object's class is examined to determine what type of MBean it is: If the class implements the interface DynamicMBean then the MBean is a Dynamic MBean.Note that the class StandardMBean implements this interface, so this case applies to a Standard MBean or MXBean created using the class StandardMBean.Otherwise, if the class matches the Standard MBean naming conventions, then the MBean is a Standard MBean.Otherwise, it may be an MXBean.The set of interfaces implemented by the object is examined for interfaces that: have a class name SMXBean where S is any non-empty string, and do not have an annotation @MXBean(false); and/or have an annotation @MXBean(true) or just @MXBean.If there is exactly one such interface, or if there is one such interface that is a subinterface of all the others, then the object is an MXBean.The interface in question is the MXBean interface.In the example above, the MXBean interface is MemoryPoolMXBean.If none of these conditions is met, the MBean is invalid and the attempt to register it will generate NotCompliantMBeanException.Every Java type that appears as the parameter or return type of a method in an MXBean interface must be convertible using the rules below.An attempt to construct an MXBean that does not conform to the above rules will produce an exception.Naming conventions The same naming conventions are applied to the methods in an MXBean as in a Standard MBean:A method T getN(), where T is a Java type (not void) and N is a non-empty string, specifies that there is a readable attribute called N. The Java type and Open type of the attribute are determined by the mapping rules below.The method final Class getClass() inherited from Object is ignored when looking for getters.A method boolean isN() specifies that there is a readable attribute called N with Java type boolean and Open type SimpleType.A method void setN(T x) specifies that there is a writeable attribute called N. The Java type and Open type of the attribute are determined by the mapping rules below.x of the parameter is irrelevant.)Every other method specifies that there is an operation with the same name as the method.The Java type and Open type of the return value and of each parameter are determined by the mapping rules below.The rules for getN and isN collectively define the notion of a getter.The rule for setN defines the notion of a setter.It is an error for there to be two getters with the same name, or two setters with the same name.If there is a getter and a setter for the same name, then the type T in both must be the same.In this case the attribute is read/write.If there is only a getter or only a setter, the attribute is read-only or write-only respectively.Type mapping rules An MXBean is a kind of Open MBean, as defined by the javax.management.openmbean package.This means that the types of attributes, operation parameters, and operation return values must all be describable using Open Types, that is the four standard subclasses of OpenType.MXBeans achieve this by mapping Java types into Open Types.For every Java type J, the MXBean mapping is described by the following information: The corresponding Open Type, opentype(J).This is an instance of a subclass of OpenType.The mapped Java type, opendata(J), which is always the same for any given opentype(J).This is a Java class.How a value is converted from type J to type opendata(J).How a value is converted from type opendata(J) to type J, if it can be.For example, for the Java type List<String>: The Open Type, opentype(List<String>), is ArrayType(1, SimpleType.The mapped Java type, opendata(List<String>), is String[].A List<String> can be converted to a String[] using List.toArray(new String[0]).A String[] can be converted to a List<String> using Arrays.asList.If no mapping rules exist to derive opentype(J) from J, then J cannot be the type of a method parameter or return value in an MXBean interface.If there is a way to convert opendata(J) back to J then we say that J is reconstructible.All method parameters in an MXBean interface must be reconstructible, because when the MXBean framework is invoking a method it will need to convert those parameters from opendata(J) to J.In a proxy generated by JMX.newMXBeanProxy, it is the return values of the methods in the MXBean interface that must be reconstructible.Null values are allowed for all Java types and Open Types, except primitive Java types where they are not possible.When converting from type J to type opendata(J) or from type opendata(J) to type J, a null value is mapped to a null value.The following table summarizes the type mapping rules.opentype(J) opendata(J) int, boolean, etc (the 8 primitive Java types) SimpleType.; this includes int[][], where E is int[]) ArrayType.getArrayType(opentype(E))An enumeration E (declared in Java as enum E {...}) SimpleType.The following sections give further details of these rules.The 8 primitive Java types (boolean, byte, short, int, long, float, double, char) are mapped to the corresponding boxed types from java.lang, namely Boolean, Byte, etc.The Open Type is the corresponding SimpleType.Thus, opentype(long) is SimpleType.LONG, and opendata(long) is java.lang.Long.An array of primitive type such as long[] can be represented directly as an Open Type.In practice, the difference between a plain int and Integer, etc, does not show up because operations in the JMX API are always on Java objects, not primitives.However, the difference does show up with arrays.A List<E> or Set<E>, such as List<String> or Set<ObjectName>, is mapped in the same way as an array of the same element type, such as String[] or ObjectName[].A SortedSet<E> is also mapped in the same way as an E[], but it is only convertible if E is a class or interface that implements Comparable.The conversion of a SortedSet instance will fail with an IllegalArgumentException if it has a non-null comparator().A List<E> is reconstructed as a java.util.ArrayList<E>;A Map<K,V> or SortedMap<K,V>, for example Map<String,ObjectName>, has Open Type TabularType and is mapped to a TabularData.The TabularType has two items called key and value.The Open Type of key is opentype(K), and the Open Type of value is opentype(V).The index of the TabularType is the single item key.For example, the TabularType for a Map<String,ObjectName> might be constructed with code like this:; The typeName here is determined by the type name rules detailed below.A SortedMap<K,V> is mapped in the same way, but it is only convertible if K is a class or interface that implements Comparable.The conversion of a SortedMap instance will fail with an IllegalArgumentException if it has a non-null comparator().A Map<K,V> is reconstructed as a java.util.HashMap<K,V>; a SortedMap<K,V> as a java.util.TreeMap<K,VTabularData is an interface.The concrete class that is used to represent a Map<K,V> as Open Data is TabularDataSupport, or another class implementing TabularData that serializes as TabularDataSupport.Mappings for MXBean interfaces An MXBean interface, or a type referenced within an MXBean interface, can reference another MXBean interface, J. Then opentype(J) is SimpleType.OBJECTNAME and opendata(J) is ObjectName.For example, suppose you have two MXBean interfaces like this: public interface ProductMXBean { public ModuleMXBean[] getModules();}public interface ModuleMXBean { public ProductMXBean getProduct();} The object implementing the ModuleMXBean interface returns from its getProduct method an object implementing the ProductMXBean interface.The ModuleMXBean object and the returned ProductMXBean objects must both be registered as MXBeans in the same MBean Server.The method ModuleMXBean.getProduct() defines an attribute called Product.The Open Type for this attribute is SimpleType.OBJECTNAME, and the corresponding ObjectName value will be the name under which the referenced ProductMXBean is registered in the MBean Server.If you make an MXBean proxy for a ModuleMXBean and call its getProduct() method, the proxy will map the ObjectName back into a ProductMXBean by making another MXBean proxy.More formally, when a proxy made with JMX.newMXBeanProxy(mbeanServerConnection, objectNameX, interfaceX) needs to map objectNameY back into interfaceY, another MXBean interface, it does so with JMX.newMXBeanProxy(mbeanServerConnection, objectNameY, interfaceY).The implementation may return a proxy that was previously created by a call to JMX.newMXBeanProxy with the same parameters, or it may create a new proxy.The reverse mapping is illustrated by the following change to the ModuleMXBean interface: public interface ModuleMXBean { public ProductMXBean getProduct(); public void setProduct(ProductMXBean c);} The presence of the setProduct method now means that the Product attribute is read/write.As before, the value of this attribute is an ObjectName.When the attribute is set, the ObjectName must be converted into the ProductMXBean object that the setProduct method expects.This object will be an MXBean proxy for the given ObjectName in the same MBean Server.If you make an MXBean proxy for a ModuleMXBean and call its setProduct method, the proxy will map its ProductMXBean argument back into an ObjectName.This will only work if the argument is in fact another proxy, for a ProductMXBean in the same MBeanServerConnection.The proxy can have been returned from another proxy (like ModuleMXBean.getProduct() which returns a proxy for a ProductMXBean); or it can have been created by JMX.newMXBeanProxy; or it can have been created using Proxy with an invocation handler that is MBeanServerInvocationHandler or a subclass.If the same MXBean were registered under two different ObjectNames, a reference to that MXBean from another MXBean would be ambiguous.Therefore, if an MXBean object is already registered in an MBean Server and an attempt is made to register it in the same MBean Server under another name, the result is an InstanceAlreadyExistsException.Registering the same MBean object under more than one name is discouraged in general, notably because it does not work well for MBeans that are NotificationBroadcasters.Mappings for other types Given a Java class or interface J that does not match the other rules in the table above, the MXBean framework will attempt to map it to a CompositeType as follows.The type name of this CompositeType is determined by the type name rules below.The class is examined for getters using the conventions above.(Getters must be public instance methods.)If there are no getters, or if any getter has a type that is not convertible, then J is not convertible.If there is at least one getter and every getter has a convertible type, then opentype(J) is a CompositeType with one item for every getter.If the getter is T getName() then the item in the CompositeType is called name and has type opentype(T).For example, if the item is String getOwner() then the item is called owner and has Open Type SimpleType.If the getter is boolean isName() then the item in the CompositeType is called name and has type SimpleType.Notice that the first character (or code point) is converted to lower case.This follows the Java Beans convention, which for historical reasons is different from the Standard MBean convention.In a Standard MBean or MXBean interface, a method getOwner defines an attribute called Owner, while in a Java Bean or mapped CompositeType, a method getOwner defines a property or item called owner.If two methods produce the same item name (for example, getOwner and isOwner, or getOwner and getowner) then the type is not convertible.When the Open Type is CompositeType, the corresponding mapped Java type (opendata(J)) is CompositeData.The mapping from an instance of J to a CompositeData corresponding to the CompositeType just described is done as follows.First, if J implements the interface CompositeDataView, then that interface's toCompositeData method is called to do the conversion.Otherwise, the CompositeData is constructed by calling the getter for each item and converting it to the corresponding Open Data type.Thus, a getter such as List<String> getNames() will have been mapped to an item with name \"names\" and Open Type ArrayType(1, SimpleType.The conversion to CompositeData will call getNames() and convert the resultant List<String> into a String[] for the item \"names\".CompositeData is an interface.The concrete class that is used to represent a type as Open Data is CompositeDataSupport, or another class implementing CompositeData that serializes as CompositeDataSupport.If opendata(J) is CompositeData for a Java type J, then either an instance of J can be reconstructed from a CompositeData, or J is not reconstructible.If any item in the CompositeData is not reconstructible, then J is not reconstructible either.For any given J, the following rules are consulted to determine how to reconstruct instances of J from CompositeData.The first applicable rule in the list is the one that will be used.If J has a method public static J from(CompositeData cd) then that method is called to reconstruct an instance of J. Otherwise, if J has at least one public constructor with a ConstructorProperties annotation, then one of those constructors (not necessarily always the same one) will be called to reconstruct an instance of J. Every such annotation must list as many strings as the constructor has parameters; each string must name a property corresponding to a getter of J; and the type of this getter must be the same as the corresponding constructor parameter.It is not an error for there to be getters that are not mentioned in the ConstructorProperties annotation(these may correspond to information that is not needed to reconstruct the object).An instance of J is reconstructed by calling a constructor with the appropriate reconstructed items from the CompositeData.The constructor to be called will be determined at runtime based on the items actually present in the CompositeData, given that this CompositeData might come from an earlier version of J where not all the items were present.A constructor is applicable if all the properties named in its ConstructorProperties annotation are present as items in the CompositeData.If no constructor is applicable, then the attempt to reconstruct J fails.For any possible combination of properties, it must be the case that either (a) there are no applicable constructors, or (b) there is exactly one applicable constructor, or (c) one of the applicable constructors(In other words, there should never be ambiguity over which constructor to choose.)Otherwise, if J has a public no-arg constructor, and for every getter in J with type T and name N there is a corresponding setter with the same name and type, then an instance of J is constructed with the no-arg constructor and the setters are called with the reconstructed items from the CompositeData to restore the values.For example, if there is a method public List<String> getNames() then there must also be a method public void setNames(List<String> names) for this rule to apply.If the CompositeData came from an earlier version of J, some items might not be present.In this case, the corresponding setters will not be called.Otherwise, if J is an interface that has no methods other than getters, an instance of J is constructed using a Proxy with a CompositeDataInvocationHandler backed by the CompositeData being converted.Rule 2 is not applicable to subset Profiles of Java SE that do not include the java.beans package.When targeting a runtime that does not include the java.beans package, and where there is a mismatch between the compile-time and runtime environment whereby J is compiled with a public constructor and the ConstructorProperties annotation, then J is not reconstructible unless another rule applies.Here are examples showing different ways to code a type NamedNumber that consists of an int and a String.In each case, the CompositeType looks like this: CompositeType( \"NamedNumber\", // typeName \"NamedNumber\", // description new String[] {\"number\", \"name\"}, // itemNames new String[] {\"number\", \"name\"}, // itemDescriptions new OpenType[] {SimpleType.Static from method: public class NamedNumber { public int getNumber() {return number;} public String getName() {return name;} private NamedNumber(int number, String name) { this.number = number; this.name = name; } public static NamedNumber from(CompositeData cd) { return new NamedNumber((Integer) cd.get(\"number\"), (String) cd.get(\"name\")); } private final int number; private final String name;} Public constructor with} Setter for every getter: public class NamedNumber { public int getNumber() {return number;} public void setNumber(int number) {this.number = number;} public String getName() {return name;} public void setName(String name) {this.name = name;} public NamedNumber() {} private int number; private String name;} Interface with only getters: public interface NamedNumber { public int getNumber(); public String getName();} It is usually better for classes that simply represent a collection of data to be immutable.An instance of an immutable class cannot be changed after it has been constructed.Immutability has many advantages, notably with regard to thread-safety and security.So the approach using setters should generally be avoided if possible.Recursive types Recursive (self-referential) types cannot be used in MXBean interfaces.This is a consequence of the immutability of CompositeType.For example, the following type could not be the type of an attribute, because it refers to itself: public interface Node { public String getName(); public int getPriority(); public Node getNext();} It is always possible to rewrite recursive types like thisDoing so may require introducing new types.An MXBean is a type of Open MBean.However, for compatibility reasons, its MBeanInfo is not an OpenMBeanInfo.In particular, when the type of an attribute, parameter, or operation return value is a primitive type such as int, or is void (for a return type), then the attribute, parameter, or operation will be represented respectively by an MBeanAttributeInfo, MBeanParameterInfo, or MBeanOperationInfo whose getType() or getReturnType() returns the primitive name (\"int\" etc).This is so even though the mapping rules above specify that the opendata mapping is the wrapped type (Integer etc).The array of public constructors returned by MBeanInfo.getConstructors() for an MXBean that is directly registered in the MBean Server will contain all of the public constructors of that MXBean.If the class of the MXBean is not public then its constructors are not considered public either.The list returned for an MXBean that is constructed using the StandardMBean class is derived in the same way as for Standard MBeans.Regardless of how the MXBean was constructed, its constructor parameters are not subject to MXBean mapping rules and do not have a corresponding OpenType.The array of notification types returned by MBeanInfo.getNotifications() for an MXBean that is directly registered in the MBean Server will be empty if the MXBean does not implement the NotificationBroadcaster interface.Otherwise, it will be the result of calling NotificationBroadcaster.getNotificationInfo() at the time the MXBean was registered.Even if the result of this method changes subsequently, the result of MBeanInfo.getNotifications() will not.The list returned for an MXBean that is constructed using the StandardMBean or StandardEmitterMBean class is derived in the same way as for Standard MBeans.The Descriptor for all of the MBeanAttributeInfo, MBeanParameterInfo, and MBeanOperationInfo objects contained in the MBeanInfo will have a field openType whose value is the OpenType specified by the mapping rules above.So even when getType() is \"int\", getDescriptor().getField(\"openType\") will be SimpleType.The Descriptor for each of these objects will also have a field originalType that is a string representing the Java type that appeared in the MXBean interface.The format of this string is described in the section Type Names below.The Descriptor for the MBeanInfo will have a field mxbean whose value is the string \"true\".Sometimes the unmapped type T of a method parameter or return value in an MXBean must be represented as a string.If T is a non-generic type, this string is the value returned by Class.getName().Otherwise it is the value of genericstring(T), defined as follows: If T is a non-generic non-array type, genericstring(T) is the value returned by Class.getName(), for example \"int\" or \"java.lang.String\".If T is an array E[], genericstring(T) is genericstring(E) followed by \"[]\".For example, genericstring(int[]) is \"int[]\", and genericstring(List<String>[][]) is \"java.util.List<java.lang.String>[][]\".Otherwise, T is a parameterized type such as List<String> and genericstring(T)consists of the following: the fully-qualified name of the parameterized type as returned by Class.getName(); a left angle bracket (\"<\"); genericstring(A) where A is the first type parameter; if there is a second type parameter B then \", \" (a comma and a single space) followed by genericstring(B); a right angle bracket (\">\").Note that if a method returns int[], this will be represented by the string \"[I\" returned by Class.getName(), but if a method returns List<int[]>, this will be represented by the string \"java.util.List<int[]>Exceptions A problem with mapping from Java types to Open types is signaled with an OpenDataException.This can happen when an MXBean interface is being analyzed, for example if it references a type like java.util.Random that has no getters.Or it can happen when an instance is being converted (a return value from a method in an MXBean or a parameter to a method in an MXBean proxy), for example when converting from SortedSet<String> to String[] if the SortedSet has a non-null Comparator.A problem with mapping to Java types from Open types is signaled with an InvalidObjectException.This can happen when an MXBean interface is being analyzed, for example if it references a type that is not reconstructible according to the rules above, in a context where a reconstructible type is required.Or it can happen when an instance is being converted (a parameter to a method in an MXBean or a return value from a method in an MXBean proxy), for example from a String to an Enum if there is no Enum constant with that name.Depending on the context, the OpenDataException or InvalidObjectException may be wrapped in another exception such as RuntimeMBeanException or UndeclaredThrowableException.For every thrown exception, the condition C will be true:\"e is OpenDataException or InvalidObjectException (as appropriate), or C is true of e.getCause()\"."},
{"description": "The MutationEvent interface provides specific contextual information associated with Mutation events."},
{"description": "Defines the requirements for a tree node object that can change -- by adding or removing child nodes, or by changing the contents of a user object stored in the node."},
{"description": "Class NumberUp is an integer valued printing attribute class that specifies the number of print-stream pages to impose upon a single side of an instance of a selected medium.That is, if the NumberUp value is n, the printer must place n print-stream pages on a single side of an instance of the selected medium.To accomplish this, the printer may add some sort of translation, scaling, or rotation.This attribute primarily controls the translation, scaling and rotation of print-stream pages.The effect of a NumberUp attribute on a multidoc print job (a job with multiple documents) depends on whether all the docs have the same number up values specified or whether different docs have different number up values specified, and on the (perhaps defaulted) value of the MultipleDocumentHandling attribute.If all the docs have the same number up value n specified, then any value of MultipleDocumentHandling makes sense, and the printer's processing depends on the MultipleDocumentHandling value:SINGLE_DOCUMENT -- All the input docs will be combined together into one output document.Each media impression will consist of nm print-stream pages from the output document.SINGLE_DOCUMENT_NEW_SHEET -- All the input docs will be combined together into one output document.Each media impression will consist of n print-stream pages from the output document.However, the first impression of each input doc will always start on a new media sheet; this means the last impression of an input doc may have fewer than n print-stream pages on it.Each media impression will consist of n print-stream pages from the input doc.Since the input docs are separate, the first impression of each input doc will always start on a new media sheet; this means the last impression of an input doc may have fewer than n print-stream pages on it.Each media impression will consist of n print-stream pages from the input doc.Since the input docs are separate, the first impression of each input doc will always start on a new media sheet; this means the last impression of an input doc may have fewer than n print-stream pages on it.SINGLE_DOCUMENT -- All the input docs will be combined together into one output document.Each media impression will consist of ni print-stream pages from the output document, where i is the number of the input doc corresponding to that point in the output document.When the next input doc has a different number up value from the previous input doc, the first print-stream page of the next input doc goes at the start of the next media impression, possibly leaving fewer than the full number of print-stream pages on the previous media impression.SINGLE_DOCUMENT_NEW_SHEET -- All the input docs will be combined together into one output document.Each media impression will consist of n print-stream pages from the output document.However, the first impression of each input doc will always start on a new media sheet; this means the last impression of an input doc may have fewer than n print-stream pages on it.i, each media impression will consist of ni print-stream pages from the input doc.Since the input docs are separate, the first impression of each input doc will always start on a new media sheet; this means the last impression of an input doc may have fewer than ni print-stream pages on it.i, each media impression will consist of ni print-stream pages from the input doc.Since the input docs are separate, the first impression of each input doc will always start on a new media sheet; this means the last impression of an input doc may have fewer than ni print-stream pages on it.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "NumberFormatter subclasses InternationalFormatter adding special behavior for numbers.Among the specializations are (these are only used if the NumberFormatter does not display invalid numbers, for example, setAllowsInvalid(false)):(- is determined from the DecimalFormatSymbols associated with the DecimalFormat) in any field but the exponent field will attempt to change the sign of the number to positive/negative.(- is determined from the DecimalFormatSymbols associated with the DecimalFormat) in the exponent field will attempt to change the sign of the exponent to positive/negative.If you are displaying scientific numbers, you may wish to turn on overwrite mode, setOverwriteMode(true).For example: DecimalFormat decimalFormat = new DecimalFormat(\"0.000E0\"); NumberFormatter textFormatter = new NumberFormatter(decimalFormat); textFormatter.setOverwriteMode(true); textFormatter.setAllowsInvalid(false); If you are going to allow the user to enter decimal values, you should either force the DecimalFormat to contain at least one decimal (#.0###), or allow the value to be invalid setAllowsInvalid(true).Otherwise users may not be able to input decimal values.NumberFormatter provides slightly different behavior to stringToValue than that of its superclass.If you have specified a Class for values, DefaultFormatter.setValueClass(java.lang.>), that is one of of Integer, Long, Float, Double, Byte or Short and the Format's parseObject returns an instance of Number, the corresponding instance of the value class will be created using the constructor appropriate for the primitive type the value class represents.For example: setValueClass(Integer.class) will cause the resulting value to be created via new Integer(((Number)formatter.parseObject(string)).intValue()).This is typically useful if you wish to set a min/max value as the various Number implementations are generally not comparable to each other.This is also useful if for some reason you need a specific Number implementation for your values.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "An abstract class for service providers that provide concrete implementations of the NumberFormat class."},
{"description": "Defines constants that are used as attribute keys in the AttributedCharacterIterator returned from NumberFormat.formatToCharacterIterator and as field identifiers in FieldPosition."},
{"description": "Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format."},
{"description": "Class NumberUpSupported is a printing attribute class, a set of integers, that gives the supported values for a NumberUp attribute.The NumberUpSupported attribute's canonical array form gives the lower and upper bound for each range of number-up to be included in an IPP \"number-up-supported\" attribute.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class NumberOfDocuments is an integer valued printing attribute that indicates the number of individual docs the printer has accepted for this job, regardless of whether the docs' print data has reached the printer or not.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class NumberOfInterveningJobs is an integer valued printing attribute that indicates the number of jobs that are ahead of this job in the relative chronological order of expected time to complete (i.e., the current scheduled order).The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "A pair of channels that implements a unidirectional pipe.A pipe consists of a pair of channels: A writable sink channel and a readable source channel.Once some bytes are written to the sink channel they can be read from source channel in exactlyAthe order in which they were written.Whether or not a thread writing bytes to a pipe will block until another thread reads those bytes, or some previously-written bytes, from the pipe is system-dependent and therefore unspecified.Many pipe implementations will buffer up to a certain number of bytes between the sink and source channels, but such buffering should not be assumed."},
{"description": "Phantom references are most often used for scheduling pre-mortem cleanup actions in a more flexible way than is possible with the Java finalization mechanism.If the garbage collector determines at a certain point in time that the referent of a phantom reference is phantom reachable, then at that time or at some later time it will enqueue the reference.In order to ensure that a reclaimable object remains so, the referent of a phantom reference may not be retrieved: The get method of a phantom reference always returns null.Unlike soft and weak references, phantom references are not automatically cleared by the garbage collector as they are enqueued.An object that is reachable via phantom references will remain so until all such references are cleared or themselves become unreachable."},
{"description": "Unlike the case for other barriers, the number of parties registered to synchronize on a phaser may vary over time.Tasks may be registered at any time (using methods register(), bulkRegister(int), or forms of constructors establishing initial numbers of parties), and optionally deregistered upon any arrival (using arriveAndDeregister()).As is the case with most basic synchronization constructs, registration and deregistration affect only internal counts; they do not establish any further internal bookkeeping, so tasks cannot query whether they are registered.(However, you can introduce such bookkeeping by subclassing this class.)Like a CyclicBarrier, a Phaser may be repeatedly awaited.Method arriveAndAwaitAdvance() has effect analogous to CyclicBarrier.await.Each generation of a phaser has an associated phase number.The phase number starts at zero, and advances when all parties arrive at the phaser, wrapping around to zero after reaching Integer.The use of phase numbers enables independent control of actions upon arrival at a phaser and upon awaiting others, via two kinds of methods that may be invoked by any registered party: Arrival.These methods do not block, but return an associated arrival phase number; that is, the phase number of the phaser to which the arrival applied.When the final party for a given phase arrives, an optional action is performed and the phase advances.These actions are performed by the party triggering a phase advance, and are arranged by overriding method onAdvance(int, int), which also controls termination.Overriding this method is similar to, but more flexible than, providing a barrier action to a CyclicBarrier.Method awaitAdvance(int) requires an argument indicating an arrival phase number, and returns when the phaser advances to (or is already at) a different phase.Unlike similar constructions using CyclicBarrier, method awaitAdvance continues to wait even if the waiting thread is interrupted.Interruptible and timeout versions are also available, but exceptions encountered while tasks wait interruptibly or with timeout do not change the state of the phaser.If necessary, you can perform any associated recovery within handlers of those exceptions, often after invoking forceTermination.Phasers may also be used by tasks executing in a ForkJoinPool, which will ensure sufficient parallelism to execute tasks when others are blocked waiting for a phase to advance.A phaser may enter a termination state, that may be checked using method isTerminated().Upon termination, all synchronization methods immediately return without waiting for advance, as indicated by a negative return value.Termination is triggered when an invocation of onAdvance returns true.The default implementation returns true if a deregistration has caused the number of registered parties to become zero.As illustrated below, when phasers control actions with a fixed number of iterations, it is often convenient to override this method to cause termination when the current phase number reaches a threshold.Method forceTermination() is also available to abruptly release waiting threads and allow them to terminate.Phasers may be tiered (i.e., constructed in tree structures) to reduce contention.Phasers with large numbers of parties that would otherwise experience heavy synchronization contention costs may instead be set up so that groups of sub-phasers share a common parent.This may greatly increase throughput even though it incurs greater per-operation overhead.Whenever the number of registered parties of a child phaser becomes non-zero (as established in the Phaser(Phaser,int) constructor, register(), or bulkRegister(int)), the child phaser is registered with its parent.Whenever the number of registered parties becomes zero as the result of an invocation of arriveAndDeregister(), the child phaser is deregistered from its parent.While synchronization methods may be invoked only by registered parties, the current state of a phaser may be monitored by any caller.At any given moment there are getRegisteredParties() parties in total, of which getArrivedParties() have arrived at the current phase (getPhase()).The values returned by these methods may reflect transient states and so are not in general useful for synchronization control.Sample usages: A Phaser may be used instead of a CountDownLatch to control a one-shot action serving a variable number of parties.The typical idiom is for the method setting this up to first register, then start the actions, then deregister, as in: void runTasks(List<Runnable> tasks) { final Phaser phaser =(); } One way to cause a set of threads to repeatedly perform actions for a given number of iterations is to override onAdvance:phaser.register(); for (final Runnable task : tasks) { phaser.register(); new Thread() { public void run() { do { task.run(); phaser.arriveAndAwaitAdvance(); }(); } phaser.arriveAndDeregister(); // deregister self, don't wait } If the main task must later await termination, it may re-register and then execute a similar loop: // ...phaser.register(); while (!phaser.isTerminated()) phaser.arriveAndAwaitAdvance(); Related constructions may be used to await particular phase numbers in contexts where you are sure that the phase will never wrap around Integer.(); // assumes caller not already registered while (p < phase) {} phaser.arriveAndDeregister(); } To create a set of n tasks using a tree of phasers, you could use code of the following form, assuming a Task class with a constructor accepting a Phaser that it registers with upon construction.After invocation of build(new Task[n], 0, n, new Phaser()), these tasks could then be started, for example by submitting to a pool: void build(Task; // assumes new Task(ph) performs ph.register() } } The best value of TASKS_PER_PHASER depends mainly on expected synchronization rates.A value as low as four may be appropriate for extremely small per-phase task bodies (thus high rates), or up to hundreds for extremely large ones.Implementation notes: This implementation restricts the maximum number of parties to 65535.Attempts to register additional parties result in IllegalStateException.However, you can and should create tiered phasers to accommodate arbitrarily large sets of participants."},
{"description": "This class is the interface to be implemented by MBeans that are meant to be persistent.MBeans supporting this interface should call the load method during construction in order to prime the MBean from the persistent store.In the case of a ModelMBean, the store method should be called by the MBeanServer based on the descriptors in the ModelMBean or by the MBean itself during normal processing of the ModelMBean."},
{"description": "The PersistenceDelegate class takes the responsibility for expressing the state of an instance of a given class in terms of the methods in the class's public API.Instead of associating the responsibility of persistence with the class itself as is done, for example, by the readObject and writeObject methods used by the ObjectOutputStream, streams like the XMLEncoder which use this delegation model can have their behavior controlled independently of the classes themselves.Normally, the class is the best place to put such information and conventions can easily be expressed in this delegation scheme to do just that.Sometimes however, it is the case that a minor problem in a single class prevents an entire object graph from being written and this can leave the application developer with no recourse but to attempt to shadow the problematic classes locally or use alternative persistence techniques.In situations like these, the delegation model gives a relatively clean mechanism for the application developer to intervene in all parts of the serialization process without requiring that modifications be made to the implementation of classes which are not part of the application itself.The writeObject analog encodes each instance in terms of its public API and there is no need to define a readObject analog since the procedure for reading the serialized form is defined by the semantics of method invocation as laid out in the Java Language Specification.Breaking the dependency between writeObject and readObject implementations, which may change from version to version, is the key factor in making the archives produced by this technique immune to changes in the private implementations of the classes to which they refer.A persistence delegate, may take control of all aspects of the persistence of an object including: Deciding whether or not an instance can be mutated into another instance of the same class."},
{"description": "A PGPData object is used to convey information related to PGP public key pairs and signatures on such keys.The XML Schema Definition is defined as: <element name=\"PGPData\"A PGPData instance may be created by invoking one of the newPGPData methods of the KeyInfoFactory class, and passing it byte arrays representing the contents of the PGP public key identifier and/or PGP key material packet, and an optional list of elements from an external namespace."},
{"description": "This exception indicates a persistent storage failure, for example, failure to establish a database connection or corruption of a database.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "Class ReferenceUriSchemesSupported is a printing attribute class an enumeration, that indicates a \"URI scheme,\" such as \"http:\" or \"ftp:\", that a printer can use to retrieve print data stored at a URI location.If a printer supports doc flavors with a print data representation class of \"java.net.URL\", the printer uses instances of class ReferenceUriSchemesSupported to advertise the URI schemes it can accept.The acceptable URI schemes are included as service attributes in the lookup service; this lets clients search the for printers that can get print data using a certain URI scheme.The acceptable URI schemes can also be queried using the capability methods in interface PrintService.However, ReferenceUriSchemesSupported attributes are used solely for determining acceptable URI schemes, they are never included in a doc's, print request's, print job's, or print service's attribute set.The Internet Assigned Numbers Authority maintains the official list of URI schemes.Class ReferenceUriSchemesSupported defines enumeration values for widely used URI schemes.A printer that supports additional URI schemes can define them in a subclass of class ReferenceUriSchemesSupported.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "These include class and interface types, array types, type variables, and the null type."},
{"description": "This class represents a reference to an object that is found outside of the naming/directory system.Reference provides a way of recording address information about objects which themselves are not directly bound to the naming/directory system.A Reference consists of an ordered list of addresses and class information about the object being referenced.Each address in the list identifies a communications endpoint for the same conceptual object.The \"communications endpoint\" is information that indicates how to contact the object.It could be, for example, a network address, a location in memory on the local machine, another process on the same machine, etc.The order of the addresses in the list may be of significance to object factories that interpret the reference.Multiple addresses may arise for various reasons, such as replication or the object offering interfaces over more than one communication mechanism.The addresses are indexed starting with zero.A Reference also contains information to assist in creating an instance of the object to which this Reference refers.It contains the class name of that object, and the class name and location of the factory to be used to create the object.The class factory location is a space-separated list of URLs representing the class path used to load the factory.When the factory class (or any class or resource upon which it depends) needs to be loaded, each URL is used (in order) to attempt to load the class.A Reference instance is not synchronized against concurrent access by multiple threads.Threads that need to access a single Reference concurrently should synchronize amongst themselves and provide the necessary locking."},
{"description": "The XML schema is defined as: <element name=\"Reference> A Reference instance may be created by invoking one of the newReference methods of the XMLSignatureFactory class; for example: XMLSignatureFactory factory ="},
{"description": "This class defines the operations common to all reference objects.Because reference objects are implemented in close cooperation with the garbage collector, this class may not be subclassed directly."},
{"description": "This class represents the address of a communications end-point.It consists of a type that describes the communication mechanism and an address contents determined by an RefAddr subclass.For example, an address type could be \"BSD Printer Address\", which specifies that it is an address to be used with the BSD printing protocol.Its contents could be the machine name identifying the location of the printer server that understands this protocol.A RefAddr is contained within a Reference.RefAddr is an abstract class.Concrete implementations of it determine its synchronization properties."},
{"description": "Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected."},
{"description": "This interface is implemented by an object that can provide a Reference to itself.A Reference represents a way of recording address information about objects which themselves are not directly bound to the naming system.Such objects can implement the Referenceable interface as a way for programs that use that object to determine what its Reference is.For example, when binding a object, if an object implements the Referenceable interface, getReference() can be invoked on the object to get its Reference to use for binding."},
{"description": "A SyncMode object represents one of the ways in which a MIDI sequencer's notion of time can be synchronized with a master or slave device.If the sequencer is being synchronized to a master, the sequencer revises its current time in response to messages from the master.If the sequencer has a slave, the sequencer similarly sends messages to control the slave's timing.There are three predefined modes that specify possible masters for a sequencer: INTERNAL_CLOCK, MIDI_SYNC, and MIDI_TIME_CODE.The latter two work if the sequencer receives MIDI messages from another device.In these two modes, the sequencer's time gets reset based on system real-time timing clock messages or MIDI time code (MTC) messages, respectively.These two modes can also be used as slave modes, in which case the sequencer sends the corresponding types of MIDI messages to its receiver (whether or not the sequencer is also receiving them from a master).A fourth mode, NO_SYNC, is used to indicate that the sequencer should not control its receiver's timing."},
{"description": "Conceptually, a semaphore maintains a set of permits.Each acquire() blocks if necessary until a permit is available, and then takes it.Each release() adds a permit, potentially releasing a blocking acquirer.However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly.Semaphores are often used to restrict the number of threads than can access some (physical or logical) resource.For example, here is a class that uses a semaphore to control access to a pool of items: class Pool { private static final int MAX_AVAILABLE = 100; private final Semaphore available = new Semaphore(MAX_AVAILABLE, true); public Object getItem() throws InterruptedException { available.acquire(); return getNextAvailableItem(); } public void putItem(Object x) { if (markAsUnused(x))whatever kinds of items being managed protected boolean[] used = new boolean[MAX_AVAILABLE]; protected synchronized Object getNextAvailableItem() { for (int i = 0; i < MAX_AVAILABLE; ++i) { if (!used[i]) { used[i] = true; return items[i]; } } return null; // not reached } protected synchronized boolean markAsUnused(Object item) { for (int i = 0; i < MAX_AVAILABLE; ++i) { if (item == items[i]) { if (used[i]) { used[i] =false; return true; } else return false; } } return false; } } Before obtaining an item each thread must acquire a permit from the semaphore, guaranteeing that an item is available for use.When the thread has finished with the item it is returned back to the pool and a permit is returned to the semaphore, allowing another thread to acquire that item.Note that no synchronization lock is held when acquire() is called as that would prevent an item from being returned to the pool.The semaphore encapsulates the synchronization needed to restrict access to the pool, separately from any synchronization needed to maintain the consistency of the pool itself.A semaphore initialized to one, and which is used such that it only has at most one permit available, can serve as a mutual exclusion lock.This is more commonly known as a binary semaphore, because it only has two states: one permit available, or zero permits available.When used in this way, the binary semaphore has the property (unlike many Lock implementations), that the \"lock\" can be released by a thread other than the owner (as semaphores have no notion of ownership).This can be useful in some specialized contexts, such as deadlock recovery.The constructor for this class optionally accepts a fairness parameter.When set false, this class makes no guarantees about the order in which threads acquire permits.In particular, barging is permitted, that is, a thread invoking acquire() can be allocated a permit ahead of a thread that has been waiting - logically the new thread places itself at the head of the queue of waiting threads.When fairness is set true, the semaphore guarantees that threads invoking any of the acquire methods are selected to obtain permits in the order in which their invocation of those methods was processedNote that FIFO ordering necessarily applies to specific internal points of execution within these methods.So, it is possible for one thread to invoke acquire before another, but reach the ordering point after the other, and similarly upon return from the method.Also note that the untimed tryAcquire methods do not honor the fairness setting, but will take any permits that are available.Generally, semaphores used to control resource access should be initialized as fair, to ensure that no thread is starved out from accessing a resource.This class also provides convenience methods to acquire and release multiple permits at a time.Beware of the increased risk of indefinite postponement when these methods are used without fairness set true."},
{"description": "A selector may be created by invoking the open method of this class, which will use the system's default selector provider to create a new selector.A selector may also be created by invoking the openSelector method of a custom selector provider.A selector remains open until it is closed via its close method.A selectable channel's registration with a selector is represented by a SelectionKey object.A selector maintains three sets of selection keys: The key set contains the keys representing the current channel registrations of this selector.This set is returned by the keys method.The selected-key set is the set of keys such that each key's channel was detected to be ready for at least one of the operations identified in the key's interest set during a prior selection operation.This set is returned by the selectedKeys method.The selected-key set is always a subset of the key set.The cancelled-key set is the set of keys that have been cancelled but whose channels have not yet been deregistered.The cancelled-key set is always a subset of the key set.All three sets are empty in a newly-created selector.A key is added to a selector's key set as a side effect of registering a channel via the channel's register method.Cancelled keys are removed from the key set during selection operations.A key is added to its selector's cancelled-key set when it is cancelled, whether by closing its channel or by invoking its cancel method.Cancelling a key will cause its channel to be deregistered during the next selection operation, at which time the key will removed from all of the selector's key sets.Keys are added to the selected-key set by selection operations.A key may be removed directly from the selected-key set by invoking the set's remove method or by invoking the remove method of an iterator obtained from the set.Keys are never removed from the selected-key set in any other way; they are not, in particular, removed as a side effect of selection operations.Keys may not be added directly to the selected-key set.During each selection operation, keys may be added to and removed from a selector's selected-key set and may be removed from its key and cancelled-key sets.Selection is performed by the select(), select(long), and selectNow() methods, and involves three steps:Each key in the cancelled-key set is removed from each key set of which it is a member, and its channel is deregistered.This step leaves the cancelled-key set empty.The underlying operating system is queried for an update as to the readiness of each remaining channel to perform any of the operations identified by its key's interest set as of the moment that the selection operation began.For a channel that is ready for at least one such operation, one of the following two actions is performed: If the channel's key is not already in the selected-key set then it is added to that set and its ready-operation set is modified to identify exactly those operations for which the channel is now reported to be ready.Any readiness information previously recorded in the ready set is discarded.Otherwise the channel's key is already in the selected-key set, so its ready-operation set is modified to identify any new operations for which the channel is reported to be ready.Any readiness information previously recorded in the ready set is preserved; in other words, the ready set returned by the underlying system is bitwise-disjoined into the key's current ready set.If all of the keys in the key set at the start of this step have empty interest sets then neither the selected-key set nor any of the keys' ready-operation sets will be updated.If any keys were added to the cancelled-key set while step (2) was in progressthen they are processed as in step (1).Whether or not a selection operation blocks to wait for one or more channels to become ready, and if so for how long, is the only essential difference between the three selection methods.Concurrency Selectors are themselves safe for use by multiple concurrent threads; their key sets, however, are not.The selection operations synchronize on the selector itself, on the key set, and on the selected-key set, in that order.They also synchronize on the cancelled-key set during steps (1) and (3) above.Changes made to the interest sets of a selector's keys while a selection operation is in progress have no effect upon that operation; they will be seen by the next selection operation.Keys may be cancelled and channels may be closed at any time.Hence the presence of a key in one or more of a selector's key sets does not imply that the key is valid or that its channel is open.Application code should be careful to synchronize and check these conditions as necessary if there is any possibility that another thread will cancel a key or close a channel.A thread blocked in one of the select() or select(long) methods may be interrupted by some other thread in one of three ways:By invoking the selector's wakeup method, By invoking the selector's close method, or By invoking the blocked thread's interrupt method, in which case its interrupt status will be set and the selector's wakeup method will be invoked.The close method synchronizes on the selector and all three key sets in the same order as in a selection operation.A selector's key and selected-key sets are not, in general, safe for use by multiple concurrent threads.If such a thread might modify one of these sets directly then access should be controlled by synchronizing on the set itself.The iterators returned by these sets' iterator methods are fail-fast: If the set is modified after the iterator is created, in any way except by invoking the iterator's own remove method, then a ConcurrentModificationException will be thrown."},
{"description": "A selector provider is a concrete subclass of this class that has a zero-argument constructor and implements the abstract methods specified below.A given invocation of the Java virtual machine maintains a single system-wide default provider instance, which is returned by the provider method.The first invocation of that method will locate the default provider as specified below.The system-wide default provider is used by the static open methods of the DatagramChannel, Pipe, Selector, ServerSocketChannel, and SocketChannel classes.It is also used by the System.inheritedChannel() method.A program may make use of a provider other than the default provider by instantiating that provider and then directly invoking the open methods defined in this class.All of the methods in this class are safe for use by multiple concurrent threads."},
{"description": "A hardware or software device that plays back a MIDI sequence is known as a sequencer.A MIDI sequence contains lists of time-stamped MIDI data, such as might be read from a standard MIDI file.Most sequencers also provide functions for creating and editing sequences.The Sequencer interface includes methods for the following basic MIDI sequencer operations: obtaining a sequence from MIDI file data starting and stopping playback moving to an arbitrary position in the sequence changing the tempo (speed) of playback synchronizing playback to an internal clock or to received MIDI messages controlling the timing of another device In addition, the following operations are supported, either directly, or indirectly through objects that the Sequencer has access to: editing the data by adding or deleting individual MIDI events or entire tracks muting or soloing individual tracks in the sequence notifying listener objects about any meta-events or control-change events encountered while playing back the sequence."},
{"description": "A SequenceInputStream represents the logical concatenation of other input streams.It starts out with an ordered collection of input streams and reads from the first one until end of file is reached, whereupon it reads from the second one, and so on, until end of file is reached on the last of the contained input streams."},
{"description": "A Sequence is a data structure containing musical information (often an entire song or composition) that can be played back by a Sequencer object.Specifically, the Sequence contains timing information and one or more tracks.Each track consists of a series of MIDI events (such as note-ons, note-offs, program changes, and meta-events).The sequence's timing information specifies the type of unit that is used to time-stamp the events in the sequence.A Sequence can be created from a MIDI file by reading the file into an input stream and invoking one of the getSequence methods of MidiSystem.A sequence can also be built from scratch by adding new Tracks to an empty Sequence, and adding MidiEvent objects to these Tracks."},
{"description": "This is the generic Signature exception."},
{"description": "The XML Schema Definition is defined as: <element name=\"SignatureMethod> A SignatureMethod instance may be created by invoking the newSignatureMethod method of the XMLSignatureFactory class."},
{"description": "The Signature class is used to provide applications the functionality of a digital signature algorithm.Digital signatures are used for authentication and integrity assurance of digital data.The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-256.The DSA algorithm using the SHA-256 message digest algorithm can be specified as SHA256withDSA.In the case of RSA the signing algorithm could be specified as, for example, SHA256withRSA.The algorithm name must be specified, as there is no default.A Signature object can be used to generate and verify digital signatures.There are three phases to the use of a Signature object for either signing data or verifying a signature:Initialization, with either a public key, which initializes the signature for verification (see initVerify), or a private key (and optionally a Secure Random Number Generator), which initializes the signature for signing (see initSign(PrivateKey) and initSign(PrivateKey, SecureRandom)).Updating Depending on the type of initialization, this will update the bytes to be signed or verified.Note that this class is abstract and extends from SignatureSpi for historical reasons.Application developers should only take notice of the methods defined in this Signature class; all the methods in the superclass are intended for cryptographic service providers who wish to supply their own implementations of digital signature algorithms.Every implementation of the Java platform is required to support the following standard Signature algorithms:These algorithms are described in the Signature section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other algorithms are supported."},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "A ShortMessage contains a MIDI message that has at most two data bytes following its status byte.The types of MIDI message that satisfy this criterion are channel voice, channel mode, system common, and system real-time--in other words, everything except system exclusive and meta-events.The ShortMessage class provides methods for getting and setting the contents of the MIDI message.A number of ShortMessage methods have integer parameters by which you specify a MIDI status or data byte.If you know the numeric value, you can express it directly.For system common and system real-time messages, you can often use the corresponding fields of ShortMessage, such as SYSTEM_RESET.For channel messages, the upper four bits of the status byte are specified by a command value and the lower four bits are specified by a MIDI channel number.To convert incoming MIDI data bytes that are in the form of Java's signed bytes, you can use the conversion code given in the MidiMessage class description."},
{"description": "Class Sides is a printing attribute class, an enumeration, that specifies how print-stream pages are to be imposed upon the sides of an instance of a selected medium, i.e., an impression.The effect of a Sides attribute on a multidoc print job (a job with multiple documents) depends on whether all the docs have the same sides values specified or whether different docs have different sides values specified, and on the (perhaps defaulted) value of the MultipleDocumentHandling attribute.If all the docs have the same sides value n specified, then any value of MultipleDocumentHandling makes sense, and the printer's processing depends on the MultipleDocumentHandling value:SINGLE_DOCUMENT -- All the input docs will be combined together into one output document.Each media sheet will consist of n impressions from the output document.SINGLE_DOCUMENT_NEW_SHEET -- All the input docs will be combined together into one output document.Each media sheet will consist of n impressions from the output document.However, the first impression of each input doc will always start on a new media sheet; this means the last media sheet of an input doc may have only one impression on it.Each media sheet will consist of n impressions from the input doc.Since the input docs are separate, the first impression of each input doc will always start on a new media sheet; this means the last media sheet of an input doc may have only one impression on it.Each media sheet will consist of n impressions from the input doc.Since the input docs are separate, the first impression of each input doc will always start on a new media sheet; this means the last media sheet of an input doc may have only one impression on it.SINGLE_DOCUMENT -- All the input docs will be combined together into one output document.Each media sheet will consist of ni impressions from the output document, where i is the number of the input doc corresponding to that point in the output document.When the next input doc has a different sides value from the previous input doc, the first print-stream page of the next input doc goes at the start of the next media sheet, possibly leaving only one impression on the previous media sheet.SINGLE_DOCUMENT_NEW_SHEET -- All the input docs will be combined together into one output document.Each media sheet will consist of n impressions from the output document.However, the first impression of each input doc will always start on a new media sheet; this means the last impression of an input doc may have only one impression on it.i, each media sheet will consist of ni impressions from the input doc.Since the input docs are separate, the first impression of each input doc will always start on a new media sheet; this means the last media sheet of an input doc may have only one impression on it.i, each media sheet will consist of ni impressions from the input doc.Since the input docs are separate, the first impression of each input doc will always start on a new media sheet; this means the last media sheet of an input doc may have only one impression on it.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "Unchecked exception thrown when an attempt is made to construct a channel in a group that is shutdown or the completion handler for an I/O operation cannot be invoked because the channel group has terminated."},
{"description": "The upper and lower bounds of the sequence are defined by properties called start and end and the size of the increase or decrease computed by the nextValue and previousValue methods is defined by a property called calendarField.The start and end properties can be null to indicate that the sequence has no lower or upper limit.The value of the calendarField property must be one of the java.util.Calendar constants that specify a field within a Calendar.The getNextValue and getPreviousValue methods change the date forward or backwards by this amount.For example, if calendarField is Calendar.DAY_OF_WEEK, then nextValue produces a Date that's 24 hours after the current value, and previousValue produces a Date that's 24 hours earlier.The legal values for calendarField are: Calendar.However some UIs may set the calendarField before committing the edit to spin the field under the cursor.If you only want one field to spin you can subclass and ignore the setCalendarField calls.This model inherits a ChangeListener."},
{"description": "Note that additional source version constants will be added to model future releases of the language."},
{"description": "This interface is primarily for the purposes of reporting where an error occurred in the XML source or transformation instructions."},
{"description": "A source data line is a data line to which data may be written.It acts as a source to its mixer.An application writes audio bytes to a source data line, which handles the buffering of the bytes and delivers them to the mixer.The mixer may mix the samples with those from other sources and then deliver the mix to a target such as an output port (which may represent an audio output device on a sound card).Note that the naming convention for this interface reflects the relationship between the line and its mixer.From the perspective of an application, a source data line may act as a target for audio data.A source data line can be obtained from a mixer by invoking the getLine method of Mixer with an appropriate DataLine.The SourceDataLine interface provides a method for writing audio data to the data line's buffer.Applications that play or mix audio should write data to the source data line quickly enough to keep the buffer from underflowing (emptying), which could cause discontinuities in the audio that are perceived as clicks.Applications can use the available method defined in the DataLine interface to determine the amount of data currently queued in the data line's buffer.The amount of data which can be written to the buffer without blocking is the difference between the buffer size and the amount of queued data.If the delivery of audio output stops due to underflow, a STOP event is generated."},
{"description": "An object that implements this interface contains the information needed to act as source input (XML source or transformation instructions)."},
{"description": "A SoundbankResource represents any audio resource stored in a Soundbank.Common soundbank resources include: Instruments.An instrument may be specified in a variety of ways.However, all soundbanks have some mechanism for defining instruments.In doing so, they may reference other resources stored in the soundbank.Each instrument has a Patch which specifies the MIDI program and bank by which it may be referenced in MIDI messages.Instrument information may be stored in Instrument objects.A sample typically is a sampled audio waveform which contains a short sound recording whose duration is a fraction of a second, or at most a few seconds.These audio samples may be used by a Synthesizer to synthesize sound in response to MIDI commands, or extracted for use by an application.(The terminology reflects musicians' use of the word \"sample\" to refer collectively to a series of contiguous audio samples or frames, rather than to a single, instantaneous sample.)The data class for an audio sample will be an object that encapsulates the audio sample data itself and information about how to interpret it (the format of the audio data), such as an AudioInputStream. Embedded sequences.A sound bank may contain built-in song data stored in a data object such as a Sequence.Synthesizers that use wavetable synthesis or related techniques play back the audio in a sample when synthesizing notes, often when emulating the real-world instrument that was originally recorded.However, there is not necessarily a one-to-one correspondence between the Instruments and samples in a Soundbank.A single Instrument can use multiple SoundbankResources (typically for notes of dissimilar pitch or brightness).Also, more than one Instrument can use the same sample."},
{"description": "A SoundbankReader supplies soundbank file-reading services.Concrete subclasses of SoundbankReader parse a given soundbank file, producing a Soundbank object that can be loaded into a Synthesizer."},
{"description": "A Soundbank contains a set of Instruments that can be loaded into a Synthesizer.Note that a Java Sound Soundbank is different from a MIDI bank.MIDI permits up to 16383 banks, each containing up to 128 instruments (also sometimes called programs, patches, or timbres).However, a Soundbank can contain 16383 times 128 instruments, because the instruments within a Soundbank are indexed by both a MIDI program number and a MIDI bank number (via a Patch object).Thus, a Soundbank can be thought of as a collection of MIDI banks.Soundbank includes methods that return String objects containing the sound bank's name, manufacturer, version number, and description.The precise content and format of these strings is left to the implementor.Different synthesizers use a variety of synthesis techniques.A common one is wavetable synthesis, in which a segment of recorded sound is played back, often with looping and pitch change.The Downloadable Sound (DLS) format uses segments of recorded sound, as does the Headspace Engine.Soundbanks and Instruments that are based on wavetable synthesis (or other uses of stored sound recordings) should typically implement the getResources() method to provide access to these recorded segments.This is optional, however; the method can return an zero-length array if the synthesis technique doesn't use sampled sound (FM synthesis and physical modeling are examples of such techniques), or if it does but the implementor chooses not to make the samples accessible."},
{"description": "An implementation of RowSorter that provides sorting and filtering using a TableModel.The following example shows adding sorting to a JTable:; This will do all the wiring such that when the user does the appropriate gesture, such as clicking on the column header, the table will visually sort.JTable's row-based methods and JTable's selection model refer to the view and not the underlying model.Therefore, it is necessary to convert between the two.For example, to get the selection in terms of myModel you need to convert the indices: int[] selection =table.getSelectedRows(); for (int i = 0; i < selection.length; i++) { selection[i] = table.convertRowIndexToModel(selection[i]); } Similarly to select a row in JTable based on a coordinate from the underlying model do the inverse: table.setRowSelectionInterval(table.convertRowIndexToView(row), table.convertRowIndexToView(row)); The previous example assumes you have not enabled filtering.If you have enabled filtering convertRowIndexToView will return -1 for locations that are not visible in the view.TableRowSorter uses Comparators for doing comparisons.The following defines how a Comparator is chosen for a column: If a Comparator has been specified for the column by the setComparator method, use it.If the column class as returned by getColumnClass is String, use the Comparator returned by Collator.getInstance().If the column class implements Comparable, use a Comparator that invokes the compareTo method.If a TableStringConverter has been specified, use it to convert the values to Strings and then use the Comparator returned by Collator.getInstance().A filter is specified using the setFilter method.The following example will only show rows containing the string \"foo\": TableModel myModel = createMyTableModel();\")); JTable table = new JTable(myModel); table.setRowSorter(sorter); If the underlying model structure changes (the modelStructureChanged method is invoked) the following are reset to their default values:Comparators by column, current sort order, and whether each column is sortable.The default sort order is natural (the same as the model), and columns are sortable by default.TableRowSorter has one formal type parameter: the type of the model.Passing in a type that corresponds exactly to your model allows you to filter based on your model without casting.DefaultTableModel returns a column class of Object.As such all comparisons will be done using toString.If the column only contains one type of value, such as an Integer, you should override getColumnClass and return the appropriate Class.This will dramatically increase the performance of this class."},
{"description": "TableModelListener defines the interface for an object that listens to changes in a TableModel."},
{"description": "TableModelEvent is used to notify listeners that a table model has changed.The model event describes changes to a TableModel and all references to rows and columns are in the co-ordinate system of the model.Depending on the parameters used in the constructors, the TableModelevent can be used to specify the following types of changes: TableModelEvent(source); //// Row 1 changed TableModelEvent(source, 3, 6); // Rows 3 to 6 inclusive changed TableModelEvent(source, 2, 2, 6); //Cell at (2, 6) changed TableModelEvent(source, 3, 6, ALL_COLUMNS, INSERT); //Rows (3, 6) were deleted It is possible to use other combinations of the parameters, not all of them are meaningful.By subclassing, you can add other information, for example: whether the event WILL happen or DID happen.This makes the specification of rows in DELETE events more useful but has not been included in the swing package as the JTable only needs post-event notification.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The TableModel interface specifies the methods the JTable will use to interrogate a tabular data model.The JTable can be set up to display any data model which implements the TableModel interface with a couple of lines of code:"},
{"description": "TableColumnModelListener defines the interface for an object that listens to changes in a TableColumnModel."},
{"description": "TableColumnModelEvent is used to notify listeners that a table column model has changed, such as a column was added, removed, or moved.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "TimeZone represents a time zone offset, and also figures out daylight savings.Typically, you get a TimeZone using getDefault which creates a TimeZone based on the time zone where the program is running.For example, for a program running in Japan, getDefault creates a TimeZone object based on Japanese Standard Time.You can also get a TimeZone using getTimeZone along with a time zone ID.For instance, the time zone ID for the U.S. Pacific Time zone is \"America/Los_Angeles\".So, you can get a U.S. Pacific Time TimeZone object with: TimeZone tz = TimeZone.getTimeZone(\"America/Los_Angeles\"); You can use the getAvailableIDs method to iterate through all the supported time zone IDs.You can then choose a supported ID to get a TimeZone.If the time zone you want is not represented by one of the supported IDs, then a custom time zone ID can be specified to produce a TimeZone.The syntax of a custom time zone ID is: CustomID: GMT Sign Hours :one of 0 1 2 3 4 5 6 7 8 9 Hours must be between 0 to 23 and Minutes must be between 00 to 59.The format is locale independent and digits must be taken from the Basic Latin block of the Unicode standard.No daylight saving time transition schedule can be specified with a custom time zone ID.If the specified string doesn't match the syntax, \"GMT\" is used.When creating a TimeZone, the specified custom time zone ID is normalized in the following syntax: NormalizedCustomID:For compatibility with JDK 1.1.x, some other three-letter time zone IDs (such as \"PST\", \"CTT\", \"AST\") are also supported.However, their use is deprecated because the same abbreviation is often used for multiple time zones (for example, \"CST\" could be U.S. \"Central Standard Time\" and \"China Standard Time\"), and the Java platform can then only recognize one of them."},
{"description": "A thin wrapper around java.util.Date that allows the JDBC API to identify this as an SQL TIMESTAMP value.It adds the ability to hold the SQL TIMESTAMP fractional seconds value, by allowing the specification of fractional seconds to a precision of nanoseconds.A Timestamp also provides formatting and parsing operations to support the JDBC escape syntax for timestamp values.The precision of a Timestamp object is calculated to be either: 19 , which is the number of characters in yyyy-mm-dd hh:mm:ss 20 + s , which is the number of characters in the yyyy-mm-ddand s represents the scale of the given Timestamp, its fractional seconds precision.Note: This type is a composite of a java.util.Date and a separate nanoseconds value.Only integral seconds are stored in the java.util.Date component.method never returns true when passed an object that isn't an instance of java.sql.Timestamp, because the nanos component of a date is unknown.As a result, the Timestamp.equals(Object) method is not symmetric with respect to the java.util.Date.equals(Object) method.Also, the hashCode method uses the underlying java.util.Date implementation and therefore does not include nanos in its computation.Due to the differences between the Timestamp class and the java.util.Date class mentioned above, it is recommended that code not view Timestamp values generically as an instance of java.util.Date.The inheritance relationship between Timestamp and java.util.Date really denotes implementation inheritance, and not type inheritance."},
{"description": "This class provides definitions of the notifications sent by timer MBeans.It defines a timer notification identifier which allows to retrieve a timer notification from the list of notifications of a timer MBean.The timer notifications are created and handled by the timer MBean."},
{"description": "An example use is an animation object that uses a Timer as the trigger for drawing its frames.Setting up a timer involves creating a Timer object, registering one or more action listeners on it, and starting the timer using the start method.For example, the following code creates and starts a timer that fires an action event once per second (as specified by the first argument to the Timer constructor).The second argument to the Timer constructor specifies a listener to receive the timer's action events....Perform a task... } }; new Timer(delay, taskPerformer).start(); Timers are constructed by specifying both a delay parameter and an ActionListener.The delay parameter is used to set both the initial delay and the delay between event firing, in milliseconds.Once the timer has been started, it waits for the initial delay before firing its first ActionEvent to registered listeners.After this first event, it continues to fire events every time the between-event delay has elapsed, until it is stopped.After construction, the initial delay and the between-event delay can be changed independently, and additional ActionListeners may be added.If you want the timer to fire only the first time and then stop, invoke setRepeats(false) on the timer.Although all Timers perform their waiting using a single, shared thread (created by the first Timer object that executes), the action event handlers for Timers execute on another thread -- the event-dispatching thread.This means that the action handlers for Timers can safely perform operations on Swing components.However, it also means that the handlers must execute quickly to keep the GUI responsive.In v 1.3, another Timer class was added to the Java platform: java.util.Timer.Both it and javax.swing.Timer provide the same basic functionality, but java.util.Timer is more general and has more features.The javax.swing.Timer has two features that can make it a little easier to use with GUIs.First, its event handling metaphor is familiar to GUI programmers and can make dealing with the event-dispatching thread a bit simpler.Second, its automatic thread sharing means that you don't have to take special steps to avoid spawning too many threads.Instead, your timer uses the same thread used to make cursors blink, tool tips appear, and so on.You can find further documentation and several examples of using timers by visiting How to Use Timers, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A TimeUnit represents time durations at a given unit of granularity and provides utility methods to convert across units, and to perform timing and delay operations in these units.A TimeUnit does not maintain time information, but only helps organize and use time representations that may be maintained separately across various contexts.A nanosecond is defined as one thousandth of a microsecond, a microsecond as one thousandth of a millisecond, a millisecond as one thousandth of a second, a minute as sixty seconds, an hour as sixty minutes, and a day as twenty four hours.A TimeUnit is mainly used to inform time-based methods how a given timing parameter should be interpreted.For example, the following code will timeout in 50 milliseconds if the lock is not available: Lock lock = ...; if (lock.tryLock(50L, TimeUnit.... while this code will timeout in 50 seconds: Lock lock = ...; if (lock.tryLock(50L, TimeUnit.Note however, that there is no guarantee that a particular timeout implementation will be able to notice the passage of time at the same granularity as the given TimeUnit."},
{"description": "A task that can be scheduled for one-time or repeated execution by a Timer."},
{"description": "This class encapsulates information about a signed timestamp.It includes the timestamp's date and time as well as information about the Timestamping Authority (TSA) which generated and signed the timestamp."},
{"description": "Represents an operation on a single operand that produces a result of the same type as its operand.This is a specialization of Function for the case where the operand and result are of the same type.This is a functional interface whose functional method is Function.apply(Object)."},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "This interface is used to mark objects created by ComponentUI delegates.The ComponentUI.installUI() and ComponentUI.uninstallUI() methods can use this interface to decide if a properties value has been overridden.For example, the JList cellRenderer property is initialized by BasicListUI.installUI(), only if it's initial value is null: if (list.getCellRenderer() == null) { list.setCellRenderer((ListCellRenderer)(UIManager.get(\"List.cellRenderer\"))); } At uninstallUI() time we reset the property to null if its value is an instance of UIResource: if (list.getCellRenderer() instanceof UIResource) { list.setCellRenderer(null); } This pattern applies to all properties except the java.awt.Component properties font, foreground, and background.If one of these properties isn't initialized, or is explicitly set to null, its container provides the value.For this reason the \"== null\" is unreliable when installUI() is called to dynamically change a components look and feel.So at installUI() time we check to see if the current value is a UIResource: if (!"},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "UIManager manages the current look and feel, the set of available look and feels, PropertyChangeListeners that are notified when the look and feel changes, look and feel defaults, and convenience methods for obtaining various default values.Specifying the look and feel The look and feel can be specified in two distinct ways: by specifying the fully qualified name of the class for the look and feel, or by creating an instance of LookAndFeel and passing it to setLookAndFeel.The following example illustrates setting the look and feel to the system look and feel:UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName()); The following example illustrates setting the look and feel based on class name: UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\"); Once the look and feel has been changed it is imperative to invoke updateUI on all JComponents.Component) makes it easy to apply updateUI to a containment hierarchy.It is very possible to receive unexpected exceptions, painting problems, or worse.Default look and feel The class used for the default look and feel is chosen in the following manner: If the system property swing.defaultlaf is non-null, use its value as the default look and feel class name.If the Properties file swing.properties exists and contains the key swing.defaultlaf, use its value as the default look and feel class name.The location that is checked for swing.properties may vary depending upon the implementation of the Java platform.Typically the swing.properties file is located in the lib subdirectory of the Java installation directory.Otherwise use the cross platform look and feel.Defaults UIManager manages three sets of UIDefaults.In order, they are: Developer defaults.With few exceptions Swing does not alter the developer defaults; these are intended to be modified and used by the developer.The look and feel defaults are supplied by the look and feel at the time it is installed as the current look and feel (The look and feel defaults can be obtained using the getLookAndFeelDefaults() method.The system defaults are provided by Swing.For example, invoking UIManager.getString(\"Table.foreground\") results in first checking developer defaults.If the developer defaults contain a value for \"Table.foreground\" it is returned, otherwise the look and feel defaults are checked, followed by the system defaults.It's important to note that getDefaults returns a custom instance of UIDefaults with this resolution logic built into it.Both resolve using the algorithm just described.In many places the documentation uses the word defaults to refer to the custom instance of UIDefaults with the resolution logic as previously described.When the look and feel is changed, UIManager alters only the look and feel defaults; the developer and system defaults are not altered by the UIManager in any way.The set of defaults a particular look and feel supports is defined and documented by that look and feel.In addition, each look and feel, or ComponentUI provided by a look and feel, may access the defaults at different times in their life cycle.Some look and feels may aggressively look up defaults, so that changing a default may not have an effect after installing the look and feel.Other look and feels may lazily access defaults so that a change to the defaults may effect an existing look and feel.Finally, other look and feels might not configure themselves from the defaults table in any way.None-the-less it is usually the case that a look and feel expects certain defaults, so that in general a ComponentUI provided by one look and feel will not work with another look and feel.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Unchecked exception thrown when an attempt is made to write to an asynchronous socket channel and a previous write has not completed."},
{"description": "Signals that one of the ObjectStreamExceptions was thrown during a write operation.Thrown during a read operation when one of the ObjectStreamExceptions was thrown during a write operation.The exception that terminated the write can be found in the detail field.The stream is reset to it's initial state and all references to objects already deserialized are discarded.As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.The \"exception causing the abort\" that is provided at construction time and accessed via the public detail field is now known as the cause, and may be accessed via the Throwable.getCause() method, as well as the aforementioned \"legacy field.\""},
{"description": "A channel that can write bytes.Only one write operation upon a writable channel may be in progress at any given time.If one thread initiates a write operation upon a channel then any other thread that attempts to initiate another write operation will block until the first operation is complete.Whether or not other kinds of I/O operations may proceed concurrently with a write operation depends upon the type of the channel."},
{"description": "This class extends Raster to provide pixel writing capabilities.The constructors of this class are protected."},
{"description": "The only methods that a subclass must implement are write(char[], int, int), flush(), and close().Most subclasses, however, will override some of the methods defined here in order to provide higher efficiency, additional functionality, or both."},
{"description": "WriteableRenderedImage is a common interface for objects which contain or can produce image data in the form of Rasters and which can be modified and/or written over.The image data may be stored/produced as a single tile or a regular array of tiles.WritableRenderedImage provides notification to other interested objects when a tile is checked out for writing (via the getWritableTile method) and when the last writer of a particular tile relinquishes its access (via a call to releaseWritableTile).Additionally, it allows any caller to determine whether any tiles are currently checked out (via hasTileWriters), and to obtain a list of such tiles (via getWritableTileIndices, in the form of a Vector of Point objects).Objects wishing to be notified of changes in tile writability must implement the TileObserver interface, and are added by a call to addTileObserver.Multiple calls to addTileObserver for the same object will result in multiple notifications.An existing observer may reduce its notifications by calling removeTileObserver; if the observer had no notifications the operation is a no-op.It is necessary for a WritableRenderedImage to ensure that notifications occur only when the first writer acquires a tile and the last writer releases it."},
{"description": "When the POA has the NON_RETAIN policy it uses servant managers that are ServantLocators.Because the POA knows that the servant returned by this servant manager will be used only for a single request, it can supply extra information to the servant manager's operations and the servant manager's pair of operations may be able to cooperate to do something different than a ServantActivator.When the POA uses the ServantLocator interface, immediately after performing the operation invocation on the servant returned by preinvoke, the POA will invoke postinvoke on the servant manager, passing the ObjectId value and the Servant value as parameters (among others).This feature may be used to force every request for objects associated with a POA to be mediated by the servant manager."},
{"description": "A naming context is an object that contains a set of name bindings in which each name is unique.Different names can be bound to an object in the same or different contexts at the same time."},
{"description": "NamingContextExt is the extension of NamingContext which contains a set of name bindings in which each name is unique and is part of Interoperable Naming Service.Different names can be bound to an object in the same or different contexts at the same time.Using NamingContextExt, you can use URL-based names to bind and resolve."},
{"description": "When the POA has the RETAIN policy it uses servant managers that are ServantActivators."},
{"description": "This class provides the Stub for the Remote Type.The class is generated by the rmic compiler, and is still under works at OMG.It's contents are subject to change without notice as the specification evolves."},
{"description": "DynValue objects support the manipulation of IDL non-boxed value types.The DynValue interface can represent both null and non-null value types.For a DynValue representing a non-null value type, the DynValue's components comprise the public and private members of the value type, including those inherited from concrete base value types, in the order of definition.A DynValue representing a null value type has no components and a current position of -1.Indiscriminantly changing the contents of private value type members can cause the value type implementation to break by violating internal constraints.Access to private members is provided to support such activities as ORB bridging and debugging and should not be used to arbitrarily violate the encapsulation of the value type."},
{"description": "DynStruct objects support the manipulation of IDL struct and exception values.Members of the exceptions are handled in the same way as members of a struct."},
{"description": "Because IDL does not have a generic type that can represent fixed types with arbitrary number of digits and arbitrary scale, the operations use the IDL string type."},
{"description": "DynEnum objects support the manipulation of IDL enumerated values.The current position of a DynEnum is always -1."},
{"description": "Note that the dimension of the array is contained in the TypeCode which is accessible through the type attribute.It can also be obtained by calling the component_count operation."},
{"description": "DynUnion objects support the manipulation of IDL unions.A union can have only two valid current positions: zero, which denotes the discriminator one, which denotes the active member The component_count value for a union depends on the current discriminator: it is 2 for a union whose discriminator indicates a named member, and 1 otherwise."},
{"description": "Any values can be dynamically interpreted (traversed) and constructed through DynAny objects.A DynAny object is associated with a data value which corresponds to a copy of the value inserted into an any.A DynAny object may be viewed as an ordered collection of component DynAnys.For DynAnys representing a basic type, such as long, or a type without components, such as an empty exception, the ordered collection of components is empty.Each DynAny object maintains the notion of a current position into its collection of component DynAnys.The current position is identified by an index value that runs from 0 to n-1, where n is the number of components.The special index value -1 indicates a current position that points nowhere.For values that cannot have a current position (such as an empty exception), the index value is fixed at -1.If a DynAny is initialized with a value that has components, the index is initialized to 0.After creation of an uninitialized DynAny (that is, a DynAny that has no value but a TypeCode that permits components), the current position depends on the type of value represented by the DynAny.(The current position is set to 0 or -1, depending on whether the new DynAny gets default values for its components.)The iteration operations rewind, seek, and next can be used to change the current position and the current_component operation returns the component at the current position.The component_count operation returns the number of components of a DynAny.Collectively, these operations enable iteration over the components of a DynAny, for example, to (recursively) examine its contents.A constructed DynAny object is a DynAny object associated with a constructed type.There is a different interface, inheriting from the DynAny interface, associated with each kind of constructed type in IDL (fixed, enum, struct, sequence, union, array, exception, and value type).A constructed DynAny object exports operations that enable the creation of new DynAny objects, each of them associated with a component of the constructed data value.As an example, a DynStruct is associated with a struct value.This means that the DynStruct may be seen as owning an ordered collection of components, one for each structure member.The DynStruct object exports operations that enable the creation of new DynAny objects, each of them associated with a member of the struct.If a DynAny object has been obtained from another (constructed)DynAny object, such as a DynAny representing a structure member that was created from a DynStruct, the member DynAny is logically contained in the DynStruct.Calling an insert or get operation leaves the current position unchanged.Destroying a top-level DynAny object (one that was not obtained as a component of another DynAny) also destroys any component DynAny objects obtained from it.DynAny object does nothing.Invoking operations on a destroyed top-level DynAny or any of its descendants raises OBJECT_NOT_EXIST.If the programmer wants to destroy a DynAny object but still wants to manipulate some component of the data value associated with it, then he or she should first create a DynAny for the component and, after that, make a copy of the created DynAny object.The behavior of DynAny objects has been defined in order to enable efficient implementations in terms of allocated memory space and speed of access.DynAny objects are intended to be used for traversing values extracted from anys or constructing values of anys at runtime.Their use for other purposes is not recommended.Insert and get operations are necessary to handle basic DynAny objects but are also helpful to handle constructed DynAny objects.Inserting a basic data type value into a constructed DynAny object implies initializing the current component of the constructed data value associated with the DynAny object.For example, invoking insert_boolean on a DynStruct implies inserting a boolean data value at the current position of the associated struct data value.A type is consistent for inserting or extracting a value if its TypeCode is equivalent to the TypeCode contained in the DynAny or, if the DynAny has components, is equivalent to the TypeCode of the DynAny at the current position.DynAny and DynAnyFactory objects are intended to be local to the process in which they are created and used.This means that references to DynAny and DynAnyFactory objects cannot be exported to other processes, or externalized with ORB.object_to_string().If any attempt is made to do so, the offending operation will raise a MARSHAL system exception.Since their interfaces are specified in IDL, DynAny objects export operations defined in the standard org.omg.CORBA.Object interface.However, any attempt to invoke operations exported through the Object interface may raise the standard NO_IMPLEMENT exception.An attempt to use a DynAny object with the DII may raise the NO_IMPLEMENT exception."},
{"description": "DynAny objects can be created by invoking operations on the DynAnyFactory object.Generally there are only two ways to create a DynAny object: invoking an operation on an existing DynAny object invoking an operation on a DynAnyFactory objectA constructed DynAny object supports operations that enable the creation of new DynAny objects encapsulating access to the value of some constituent.DynAny objects also support the copy operation for creating new DynAny objects.A reference to the DynAnyFactory object is obtained by calling ORB.resolve_initial_references() with the identifier parameter set to the string constant \"DynAnyFactory\".Dynamic interpretation of an any usually involves creating a DynAny object using create_dyn_any() as the first step.Depending on the type of the any, the resulting DynAny object reference can be narrowed to a DynFixed, DynStruct, DynSequence, DynArray, DynUnion, DynEnum, or DynValue object reference.(), passing the TypeCode associated with the value to be created.The returned reference is narrowed to one of the complex types, such as DynStruct, if appropriate.Then, the value can be initialized by means of invoking operations on the resulting object.Finally, the to_any operation can be invoked to create an any value from the constructed DynAny."},
{"description": "The BindingIterator interface allows a client to iterate through the bindings using the next_one or next_n operations.The bindings iterator is obtained by using the list method on the NamingContext."},
{"description": "ZoneView is a View implementation that creates zones for which the child views are not created or stored until they are needed for display or model/view translations.This enables a substantial reduction in memory consumption for situations where the model being represented is very large, by building view objects only for the region being actively viewed/edited.The size of the children can be estimated in some way, or calculated asynchronously with only the result being saved.ZoneView extends BoxView to provide a box that implements zones for its children.The zones are special View implementations (the children of an instance of this class) that represent only a portion of the model that an instance of ZoneView is responsible for.The zones don't create child views until an attempt is made to display them.A box shaped view is well suited to this because: Boxes are a heavily used view, and having a box that provides this behavior gives substantial opportunity to plug the behavior into a view hierarchy from the view factory.Boxes are tiled in one direction, so it is easy to divide them into zones in a reliable way.Boxes typically have a simple relationship to the model (i.e. they create child views that directly represent the child elements).Boxes are easier to estimate the size of than some other shapes.The default behavior is controlled by two properties, maxZoneSize and maxZonesLoaded.MAX_VALUE would have the effect of causing only one zone to be created.This would effectively turn the view into an implementation of the decorator pattern.For simplicity, zones are created on boundaries represented by the child elements of the elementThe zones can be any View implementation, but the default implementation is based upon AsyncBoxView which supports fairly large zones efficiently."},
{"description": "This exception is used to indicate a problems with the configured time-zone rules."},
{"description": "This class manages the configuration of time-zone rules.The static methods provide the public API that can be used to manage the providers.The abstract methods provide the SPI that allows rules to be provided.ZoneRulesProvider may be installed in an instance of the Java Platform as extension classes, that is, jar files placed into any of the usual extension directories.Installed providers are loaded using the service-provider loading facility defined by the ServiceLoader class.A ZoneRulesProvider identifies itself with a provider configuration file named java.time.zone.ZoneRulesProvider in the resource directory META-INF/services.The file should contain a line that specifies the fully qualified concrete zonerules-provider class name.Providers may also be made available by adding them to the class path or by registering themselves via registerProvider(java.time.zone.The Java virtual machine has a default provider that provides zone rules for the time-zones defined by IANA Time Zone Database (TZDB).If the system property java.time.zone.DefaultZoneRulesProvider is defined then it is taken to be the fully-qualified name of a concrete ZoneRulesProvider class to be loaded as the default provider, using the system class loader.If this system property is not defined, a system-default provider will be loaded to serve as the default provider.Rules are looked up primarily by zone ID, as used by ZoneId.Time-zone rules are political, thus the data can change at any time.Each provider will provide the latest rules for each zone ID, but they may also provide the history of how the rules changed."},
{"description": "The rules defining how the zone offset varies for a single time-zone.The rules model all the historic and future transitions for a time-zone.ZoneOffsetTransition is used for known transitions, typically historic.ZoneOffsetTransitionRule is used for future transitions that are based on the result of an algorithm.The rules are loaded via ZoneRulesProvider using a ZoneId.The same rules may be shared internally between multiple zone IDs.Serializing an instance of ZoneRules will store the entire set of rules.It does not store the zone ID as it is not part of the state of this object.A rule implementation may or may not store full information about historic and future transitions, and the information stored is only as accurate as that supplied to the implementation by the rules provider.Applications should treat the data provided as representing the best information available to the implementation of this rule."},
{"description": "A definition of the way a local time can be converted to the actual transition date-time.Time zone rules are expressed in one of three ways:Relative to UTC Relative to the standard offset in force Relative to the wall offset (what you would see on a clock on the wall)"},
{"description": "This class allows rules for identifying future transitions to be expressed.A rule might be written in many forms: the 16th March the Sunday on or after the 16th March the Sunday on or before the 16th March the last Sunday in February These different rule types can be expressed and queried."},
{"description": "A ZoneId is used to identify the rules used to convert between an Instant and a LocalDateTime.There are two distinct types of ID:Fixed offsets - a fully resolved offset from UTC/Greenwich, that uses the same offset for all local date-times Geographical regions - an area where a specific set of rules for finding the offset from UTC/Greenwich apply Most fixed offsets are represented by ZoneOffset.Calling normalized() on any ZoneId will ensure that a fixed offset ID will be represented as a ZoneOffset.The actual rules, describing when and how the offset changes, are defined by ZoneRules.This class is simply an ID used to obtain the underlying rules.This approach is taken because rules are defined by governments and change frequently, whereas the ID is stable.The distinction has other effects.Serializing the ZoneId will only send the ID, whereas serializing the rules sends the entire data set.Similarly, a comparison of two IDs only examines the ID, whereas a comparison of two rules examines the entire data set.The ID is unique within the system.There are three types of ID.The simplest type of ID is that from ZoneOffset.The next type of ID are offset-style IDs with some form of prefix, such as 'GMT+2' or 'UTC+01:00'.The recognised prefixes are 'UTC', 'GMT' and 'UT'.The offset is the suffix and will be normalized during creation.These IDs can be normalized to a ZoneOffset using normalized().The third type of ID are region-based IDs.A region-based ID must be of two or more characters, and not start with 'UTC', 'GMT', 'Region-based IDs are defined by configuration, see ZoneRulesProvider.The configuration focuses on providing the lookup from the ID to the underlying ZoneRules.Time-zone rules are defined by governments and change frequently.There are a number of organizations, known here as groups, that monitor time-zone changes and collate them.The default group is the IANA Time Zone Database (TZDB).Other organizations include IATA (the airline industry body) and Microsoft.Each group defines its own format for the region ID it provides.The TZDB group defines IDs such as 'Europe/London' or 'America/New_York'.TZDB IDs take precedence over other groups.It is strongly recommended that the group name is included in all IDs supplied by groups other than TZDB to avoid conflicts.For example, IATA airline time-zone region IDs are typically the same as the three letter airport code.However, the airport of Utrecht has the code 'UTC', which is obviously a conflict.The recommended format for region IDs from groups other than TZDB is 'group~region'.Thus if IATA data were defined, Utrecht airport would be 'IATA~UTC'.Serialization This class can be serialized and stores the string zone ID in the external form.The ZoneOffset subclass uses a dedicated format that only stores the offset from UTC/Greenwich.A ZoneId can be deserialized in a Java Runtime where the ID is unknown.For example, if a server-side Java Runtime has been updated with a new zone ID, but the client-side Java Runtime has not been updated.In this case, the ZoneId object will exist, and can be queried using getId, equals, hashCode, toString, getDisplayName and normalized.However, any call to getRules will fail with ZoneRulesException.This approach is designed to allow a ZonedDateTime to be loaded and queried, but not modified, on a Java Runtime with incomplete time-zone information.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of ZoneId may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "This class implements an output stream filter for writing files in the ZIP file format."},
{"description": "A transition between two offsets is normally the result of a daylight savings cutover.The discontinuity is normally a gap in spring and an overlap in autumn.ZoneOffsetTransition models the transition between the two offsets.Gaps occur where there are local date-times that simply do not exist.An example would be when the offset changes from +03:00 to +04:00.This might be described as 'the clocks will move forward one hour tonight at 1am'.Overlaps occur where there are local date-times that exist twice.An example would be when the offset changes from +04:00 to +03:00.This might be described as 'the clocks will move back one hour tonight at 2am'."},
{"description": "A time-zone offset is the amount of timeThis is usually a fixed number of hours and minutes.Different parts of the world have different time-zone offsets.The rules for how offsets vary by place and time of year are captured in the ZoneId class.For example, Paris is one hour ahead of Greenwich/UTC in winter and two hours ahead in summer.The ZoneId instance for Paris will reference two ZoneOffset instances - a +01:00 instance for winter, and a +02:00 instance for summer.In 2008, time-zone offsets around the world extended from -12:00 to +14:00.To prevent any problems with that range being extended, yet still provide validation, the range of offsets is restricted to -18:00 to 18:00 inclusive.This class is designed for use with the ISO calendar system.The fields of hours, minutes and seconds make assumptions that are valid for the standard ISO definitions of those fields.This class may be used with other calendar systems providing the definition of the time fields matches those of the ISO calendar system.Instances of ZoneOffset must be compared using equals(java.lang.Implementations may choose to cache certain common offsets, however applications must not rely on such caching.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of ZoneOffset may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "ZonedDateTime is an immutable representation of a date-time with a time-zone.This class stores all date and time fields, to a precision of nanoseconds, and a time-zone, with a zone offset used to handle ambiguous local date-times.For example, the value \"2nd October 2007 at 13:45.30.123456789 +02:00 in the Europe/Paris time-zone\" can be stored in a ZonedDateTime.This class handles conversion from the local time-line of LocalDateTime to the instant time-line of Instant.The difference between the two time-lines is the offset from UTC/Greenwich, represented by a ZoneOffset.Converting between the two time-lines involves calculating the offset using the rules accessed from the ZoneId.Obtaining the offset for an instant is simple, as there is exactly one valid offset for each instant.By contrast, obtaining the offset for a local date-time is not straightforward.There are three cases: Normal, with one valid offset.For the vast majority of the year, the normal case applies, where there is a single valid offset for the local date-time.This is when clocks jump forward typically due to the spring daylight savings change from \"winter\" to \"summer\".In a gap there are local date-time values with no valid offset.This is when clocks are set back typically due to the autumn daylight savings change from \"summer\" to \"winter\".In an overlap there are local date-time values with two valid offsets.Any method that converts directly or implicitly from a local date-time to an instant by obtaining the offset has the potential to be complicated.For Gaps, the general strategy is that if the local date-time falls in the middle of a Gap, then the resulting zoned date-time will have a local date-time shifted forwards by the length of the Gap, resulting in a date-time in the later offset, typically \"summer\" time.For Overlaps, the general strategy is that if the local date-time falls in the middle of an Overlap, then the previous offset will be retained.If there is no previous offset, or the previous offset is invalid, then the earlier offset is used, typically \"summer\" time..Two additional methods, withEarlierOffsetAtOverlap() and withLaterOffsetAtOverlap(), help manage the case of an overlap.In terms of design, this class should be viewed primarily as the combination of a LocalDateTime and a ZoneId.The ZoneOffset is a vital, but secondary, piece of information, used to ensure that the class represents an instant, especially during a daylight savings overlap.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of ZonedDateTime may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "This class implements an input stream filter for reading files in the ZIP file format."},
{"description": "Year is an immutable date-time object that represents a year.Any field that can be derived from a year can be obtained.Parts of Russia did not switch to the modern Gregorian/ISO rules until 1920.As such, historical years must be treated with caution.For example, the value \"2007\" can be stored in a Year.Years represented by this class follow the ISO-8601 standard and use the proleptic numbering system.Year 1 is preceded by year 0, then by year -1.The ISO-8601 calendar system is the modern civil calendar system used today in most of the world.It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time.For most applications written today, the ISO-8601 rules are entirely suitable.However, any application that makes use of historical dates, and requires them to be accurate will find the ISO-8601 approach unsuitable.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of Year may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "Signals that a Zip exception of some sort has occurred."},
{"description": "This class is used to represent a ZIP file entry."},
{"description": "YearMonth is an immutable date-time object that represents the combination of a year and month.Any field that can be derived from a year and month, such as quarter-of-year, can be obtained.For example, the value \"October 2007\" can be stored in a YearMonth.The ISO-8601 calendar system is the modern civil calendar system used today in most of the world.It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time.For most applications written today, the ISO-8601 rules are entirely suitable.However, any application that makes use of historical dates, and requires them to be accurate will find the ISO-8601 approach unsuitable.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of YearMonth may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "This class is used to read entries from a zip file.Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown."},
{"description": "The parameters include a namespace-qualified stylesheet element.An XSLTTransformParameterSpec is instantiated with a mechanism-dependent (ex: DOM)XSLTTransformParameterSpec spec = new XSLTransformParameterSpec(stylesheet); where element is an Element containing the namespace-qualified stylesheet element."},
{"description": "XPathVariableResolver provides access to the set of user defined XPath variables.The XPathVariableResolver and the XPath evaluator must adhere to a contract that cannot be directly enforced by the API.Although variables may be mutable, that is, an application may wish to evaluate the same XPath expression more than once with different variable values, in the course of evaluating any single XPath expression, a variable's value must not change."},
{"description": "XPathFunctionResolver provides access to the set of user defined XPathFunctions.XPath functions are resolved by name and arity.The resolver is not needed for XPath built-in functions and the resolver cannot be used to override those functions.In particular, the resolver is only called for functions in an another namespace (functions with an explicit prefix).This means that you cannot use the XPathFunctionResolver to implement specifications like XML-Signature Syntax and Processing which extend the function library of XPath 1.0 in the same namespace.This is a consequence of the design of the resolver.If you wish to implement additional built-in functions, you will have to extend the underlying implementation directly."},
{"description": "XPathFunction provides access to XPath functions.Functions are identified by QName and arity in XPath."},
{"description": "XPathFunctionException represents an error with an XPath function."},
{"description": "The parameters include the XPath expression and an optional Map of additional namespace prefix mappings.The XML Schema Definition of the XPath Filtering transform parameters is defined as: <element name=\"XPath"},
{"description": "The parameters include a list of one or more XPathType objects."},
{"description": "XPathException represents a generic XPath exception."},
{"description": "XPathExpressionException represents an error in an XPath expression."},
{"description": "XPathFactoryConfigurationException represents a configuration error in a XPathFactory environment."},
{"description": "A specialized interface that facilitates an extension of the SyncProvider abstract class for XML orientated synchronization providers.SyncProvider implementations that supply XML data writer capabilities such as output XML stream capabilities can implement this interface to provide standard XmlWriter objects to WebRowSet implementations.Writing a WebRowSet object includes printing the rowset's data, metadata, and properties, all with the appropriate XML tags."},
{"description": "An XPathFactory instance can be used to create XPath objects.In other words, it is the application's responsibility to ensure that at most one thread is using a XPathFactory object at any given moment.Implementations are encouraged to mark methods as synchronized to protect themselves from broken clients.While one of the newInstance methods is being invoked, applications may not attempt to recursively invoke a newInstance method, even from the same thread."},
{"description": "XPathExpression provides access to compiled XPath expressions.If a request is made to evaluate the expression in the absence of a context item, an empty document node will be used for the context.For the purposes of evaluating XPath expressions, a DocumentFragment is treated like a Document node.If the expression contains a variable reference, its value will be found through the XPathVariableResolver.An XPathExpressionException is raised if the variable resolver is undefined or the resolver returns null for the variable.The value of a variable must be immutable through the course of any single evaluation.If the expression contains a function reference, the function will be found through the XPathFunctionResolver.An XPathExpressionException is raised if the function resolver is undefined or the function resolver returns null for the function.QNames QNames in the expression are resolved against the XPath namespace context.This result of evaluating an expression is converted to an instance of the desired return type.Valid return types are defined in XPathConstants.Conversion to the return type follows XPath conversion rules.In other words, it is the application's responsibility to make sure that one XPathExpression object is not used from more than one thread at any given time, and while the evaluate method is invoked, applications may not recursively call the evaluate method."},
{"description": "XPath provides access to the XPath evaluation environment and expressions.If a request is made to evaluate the expression in the absence of a context item, an empty document node will be used for the context.For the purposes of evaluating XPath expressions, a DocumentFragment is treated like a Document node.If the expression contains a variable reference, its value will be found through the XPathVariableResolver set with setXPathVariableResolver(XPathVariableResolver resolver).An XPathExpressionException is raised if the variable resolver is undefined or the resolver returns null for the variable.The value of a variable must be immutable through the course of any single evaluation.If the expression contains a function reference, the function will be found through the XPathFunctionResolver set with setXPathFunctionResolver(XPathFunctionResolver resolver).An XPathExpressionException is raised if the function resolver is undefined or the function resolver returns null for the function.QNames QNames in the expression are resolved against the XPath namespace context set with setNamespaceContext(NamespaceContext nsContext).This result of evaluating an expression is converted to an instance of the desired return type.Valid return types are defined in XPathConstants.Conversion to the return type follows XPath conversion rules.In other words, it is the application's responsibility to make sure that one XPath object is not used from more than one thread at any given time, and while the evaluate method is invoked, applications may not recursively call the evaluate method."},
{"description": "Enables mapping a class to a XML Schema complex type with a simpleContent or a XML Schema simple type.The @XmlValue annotation can be used with the following program elements: a JavaBean property.The usage is subject to the following usage constraints:@XmlValue can be used with the following annotations: XmlList.However this is redundant since XmlList maps a type to a simple schema type that derives by list just as XmlValue would.If the type of the field or property is a collection type, then the collection item type must map to a simple schema type.If the type of the field or property is not a collection type, then the type must map to a XML Schema simple type.If the annotated JavaBean property is the sole class member being mapped to XML Schema construct, then the class is mapped to a simple type.If there are additional JavaBean properties (other than the JavaBean property annotated with @XmlValue annotation) that are mapped to XML attributes, then the class is mapped to a complex type with simpleContent."},
{"description": "The purpose of this interface is to group (and provide type safety for) all representations of XML structures."},
{"description": "The XMLStreamWriter does not perform well formedness checking on its input.For attribute values the writeAttribute method will escape the above characters plus \" to ensure that all character content and attribute values are well formed.writeEmptyElement(prefix, localName, namespaceURI) bound to same prefix:if namespaceURI == default Namespace URI, then no prefix is written [2] if prefix == \"\" || null && namespaceURI == \"\", then no prefix or Namespace declaration is generated or written [3] if prefix == \"\" || null, then a prefix is randomly generated [4] if prefix == \"\" || null, then it is treated as the default Namespace and no prefix is generated or written, an xmlns declaration is generated and written if the namespaceURI is unbound [5] if prefix == \"\" || null, then it is treated as an invalid attempt to define the default Namespace and an XMLStreamException is thrown"},
{"description": "Used in XmlType.factoryClass() to signal that either factory mehod is not used or that it's in the class with this XmlType itself."},
{"description": "The XMLStreamReader interface allows forward, read-only access to XML.It is designed to be the lowest level and most efficient way to read XML data.The XMLStreamReader is designed to iterate over XML using next() and hasNext().The data can be accessed using methods such as getEventType(), getNamespaceURI(), getLocalName() and getText(); The next() method causes the reader to read the next parse event.The next() method returns an integer which identifies the type of event just read.The event type can be determined using getEventType().Parsing events are defined as the XML Declaration, a DTD, start tag, character data, white space, end tag, comment, or processing instruction.An attribute or namespace event may be encountered at the root level of a document as the result of a query operation.For XML 1.0 compliance an XML processor must pass the identifiers of declared unparsed entities, notation declarations and their associated identifiers to the application.This information is provided through the property API on this interface.The following two properties allow access to this information: javax.xml.stream.notations and javax.xml.stream.entities.When the current event is a DTD the following call will return a list of Notations List l =getProperty(\"javax.xml.stream.notations\"); The following call will return a list of entity declarations:List l = (List) getProperty(\"javax.xml.stream.entities\"); These properties can only be accessed during a DTD event and are defined to return null if the information is not available.The following table describes which methods are valid in what state.If a method is called in an invalid state the method will throw a java.lang.IllegalStateException."},
{"description": "Usage The @XmlType annnotation can be used with the following program elements: a top level class an enum type See \"Package Specification\" in javax.xml.bind.package javadoc for additional common information.A class is a data container for values represented by properties and fields.A schema type is a data container for values represented by schema components within a schema type's content model (e.g. model groups, attributes etc).To be mapped, a class must either have a public no-arg constructor or a static no-arg factory method.The static factory method can be specified in factoryMethod() and factoryClass() annotation elements.The static factory method or the no-arg constructor is used during unmarshalling to create an instance of this class.If both are present, the static factory method overrides the no-arg constructor.The XML Schema type is derived based on the mapping of JavaBean properties and fields contained within the class.The schema type to which the class is mapped can either be named or anonymous.A class can be mapped to an anonymous schema type by annotating the class with @XmlType(name=\"\").Either a global element, local element or a local attribute can be associated with an anonymous type as follows:global element: A global element of an anonymous type can be derived by annotating the class with @XmlRootElement.A JavaBean property that references a class annotated with @XmlType(name=\"\") and is mapped to the element associated with the anonymous type.A JavaBean property that references a class annotated with @XmlType(name=\"\") and is mapped to the attribute associated with the anonymous type.If class is annotated with @XmlType(name=\"\") , it is mapped to an anonymous type otherwise, the class name maps to a complex type name.The XmlName() annotation element can be used to customize the name.Properties and fields that are mapped to elements are mapped to a content model within a complex type.The annotation element propOrder() can be used to customize the content model to be xs:all or xs:sequence.It is used for specifying the order of XML elements in xs:sequence.Properties and fields can be mapped to attributes within the complex type.The targetnamespace of the XML Schema type can be customized using the annotation element namespace().Mapping class to XML Schema simple type A class can be mapped to a XML Schema simple type using the @XmlValue annotation.The following table shows the mapping of the class to a XML Schema complex type or simple type.The notational symbols used in the table are: -> : represents a mapping [x]+ : one or more occurances of x [ @XmlValue property ]:Usage with other annotations This annotation can be used with the following annotations: XmlRootElement, XmlAccessorOrder, XmlAccessorType, XmlEnum.However, XmlAccessorOrder and XmlAccessorType are ignored when this annotation is used on an enum type.XML Schema mapping for USAddress --XML Schema mapping for USAddress --XML Schema mapping for USAddress --: Code fragment public class Invoice { USAddress addr; ... } @XmlType(name=\"\") public class USAddress { ... } } <!-- XML Schema mapping for USAddress --} public class USAddressFactory { public static USAddress getUSAddress(){ return new USAddress(\"Mark Baker\", \"23 Elm St\", \"Dayton\", \"OH\", 90952); } Example 7: Define factoryMethod and use the default factoryClass @XmlType(name=\"USAddressType\", factoryMethod=\"getNewInstance\") public class USAddress { private String city; private String name; private String state; private String street; private int zip; private USAddress() {} public static USAddress getNewInstance(){ return new USAddress(); } }"},
{"description": "The @XmlTransient annotation is useful for resolving name collisions between a JavaBean property name and a field name or preventing the mapping of a field/property.A name collision can occur when the decapitalized JavaBean property name and a field name are the same.If the JavaBean property refers to the field, then the name collision can be resolved by preventing the mapping of either the field or the JavaBean property using the @XmlTransient annotation.When placed on a class, it indicates that the class shouldn't be mapped to XML by itself.Properties on such class will be mapped to XML along with its derived classes, as if the class is inlined.Usage The @XmlTransient annotation can be used with the following program elements: a JavaBean property field class @XmlTransientis mutually exclusive with all other JAXB defined annotations.The field name \"name\" collides with the property name // obtained by bean decapitalization of getName() below @XmlTransient"},
{"description": "This interface is primarily intended for type-safety.Note that XMLValidateContext instances can contain information and state specific to the XML signature structure it is used with.The results are unpredictable if an XMLValidateContext is used with different signature structures (for example, you should not use the same XMLValidateContext instance to validate two different XMLSignature objects).The following properties can be set by an application using the setProperty method.value must be a Boolean.This property controls whether or not the Reference.validate method will cache the dereferenced content and pre-digested input for subsequent retrieval via the Reference.getDereferencedData and Reference.getDigestInputStream methods."},
{"description": "This Exception class is used to report well-formedness errors as well as unexpected processing conditions."},
{"description": "This interface is primarily intended for type-safety.Note that XMLSignContext instances can contain information and state specific to the XML signature structure it is used with.The results are unpredictable if an XMLSignContext is used with different signature structures (for example, you should not use the same XMLSignContext instance to sign two different XMLSignature objects).The following properties can be set using the setProperty method.value must be a Boolean.This property controls whether or not the digested Reference objects will cache the dereferenced content and pre-digested input for subsequent retrieval via the Reference.getDereferencedData and Reference.getDigestInputStream methods."},
{"description": "Indicates an exceptional condition that occurred during the XML signature generation or validation process.An XMLSignatureException can contain a cause: another throwable that caused this XMLSignatureException to get thrown."},
{"description": "Each instance of XMLSignatureFactory supports a specific XML mechanism type.XMLSignatureFactory.getInstance(\"DOM\"); The objects that this factory produces will be based on DOM and abide by the DOM interoperability requirements as defined in the DOM Mechanism Requirements section of the API overview.XMLSignatureFactory implementations are registered and loaded using the Provider mechanism.For example, a service provider that supports the DOM mechanism would be specified in the Provider subclass as: put(\"XMLSignatureFactory.DOM\", \"org.example.DOMXMLSignatureFactory\"); An implementation MUST minimally support the default mechanism type: DOM.Note that a caller must use the same XMLSignatureFactory instance to create the XMLStructures of a particular XMLSignature that is to be generated.The behavior is undefined if XMLStructures from different providers or different mechanism types are used together.Also, the XMLStructures that are created by this factory may contain state specific to the XMLSignature and are not intended to be reusable.Creating XMLSignatures from scratch Once the XMLSignatureFactory has been created, objects can be instantiated by calling the appropriate method.For example, a Reference instance may be created by invoking one of the newReference methods.Unmarshalling XMLSignatures from XML Alternatively, an XMLSignature may be created from an existing XML representation by invoking the unmarshalXMLSignature method and passing it a mechanism-specific XMLValidateContext instance containing the XML content: DOMValidateContext context =; Each XMLSignatureFactory must support the required XMLValidateContext types for that factory type, but may support others.A DOM XMLSignatureFactory must support DOMValidateContext objects.Signing and marshalling XMLSignatures to XML Each XMLSignature created by the factory can also be marshalled to an XML representation and signed, by invoking the sign method of the XMLSignature object and passing it a mechanism-specific XMLSignContext object containing the signing key and marshalling parameters (see DOMSignContext).For example: DOMSignContext context = new DOMSignContext(privateKey, document); signature.sign(context); Concurrent Access The static methods of this class are guaranteed to be thread-safe.Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.However, this is not true for the non-static methods defined by this class.Unless otherwise documented by a specific provider, threads that need to access a single XMLSignatureFactory instance concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating a different XMLSignatureFactory instance need not synchronize."},
{"description": "The XML Schema Definition is defined as: <element name=\"SignatureValue\""},
{"description": "This interface declares the constants used in this API.Numbers in the range 0 to 256 are reserved for the specification, user defined events must use event codes outside that range."},
{"description": "This class contains methods for signing and validating XML signatures with behavior as defined by the W3C specification.The XML Schema Definition is defined as: <element name=\"Signature\"An XMLSignature instance may be created by invoking one of the newXMLSignature methods of the XMLSignatureFactory class.If the contents of the underlying document containing the XMLSignature are subsequently modified, the behavior is undefined.Note that this class is named XMLSignature rather than Signature to avoid naming clashes with the existing java.security.Signature class."},
{"description": "Instructs JAXB to also bind other classes when binding this class.Java makes it impractical/impossible to list all sub-classes of a given class.This often gets in a way of JAXB users, as it JAXB cannot automatically list up the classes that need to be known to JAXBContext.For example, with the following class definitions: class Animal {} class Dog extends Animal {} class Cat extends Animal {} The user would be required to create JAXBContext as JAXBContext.newInstance(Dog.class,Cat.class)(Animal will be automatically picked up since Dog and Cat refers to it.)XmlSeeAlso annotation would allow you to write: @XmlSeeAlso({Dog.class,Cat.class}) class Animal {} class Dog extends Animal {} class Cat extends Animal {} This would allow you to do JAXBContext.newInstance(Animal.class).By the help of this annotation, JAXB implementations will be able to correctly bind Dog and Cat."},
{"description": "Multiple annotations of the same type are not allowed on a program element.This annotation therefore serves as a container annotation for multiple @XmlSchemaType annotations as follows: @XmlSchemaTypes({ @XmlSchemaType(...), @XmlSchemaType(...) })The @XmlSchemaTypes annnotation can be used to define XmlSchemaType for different types at the package level."},
{"description": "Used in XmlSchemaType.type() to signal that the type be inferred from the signature of the property."},
{"description": "Usage @XmlSchemaType annotation can be used with the following program elements: a JavaBean property field package @XmlSchemaType annotation defined for Java type applies to all references to the Java type from a property/field.A @XmlSchemaType annotation specified on the property/field overrides the @XmlSchemaType annotation specified at the package level.This annotation can be used with the following annotations: XmlElement, XmlAttribute."},
{"description": "Usage The XmlSchema annotation can be used with the following program elements:This is a package level annotation and follows the recommendations and restrictions contained in JSR 175, section III, \"Annotations\".Thus the usage is subject to the following constraints and recommendations.There can only be one package declaration as noted in JSR 175, section III, \"Annotations\".JSR 175 recommends package-info.java for package level annotations.JAXB Providers that follow this recommendation will allow the package level annotations to be defined in package-info.java.Customize name of XML namespace to which package is mapped.prefixes generated by default are implementation depedenent --> Example 2:po=\"http://www.example.com/PO1\" targetNamespace=\"http://www.example.com/PO1\"> Example 3: Customize elementFormDefault @javax.xml.bind.annotation."},
{"description": "This interface is used to resolve resources during an XML parse.If an application wishes to perform custom entity resolution it must register an instance of this interface with the XMLInputFactory using the setXMLResolver method."},
{"description": "This interface is used to report non-fatal errors.Only warnings should be echoed through this interface."},
{"description": "Marks a class that has XmlElementDecls."},
{"description": "Usage The @XmlRootElement annotation can be used with the following program elements: a top level class an enum type See \"Package Specification\" in javax.xml.bind.package javadoc for additional common information.When a top level class or an enum type is annotated with the @XmlRootElement annotation, then its value is represented as XML element in an XML document.This annotation can be used with the following annotations: XmlType, XmlEnum, XmlAccessorType, XmlAccessorOrder.The annotation causes an global element declaration to be produced in the schema.The global element declaration is associated with the XML schema type to which the class is mapped.An element declaration annotated on a type is not inherited by its derived types.The following example shows this.Example: Code fragment @XmlRootElement class Point3D extends Point { int z;-- The element name is point3D not point --Associate a global element with XML Schema type to which the class is mapped. //Exampletype=\"xs:decimal\"/> </sequence>"},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This class contains static methods for creating an XML reader from an explicit class name, or based on runtime defaults: try { XMLReader myReader = XMLReaderFactory.createXMLReader(); } catch (SAXException e) { System.err.println(e.getMessage()); } Note to Distributions bundled with parsers: You should modify the implementation of the no-arguments createXMLReader to handle cases where the external configuration mechanisms aren't set up.That method should do its best to return a parser when one is in the class path, even when nothing bound its class name to org.xml.sax.driver so those configuration mechanisms would see it."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This class wraps a SAX2 XMLReader and makes it act as a SAX1 Parser.The XMLReader must support a true value for the http://xml.org/sax/features/namespace-prefixes property or parsing will fail with a SAXException; if the XMLReader supports a false value for the http://xml.org/sax/features/namespaces property, that will also be used to improve efficiency."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.Note: despite its name, this interface does not extend the standard Java Reader interface, because reading XML is a fundamentally different activity than reading character data.XMLReader is the interface that an XML parser's SAX2 driver must implement.This interface allows an application to set and query features and properties in the parser, to register event handlers for document processing, and to initiate a document parse.All SAX interfaces are assumed to be synchronous: the parse methods must not return until parsing is complete, and readers must wait for an event-handler callback to return before reporting the next event.This interface replaces the (now deprecated) SAX 1.0 Parser interface.The XMLReader interface contains two important enhancements over the old Parser interface (as well as some minor ones): it adds a standard way to query and set features and properties; and it adds Namespace support, which is required for many higher-level XML standards.There are adapters available to convert a SAX1 Parser to a SAX2 XMLReader and vice-versa."},
{"description": "An XMLObject may contain any data and may include optional MIME type, ID, and encoding attributes.The XML Schema Definition is defined as: <element name=\"Object> <attribute name=\"Id\" type=\"ID\" use=\"optional\"/> <attribute name=\"MimeTypeA XMLObject instance may be created by invoking the newXMLObject method of the XMLSignatureFactory class;for example: XMLSignatureFactory fac = XMLSignatureFactory.getInstance(\"DOM\"); List content = Collections.singletonList(fac.newManifest(references))); XMLObject object =, \"object-1\", null, null); Note that this class is named XMLObject rather than Object to avoid naming clashes with the existing java.lang.Object class."},
{"description": "This exception is thrown when an XML formatted string is being parsed into ModelMBean objects or when XML formatted strings are being created from ModelMBean objects.It is also used to wrapper exceptions from XML parsers that may be used.The serialVersionUID of this class is 3176664577895105181L."},
{"description": "A specialized interface that facilitates an extension of the SyncProvider abstract class for XML orientated synchronization providers.SyncProvider implementations that supply XML data reader capabilities such as output XML stream capabilities can implement this interface to provide standard XmlReader objects to WebRowSet implementations.An XmlReader object is registered as the XML reader for a WebRowSet by being assigned to the rowset's xmlReader field.When the WebRowSet object's readXml method is invoked, it in turn invokes its XML reader's readXML method."},
{"description": "The following table defines the standard properties of this specification.Each property varies in the level of support required by each implementation.The level of support required is described in the 'Required' column.The following paragraphs describe the namespace and prefix repair algorithm: The property can be set with the following code line: setProperty(\"javax.xml.stream.isRepairingNamespaces\",new Boolean(true|false)); This property specifies that the writer default namespace prefix declarations.If a writer isRepairingNamespaces it will create a namespace declaration on the current StartElement for any attribute that does not currently have a namespace declaration in scope.If the StartElement has a uri but no prefix specified a prefix will be assigned, if the prefix has not been declared in a parent of the current StartElement it will be declared on the current StartElement.If the defaultNamespace is bound and in scope and the default namespace matches the URI of the attribute or StartElement QNameIf an element or attribute name has a prefix, but is not bound to any namespace URI, then the prefix will be removed during serialization.If element and/or attribute names in the same start or empty-element tag are bound to different namespace URIs and are using the same prefix then the element or the first occurring attribute retains the original prefix and the following attributes have their prefixes replaced with a new prefix that is bound to the namespace URIs of those attributes.If an element or attribute name uses a prefix that is bound to a different URI than that inherited from the namespace context of the parent of that elementand there is no namespace declaration in the context of the current element then such a namespace declaration is added.If an element or attribute name is bound to a prefix and there is a namespace declaration that binds that prefix to a different URI then that namespace declaration is either removed if the correct mapping is inherited from the parent context of that element, or changed to the namespace URI of the element or attribute using that prefix."},
{"description": "Usage The namespace qualification values are used in the annotations defined in this packge.The enumeration values are mapped as follows: Enum Value XML Schema Value UNQUALIFIED unqualified QUALIFIED qualified UNSET namespace qualification attribute is absent from the XML Schema fragment"},
{"description": "Usage The @XmlList annotation can be used with the following program elements: JavaBean property field When a collection property is annotated just with @XmlElement, each item in the collection will be wrapped by an element.For example, @XmlRootElement class Foo { @XmlElement List<String> data; } would produce XML like this: <foo> <data>abc <data>def </foo> @XmlList annotation, on the other hand, allows multiple values to be represented as whitespace-separated tokens in a single element.For example, @XmlRootElement class Foo { @XmlElement @XmlList List<String> data; } the above code will produce XML like this: <foo> <data>abc defThis annotation can be used with the following annotations: XmlElement, XmlAttribute, XmlValue, XmlIDREF.The use of @XmlList with XmlValue while allowed, is redundant since XmlList maps a collection type to a simple schema type that derives by list just as XmlValue would.The use of @XmlList with XmlAttribute while allowed, is redundant since XmlList maps a collection type to a simple schema type that derives by list just as XmlAttribute would."},
{"description": "Used in XmlJavaTypeAdapter.type() to signal that the type be inferred from the signature of the field, property, parameter or the class."},
{"description": "Multiple annotations of the same type are not allowed on a program element.This annotation therefore serves as a container annotation for multiple @XmlJavaTypeAdapterThe @XmlJavaTypeAdapters annnotation is useful for defining XmlJavaTypeAdapter annotations for different types at the package level."},
{"description": "The usage is subject to the following constraints: can be used with @XmlElementRef, @XmlElementRefs or @XmlAnyElementannotated multi-valued property XML text information items are added as values of java.lang.String.Children element information items are added as instances of JAXBElement or instances with a class that is annotated with @XmlRootElement.Unknown content that is not be bound to a JAXB mapped class is inserted as Element.(Assumes property annotated with @XmlAnyElement)Below is an example of binding and creation of mixed content.// (Only annotations relevant to mixed content are shown below, // others are ommitted.)createLetterBody(); } public class LetterBody { // Mixed content can contain instances of Element classes //Text data is represented as // java.util.String for text.} The following is an XML instance document with mixed content <letterBodyBaby Monitor</productName> shipped from our warehouse.</letterBody> that can be constructed using following JAXB API calls.// add text information item See \"Package Specification\" in javax.xml.bind.package javadoc for additional common information."},
{"description": "Associates the MIME type that controls the XML representation of the property.This annotation is used in conjunction with datatypes such as Image or Source that are bound to base64-encoded binary in XML.If a property that has this annotation has a sibling property bound to the xmime:contentType attribute, and if in the instance the property has a value, the value of the attribute takes precedence and that will control the marshalling."},
{"description": "annotation is intended for use from other program annotations."},
{"description": "The following table defines the standard properties of this specification.Each property varies in the level of support required by each implementation.The level of support required is described in the 'Required' column.javax.xml.stream.isReplacingEntityReferencesreplace internal entity references with their replacement text and report them as charactersBooleanTrueYesjavax.xml.stream.isSupportingExternalEntitiesResolve external parsed entitiesBooleanUnspecifiedYesjavax.xml.stream.supportDTDUse this property to request processors that do not support DTDsBooleanTrueYesjavax.xml.stream.reportersets/gets the impl of the XMLReporter javax.xml.stream.XMLReporterNullYesjavax.xml.stream.resolversets/getsthe impl of the XMLResolver interfacejavax.xml.stream.XMLResolverNullYesjavax.xml.stream.allocatorsets/gets the impl of the XMLEventAllocator interfacejavax.xml.stream.util.XMLEventAllocatorNullYes"},
{"description": "Use an adapter that implements XmlAdapter for custom marshaling.The @XmlJavaTypeAdapter annotation can be used with the following program elements: a JavaBean property field parameter package from within XmlJavaTypeAdapters When @XmlJavaTypeAdapter annotation is defined on a class, it applies to all references to the class.When @XmlJavaTypeAdapter annotation is defined at the package level it applies to all references from within the package to @XmlJavaTypeAdapter.type().When @XmlJavaTypeAdapter annotation is defined on the field, property or parameter, then the annotation applies to the field, property or the parameter only.A @XmlJavaTypeAdapter annotation on a field, property or parameter overrides the @XmlJavaTypeAdapter annotation associated with the class being referenced by the field, property or parameter.A @XmlJavaTypeAdapter annotation on a class overrides the @XmlJavaTypeAdapter annotation specified at the package level for that class.This annotation can be used with the following other annotations: XmlElement, XmlAttribute, XmlElementRef, XmlElementRefs, XmlAnyElement.This can also be used at the package level with the following annotations: XmlAccessorType, XmlSchema, XmlSchemaType, XmlSchemaTypes."},
{"description": "Disable consideration of XOP encoding for datatypes that are bound to base64-encoded binary data in XML.When XOP encoding is enabled as described in AttachmentMarshaller.isXOPPackage(), this annotation disables datatypes such as Image or Source or byte[] that are bound to base64-encoded binary from being considered for XOP encoding.If a JAXB property is annotated with this annotation or if the JAXB property's base type is annotated with this annotation, neither AttachmentMarshaller.addMtomAttachment(DataHandler, String, String) nor AttachmentMarshaller.addMtomAttachment(byte[], int, int, String, String, String) is ever called for the property."},
{"description": "Usage The @XmlIDREF annotation can be used with the following program elements: a JavaBean property non static, non transient field See \"Package Specification\" in javax.xml.bind.package javadoc for additional common information.The usage is subject to the following constraints: If the type of the field or property is a collection type, then the collection item type must contain a property or field annotated with @XmlID.If the field or property is single valued, then the type of the property or field must contain a property or field annotated with @XmlID.Note: If the collection item type or the type of the property (for non collection type) is java.lang.Object, then the instance must contain a property/field annotated with @XmlID attribute.This annotation can be used with the following annotations: XmlElement, XmlAttribute, XmlList, and XmlElements.: The following is a complete example of containment versus reference.By default, Customer maps to complex typexs:Customer public class Customer { // map JavaBean property type to xs:ID @XmlID public String getCustomerID(); public void setCustomerID(StringBy default, Invoice maps to a complex typeShipping public class Shipping { // map by reference @XmlIDREF public Customer getCustomer(); public void setCustomer(Customer customer); } // at least one class must reference Customer by containment; // Customer instances won't be marshalled.XML Schema mapping for above code frament --"},
{"description": "Usage The @XmlID annotation can be used with the following program elements: a JavaBean property non static, non transient field See \"Package Specification\" in javax.xml.bind.package javadoc for additional common information.The usage is subject to the following constraints:At most one field or property in a class can be annotated with @XmlID.The only other mapping annotations that can be used with @XmlID are:@XmlElement and @XmlAttribute."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This class is designed to sit between an XMLReader and the client application's event handlers.By default, it does nothing but pass requests up to the reader and events on to the handlers unmodified, but subclasses can override specific methods to modify the event stream or the configuration requests as they pass through."},
{"description": "The DTD specification is provided as Appendix A to the Java Logging APIs specification.The XMLFormatter can be used with arbitrary character encodings, but it is recommended that it normally be used with UTF-8.The character encoding can be set on the output Handler."},
{"description": "Specifically, these date/time datatypes are DatatypeConstants.These datatypes are normatively defined in W3C XML Schema 1.0 Part 2, Section 3.2.7-14.The table below defines the mapping between XML Schema 1.0 date/time datatype fields and this class' fields.It also summarizes the value constraints for the date and time fields defined in W3C XML Schema 1.0 Part 2, Appendix D, ISO 8601 Date and Time Formats.A value of null indicates field is undefined.Given that XML Schema 1.0 errata states that the year zero will be a valid lexical value in a future version of XML Schema, this class allows the year field to be set to zero.Otherwise, the year field value is handled exactly as described in the errata and [ISO-8601-1988].Note that W3C XML Schema 1.0 validation does not allow for the year field to have a value of zero.FIELD_UNDEFINED day getDay() Independent of month, max range is 1 to 31 or DatatypeConstants.The normative value constraint stated relative to month field's value is in W3C XML Schema 1.0 Part 2, Appendix D. hour getHour() 0 to 23 or DatatypeConstants.An hour value of 24 is allowed to be set in the lexical space provided the minute and second field values are zero.However, an hour value of 24 is not allowed in value space and will be transformed to represent the value of the first instance of the following day as per XML Schema Part 2: Datatypes Second Edition, 3.2 Primitive datatypes.getFractionalSecond() allows for infinite precision over the range from 0.0 to 1.0 when the getSecond() is defined.FractionalSecond is optional and has a value of null when it is undefined.getMillisecond() is the convenience millisecond precision of value of getFractionalSecond().Value range from -14 hoursAll maximum value space constraints listed for the fields in the table above are checked by factory methods, @{linkIllegalArgumentException is thrown when a parameter's value is outside the value constraint for the field or if the composite values constitute an invalid XMLGregorianCalendar instance (for example, if the 31st of June is specified).The following operations are defined for this class: accessors/mutators for independent date/time fields conversion between this class and W3C XML Schema 1.0 lexical representation, toString(), DatatypeFactory.newXMLGregorianCalendar(String lexicalRepresentation) conversion between this class and GregorianCalendar, toGregorianCalendar(java.util."},
{"description": "This is the top level interface for writing XML documents.Instances of this interface are not required to validate the form of the XML."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.An XML filter is like an XML reader, except that it obtains its events from another XML reader rather than a primary source like an XML document or database.Filters can modify a stream of events as they pass on to the final application.The XMLFilterImpl helper class provides a convenient base for creating SAX2 filters, by passing on all EntityResolver, DTDHandler, ContentHandler and ErrorHandler events automatically."},
{"description": "This is the top level interface for parsing XML Events.It provides the ability to peek at the next event and returns configuration information through the property interface."},
{"description": "This interface defines a utility class for creating instances of XMLEvents"},
{"description": "Usage The @XmlEnumValue annotation can be used with the following program elements:enum constant See \"Package Specification\" in javax.xml.bind.package javadoc for additional common information.This annotation, together with XmlEnum provides a mapping of enum type to XML representation.An enum type is mapped to a schema simple type with enumeration facets.The schema type is derived from the Java type specified in @XmlEnum.value().Each enum constant @XmlEnumValue must have a valid lexical representation for the type @XmlEnum.value()Code fragment @XmlEnum(String.class) public enum Card { CLUBS, DIAMONDS, HEARTS, SPADES } <!--"},
{"description": "This is the base event interface for handling markup events.Events are value objects that are used to communicate the XML 1.0 InfoSet to the Application."},
{"description": "The XMLEncoder class is a complementary alternative to the ObjectOutputStream and can used to generate a textual representation of a JavaBean in the same way that the ObjectOutputStream can be used to create binary representation of Serializable objects.For example, the following fragment can be used to create a textual representation the supplied JavaBean and all its properties: XMLEncoder e = new XMLEncoder(new BufferedOutputStream( new FileOutputStream(\"Test.xml\"))); e.writeObject(new JButton(\"Hello, world\")); e.close(); Despite the similarity of their APIs, the XMLEncoder class is exclusively designed for the purpose of archiving graphs of JavaBeans as textual representations of their public properties.Like Java source files, documents written this way have a natural immunity to changes in the implementations of the classes involved.The ObjectOutputStream continues to be recommended for interprocess communication and general purpose serialization.The XMLEncoder class provides a default denotation for JavaBeans in which they are represented as XML documents complying with version 1.0 of the XML specification and the UTF-8 character encoding of the Unicode/ISO 10646 character set.The XML documents produced by the XMLEncoder class are: Portable and version resilient: they have no dependencies on the private implementation of any classand so, like Java source files, they may be exchanged between environments which may have different versions of some of the classes and between VMs from different vendors.Structurally compact: The XMLEncoder class uses a redundancy elimination algorithm internally so that the default values of a Bean's properties are not written to the stream.Fault tolerant: Non-structural errors in the file, caused either by damage to the file or by API changes made to classes in an archive remain localized so that a reader can report the error and continue to load the parts of the document which were not affected by the error.Below is an example of an XML archive containing some user interface components from the swing toolkit: <?\"> <string>frame1</string> </void> <void property=\"bounds\"> <object class=\"java.awt.The XML syntax uses the following conventions: Each element represents a method call.The \"object\" tag denotes an expression whose value is to be used as the argument to the enclosing element.The \"void\" tag denotes a statement which will be executed, but whose result will not be used as an argument to the enclosing method.Elements which contain elements use those elements as arguments, unless they have the tag: \"void\".The name of the method is denoted by the \"method\" attribute.XML's standard \"id\" and \"idref\" attributes are used to make references to previous expressions - so as to deal with circularities in the object graph.The \"class\" attribute is used to specify the target of a static method or constructor explicitly; its value being the fully qualified name of the class.Elements with the \"void\" tag are executed using the outer context as the target if no target is defined by a \"class\" attribute.world</string> where the characters of the string are converted to bytes using the UTF-8 character encoding.Although all object graphs may be written using just these three tags, the following definitions are included so that common data structures can be expressed more concisely: The default method name is \"new\".A reference to a java class is written in the form <class>javax.swing.Instances of the wrapper classes for Java's primitive types are written using the name of the primitive type as the tag.For example, an instance of the Integer class could be written: <int>123</int>.Note that the XMLEncoder class uses Java's reflection package in which the conversion between Java's primitive types and their associated \"wrapper classes\" is handled internally.The API for the XMLEncoder class itself deals only with Objects.In an element representing a nullary method whose name starts with \"get\", the \"method\" attribute is replaced with a \"property\" attribute whose value is given by removing the \"get\" prefix and decapitalizing the result.In an element representing a monadic method whose name starts with \"set\", the \"method\" attribute is replaced with a \"property\" attribute whose value is given by removing the \"set\" prefix and decapitalizing the result.In an element representing a method named \"get\" taking one integer argument, the \"method\" attribute is replaced with an \"index\" attribute whose value the value of the first argument.In an element representing a method named \"set\" taking two arguments, the first of which is an integer, the \"method\" attribute is replaced with an \"index\" attribute whose value the value of the first argument.A reference to an array is written using the \"array\" tag.The \"class\" and \"length\" attributes specify the sub-type of the array and its length respectively.For more information you might also want to check out Using XMLEncoder, an article in The Swing Connection."},
{"description": "This annotation, together with XmlEnumValue provides a mapping of enum type to XML representation.Usage The @XmlEnum annotation can be used with the following program elements: enum typeThe usage is subject to the following constraints: This annotation can be used the following other annotations: XmlType, XmlRootElement See \"Package Specification\" in javax.xml.bind.package javadoc for additional common information An enum type is mapped to a schema simple type with enumeration facets.The schema type is derived from the Java type to which @XmlEnum.value().Each enum constant @XmlEnumValue must have a valid lexical representation for the type @XmlEnum.value() ."},
{"description": "This interface defines a class that allows a user to register a way to allocate events given an XMLStreamReader.An implementation is not required to use the XMLEventFactory implementation but this is recommended.The XMLEventAllocator can be set on an XMLInputFactory using the property \"javax.xml.stream.allocator\""},
{"description": "This interface defines an event consumer interface.The contract of the of a consumer is to accept the event.This interface can be used to mark an object as able to receive events.Add may be called several times in immediate succession so a consumer must be able to cache events it hasn't processed yet."},
{"description": "A container for multiple @XmlElement annotations.Multiple annotations of the same type are not allowed on a program element.This annotation therefore serves as a container annotation for multiple @XmlElements as follows: @XmlElementsThe @XmlElements annnotation can be used with the following program elements: a JavaBean property non static, non transient field This annotation is intended for annotation a JavaBean collection property (e.g. List).Usage The usage is subject to the following constraints: This annotation can be used with the following annotations:If @XmlIDREF is also specified on the JavaBean property, then each @XmlElement.type() must contain a JavaBean property annotated with @XmlID.-- XML Representation for a List of {1,2.5} XML output is not wrapped using another element --> ... <complexType name=\"Foo\"> <xs:sequence>complexType name=\"Foo\"> <xs:sequence>class PX extends P {...} @XmlType(name=\"PY\")class PY extends P {...} <!--complexType name=\"Foo\"> <xs:sequence>"},
{"description": "Used in XmlElementDecl.scope() to signal that the declaration is in the global scope."},
{"description": "Usage @XmlElementRef annotation can be used with a JavaBean property or from within XmlElementRefsThis annotation dynamically associates an XML element name with the JavaBean property.When a JavaBean property is annotated with XmlElement, the XML element name is statically derived from the JavaBean property name.However, when this annotation is used, the XML element name is derived from the instance of the type of the JavaBean property at runtime.XML Schema substitution group support XML Schema allows a XML document author to use XML element names that were not statically specified in the content model of a schema using substitution groups.Schema derived code provides support for substitution groups using an element property, (section 5.5.5, \"Element Property\" of JAXB 2.0 specification).An element property method signature is of the form: public void setTerm(JAXBElement extends Operator>); public JAXBElement extends Operator> getTerm(); An element factory method annotated with XmlElementDecl is used to create a JAXBElement instance, containing an XML element name.The presence of @XmlElementRef annotation on an element property indicates that the element name from JAXBElement instance be used instead of deriving an XML element name from the JavaBean property name.The usage is subject to the following constraints: If the collection item type (for collection property) or property type (for single valued property) is JAXBElement, then @XmlElementRef}.name() and @XmlElementRef.namespace() must point an element factory method with an @XmlElementDecl annotation in a class annotated with @XmlRegistry (usually ObjectFactory class generated by the schema compiler) :If the collection item type (for collection property) or property type (for single valued property) is not JAXBElement, then the type referenced by the property or field must be annotated with XmlRootElement.This annotation can be used with the following annotations:An Ant task corresponds to a class in the class hierarchy.The XML element name of an Ant task is indicated by the @XmlRootElement annotation on its corresponding class.The presence of @XmlElementRef indicates that the XML // element name will be derived from the @XmlRootElement //class JarTask extends Task { ... } @XmlRootElement(name=\"javac\") class JavacTask extends Task { ... } <!choice maxOccurs=\"unbounded\"> <xs:element ref=\"jar\"Thus the following code fragment: Target target = new Target(); target.tasks.add(new JarTask()); target.tasks.add(new JavacTask()); marshal(target); will produce the following XML output: <target> <jar> .... </jar>It is not an error to have a class that extends Task that doesn't have XmlRootElement.But they can't show up in an XML instance (because they don't have XML element names).Example 2: XML Schema Susbstitution group support The following example shows the annotations for XML Schema substitution groups.The annotations and the ObjectFactory are derived from the schema. @XmlElementThe value of type()is // JAXBElement.class , which indicates the XML // element name ObjectFactory - in general a class marked // with @XmlRegistry.The name() is \"operator\", a pointer to a // factory method annotated with a // XmlElementDecl with the name \"operator\".Since // \"operator\" is the head of a substitution group that // contains elements \"add\" and \"sub\" elements, \"operator\" //element can be substituted in an instance document by // elements \"add\" or \"sub\".At runtime, JAXBElement // instance contains the element name that has been // substituted in the XML document."},
{"description": "Used in XmlElement.type() to signal that the type be inferred from the signature of the property."},
{"description": "Usage The annotation creates a mapping between an XML schema element declaration and a element factory method that returns a JAXBElement instance representing the element declaration.Typically, the element factory method is generated (and annotated) from a schema into the ObjectFactory class in a Java package that represents the binding of the element declaration's target namespace.Thus, while the annotation syntax allows @XmlElementDecl to be used on any method, semantically its use is restricted to annotation of element factory method.The usage is subject to the following constraints: The class containing the element factory method annotated with @XmlElementDecl must be marked with XmlRegistry.The element factory method must take one parameter assignable to Object.The following example illustrates the use of scope annotation parameter in binding of element declaration in schema derived code.The following example may be replaced in a future revision of this javadoc.choice maxOccurs=\"unbounded\"> <xs:element name=\"foo\" type=\"xs:string\"/> <xs:element name=\"bar\" type=\"xs:string\"/> </xs:choice> </xs:@XmlElementDecl(name=\"foo\") JAXBElement createFoo(Integer i); } Without scope createFoo and createPeaFoo would become ambiguous since both of them map to a XML schema element with the same local name \"foo\"."},
{"description": "This is primarily intended to be used to produce a wrapper XML element around collections.The annotation therefore supports two forms of serialization shown below. //Example<wrapperElement> <names> value-of-item </names> <names> value-of-item </names> ....> The two serialized XML forms allow a null collection to be represented either by absence or presence of an element with a nillable attribute.Usage The @XmlElementWrapper annotation can be used with the following program elements:The usage is subject to the following constraints: The property must be a collection propertyThis annotation can be used with the following annotations: XmlElement, XmlElements, XmlElementRef, XmlElementRefs, XmlJavaTypeAdapter."},
{"description": "Marks a property that refers to classes with XmlElement or JAXBElement.Compared to an element property (property with XmlElement annotation), a reference property has a different substitution semantics.When a sub-class is assigned to a property, an element property produces the same tag name with @xsi:type, whereas a reference property produces a different tag name (the tag name that's on the the sub-class.)This annotation can be used with the following annotations: XmlJavaTypeAdapter, XmlElementWrapper."},
{"description": "Used in XmlElementRef.type() to signal that the type be inferred from the signature of the property."},
{"description": "The XMLDecoder class is used to read XML documents created using the XMLEncoder and is used just like the ObjectInputStream.For example, one can use the following fragment to read the first object defined in an XML document written by the XMLEncoder class: XMLDecoder d = new XMLDecoder( new BufferedInputStream( new FileInputStream(\"Test.xml\"))); Object result = d.readObject(); d.close(); For more information you might also want to check out Long Term Persistence of JavaBeans Components: XML Schema, an article in The Swing Connection."},
{"description": "Usage @XmlElement annotation can be used with the following program elements: a JavaBean property non static, non transient field within XmlElementsThe usage is subject to the following constraints: This annotation can be used with following annotations: XmlID, XmlIDREF, XmlList, XmlSchemaType, XmlValue, XmlAttachmentRef,XmlInlineBinaryData, XmlElementWrapper, XmlJavaTypeAdapter if the type of JavaBean property is a collection type of array, an indexed property, or a parameterized list, and this annotation is used with XmlElements then, @XmlElement.type() must be DEFAULT.class since the collection item type is already known.A JavaBean property, when annotated with @XmlElement annotation is mapped to a local element in the XML Schema complex type to which the containing class is mapped."},
{"description": "Usage The @XmlAttribute annotation can be used with the following program elements:A static final field is mapped to a XML fixed attribute.The usage is subject to the following constraints: If type of the field or the property is a collection type, then the collection item type must be mapped to schema simple type.Examples @XmlAttribute List<Integer> items;//legal @XmlAttribute List<Bar> foo; // illegal if Bar does not map to a schema simple type If the type of the field or the property is a non collection type, then the type of the property or field must map to a simple schema type.Examples @XmlAttribute int foo;illegal if Foo does not map to a schema simple type This annotation can be used with the following annotations: XmlID, XmlIDREF, XmlList, XmlSchemaType, XmlValue, XmlAttachmentRef,"},
{"description": "This interface contains methods for setting and retrieving properties that affect the processing of XML signatures or XML encrypted structures.Note that XMLCryptoContext instances can contain information and state specific to the XML cryptographic structure it is used with.The results are unpredictable if an XMLCryptoContext is used with multiple structures (for example, you should not use the same XMLValidateContext instance to validate two different XMLSignature objects)."},
{"description": "Marks a field/property that its XML form is a uri reference to mime content.The mime content is optimally stored out-of-line as an attachment.A field/property must always map to the DataHandler class."},
{"description": "This annotation serves as a \"catch-all\" property while unmarshalling xml content into a instance of a JAXB annotated class.It typically annotates a multi-valued JavaBean property, but it can occur on single value JavaBean property.During unmarshalling, each xml element that does not match a static @XmlElement or @XmlElementRef annotation for the other JavaBean properties on the class, is added to this \"catch-all\" property.public Object[] others; @XmlAnyElement private List<Element> nodes; @XmlAnyElement private Element node; Restriction usage constraints This annotation is mutually exclusive with XmlElement, XmlAttribute, XmlValue, XmlElements, XmlID, and XmlIDREF.There can be only one XmlAnyElement annotated JavaBean property in a class and its super classes.Relationship to other annotations This annotation can be used with XmlJavaTypeAdapter, so that users can map their own data structure to DOM, which in turn can be composed into XML.This annotation can be used with XmlMixed like this: // List of java.lang.String or DOM nodes.List<Object> others;The following schema would produce the following Java class: <xs:complexType name=\"foo\"> <xs:sequence>complexType> class Foo { int a; int b;@XmlAnyElement List<Element> any; } It can unmarshal instances like <foo xmlns:this will be bound to DOM, because unmarshalling is orderless <b>3this will be bound to DOM, because the annotation doesn't remember namespaces.The following schema would produce the following Java class:complexType> class Bar extends Foo { int c; //} It can unmarshal instances like <bar xmlns:e=\"extra\"> <a>1this will be bound to DOM, because unmarshalling is orderless <b>3this will go to Foo.any </barThe XmlAnyElement annotation can be used with XmlElementRefs to designate additional elements that can participate in the content tree.The following schema would produce the following Java class: <xs:complexType name=\"foo\"> <xs:choice maxOccurs=\"unbounded\" minOccurs=\"0\"List<Object> others; } @XmlRegistryIt can unmarshal instances like <foo xmlns:this will unmarshal to a JAXBElement instance whose value is 1.this will unmarshal to a DOM Element.this will unmarshal to a JAXBElement instance whose value is 1.The lax element of the annotation enables the emulation of the \"lax\" wildcard semantics.For example, when the Java source code is annotated like this: @XmlRootElement class Foo { @XmlAnyElement(lax=true) public Object[] others; } then the following document will unmarshal like this: <foo> <unknown /> <foo /> </foo"},
{"description": "Usage The @XmlAnyAttribute annotation can be used with the following program elements:JavaBean property non static, non transient field See \"Package Specification\" in javax.xml.bind.package javadoc for additional common information.The usage is subject to the following constraints:At most one field or property in a class can be annotated with @XmlAnyAttribute.must java.util.Map While processing attributes to be unmarshalled into a value class, each attribute that is not statically associated with another JavaBean property, via XmlAttribute, is entered into the wildcard attribute map represented by Map<QName,Object>.The attribute QName is the map's key.The key's value is the String value of the attribute."},
{"description": "Usage: Some Java types do not map naturally to a XML representation, for example HashMap or other non JavaBean classes.Conversely, a XML repsentation may map to a Java type but an application may choose to accesss the XML representation using another Java type.For example, the schema to Java binding rules bind xs:But an application may desire to bind xs:In both cases, there is a mismatch between bound type , used by an application to access XML content and the value type, that is mapped to an XML representation.The methods are invoked by the JAXB binding framework during marshaling and unmarshalling: XmlAdapter.marshal(...): During marshalling, JAXB binding framework invokes(..) to adapt a bound type to value type, which is then marshaled to XML representation.(...): During unmarshalling, JAXB binding framework first unmarshals XML representation to a value type and then invokes XmlAdapter.unmarshal(..)Writing an adapter therefore involves the following steps: Write an adapter that implements this abstract class.The following example illustrates the use of @XmlAdapter and @XmlJavaTypeAdapter to customize the mapping of a HashMap.key=\"id123\">this is a value</entry> <entry key=\"id312\">this is another value</entry> ...Determine the schema definition that the desired XML representation shown above should follow.Write value types that can generate the above schema definition.public class MyHashMapType { List<MyHashMapEntryType> entry; } public class MyHashMapEntryType { @XmlAttribute public Integer key; @XmlValue public String value; } Step 4: Write the adapter that adapts the value type, MyHashMapType to a bound type, HashMap, used by the application.public final class MyHashMapAdapter extends XmlAdapter<MyHashMapType,HashMap> { ...HashMap hashmap; ... } The above code fragment will map to the following schema:"},
{"description": "Controls whether fields or Javabean properties are serialized by default.Usage @XmlAccessorType annotation can be used with the following program elements: package a top level class See \"Package Specification\" in javax.xml.bind.package javadoc for additional common information.This annotation provides control over the default serialization of properties and fields in a class.The following inheritance semantics apply: If there is a @XmlAccessorType on a class, then it is used.Otherwise, if a @XmlAccessorType exists on one of its super classes, then it is inherited.Otherwise, the @XmlAccessorType on a package is inherited.Defaulting Rules: By default, if @XmlAccessorType on a package is absent, then the following package level annotation is assumed. @XmlAccessorType(XmlAccessType.By default, if @XmlAccessorType on a class is absent, and none of its super classes is annotated with @XmlAccessorType, then the following default on the class is assumed: @XmlAccessorType(XmlAccessType.This annotation can be used with the following annotations: XmlType, XmlRootElement, XmlAccessorOrder, XmlSchema, XmlSchemaType, XmlSchemaTypes, , XmlJavaTypeAdapter.It can also be used with the following annotations at the package level: XmlJavaTypeAdapter."},
{"description": "Usage @XmlAccessorOrder annotation can be used with the following program elements:package a top level class See \"Package Specification\" in javax.xml.bind package javadoc for additional common information.The effective XmlAccessOrder on a class is determined as follows: If there is a @XmlAccessorOrder on a class, then it is used.Otherwise, if a @XmlAccessorOrder exists on one of its super classes, then it is inherited (by the virtue of Inherited)Otherwise, the @XmlAccessorOrder on the package of the class is used, if it's there.This annotation can be used with the following annotations: XmlType, XmlRootElement, XmlAccessorType, XmlSchema, XmlSchemaType, XmlSchemaTypes, , XmlJavaTypeAdapter.It can also be used with the following annotations at the package level: XmlJavaTypeAdapter."},
{"description": "The Xid interface is a Java mapping of the X/Open transaction identifier XID structure.This interface specifies three accessor methods to retrieve a global transaction format ID, global transaction ID, and branch qualifier.The Xid interface is used by the transaction manager and the resource managers.This interface is not visible to the application programs."},
{"description": "The XAException is thrown by the Resource Manager (RM) to inform the Transaction Manager of an error encountered by the involved transaction."},
{"description": "The XAResource interface is a Java mapping of the industry standard XA interface based on the X/Open CAE Specification (Distributed Transaction Processing: The XA Specification).The XA interface defines the contract between a Resource Manager and a Transaction Manager in a distributed transaction processing (DTP) environment.A JDBC driver or a JMS provider implements this interface to support the association between a global transaction and a database or message service connection.The XAResource interface can be supported by any transactional resource that is intended to be used by application programs in an environment where transactions are controlled by an external transaction manager.An example of such a resource is a database management system.An application may access data through multiple database connections.Each database connection is enlisted with the transaction manager as a transactional resource.The transaction manager obtains an XAResource for each connection participating in a global transaction.The transaction manager uses the start method to associate the global transaction with the resource, and it uses the end method to disassociate the transaction from the resource.The resource manager is responsible for associating the global transaction to all work performed on its data between the start and end method invocations.At transaction commit time, the resource managers are informed by the transaction manager to prepare, commit, or rollback a transaction according to the two-phase commit protocol."},
{"description": "A factory for XAConnection objects that is used internally.An object that implements the XADataSource interface is typically registered with a naming service that uses the Java Naming and Directory Interface\u2122 (JNDI).An implementation of XADataSource must include a public no-arg constructor."},
{"description": "An object that provides support for distributed transactions.An XAConnection object may be enlisted in a distributed transaction by means of an XAResource object.A transaction manager, usually part of a middle tier server, manages an XAConnection object through the XAResource object.An application programmer does not use this interface directly; rather, it is used by a transaction manager working in the middle tier server."},
{"description": "Instance of this interface manage which X509 certificates may be used to authenticate the remote side of a secure socket.Decisions may be based on trusted certificate authorities, certificate revocation lists, online status checking or other means."},
{"description": "To prevent man-in-the-middle attacks, hostname checks can be done to verify that the hostname in an end-entity certificate matches the targeted hostname.TLS does not require such checks, but some protocols over TLS (such as HTTPS) do.In earlier versions of the JDK, the certificate chain checks were done at the SSL/TLS layer, and the hostname verification checks were done at the layer over TLS.This class allows for the checking to be done during a single call to this class.RFC 2830 defines the server identification specification for the \"LDAPS\" algorithm.RFC 2818 defines both the server identification and the client identification specification for the \"HTTPS\" algorithm."},
{"description": "An X509IssuerSerial object contains an X.509 issuer distinguished name (DN) and serial number pair.The XML schema definition is defined as: <element name=\"X509IssuerSerial\" type=\"ds:X509IssuerSerialType\"/> <complexType name=\"X509IssuerSerialType\"> <sequence> <element name=\"X509IssuerName\"An X509IssuerSerial instance may be created by invoking the newX509IssuerSerial method of the KeyInfoFactory class, and passing it a String and BigInteger representing the X.500 DN and serial number.Here is an example of creating an X509IssuerSerial from the issuer DN and serial number of an existing X509Certificate: KeyInfoFactory factory = KeyInfoFactory.getInstance(\"DOM\"); X509IssuerSerial issuer = factory.newX509IssuerSerial ("},
{"description": "Abstract class that provides for extension of the X509KeyManager interface.Methods in this class should be overriden to provide actual implementations."},
{"description": "The extensions defined for X.509 v3 Certificates and v2 CRLs (Certificate Revocation Lists) provide methods for associating additional attributes with users or public keys, for managing the certification hierarchy, and for managing CRL distribution.The X.509 extensions format also allows communities to define private extensions to carry information unique to those communities.Each extension in a certificate/CRL may be designated as critical or non-critical.A certificate/CRL-using system (an application validating a certificate/CRL) must reject the certificate/CRL if it encounters a critical extension it does not recognize.The ASN.1 definition for this is: Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension Extension ::= SEQUENCE { extnId OBJECT IDENTIFIER, critical BOOLEAN DEFAULT FALSE, extnValue OCTET STRING -- contains a DER encoding of a value -- of the type registered for use with -- the extnId object identifier value } Since not all extensions are known, the getExtensionValue method returns the DER-encoded OCTET STRING of the extension value (i.e., the extnValue).This can then be handled by a Class that understands the extension."},
{"description": "Instances of this interface manage which X509 certificate-based key pairs are used to authenticate the local side of a secure socket.During secure socket negotiations, implentations call methods in this interface to: determine the set of aliases that are available for negotiations based on the criteria presented, select the best alias based on the criteria presented, and obtain the corresponding key material for given aliases.Note: the X509ExtendedKeyManager should be used in favor of this class."},
{"description": "An X509Data object contains one or more identifers of keys or X.509 certificates (or certificates' identifiers or a revocation list).The XML Schema Definition is defined as: <element name=\"X509Datatype=\"ds:X509DataType\"/> <complexType name=\"X509DataType\"> <sequence maxOccurs=\"unbounded\"> <choice>An X509Data instance may be created by invoking the newX509Data methods of the KeyInfoFactory class and passing it a list of one or more XMLStructures representing X.509 content; for example: KeyInfoFactory factory = KeyInfoFactory.getInstance(\"DOM\");"},
{"description": "A CRLSelector that selects X509CRLs that match all specified criteria.This class is particularly useful when selecting CRLs from a CertStore to check revocation status of a particular certificate.When first constructed, an X509CRLSelector has no criteria enabled and each of the get methods return a default value (null).Therefore, the match method would return true for any X509CRL.Typically, several criteria are enabled (by calling setIssuers or setDateAndTime, for instance) and then the X509CRLSelector is passed to CertStore.getCRLs or some similar method.Unless otherwise specified, the methods defined in this class are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "A CRL is a time-stamped list identifying revoked certificates.It is signed by a Certificate Authority (CA) and made freely available in a public repository.Each revoked certificate is identified in a CRL by its certificate serial number.When a certificate-using system uses a certificate (e.g., for verifying a remote user's digital signature), that system not only checks the certificate signature and validity but also acquires a suitably- recent CRL and checks that the certificate serial number is not on that CRL.The meaning of \"suitably-recent\" may vary with local policy, but it usually means the most recently-issued CRL.A CA issues a new CRL on a regular periodic basis (e.g., hourly, daily, or weekly).Entries are added to CRLs as revocations occur, and an entry may be removed when the certificate expiration date is reached.The X.509 v2 CRL format is described below in ASN.1: CertificateList ::= SEQUENCE { tbsCertList TBSCertList, signatureAlgorithm AlgorithmIdentifier, signature BIT STRING }More information can be found in RFC 3280:The ASN.1 definition of tbsCertList is: TBSCertList ::=v2 signature AlgorithmIdentifier, issuer Name, thisUpdate ChoiceOfTime, nextUpdate ChoiceOfTime OPTIONAL, revokedCertificates SEQUENCE OF SEQUENCE { userCertificate CertificateSerialNumber, revocationDate ChoiceOfTime, crlEntryExtensions Extensions OPTIONAL --EXPLICIT Extensions OPTIONAL -- if present, must be v2 } CRLs are instantiated using a certificate factory.The following is an example of how to instantiate an X.509 CRL: try (InputStream inStream = new FileInputStream(\"fileName-of-crl\")) { CertificateFactory cf = CertificateFactory.getInstance(\"X.509\"); X509CRL crl = (X509CRL)cf.generateCRL(inStream); }"},
{"description": "A CertSelector that selects X509Certificates that match all specified criteria.This class is particularly useful when selecting certificates from a CertStore to build a PKIX-compliant certification path.When first constructed, an X509CertSelector has no criteria enabled and each of the get methods return a default value (null, or -1 for the getBasicConstraints method).Therefore, the match method would return true for any X509Certificate.Typically, several criteria are enabled (by calling setIssuer or setKeyUsage, for instance) and then the X509CertSelector is passed to CertStore.getCertificates or some similar method.Several criteria can be enabled (by calling setIssuer and setSerialNumber, for example) such that the match method usually uniquely matches a single X509Certificate.We say usually, since it is possible for two issuing CAs to have the same distinguished name and each issue a certificate with the same serial number.Other unique combinations include the issuer, subject, subjectKeyIdentifier and/or the subjectPublicKey criteria.Unless otherwise specified, the methods defined in this class are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "This provides a standard way to access all the version 1 attributes of an X.509 certificate.Attributes that are specific to X.509 v2 or v3 are not available through this interface.Future API evolution will provide full access to complete X.509 v3 attributes.The basic X.509 format was defined by ISO/IEC and ANSI X9 and is described below in ASN.1:These certificates are widely used to support authentication and other functionality in Internet security systems.Common applications include Privacy Enhanced Mail (PEM), Transport Layer Security (SSL), code signing for trusted software distribution, and Secure Electronic Transactions (SET).These certificates are managed and vouched for by Certificate Authorities (CAs).CAs are services which create certificates by placing data in the X.509 standard format and then digitally signing that data.CAs act as trusted third parties, making introductions between principals who have no direct knowledge of each other.CA certificates are either signed by themselves, or by some other CA such as a \"root\" CA.The ASN.1 definition of tbsCertificate is: TBSCertificate ::=SEQUENCE { version [0] EXPLICIT Version DEFAULT v1, serialNumber CertificateSerialNumber, signature AlgorithmIdentifier, issuer Name, validity Validity, subject Name, subjectPublicKeyInfo SubjectPublicKeyInfo, } Here is sample code to instantiate an X.509 certificate: InputStream inStream =inStream.close(); OR byte[] certData = <certificate read from a file, say> X509Certificate cert = X509Certificate.getInstance(certData); In either case, the code that instantiates an X.509 certificate consults the value of the cert.provider.x509v1 security property to locate the actual implementation or instantiates a default implementation.The cert.provider.x509v1 property is set to a default implementation for X.509 such as: cert.provider.x509v1=com.sun.security.cert.internal.x509.X509V1CertImplThe value of this cert.provider.x509v1 property has to be changed to instantiate another implementation.Currently, due to possible security restrictions on access to Security properties, this value is looked up and cached at class initialization time and will fallback on a default implementation if the Security property is not accessible.Note: The classes in the package javax.security.cert exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE).New applications should instead use the standard Java SE certificate classes located in java.security.cert."},
{"description": "This class represents the ASN.1 encoding of a public key, encoded according to the ASN.1 type SubjectPublicKeyInfo.The SubjectPublicKeyInfo syntax is defined in the X.509 standard as follows: SubjectPublicKeyInfo ::= SEQUENCE { algorithm AlgorithmIdentifier, subjectPublicKey BIT STRING }"},
{"description": "The ASN.1 definition for revokedCertificates is: revokedCertificates SEQUENCE OF SEQUENCE { userCertificate CertificateSerialNumber, revocationDate ChoiceOfTime, crlEntryExtensions Extensions OPTIONAL -- if present, must be v2 } OPTIONAL CertificateSerialNumber ::=INTEGER Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension Extension ::= SEQUENCE { extnId OBJECT IDENTIFIER, critical BOOLEAN DEFAULT FALSE, extnValue OCTET STRING -- contains a DER encoding of a value -- of the type registered for use with -- the extnId object identifier value }"},
{"description": "This provides a standard way to access all the attributes of an X.509 certificate.In June of 1996, the basic X.509 v3 format was completed by ISO/IEC and ANSI X9, which is described below in ASN.1: Certificate ::= SEQUENCE { tbsCertificate TBSCertificate, signatureAlgorithm AlgorithmIdentifier, signature BIT STRING }These certificates are widely used to support authentication and other functionality in Internet security systems.Common applications include Privacy Enhanced Mail (PEM), Transport Layer Security (SSL), code signing for trusted software distribution, and Secure Electronic Transactions (SET).These certificates are managed and vouched for by Certificate Authorities (CAs).CAs are services which create certificates by placing data in the X.509 standard format and then digitally signing that data.CAs act as trusted third parties, making introductions between principals who have no direct knowledge of each other.CA certificates are either signed by themselves, or by some other CA such as a \"root\" CA.More information can be found in RFC 3280:The ASN.1 definition of tbsCertificate is: TBSCertificate ::=SEQUENCE { version [0] EXPLICIT Version DEFAULT v1, serialNumber CertificateSerialNumber, signature AlgorithmIdentifier, issuer Name, validity Validity, subject Name, subjectPublicKeyInfo SubjectPublicKeyInfo,issuerUniqueID [1] IMPLICIT UniqueIdentifier OPTIONAL, -- If present, version must be v2 or v3subjectUniqueID [2] IMPLICIT UniqueIdentifier OPTIONAL, -- If present, version must be v2 or v3 extensions [3] EXPLICIT Extensions OPTIONAL --If present, version must be v3 } Certificates are instantiated using a certificate factory.The following is an example of how to instantiate an X.509 certificate:"},
{"description": "This class represents an X500PrivateCredential.It associates an X.509 certificate, corresponding private key and the KeyStore alias used to reference that exact key pair in the KeyStore.This enables looking up the private credentials for an X.500 principal in a subject."},
{"description": "This class represents an X.500 Principal.X500Principals are represented by distinguished names such as \"CN=Duke, OU=This class can be instantiated by using a string representation of the distinguished name, or by using the ASN.1 DER encoded byte representation of the distinguished name.The current specification for the string representation of a distinguished name is defined in RFC 2253:This class, however, accepts string formats from both RFC 2253 and RFC 1779:A String Representation of Distinguished Names, and also recognizes attribute type keywords whose OIDs (Object Identifiers) are defined in RFC 3280:The string representation for this X500Principal can be obtained by calling the getName methods.Note that the getSubjectX500Principal and getIssuerX500Principal methods of X509Certificate return X500Principals representing the issuer and subject fields of the certificate."},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "This exception is thrown only by the methods Request.get_response and ORB.get_next_response when they are invoked from a transaction scope that is different from the one in which the client originally sent the request."},
{"description": "Interface for JDBC classes which provide the ability to retrieve the delegate instance when the instance in question is in fact a proxy class.The wrapper pattern is employed by many JDBC driver implementations to provide extensions beyond the traditional JDBC API that are specific to a data source.Developers may wish to gain access to these resources that are wrapped (the delegates) as proxy class instances representing the the actual resources.This interface describes a standard mechanism to access these wrapped resources represented by their proxy, to permit direct access to the resource delegates."},
{"description": "The class that is interested in processing a window event either implements this interface (and all the methods it contains) or extends the abstract WindowAdapter class (overriding only the methods of interest).The listener object created from that class is then registered with a Window using the window's addWindowListener method.When the window's status changes by virtue of being opened, closed, activated or deactivated, iconified or deiconified, the relevant method in the listener object is invoked, and the WindowEvent is passed to it."},
{"description": "The class that is interested in processing a WindowEvent either implements this interface (and all the methods it contains) or extends the abstract WindowAdapter class (overriding only the methods of interest).The listener object created from that class is then registered with a Window using the Window's addWindowFocusListener method.When the Window's status changes by virtue of it being opened, closed, activated, deactivated, iconified, or deiconified, or by focus being transfered into or out of the Window, the relevant method in the listener object is invoked, and the WindowEvent is passed to it."},
{"description": "Thrown to indicate that code has attempted to call a method handle via the wrong method type.As with the bytecode representation of normal Java method calls, method handle calls are strongly typed to a specific type descriptor associated with a call site.This amounts to an early evaluation of the type mismatch, at method handle construction time, instead of when the mismatched method handle is called."},
{"description": "View of plain text (text with only one font and color) that does line-wrapping.This view expects that its associated element has child elements that represent the lines it should be wrapping.It is implemented as a vertical box that contains logical line views.The logical line views are nested classes that render the logical line as multiple physical line if the logical line is too wide to fit within the allocation.The line views draw upon the outer class for its state to reduce their memory requirements.The line views do all of their rendering through the drawLine method which in turn does all of its rendering through the drawSelectedText and drawUnselectedText methods.This enables subclasses to easily specialize the rendering without concern for the layout aspects."},
{"description": "A low-level event that indicates that a window has changed its status.This low-level event is generated by a Window object when it is opened, closed, activated, deactivated, iconified, or deiconified, or when focus is transfered into or out of the Window.The event is passed to every WindowListener or WindowAdapter object which registered to receive such events using the window's addWindowListener method.(WindowAdapter objects implement the WindowListener interface.)Each such listener object gets this WindowEvent when the event occurs.An unspecified behavior will be caused if the id parameter of any particular WindowEvent instance is not in the range from WINDOW_FIRST to WINDOW_LAST."},
{"description": "A window type defines the generic visual appearance and behavior of a top-level window.For example, the type may affect the kind of decorations of a decorated Frame or Dialog instance.Some platforms may not fully support a certain window type.Depending on the level of support, some properties of the window type may be disobeyed."},
{"description": "The methods in this class are empty.This class exists as convenience for creating listener objects.(If you implement the WindowListener interface, you have to define all of the methods in it.This abstract class defines null methods for them all, so you can only have to define methods for events you care about.)When the window's status changes by virtue of being opened, closed, activated or deactivated, iconified or deiconified, the relevant method in the listener object is invoked, and the WindowEvent is passed to it."},
{"description": "Constants used to control the window-closing operation.The setDefaultCloseOperation and getDefaultCloseOperation methods provided by JFrame, JInternalFrame, and JDialog use these constants."},
{"description": "T A wildcard may have its upper bound explicitly set by an extends clause, its lower bound explicitly set by a super clause, or neither (but not both)."},
{"description": "A Window object is a top-level window with no borders and no menubar.The default layout for a window is BorderLayout.A window must have either a frame, dialog, or another window defined as its owner when it's constructed.In a multi-screen environment, you can create a Window on a different screen device by constructing the Window with Window(Window, GraphicsConfiguration).The GraphicsConfiguration object is one of the GraphicsConfiguration objects of the target screen device.In a virtual device multi-screen environment in which the desktop area could span multiple physical screen devices, the bounds of all configurations are relative to the virtual device coordinate system.The origin of the virtual-coordinate system is at the upper left-hand corner of the primary physical screen.Depending on the location of the primary screen in the virtual device, negative coordinates are possible, as shown in the following figure.In such an environment, when calling setLocation, you must pass a virtual coordinate to this method.The following code sets the location of a Window at (10, 10) relative to the origin of the physical screen of the corresponding GraphicsConfiguration.If the bounds of the GraphicsConfiguration is not taken into account, the Window location would be set at (10, 10) relative to the virtual-coordinate system and would appear on the primary physical screen, which might be different from the physical screen of the specified GraphicsConfiguration.; Note: the location and size of top-level windows (including Windows, Frames, and Dialogs) are under the control of the desktop's window management system.Calls to setLocation, setSize, and setBounds are requests (not directives) which are forwarded to the window management system.Every effort will be made to honor such requests.However, in some cases the window management system may ignore such requests, or modify the requested geometry in order to place and size the Window in a way that more closely matches the desktop settings.Due to the asynchronous nature of native event handling, the results returned by getBounds, getLocation, getLocationOnScreen, and getSize might not reflect the actual geometry of the Window on screen until the last request has been processed.During the processing of subsequent requests these values might change accordingly while the window management system fulfills the requests.An application may set the size and location of an invisible Window arbitrarily, but the window management system may subsequently change its size and/or location when the Window is made visible.One or more ComponentEvents will be generated to indicate the new geometry.Windows are capable of generating the following WindowEvents:"},
{"description": "WildcardType represents a wildcard type expression, such as ?, ? extends Number, or ?"},
{"description": "The WebServiceRefs annotation allows multiple web service references to be declared at the class level.It can be used to inject both service and proxy instances.If the references are accessed by multiple threads, usual synchronization techniques can be used to support multiple threads.There is no way to associate web service features with the injected instances.If an instance needs to be configured with web service features, use @WebServiceRef to inject the resource along with its features.The StockQuoteProvider proxy instance, and the StockQuoteService service instance are injected using @WebServiceRefs.public class MyClient { void init() { Context ic = new InitialContext(); StockQuoteService service = (StockQuoteService) ic.lookup(\"java:comp/env/service/stockquoteservice\"); StockQuoteProvider port = (StockQuoteProvider) ic.lookup(\"java:comp/env/service/stockquoteprovider\"); ... } ... }"},
{"description": "The WebServiceRef annotation is used to define a reference to a web service and (optionally) an injection target for it.It can be used to inject both service and proxy instances.If the references are accessed by multiple threads, usual synchronization techinques can be used to support multiple threads.Web service references are resources in the Java EE 5 sense.The annotations (for example, Addressing) annotated with meta-annotation WebServiceFeatureAnnotation can be used in conjunction with WebServiceRef.The created reference MUST be configured with annotation's web service feature.For example, in the code below, the injected StockQuoteProvider proxy MUST have WS-Addressing enabled as specifed by the Addressing annotation.public class MyClient { @Addressing @WebServiceRef(StockQuoteService.class) private StockQuoteProvider stockQuoteProvider; ...} If a JAX-WS implementation encounters an unsupported or unrecognized annotation annotated with the WebServiceFeatureAnnotation that is specified with WebServiceRef, an ERROR MUST be given."},
{"description": "A standard week is seven days long, but cultures have different definitions for some other aspects of a week.This class represents the definition of the week, for the purpose of providing TemporalField instances.WeekFields provides five fields, dayOfWeek(), weekOfMonth(), weekOfYear(), weekOfWeekBasedYear(), and weekBasedYear() that provide access to the values from any temporal object.The computations for day-of-week, week-of-month, and week-of-year are based on the proleptic-year, month-of-year, day-of-month, and ISO day-of-week which are based on the epoch-day and the chronology.The values may not be aligned with the year-of-Era depending on the Chronology.A week is defined by: The first day-of-week.For example, the ISO-8601 standard counts the first week as needing at least 4 days.Together these two values allow a year or month to be divided into weeks.Week of Month One field is used: week-of-month.The calculation ensures that weeks never overlap a month boundary.The month is divided into periods where each period starts on the defined first day-of-week.The earliest period is referred to as week 0if it has less than the minimal number of days and week 1 if it has at least the minimal number of days.2009 Week of Year One field is used: week-of-year.The calculation ensures that weeks never overlap a year boundary.The year is divided into periods where each period starts on the defined first day-of-week.The earliest period is referred to as week 0if it has less than the minimal number of days and week 1 if it has at least the minimal number of days.Week Based Year Two fields are used for week-based-year, one for the week-of-week-based-year and one for week-based-year.Week 1 of a year is the first week that starts on the first day-of-week and has at least the minimum number of days.The first and last weeks of a year may contain days from the previous calendar year or next calendar year respectively."},
{"description": "Web service Permissions are identified by name (also referred to as a \"target name\") alone.There are no actions associated with them.publishEndpoint The publishEndpoint permission allows publishing a web service endpoint using the publish methods defined by the javax.xml.ws.Endpoint class.Granting publishEndpoint allows the application to be exposed as a network service.Depending on the security of the runtime and the security of the application, this may introduce a security hole that is remotely exploitable."},
{"description": "Annotation used to identify other annotations as a WebServiceFeature.Each WebServiceFeature annotation annotated with this annotationJAX-WS defines the following WebServiceFeature annotations (Addressing, MTOM, RespectBinding), however, an implementation may define vendors specific annotations for other features.Annotations annotated with WebServiceFeatureAnnotation MUST have the same @Target of WebServiceRef annotation, so that the resulting feature annotation can be used in conjunction with the WebServiceRef annotation if necessary.If a JAX-WS implementation encounters an annotation annotated with the WebServiceFeatureAnnotation that it does not recognize/support an error MUST be given."},
{"description": "The class that is interested in processing a window state event either implements this interface (and all the methods it contains) or extends the abstract WindowAdapter class (overriding only the methods of interest).The listener object created from that class is then registered with a window using the Window's addWindowStateListener method., the windowStateChanged method in the listener object is invoked, and the WindowEvent is passed to it."},
{"description": "A WebServiceFeature is used to represent a feature that can be enabled or disabled for a web service.The JAX-WS specification will define some standard features and JAX-WS implementors are free to define additional features if necessary.Vendor specific features may not be portable so caution should be used when using them.Each Feature definition MUST define a public static final String ID that can be used in the Feature annotation to refer to the feature.This ID MUST be unique across all features of all vendors."},
{"description": "The WebServiceException class is the base exception class for all JAX-WS API runtime exceptions."},
{"description": "A WebServiceContext makes it possible for a web service endpoint implementation class to access message context and security information relative to a request being served.Typically a WebServiceContext is injected into an endpoint implementation class using the Resource annotation."},
{"description": "The information specified in this annotation is sufficient to uniquely identify a wsdl:service element inside a WSDL document.This wsdl:service element represents the Web service for which the generated service interface provides a client view."},
{"description": "The standard interface that all implementations of a WebRowSet must implement.1.0 Overview The WebRowSetImpl provides the standard reference implementation, which may be extended if required.The standard WebRowSet XML Schema definition is available at the following URI: http://java.sun.com/xml/ns/jdbc/webrowset.xsdIt describes the standard XML document format required when describing a RowSet object in XML and must be used be all standard implementations of the WebRowSet interface to ensure interoperability.In addition, the WebRowSet schema uses specific SQL/XML Schema annotations, thus ensuring greater cross platform inter-operability.This is an effort currently under way at the ISO organization.The SQL/XML definition is available at the following URI: http://standards.iso.org/iso/9075/2002/12/sqlxml The schema definition describes the internal data of a RowSet object in three distinct areas: properties -These properties describe the standard synchronization provider properties in addition to the more general RowSet properties.metadata - This describes the metadata associated with the tabular structure governed by a WebRowSet object.The metadata described is closely aligned with the metadata accessible in the underlying java.sql.ResultSet interface.data - This describes the original data (the state of data since the last population or last synchronization of the WebRowSet object) and the current data.By keeping track of the delta between the original data and the current data, a WebRowSet maintains the ability to synchronize changes in its data back to the originating data source.The following sections demonstrates how a WebRowSet implementation should use the XML Schema to describe update, insert, and delete operations and to describe the state of a WebRowSet object in XML.In this example, a WebRowSet object is created and populated with a simple 2 column, 5 row table from a data source.Having the 5 rows in a WebRowSet object makes it possible to describe them in XML.The metadata describing the various standard JavaBeans properties as defined in the RowSet interface plus the standard properties defined in the CachedRowSet\u2122 interface provide key details that describe WebRowSet properties.Outputting the WebRowSet object to XML using the standard writeXml methods describes the internal properties as follows: <properties<datasource/> <escape-processing>true</escape-processing> <fetch-direction>0</fetch-direction> <fetch-size>0</fetch-size> <isolation-level>1</isolation-level> <key-columns/> <map/> <max-field-size>0</max-field-size> <max-rows>0</max-rows> <query-timeout>0</query-timeout> <read-only>false</read-only> <rowset-type>TRANSACTION_READ_UNCOMMITED</rowset-type> <show-deleted>false</show-deleted> <table-name/> <url>jdbc:The meta-data describing the make up of the WebRowSet is described in XML as detailed below.Note both columns are described between the column-definition tags.<column-count>2</column-count> <column-definition> <column-index>1</column-index> <auto-increment>false</auto-increment> <case-sensitive>true</case-sensitive> <currency>false</currency> <nullable>1</nullable> <signed>false</signed> <searchable>true</searchable> <column-display-size>10</column-display-size> <column-label>COL1</column-label> <column-name>COL1</column-name><schema-name/> <column-precision>10</column-precision> <column-scale>0</column-scale> <table-name/> <catalog-name/> <column-type>1</column-type> <column-type-name>CHAR</column-type-name> </column-definition> <column-definition> <column-index>2</column-index> <auto-increment>false</auto-increment> <case-sensitive>false</case-sensitive> <currency>false</currency> <nullable>1</nullable> <signed>true</signed> <searchable>true</searchable> <column-display-size>39</column-display-size> <column-label>COL2</column-label> <column-name>COL2</column-name> <schema-name/> <column-precision>38</column-precision> <column-scale>0</column-scale> <table-name/> <catalog-name/> <column-type>3</column-type> <column-type-name>NUMBER</column-type-name> </column-definition> </metadataHaving detailed how the properties and metadata are described, the following details how the contents of a WebRowSet object is described in XML.Note, that this describes a WebRowSet object that has not undergone any modifications since its instantiation.A currentRow tag is mapped to each row of the table structure that the WebRowSet object provides.A columnValue tag may contain either the stringData or binaryData tag, according to the SQL type that the XML value is mapping back to.The binaryData tag contains data in the Base64 encoding and is typically used for BLOB and CLOB type data.a Row Deleting a row in a WebRowSet object involves simply moving to the row to be deleted and then calling the method deleteRow, as in any other RowSet object.The following two lines of code, in which wrs is a WebRowSet object, delete the third row.; wrs.deleteRow(); The XML description shows the third row is marked as a deleteRow, which eliminates the third row in the WebRowSet object.A WebRowSet object can insert a new row by moving to the insert row, calling the appropriate updater methods for each column in the row, and then calling the method insertRow.wrs.insertRow(); The following code fragment changes the second column value in the row just inserted.Note that this code applies when new rows are inserted right after the current row, which is why the method next moves the cursor to the correct row.Calling the method acceptChanges writes the change to the data source.(); wrs.next(); wrs.updateString(2, \"V\"); wrs.acceptChanges(); Describing this in XML demonstrates where the Java code inserts a new row and then performs an update on the newly inserted row on an individual field.2.4 State 4 - Modifying a Row Modifying a row produces specific XML that records both the new value and the value that was replaced.The value that was replaced becomes the original value, and the new value becomes the current value.The following code moves the cursor to a specific row, performs some modifications, and updates the row when complete.; wrs.updateString(1, \"new4thRow\"); wrs.updateString(2, \"IV\"); wrs.updateRow(); In XML, this is described by the modifyRow tag.Both the original and new values are contained within the tag for original row tracking purposes."},
{"description": "The information specified in this annotation is sufficient to uniquely identify a wsdl:port element inside a wsdl:service.The latter is determined based on the value of the WebServiceClient annotation on the generated service interface itself."},
{"description": "A watch service that watches registered objects for changes and events.For example a file manager may use a watch service to monitor a directory for changes so that it can update its display of the list of files when files are created or deleted.A Watchable object is registered with a watch service by invoking its register method, returning a WatchKey to represent the registration.When an event for an object is detected the key is signalled, and if not currently signalled, it is queued to the watch service so that it can be retrieved by consumers that invoke the poll or take methods to retrieve keys and process events.Once the events have been processed the consumer invokes the key's reset method to reset the key which allows the key to be signalled and re-queued with further events.Registration with a watch service is cancelled by invoking the key's cancel method.A key that is queued at the time that it is cancelled remains in the queue until it is retrieved.Depending on the object, a key may be cancelled automatically.For example, suppose a directory is watched and the watch service detects that it has been deleted or its file system is no longer accessible.When a key is cancelled in this manner it is signalled and queued, if not currently signalled.To ensure that the consumer is notified the return value from the reset method indicates if the key is valid.A watch service is safe for use by multiple concurrent consumers.To ensure that only one consumer processes the events for a particular object at any time then care should be taken to ensure that the key's reset method is only invoked after its events have been processed.The close method may be invoked at any time to close the service causing any threads waiting to retrieve keys, to throw ClosedWatchServiceException.File systems may report events faster than they can be retrieved or processed and an implementation may impose an unspecified limit on the number of events that it may accumulate.Where an implementation knowingly discards events then it arranges for the key's pollEvents method to return an element with an event type of OVERFLOW.This event can be used by the consumer as a trigger to re-examine the state of the object.When an event is reported to indicate that a file in a watched directory has been modified then there is no guarantee that the program (or programs) that have modified the file have completed.Care should be taken to coordinate access with other programs that may be updating the file.Platform dependencies The implementation that observes events from the file system is intended to map directly on to the native file event notification facility where available, or to use a primitive mechanism, such as polling, when a native facility is not available.Consequently, many of the details on how events are detected, their timeliness, and whether their ordering is preserved are highly implementation specific.For example, when a file in a watched directory is modified then it may result in a single ENTRY_MODIFY event in some implementations but several events in other implementations.Short-lived files (meaning files that are deleted very quickly after they are created) may not be detected by primitive implementations that periodically poll the file system to detect changes.If a watched file is not located on a local storage device then it is implementation specific if changes to the file can be detected.In particular, it is not required that changes to files carried out on remote systems be detected."},
{"description": "An entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use.More precisely, the presence of a mapping for a given key will not prevent the key from being discarded by the garbage collector, that is, made finalizable, finalized, and then reclaimed.When a key has been discarded its entry is effectively removed from the map, so this class behaves somewhat differently from other Map implementations.This class has performance characteristics similar to those of the HashMap class, and has the same efficiency parameters of initial capacity and load factor.Like most collection classes, this class is not synchronized.A synchronized WeakHashMap may be constructed using the Collections.synchronizedMap method.This class is intended primarily for use with key objects whose equals methods test for object identity using the == operator.Once such a key is discarded it can never be recreated, so it is impossible to do a lookup of that key in a WeakHashMap at some later time and be surprised that its entry has been removed.This class will work perfectly well with key objects whose equals methods are not based upon object identity, such as String instances.With such recreatable key objects, however, the automatic removal of WeakHashMap entries whose keys have been discarded may prove to be confusing.The behavior of the WeakHashMap class depends in part upon the actions of the garbage collector, so several familiar (though not required)Map invariants do not hold for this class.Because the garbage collector may discard keys at any time, a WeakHashMap may behave as though an unknown thread is silently removing entries.In particular, even if you synchronize on a WeakHashMap instance and invoke none of its mutator methods, it is possible for the size method to return smaller values over time, for the isEmpty method to return false and then true, for the containsKey method to return true and later false for a given key, for the get method to return a value for a given key but later return null, for the put method to return null and the remove method to return false for a key that previously appeared to be in the map, and for successive examinations of the key set, the value collection, and the entry set to yield successively smaller numbers of elements.Each key object in a WeakHashMap is stored indirectly as the referent of a weak reference.Therefore a key will automatically be removed only after the weak references to it, both inside and outside of the map, have been cleared by the garbage collector.Implementation note: The value objects in a WeakHashMap are held by ordinary strong references.Thus care should be taken to ensure that value objects do not strongly refer to their own keys, either directly or indirectly, since that will prevent the keys from being discarded.Note that a value object may refer indirectly to its key via the WeakHashMap itself; that is, a value object may strongly refer to some other key objectwhose associated value object, in turn, strongly refers to the key of the first value object.If the values in the map do not rely on the map holding strong references to them, one way to deal with this is to wrap values themselves within WeakReferences before inserting, as in: m.put(key, new WeakReference(value)), and then unwrapping upon each get.The iterators returned by the iterator method of the collections returned by all of this class's \"collection view methods\" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException.Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast iterators throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.This class is a member of the Java Collections Framework."},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "Weak reference objects, which do not prevent their referents from being made finalizable, finalized, and then reclaimed.Weak references are most often used to implement canonicalizing mappings.Suppose that the garbage collector determines at a certain point in time that an object is weakly reachable.At that time it will atomically clear all weak references to that object and all weak references to any other weakly-reachable objects from which that object is reachable through a chain of strong and soft references.At the same time it will declare all of the formerly weakly-reachable objects to be finalizable.At the same time or at some later time it will enqueue those newly-cleared weak references that are registered with reference queues."},
{"description": "A watch key is created when a watchable object is registered with a watch service.The key remains valid until: It is cancelled, explicitly, by invoking its cancel method, or Cancelled implicitly, because the object is no longer accessible, or By closing the watch service.A watch key has a state.When an event is detected then the key is signalled and queued so that it can be retrieved by invoking the watch service's poll or take methods.Once signalled, a key remains in this state until its reset method is invoked to return the key to the ready state.Events detected while the key is in the signalled state are queued but do not cause the key to be re-queued for retrieval from the watch service.Events are retrieved by invoking the key's pollEvents method.When initially created, a watch key has no pending events.Typically events are retrieved when the key is in the signalled state leading to the following idiom: for (;;) { // retrieve key WatchKey key = watcher.take(); // process events for (WatchEvent<?> event: key.pollEvents()) { : } // reset the key boolean valid =if (!valid) { // object no longer registered } } Watch keys are safe for use by multiple concurrent threads.Where there are several threads retrieving signalled keys from a watch service then care should be taken to ensure that the reset method is only invoked after the events for the object have been processed.This ensures that one thread is processing the events for an object at any time."},
{"description": "An event or a repeated event for an object that is registered with a WatchService.An event is classified by its kind and has a count to indicate the number of times that the event has been observed.This allows for efficient representation of repeated events.The context method returns any context associated with the event.In the case of a repeated event then the context is the same for all events.Watch events are immutable and safe for use by multiple concurrent threads."},
{"description": "This class is used to build W3CEndpointReference instances.The intended use of this clsss is for an application component, for example a factory component, to create an W3CEndpointReference for a web service endpoint published by the same Java EE application.It can also be used to create W3CEndpointReferences for an Java SE based endpoint by providing the address property.When creating a W3CEndpointReference for an endpoint that is not published by the same Java EE application, the address property MUST be specified.When creating a W3CEndpointReference for an endpoint published by the same Java EE application, the address property MAY be nullbut then the serviceName and endpointName MUST specify an endpoint published by the same Java EE application.When the wsdlDocumentLocation is specified it MUST refer to a valid WSDL document and the serviceName and endpointName (if specified)"},
{"description": "This class represents a W3C Addressing EndpointReferece which is a remote reference to a web service endpoint that supports the W3C WS-Addressing 1.0 - Core Recommendation.Developers should use this class in their SEIs if they want to pass/return endpoint references that represent the W3C WS-Addressing recommendation.JAXB will use the JAXB annotations and bind this class to XML infoset that is consistent with that defined by WS-Addressing."},
{"description": "An event modifier that qualifies how a Watchable is registered with a WatchService.This release does not define any standard modifiers."},
{"description": "An object that may be registered with a watch service so that it can be watched for changes and events.This interface defines the register method to register the object with a WatchService returning a WatchKey to represent the registration.An object may be registered with more than one watch service.Registration with a watch service is cancelled by invoking the key's cancel method."},
{"description": "VolatileImage is an image which can lose its contents at any time due to circumstances beyond the control of the application (e.g., situations caused by the operating system or by other applications).Because of the potential for hardware acceleration, a VolatileImage object can have significant performance benefits on some platforms.The drawing surface of an image (the memory where the image contents actually reside) can be lost or invalidated, causing the contents of that memory to go away.The drawing surface thus needs to be restored or recreated and the contents of that surface need to be re-rendered.VolatileImage provides an interface for allowing the user to detect these problems and fix them when they occur.When a VolatileImage object is created, limited system resources such as video memory (VRAM) may be allocated in order to support the image.When a VolatileImage object is no longer used, it may be garbage-collected and those system resources will be returned, but this process does not happen at guaranteed times.Applications that create many VolatileImage objects (for example, a resizing window may force recreation of its back buffer as the size changes) may run out of optimal system resources for new VolatileImage objects simply because the old objects have not yet been removed from the system.(New VolatileImage objects may still be created, but they may not perform as well as those created in accelerated memory).The flush method may be called at any time to proactively release the resources used by a VolatileImage so that it does not prevent subsequent VolatileImage objects from being accelerated.In this way, applications can have more control over the state of the resources taken up by obsolete VolatileImage objects.This image should not be subclassed directly but should be created by using the Component.createVolatileImage or GraphicsConfiguration.createCompatibleVolatileImage(int, int) methods.An example of using a VolatileImage object follows: // image creation VolatileImage vImg{ // old vImg doesn't work with new GraphicsConfig; re-create it vImg = createVolatileImage(w, h); } Graphics2D g = vImg.createGraphics(); // // miscellaneous rendering commands...(); } while (vImg.contentsLost()); } // copying from the image (here, gScreen is the Graphics // object for the onscreen window) do { int returnCode = vImg.validate(getGraphicsConfiguration()); if (returnCode == VolatileImage.{ // old vImg doesn't work with new GraphicsConfig; re-create it vImg = createVolatileImage(w, h);; } while (vImg.contentsLost()); Note that this class subclasses from the Image class, which includes methods that take an ImageObserver parameter for asynchronous notifications as information is received from a potential ImageProducer.Since this VolatileImage is not loaded from an asynchronous source, the various methods that take an ImageObserver parameter will behave as if the data has already been obtained from the ImageProducer.Specifically, this means that the return values from such methods will never indicate that the information is not yet available and the ImageObserver used in such methods will never need to be recorded for an asynchronous callback notification."},
{"description": "A VolatileCallSite is a CallSite whose target acts like a volatile variable.An invokedynamic instruction linked to a VolatileCallSite sees updates to its call site target immediately, even if the update occurs in another thread.There may be a performance penalty for such tight coupling between threads.Unlike MutableCallSite, there is no syncAll operation on volatile call sites, since every write to a volatile variable is implicitly synchronized with reader threads.In other respects, a VolatileCallSite is interchangeable with MutableCallSite."},
{"description": "A VoiceStatus object contains information about the current status of one of the voices produced by a Synthesizer.MIDI synthesizers are generally capable of producing some maximum number of simultaneous notes, also referred to as voices.A voice is a stream of successive single notes, and the process of assigning incoming MIDI notes to specific voices is known as voice allocation.However, the voice-allocation algorithm and the contents of each voice are normally internal to a MIDI synthesizer and hidden from outside view.One can, of course, learn from MIDI messages which notes the synthesizer is playing, and one might be able deduce something about the assignment of notes to voices.But MIDI itself does not provide a means to report which notes a synthesizer has assigned to which voice, nor even to report how many voices the synthesizer is capable of synthesizing.In Java Sound, however, a Synthesizer class can expose the contents of its voices through its getVoiceStatus() method.This behavior is recommended but optional; synthesizers that don't expose their voice allocation simply return a zero-length array.A Synthesizer that does report its voice status should maintain this information at all times for all of its voices, whether they are currently sounding or not.In other words, a given type of Synthesizer always has a fixed number of voices, equal to the maximum number of simultaneous notes it is capable of sounding.If the voice is not currently processing a MIDI note, it is considered inactive.A voice is inactive when it has been given no note-on commands, or when every note-on command received has been terminated by a corresponding note-off (or by an \"all notes off\" message).For example, this happens when a synthesizer capable of playing 16 simultaneous notes is told to play a four-note chord; only four voices are active in this case (assuming no earlier notes are still playing).Usually, a voice whose status is reported as active is producing audible sound, but this is not always true; it depends on the details of the instrument (that is, the synthesis algorithm) and how long the note has been going on.For example, a voice may be synthesizing the sound of a single hand-clap.In such a situation, the voice is still considered active even though no sound is currently being produced.Besides its active or inactive status, the VoiceStatus class provides fields that reveal the voice's current MIDI channel, bank and program number, MIDI note number, and MIDI volume.All of these can change during the course of a voice.While the voice is inactive, each of these fields has an unspecified value, so you should check the active field first."},
{"description": "The Void class is an uninstantiable placeholder class to hold a reference to the Class object representing the Java keyword void."},
{"description": "A value type is truncatable if it inherits \"safely\" from another value type, which means it can be cast to a more general inherited type.This is one of the possible results of the type_modifier method on the TypeCode interface."},
{"description": "This is one of the possible results of the type_modifier method on the TypeCode interface."},
{"description": "A VMID is a identifier that is unique across all Java virtual machines.VMIDs are used by the distributed garbage collector to identify client VMs."},
{"description": "This is one of the possible results of the type_modified method on the TypeCode interface."},
{"description": "Thrown to indicate that the Java Virtual Machine is broken or has run out of resources necessary for it to continue operating."},
{"description": "Under some circumstances a bean may be run on servers where a GUI is not available.This interface can be used to query a bean to determine whether it absolutely needs a gui, and to advise the bean whether a GUI is available.This interface is for expert developers, and is not needed for normal simple beans.To avoid confusing end-users we avoid using getXXX setXXX design patterns for these methods."},
{"description": "ViewportLayout defines a policy for layout that should be useful for most applications.The viewport makes its view the same size as the viewport, however it will not make the view smaller than its minimum size.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This is intended to enable customization of how views get mapped over a document model."},
{"description": "A very important part of the text package is the View class.As the name suggests it represents a view of the text model, or a piece of the text model.It is this class that is responsible for the look of the text component.The view is not intended to be some completely new thing that one must learn, but rather is much like a lightweight component.By default, a view is very light.It contains a reference to the parentview from which it can fetch many things without holding state, and itcontains a reference to a portion of the model (Element).A view does nothave to exactly represent an element in the model, that is simply a typicaland therefore convenient mapping.A view can alternatively maintain a coupleof Position objects to maintain its location in the model (i.e. representa fragment of an element).This is typically the result of formatting whereviews have been broken down into pieces.The convenience of a substantialrelationship to the element makes it easier to build factories to produce theviews, and makes it easier to keep track of the view pieces as the model ischanged and the view must be changed to reflect the model.Simple viewstherefore represent an Element directly and complex views do not.A view has the following responsibilities: Participate in layout.The view has a setSize method which is like doLayout and setSize in Component combined.The view has a preferenceChanged method which is like invalidate in Component except that one can invalidate just one axis and the child requesting the change is identified.A View expresses the size that it would like to be in terms of three values, a minimum, a preferred, and a maximum span.Layout in a view is can be done independently upon each axis.For a properly functioning View implementation, the minimum span will be <=the preferred span which in turn will be <=The minimum set of methods for layout are: getMinimumSpan getPreferredSpan getMaximumSpan getAlignment preferenceChanged setSizeThe setSize method should be prepared to be called a number of timesThe setSize method is generally called to make sure the View layout is complete prior to trying to perform an operation on it that requires an up-to-date layout.A view's size should always be set to a value within the minimum and maximum span specified by that view.Additionally, the view must always call the preferenceChanged method on the parent if it has changed the values for the layout it would like, and expects the parent to honor.The parent View is not required to recognize a change until the preferenceChanged has been sent.This allows parent View implementations to cache the child requirements if desired.The calling sequence looks something like the following: The exact calling sequence is up to the layout functionality of the parent view (if the view has any children).The view may collect the preferences of the children prior to determining what it will give each child, or it might iteratively update the children one at a time.This is done in the paint method, which is pretty much like a component paint method.Views are expected to potentially populate a fairly large tree.A View has the following semantics for rendering: The view gets its allocation from the parent at paint time, so it must be prepared to redo layout if the allocated area is different from what it is prepared to deal with.The coordinate system is the same as the hosting Component (i.e. the Component returned by the getContainer method).This means a child view lives in the same coordinate system as the parent view unless the parent has explicitly changed the coordinate system.The default is to not clip the children.It is more efficient to allow a view to clip only if it really feels it needs clipping.The Graphics object given is not initialized in any way.A view should set any settings needed.While a view may render into its entire allocation, typically a view does not.Rendering is performed by traversing down the tree of View implementations.Each View is responsible for rendering its children.This behavior is depended upon for thread safety.While view implementations do not necessarily have to be implemented with thread safety in mind, other view implementations that do make use of concurrency can depend upon a tree traversal to guarantee thread safety.The order of views relative to the model is up to the implementation.Although child views will typically be arranged in the same order that they occur in the model, they may be visually arranged in an entirely different order.View implementations may have Z-Order associated with them if the children are overlapping.The methods for rendering are: paint Translate between the model and view coordinate systems.Because the view objects are produced from a factory and therefore cannot necessarily be counted upon to be in a particular pattern, one must be able to perform translation to properly locate spatial representation of the model.The methods for doing this are: modelToView viewToModel getDocumentgetElement getStartOffset getEndOffset The layout must be valid prior to attempting to make the translation.The translation is not valid, and must not be attempted while changes are being broadcasted from the model via a DocumentEvent.If the overall view is represented by many pieces (which is the best situation if one want to be able to change the view and write the least amount of new code), it would be impractical to have a huge number of DocumentListeners.If each view listened to the model, only a few would actually be interested in the changes broadcasted at any given time.Since the model has no knowledge of views, it has no way to filter the broadcast of change information.The view hierarchy itself is instead responsible for propagating the change information.At any level in the view hierarchy, that view knows enough about its children to best distribute the change information further.Changes are therefore broadcasted starting from the root of the view hierarchy.The methods for doing this are: insertUpdate removeUpdate changedUpdate"},
{"description": "A class which extends the EventListenerProxy specifically for adding a VetoableChangeListener with a \"constrained\" property.Instances of this class can be added as VetoableChangeListeners to a bean which supports firing vetoable change events.If the object has a getVetoableChangeListeners method then the array returned could be a mixture of VetoableChangeListener and VetoableChangeListenerProxy objects."},
{"description": "A VetoableChange event gets fired whenever a bean changes a \"constrained\" property.You can register a VetoableChangeListener with a source bean so as to be notified of any constrained property updates."},
{"description": "The Vector class implements a growable array of objects.Like an array, it contains components that can be accessed using an integer index.However, the size of a Vector can grow or shrink as needed to accommodate adding and removing items after the Vector has been created.Each vector tries to optimize storage management by maintaining a capacity and a capacityIncrement.The capacity is always at least as large as the vector size; it is usually larger because as components are added to the vector, the vector's storage increases in chunks the size of capacityIncrement.An application can increase the capacity of a vector before inserting a large number of components; this reduces the amount of incremental reallocation.The iterators returned by this class's iterator and listIterator methods are fail-fast: if the vector is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException.Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.The Enumerations returned by the elements method are not fail-fast.Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast iterators throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.As of the Java 2 platform v1.2, this class was retrofitted to implement the List interface, making it a member of the Java Collections Framework.Unlike the new collection implementations, Vector is synchronized.If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector."},
{"description": "This will become more open in a future release.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Thrown when the \"verifier\" detects that a class file, though well formed, contains some sort of internal inconsistency or security problem."},
{"description": "This is a utility class that can be used by beans that support constrained properties.It manages a list of listeners and dispatches PropertyChangeEvents to them.You can use an instance of this class as a member field of your bean and delegate these types of work to it.The VetoableChangeListener can be registered for all properties or for a property specified by name.Here is an example of VetoableChangeSupport usage that follows the rules and recommendations laid out in the JavaBeans\u2122 specification: public class MyBean { private final VetoableChangeSupport vcs = new VetoableChangeSupport(this); public void addVetoableChangeListener(VetoableChangeListener listener) { this.vcs.addVetoableChangeListener(listener); } public void removeVetoableChangeListener(VetoableChangeListener listener) { this.vcs.removeVetoableChangeListener(listener); } private String value; public String getValue() { return this.value; } public void setValue(String newValue) throws PropertyVetoException { String oldValue = this.value; this.vcs.fireVetoableChange(\"value\", oldValue, newValue);Any non-serializable listeners will be skipped during serialization."},
{"description": "Represents a field, enum constant, method or constructor parameter, local variable, resource variable, or exception parameter."},
{"description": "All TemporalField instances have a valid range of values.This class captures that valid range.It is important to be aware of the limitations of this class.It is possible for there to be invalid values within the outer range.For example, a weird field may have valid values of 1, 2, 4, 6, 7, thus have a range of '1 - 7', despite that fact that values 3 and 5 are invalid.Instances of this class are not tied to a specific field."},
{"description": "Java to IDL ptc 02-01-12 1.5.1.3 ValueOutputStream is used for implementing RMI-IIOP stream format version 2."},
{"description": "Java to IDL ptc 02-01-12ValueInputStream is used for implementing RMI-IIOP stream format version 2."},
{"description": "Defines methods which allow serialization of Java objects to and from GIOP streams."},
{"description": "The ValueFactory interface is the native mapping for the IDL type CORBA::ValueFactory.The read_value() method is called by the ORB runtime while in the process of unmarshaling a value type.A user shall implement this method as part of implementing a type specific value factory.In the implementation, the user shall call is.read_value(java.io.Serializable) with a uninitialized valuetype to use for unmarshaling.The value returned by the stream is the same value passed in, with all the data unmarshaled."},
{"description": "Represents values that can be passed as arguments to relational expressions.Strings, numbers, attributes are valid values and should be represented by implementations of ValueExp."},
{"description": "A Holder class for a java.io.Serializable that is used to store \"out\" and \"inout\" parameters in IDL methods.If an IDL method signature has an IDL ValueBase as an \"out\" or \"inout\" parameter, the programmer must pass an instance of ValueBaseHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myValueBaseHolder is an instance of ValueBaseHolder, the value stored in its value field can be accessed with myValueBaseHolder.value."},
{"description": "The generated Java classes corresponding to valuetype IDL types implement this interface.In other words, the Java mapping of valuetype objects implement the ValueBase interface.The generated Java class for valuetype's shall provide an implementation of the ValueBase interface for the corresponding value type.For value types that are streamable (i.e. non-custom), the generated Java class shall also provide an implementation for the org.omg.CORBA.portable.Streamable interface.(CORBA::ValueBase is mapped to java.io.Serializable.)"},
{"description": "Streaming validator that works on SAX stream.In other words, it is the application's responsibility to make sure that one ValidatorHandler object is not used from more than one thread at any given time.ValidatorHandler checks if the SAX events follow the set of constraints described in the associated Schema, and additionally it may modify the SAX events (for example by adding default values, etc.)ValidatorHandler extends from ContentHandler, but it refines the underlying ContentHandler in the following way: startElement/endElement events must receive non-null String for uri, localName, and qname, even though SAX allows some of them to be null.Similarly, the user-specified ContentHandler will receive non-null Strings for all three parameters.Similarly, the user-specified ContentHandler will receive startPrefixMapping/endPrefixMapping events.If the ValidatorHandler introduces additional namespace bindings, the user-specified ContentHandler will receive additional startPrefixMapping/endPrefixMapping events.Attributes for the ContentHandler.startElement(String,String,String,Attributes) method may or may not include xmlns* attributes.Recognized Properties and Features This spec defines the following feature that must be recognized by all ValidatorHandler implementations.This feature controls how a ValidatorHandler introduces namespace bindings that were not present in the original SAX event stream.When this feature is set to true, it must make sure that the user's ContentHandler will see the corresponding xmlnsOtherwise, xmlns* attributes must not be added to Attributes that's passed to the user-specified ContentHandler.(Note that regardless of this switch, namespace bindings are always notified to applications through ContentHandler.startPrefixMapping(String,String) and ContentHandler.endPrefixMapping(String)Note that this feature does NOT affect the way a ValidatorHandler receives SAX events.It merely changes the way it augments SAX events.This feature is set to false by default."},
{"description": "A processor that checks an XML document against Schema.In other words, it is the application's responsibility to make sure that one Validator object is not used from more than one thread at any given time, and while the validate method is invoked, applications may not recursively call the validate method."},
{"description": "This exception indicates that an error has occurred while performing a validate operation.The ValidationEventHandler can cause this exception to be thrown during the validate operations."},
{"description": "JAXB providers are allowed to use whatever class that implements the ValidationEventLocator interface.This class is just provided for a convenience."},
{"description": "Different fields will be set depending on the type of validation that was being performed when the error or warning was detected.For example, on-demand validation would produce locators that contained references to objects in the Java content tree while unmarshal-time validation would produce locators containing information appropriate to the source of the XML data (file, url, Node, etc)."},
{"description": "ValidationEventHandler implementation that collects all events.After the call to validate or unmarshal completes, call the getEvents method to retrieve all the reported errors and warnings."},
{"description": "A class that represents an immutable universally unique identifier (UUID).A UUID represents a 128-bit value.There exist different variants of these global identifiers.The methods of this class are for manipulating the Leach-Salz variant, although the constructors allow the creation of any variant of UUID (described below).UUID is as follows: The most significant long consists of the following unsigned fields: 0xFFFFFFFF00000000The variant field contains a value which identifies the layout of the UUID.The bit layout described above is valid only for a UUID with a variant value of 2, which indicates the Leach-Salz variant.The version field holds a value that describes the type of this UUID.There are four different basic types of UUIDs: time-based, DCE security, name-based, and randomly generated UUIDs.These types have a version value of 1, 2, 3 and 4, respectively.A Universally Unique IDentifier (UUID) URN Namespace, section 4.2 \"Algorithms for Creating a Time-Based UUID\"."},
{"description": "If an application needs to implement customized event handling, it must implement this interface and then register it with either the Unmarshaller, the Validator, or the Marshaller.The JAXB Provider will then report validation errors and warnings encountered during the unmarshal, marshal, and validate operations to these event handlers.If the handleEvent method throws an unchecked runtime exception, the JAXB Provider must treat that as if the method returned false, effectively terminating whatever operation was in progress at the time (unmarshal, validate, or marshal).Modifying the Java content tree within your event handler is undefined by the specification and may result in unexpected behaviour."},
{"description": "JAXB providers are allowed to use whatever class that implements the ValidationEvent interface.This class is just provided for a convenience."},
{"description": "This event indicates that a problem was encountered while validating the incoming XML data during an unmarshal operation, while performing on-demand validation of the Java content tree, or while marshalling the Java content tree back to XML data."},
{"description": "Checked exception thrown when a lookup of UserPrincipal fails because the principal does not exist."},
{"description": "A UserPrincipal represents an identity that may be used to determine access rights to objects in a file system.A GroupPrincipal represents a group identity.A UserPrincipalLookupService defines methods to lookup identities by name or group name (which are typically user or account names).Whether names and group names are case sensitive or not depends on the implementation.The exact definition of a group is implementation specific buttypically a group represents an identity created for administrative purposes so as to determine the access rights for the members of the group.In particular it is implementation specific if the namespace for names and groups is the same or is distinct.To ensure consistent and correct behavior across platforms it is recommended that this API be used as if the namespaces are distinct.In other words, the lookupPrincipalByName should be used to lookup users, and lookupPrincipalByGroupName should be used to lookup groups."},
{"description": "Provides utility methods that can be used by stubs and ties to perform common operations."},
{"description": "The delegate is a singleton instance of a class that implements this interface and provides a replacement implementation for all the methods of javax.rmi.CORBA.Util.Delegation is enabled by providing the delegate's class name as the value of the javax.rmi.CORBA.UtilClass system property."},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "On many platforms and file systems an entity requires appropriate access rights or permissions in order to access objects in a file system.The access rights are generally performed by checking the identity of the entity.For example, on implementations that use Access Control Lists (ACLs) to enforce privilege separation then a file in the file system may have an associated ACL that determines the access rights of identities specified in the ACL.A UserPrincipal object is an abstract representation of an identity.It has a name that is typically the username or account name that it represents.User principal objects may be obtained using a UserPrincipalLookupService, or returned by FileAttributeView implementations that provide access to identity related attributes.For example, the AclFileAttributeView and PosixFileAttributeView provide access to a file's owner."},
{"description": "All CORBA user exceptions are checked exceptions, which means that they need to be declared in method signatures."},
{"description": "A file attribute view that provides a view of a file's user-defined attributes, sometimes known as extended attributes.User-defined file attributes are used to store metadata with a file that is not meaningful to the file system.It is primarily intended for file system implementations that support such a capability directly but may be emulated.The details of such emulation are highly implementation specific and therefore not specified.This FileAttributeView provides a view of a file's user-defined attributes as a set of name/value pairs, where the attribute name is represented by a String.An implementation may require to encode and decode from the platform or file system representation when accessing the attribute.The value has opaque content.This attribute view defines the read and write methods to read the value into or write from a ByteBuffer.This FileAttributeView is not intended for use where the size of an attribute value is larger than Integer.User-defined attributes may be used in some implementations to store security related attributes so consequently, in the case of the default provider at least, all methods that access user-defined attributes require the RuntimePermission(\"accessUserDefinedAttributes\") permission when a security manager is installed.The supportsFileAttributeView method may be used to test if a specific FileStore supports the storage of user-defined attributes.Where dynamic access to file attributes is required, the getAttribute method may be used to read the attribute value.The attribute value is returned as a byte array (byte[]).The setAttribute method may be used to write the value of a user-defined attribute from a buffer (as if by invoking the write method), or byte array (byte[])."},
{"description": "Signals that a malformed string in modified UTF-8 format has been read in a data input stream or by any class that implements the data input interface.See the DataInput class description for the format in which modified UTF-8 strings are read and written."},
{"description": "URLString is the URL address (corbaloc: or corbaname:) represented as a String."},
{"description": "When associating an object to a key on a node using Node.setUserData() the application can provide a handler that gets called when the node the object is associated to is being cloned, imported, or renamed.This can be used by the application to implement various behaviors regarding the data it associates to the DOM nodes.This interface defines that handler."},
{"description": "This interface defines a factory for URL stream protocol handlers.It is used by the URL class to create a URLStreamHandler for a specific protocol."},
{"description": "The abstract class URLStreamHandler is the common superclass for all stream protocol handlers.A stream protocol handler knows how to make a connection for a particular protocol type, such as http or https.In most cases, an instance of a URLStreamHandler subclass is not created directly by an application.Rather, the first time a protocol name is encountered when constructing a URL, the appropriate stream protocol handler is automatically loaded."},
{"description": "The name of the permission is the url string.The actions string is a concatenation of the request methods and headers.The range of method and header names is not restricted by this class.The url The url string has the following expected structure.authority [ / path ] scheme will typically be http or https, but is not restricted by this class.authority is specified as: authority =| IPv6address dnsname is a standard DNS host or domain name, ie.IPv4address is a standard literal IPv4 address and IPv6address is as defined in RFC 2732.addresses must however, be enclosed in '[]' characters.The dnsname specification can be preceded by \"*.\" which means the name will match any hostname whose right-most domain labels are the same as this name.For example, \"*.oracle.com\" matches \"foo.bar.oracle.com\" portrange is used to specify a port number, or a bounded or unbounded range of ports that this permission applies to.If portrange is absent or invalid, then a default port number is assumed if the scheme is http (default 80) or https (default 443).No default is assumed for other schemes.A wildcard may be specified which means all ports.A userinfo component if present, is ignored when creating a URLPermission, and has no effect on any other methods defined by this class.The path component comprises a sequence of path segments, separated by '/' characters.The path is specified in a similar way to the path in FilePermission.There are three different ways as the following examples show: URL ExamplesA url which identifies a specific (single) resourceThe '*' character refers to all resources in the same \"directory\" - in other words all resources with the same number of path components, and which only differ in the final path component, represented by the '*'.The '-' character refers to all resources recursively below the preceding path (eg.http://www.oracle.com/a/b/c/d/e.html matches this example).The '*' and '-' may only be specified in the final segment of a path and must be the only character in that segment.Any query or fragment components of the url are ignored when constructing URLPermissions.The scheme and authority components of the url string are handled without regard to case.This means equals(Object), hashCode() and implies(Permission) are case insensitive with respect to these components.If the authority contains a literal IP address, then the address is normalized for comparison.The actions string The actions string of a URLPermission is a concatenation of the method list and the request headers list.These are lists of the permitted request methods and permitted request headers of the permission (respectively).The two lists are separated by a colon ':' character and elements of each list are comma separated.Some examples are: \"POST,GET,DELETE\" \"GET:X-Foo-Request,X-Bar-Request\" \"POST,GET:Header1,Header2\" The first example specifies the methods: POST, GET and DELETE, but no request headers.The second example specifies one request method and two headers.The third example specifies two request methods, and two headers.No white-space is permitted in the actions string.The action strings supplied to the URLPermission constructors are case-insensitive and are normalized by converting method names to upper-case and header names to the form defines in RFC2616 (lower case with initial letter of each word capitalized).Either list can contain a wild-card '*' character which signifies all request methods or headers respectively.Depending on the context of use, some request methods and headers may be permitted at all times, and others may not be permitted at any time.For example, the HTTP protocol handler might disallow certain headers such as Content-Length from being set by application code, regardless of whether the security policy in force, permits it."},
{"description": "The abstract class URLConnection is the superclass of all classes that represent a communications link between the application and a URL.Instances of this class can be used both to read from and to write to the resource referenced by the URL.In general, creating a connection to a URL is a multistep process: openConnection() connect()Manipulate parameters that affect the connection to the remote resource.> time The connection object is created by invoking the openConnection method on a URL.The actual connection to the remote object is made, using the connect method.The header fields and the contents of the remote object can be accessed.The setup parameters are modified using the following methods: setAllowUserInteraction setDoInput setDoOutput setIfModifiedSince setUseCaches and the general request properties are modified using the method: setRequestProperty Default values for the AllowUserInteraction and UseCaches parameters can be set using the methods setDefaultAllowUserInteraction and setDefaultUseCaches.Each of the above set methods has a corresponding get method to retrieve the value of the parameter or general request property.The following methods are used to access the header fields and the contents after the connection is made to the remote object:The methods: getContentEncoding getContentLength getContentType getDate getExpiration getLastModifed provide convenient access to these fields.The getContentType method is used by the getContent method to determine the type of the remote object; subclasses may find it convenient to override the getContentType method.In the common case, all of the pre-connection parameters and general request properties can be ignored: the pre-connection parameters and request properties default to sensible values.For most clients of this interface, there are only two interesting methods: getInputStream and getContent, which are mirrored in the URL class by convenience methods.More information on the request properties and header fields of an http connection can be found at: http://www.ietf.org/rfc/rfc2616.txtInvoking the close() methods on the InputStream or OutputStream of an URLConnection after a request may free network resources associated with this instance, unless particular protocol specifications specify different behaviours for it."},
{"description": "Class URL represents a Uniform Resource Locator, a pointer to a \"resource\" on the World Wide Web.A resource can be something as simple as a file or a directory, or it can be a reference to a more complicated object, such as a query to a database or to a search engine.More information on the types of URLs and their formats can be found at: Types of URL In general, a URL can be broken into several parts.The URL above indicates that the protocol to use is http (HyperText Transfer Protocol) and that the information resides on a host machine named www.example.com.The information on that host machine is named /docs/resource1.html.The exact meaning of this name on the host machine is both protocol dependent and host dependent.The information normally resides in a file, but it could be generated on the fly.This component of the URL is called the path component.A URL can optionally specify a \"port\", which is the port number to which the TCP connection is made on the remote host machine.If the port is not specified, the default port for the protocol is used instead.For example, the default port for http is 80.An alternative port could be specified as: http://www.example.com:1080/docs/resource1.htmlThe syntax of URL is defined by RFC\u00a02396:The Literal IPv6 address format also supports scope_ids.The syntax and usage of scope_ids is described here.A URL may have appended to it a \"fragment\", also known as a \"ref\" or a \"reference\".The fragment is indicated by the sharp sign character \"#\" followed by more characters.For example, http://java.sun.com/index.html#chapter1 This fragment is not technically part of the URL.Rather, it indicates that after the specified resource is retrieved, the application is specifically interested in that part of the document that has the tag chapter1 attached to it.The meaning of a tag is resource specific.An application can also specify a \"relative URL\", which contains only enough information to reach the resource relative to another URL.Relative URLs are frequently used within HTML pages.For example, if the contents of the URL: http://java.sun.com/index.html contained within it the relative URL: FAQ.html it would be a shorthand for:The relative URL need not specify all the components of a URL.If the protocol, host name, or port number is missing, the value is inherited from the fully specified URL.The URL class does not itself encode or decode any URL components according to the escaping mechanism defined in RFC2396.It is the responsibility of the caller to encode any fields, which need to be escaped prior to calling URL, and also to decode any escaped fields, that are returned from URL.Furthermore, because URL has no knowledge of URL escaping, it does not recognise equivalence between the encoded or decoded form of the same URL.For example, the two URLs: http://foo.com/hello world/ and http://foo.com/hello%20world would be considered not equal to each other.Note, the URI class does perform escaping of its component fields in certain circumstances.The recommended way to manage the encoding and decoding of URLs is to use URI, and to convert between these two classes using toURI() and URI.toURL().The URLEncoder and URLDecoder classes can also be used, but only for HTML form encoding, which is not the same as the encoding scheme defined in RFC2396."},
{"description": "This class loader is used to load classes and resources from a search path of URLs referring to both JAR files and directories.Any URL that ends with a '/' is assumed to refer to a directory.Otherwise, the URL is assumed to refer to a JAR file which will be opened as needed.The AccessControlContext of the thread that created the instance of URLClassLoader will be used when subsequently loading classes and resources.The classes that are loaded are by default granted permission only to access the URLs specified when the URLClassLoader was created."},
{"description": "Checked exception thrown to indicate that a string could not be parsed as a URI reference."},
{"description": "This class contains static methods for decoding a String from the application/x-www-form-urlencoded MIME format.The conversion process is the reverse of that used by the URLEncoder class.It is assumed that all characters in the encoded string are one of the following: \"a\" through \"z\", \"A\" through \"Z\", \"0\" through \"9\", and \"-\", \"_\", \".The character \"%\" is allowed but is interpreted as the start of a special escaped sequence.The following rules are applied in the conversion: The alphanumeric characters \"a\" through \"z\", \"A\" through \"Z\" and \"0\" through \"9\" remain the same.\", \"-\", \"*\", and \"_\" remain the same.The plus sign \"+\" is converted into a space character \" \u00a0 \" .A sequence of the form \"%xy\" will be treated as representing a byte where xy is the two-digit hexadecimal representation of the 8 bits.Then, all substrings that contain one or more of these byte sequences consecutively will be replaced by the character(s) whose encoding would result in those consecutive bytes.The encoding scheme used to decode these characters may be specified, or if unspecified, the default encoding of the platform will be used.There are two possible ways in which this decoder could deal with illegal strings.It could either leave illegal characters alone or it could throw an IllegalArgumentException.Which approach the decoder takes is left to the implementation."},
{"description": "The URLDataSource class provides an object that wraps a URL object in a DataSource interface.URLDataSource simplifies the handling of data described by URLs within the JavaBeans Activation Framework because this class can be used to create new DataHandlers.The DataHandler object creates a URLDataSource internally, when it is constructed with a URL."},
{"description": "This class contains static methods for converting a String to the application/x-www-form-urlencoded MIME format.When encoding a String, the following rules apply: The alphanumeric characters \"a\" through \"z\", \"A\" through \"Z\" and \"0\" through \"9\" remain the same.\", \"-\", \"*\", and \"_\" remain the same.The space character \" \u00a0 \" is converted into a plus sign \"+\".All other characters are unsafe and are first converted into one or more bytes using some encoding scheme.Then each byte is represented by the 3-character string \"%xy\", where xy is the two-digit hexadecimal representation of the byte.The recommended encoding scheme to use is UTF-8.However, for compatibility reasons, if an encoding is not specified, then the default encoding of the platform is used.For example using UTF-8 as the encoding scheme the string \"The string \u00fc@foo-bar\" would get converted to \"The+string+%C3%BC%40foo-bar\" because in UTF-8 the character \u00fc is encoded as two bytes C3 (hex) and BC (hex), and the character @ is encoded as one byte 40 (hex)."},
{"description": "Class URISyntax is an abstract base class providing the common implementation of all attributes whose value is a Uniform Resource Identifier (URI)."},
{"description": "Interface URIException is a mixin interface which a subclass of PrintException can implement to report an error condition involving a URI address.The Print Service API does not define any print exception classes that implement interface URIException, that being left to the Print Service implementor's discretion."},
{"description": "The result of dereferencing a URIReference is either an instance of OctetStreamData or NodeSetData.Unless the URIReference is a same-document reference as defined in section 4.2 of the W3C Recommendation for XML-Signature Syntax and Processing, the result of dereferencing the URIReference MUST be an OctetStreamData."},
{"description": "Aside from some minor deviations noted below, an instance of this class represents a URI reference as defined by RFC\u00a02396:The Literal IPv6 address format also supports scope_ids.The syntax and usage of scope_ids is described here.This class provides constructors for creating URI instances from their components or by parsing their string forms, methods for accessing the various components of an instance, and methods for normalizing, resolving, and relativizing URI instances.Instances of this class are immutable.URI syntax and components At the highest level a URI reference (hereinafter simply \"URI\") in string form has the syntax [scheme:]scheme-specific-part[#fragment] where square brackets [...] delineate optional components and the characters : and # stand for themselves.An absolute URI specifies a scheme; a URI that is not absolute is said to be relative.An opaque URI is an absolute URIwhose scheme-specific part does not begin with a slash character ('/').Some examples of opaque URIs are: mailto:java-net@java.sun.com news:isbn:096139210x A hierarchical URI is either an absolute URI whose scheme-specific part begins with a slash character, or a relative URI, that is, a URI that does not specify a scheme.Some examples of hierarchical URIs are: http://java.sun.com/j2se/1.3/ docs/guide/collections/designfaq.html#28 ../A hierarchical URI is subject to further parsing according to the syntax [scheme:][//authority][path][?query][#fragment] where the characters :, /, ?, and # stand for themselves.The authority component of a hierarchical URI is, if specified, either server-based or registry-based.Nearly all URI schemes currently in use are server-based.An authority component that does not parse in this way is considered to be registry-based.The path component of a hierarchical URI is itself said to be absolute if it begins with a slash character ('/'); otherwise it is relative.The path of a hierarchical URI that is either absolute or specifies an authority is always absolute.All told, then, a URI instance has the following nine components: ComponentType schemeString scheme-specific-part\u00a0\u00a0\u00a0\u00a0String authorityString user-infoString hostString portint pathString queryString fragmentString In a given instance any particular component is either undefined or defined with a distinct value.Undefined string components are represented by null, while undefined integer components are represented by -1.A string component may be defined to have the empty string as its value; this is not equivalent to that component being undefined.Whether a particular component is or is not defined in an instance depends upon the type of the URI being represented.An absolute URI has a scheme component.An opaque URI has a scheme, a scheme-specific part, and possibly a fragment, but has no other components.A hierarchical URI always has a path (though it may be empty) and a scheme-specific-part (which at least contains the path), and may have any of the other components.Operations on URI instances The key operations supported by this class are those of normalization, resolution, and relativization.Normalization is the process of removing unnecessary \".A \"..\" segment is removed only if it is preceded by a non-\"..\" segment.Normalization has no effect upon opaque URIs.Resolution is the process of resolving one URI against another, base URI.The resulting URI is constructed from components of both URIs in the manner specified by RFC\u00a02396, taking components from the base URI for those not specified in the original.For hierarchical URIs, the path of the original is resolved against the path of the base and then normalized.The result, for example, of resolving docs/guide/collections/designfaq.html#28 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0(1) against the base URI http://java.sun.com/j2se/1.3/ is the result URI https://docs.oracle.com/javase/1.3/docs/guide/collections/designfaq.html#28 Resolving the relative URI ..//demo/jfc/SwingSet2/src/SwingSet2.java\u00a0\u00a0\u00a0\u00a0(2) against this result yields, in turn, http://java.sun.com/j2se/1.3/demo/jfc/SwingSet2/src/SwingSet2.java Resolution of both absolute and relative URIs, and of both absolute and relative paths in the case of hierarchical URIs, is supported.Resolving the URI file:///~calendar against any other URI simply yields the original URI, since it is absolute.URI (1) yields the normalized, but still relative, URI demo/jfc/SwingSet2/src/SwingSet2.java Relativization, finally, is the inverse of resolution: For any two normalized URIs u and\u00a0v, u.relativize(u.resolve(v)).equals(v)\u00a0\u00a0and u.resolve(u.relativize(v)).equals(v)\u00a0\u00a0This operation is often useful when constructing a document containing URIs that must be made relative to the base URI of the document wherever possible.For example, relativizing the URI https://docs.oracle.com/javase/1.3/docs/guide/index.html against the base URI http://java.sun.com/j2se/1.3 yields the relative URI docs/guide/index.html.RFC\u00a02396 specifies precisely which characters are permitted in the various components of a URI reference.The following categories, most of which are taken from that specification, are used below to describe these constraints: alpha The US-ASCII alphabetic characters, 'that is, triplets consisting of the percent character ('%') followed by two hexadecimal digits ('0'-'9', 'A'-'F', and 'a'-'f')other The Unicode characters that are not in the US-ASCII character set, are not control characters (according to the Character.isISOControl method), and are not space characters (according to the Character.isSpaceChar method)\u00a0\u00a0(Deviation from RFC 2396, which is limited to US-ASCII)The set of all legal URI characters consists of the unreserved, reserved, escaped, and other characters.Escaped octets, quotation, encoding, and decoding RFC 2396 allows escaped octets to appear in the user-info, path, query, and fragment components.Escaping serves two purposes in URIs: To encode non-US-ASCII characters when a URI is required to conform strictly to RFC\u00a02396 by not containing any other characters.To quote characters that are otherwise illegal in a component.The user-info, path, query, and fragment components differ slightly in terms of which characters are considered legal and illegal.These purposes are served in this class by three related operations: A character is encoded by replacing it with the sequence of escaped octets that represent that character in the UTF-8 character set.The Euro currency symbol ('\\u20AC'), for example, is encoded as \"%E2%82%AC\".(Deviation from RFC\u00a02396, which does not specify any particular character set.)An illegal character is quoted simply by encoding it.The space character, for example, is quoted by replacing it with \"%20\".UTF-8 contains US-ASCII, hence for US-ASCII characters this transformation has exactly the effect required by RFC\u00a02396.A sequence of escaped octets is decoded by replacing it with the sequence of characters that it represents in the UTF-8 character set.UTF-8 contains US-ASCII, hence decoding has the effect of de-quoting any quoted US-ASCII characters as well as that of decoding any encoded non-US-ASCII characters.If a decoding error occurs when decoding the escaped octets then the erroneous octets are replaced by '\\uFFFD', the Unicode replacement character.These operations are exposed in the constructors and methods of this class as follows: The single-argument constructor requires any illegal characters in its argument to be quoted and preserves any escaped octets and other characters that are present.The multi-argument constructors quote illegal characters as required by the components in which they appear.The percent character ('%') is always quoted by these constructors.The getRawUserInfo, getRawPath, getRawQuery, getRawFragment, getRawAuthority, and getRawSchemeSpecificPart methods return the values of their corresponding components in raw form, without interpreting any escaped octets.The strings returned by these methods may contain both escaped octets and other characters, and will not contain any illegal characters.The getUserInfo, getPath, getQuery, getFragment, getAuthority, and getSchemeSpecificPart methods decode any escaped octets in their corresponding components.The strings returned by these methods may contain both other characters and illegal characters, and will not contain any escaped octets.The toString method returns a URI string with all necessary quotation but which may contain other characters.The toASCIIString method returns a fully quoted and encoded URI string that does not contain any other characters.Identities For any URI u, it is always the case that new URI(u.toString()).equals(u)\u00a0.For any URI u that does not contain redundant syntax such as two slashes before an empty authority (as in file:///tmp/\u00a0) or a colon following a host name but no port (as in http://java.sun.com:\u00a0), and that does not encode characters except those that must be quoted, the following identities also hold: new URI(u.getScheme(), u.getSchemeSpecificPart(), u.getFragment()) .equals(u) in all cases, new URI(u.getScheme(), u.getUserInfo(), u.getAuthority(), u.getPath(), u.getQuery(), u.getFragment()) .equals(u)if u is hierarchical and has either no authority or a server-based authority.A URI is a uniform resource identifier while a URL is a uniform resource locator.Hence every URL is a URI, abstractly speaking, but not every URI is a URL.This is because there is another subcategory of URIs, uniform resource names (URNs), which name resources but do not specify how to locate them.The mailto, news, and isbn URIs shown above are examples of URNs.The conceptual distinction between URIs and URLs is reflected in the differences between this class and the URL class.An instance of this class represents a URI reference in the syntactic sense defined by RFC\u00a02396.A URI string is parsed according to the generic syntax without regard to the scheme, if any, that it specifies.No lookup of the host, if any, is performed, and no scheme-dependent stream handler is constructed.Equality, hashing, and comparison are defined strictly in terms of the character content of the instance.In other words, a URI instance is little more than a structured string that supports the syntactic, scheme-independent operations of comparison, normalization, resolution, and relativization.An instance of the URL class, by contrast, represents the syntactic components of a URL together with some of the information required to access the resource that it describes.A URL must be absolute, that is, it must always specify a scheme.A URL string is parsed according to its scheme.A stream handler is always established for a URL, and in fact it is impossible to create a URL instance for a scheme for which no handler is available.Equality and hashing depend upon both the scheme and the Internet address of the host, if any; comparison is not defined.In other words, a URL is a structured string that supports the syntactic operation of resolution as well as the network"},
{"description": "A URIReferenceException can contain a cause: another throwable that caused this URIReferenceException to get thrown."},
{"description": "Note that some subclasses may not have a type attribute and for objects of those types, the getType()"},
{"description": "An object that implements this interface that can be called by the processor to turn a URI used in document(), xsl:import, or xsl:include into a Source object."},
{"description": "A parameter that contains a URI pointing to data intended for a PolicySpi or ConfigurationSpi implementation."},
{"description": "An exception that indicates the requested look & feel management classes are not present on the user's system.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Signals that the requested data is not supported in this flavor."},
{"description": "Signals that the requested operation does not support the requested data type."},
{"description": "Thrown when the Java Virtual Machine attempts to read a class file and determines that the major and minor version numbers in the file are not supported."},
{"description": "Unchecked exception thrown when no support is available for a requested charset."},
{"description": "This class is a member of the Java Collections Framework."},
{"description": "UnsupportedTemporalTypeException indicates that a ChronoField or ChronoUnit is not supported for a Temporal class."},
{"description": "This class represents an event fired in response to an unsolicited notification sent by the LDAP server."},
{"description": "Signals that a CallbackHandler does not recognize a particular Callback."},
{"description": "An UnsupportedAudioFileException is an exception indicating that an operation failed because a file did not contain valid data of a recognized file type and format."},
{"description": "A PolicyErrorCode which would be filled if the value requested for the Policy is of a valid type and within the valid range for that type, but this valid value is not currently supported."},
{"description": "Unchecked exception thrown when an attempt is made to bind or connect to a socket address of a type that is not supported."},
{"description": "One of the PolicyErrorCodes which would be filled if the requested Policy is understood to be valid by the ORB, but is not currently supported."},
{"description": "This interface is for handling UnsolicitedNotificationEvent. \"Unsolicited notification\" is defined in RFC 2251.It allows the server to send unsolicited notifications to the client.A UnsolicitedNotificationListener must: Implement this interface and its method Implement NamingListener.namingExceptionThrown() so that it will be notified of exceptions thrown while attempting to collect unsolicited notification events.Only the NamingListener argument of these methods are applicable; the rest are ignored for a UnsolicitedNotificationListener.(These arguments might be applicable to the listener if it implements other listener interfaces)."},
{"description": "This interface represents an unsolicited notification as defined in RFC 2251.An unsolicited notification is sent by the LDAP server to the LDAP client without any provocation from the client.Its format is that of an extended response (ExtendedResponse)."},
{"description": "Thrown if the Java Virtual Machine cannot find an appropriate native-language definition of a method declared native."},
{"description": "A remote object implementation should implement the Unreferenced interface to receive notification when there are no more clients that reference that remote object."},
{"description": "The UnresolvedPermission class is used to hold Permissions that were \"unresolved\" when the Policy was initialized.An unresolved permission is one whose actual Permission class does not yet exist at the time the Policy is initialized (see below).The policy for a Java runtime (specifying which permissions are available for code from various principals) is represented by a Policy object.Whenever a Policy is initialized or refreshed, Permission objects of appropriate classes are created for all permissions allowed by the Policy.Many permission class types referenced by the policy configuration are ones that exist locally (i.e., ones that can be found on CLASSPATH).Objects for such permissions can be instantiated during Policy initialization.For example, it is always possible to instantiate a java.io.FilePermission, since the FilePermission class is found on the CLASSPATH.Other permission classes may not yet exist during Policy initialization.For example, a referenced permission class may be in a JAR file that will later be loaded.For each such class, an UnresolvedPermission is instantiated.Thus, an UnresolvedPermission is essentially a \"placeholder\" containing information about the permission.Later, when code calls AccessController.checkPermission on a permission of a type that was previously unresolved, but whose class has since been loaded, previously-unresolved permissions of that type are \"resolved\".That is, for each such UnresolvedPermission, a new object of the appropriate class type is instantiated, based on the information in the UnresolvedPermission.To instantiate the new class, UnresolvedPermission assumes the class provides a zero, one, and/or two-argument constructor.The zero-argument constructor would be used to instantiate a permission without a name and without actions.A one-arg constructor is assumed to take a String name as input, and a two-arg constructor is assumed to take a String name and String actions as input.UnresolvedPermission may invoke a constructor with a null name and/or actions.If an appropriate permission constructor is not available, the UnresolvedPermission is ignored and the relevant permission will not be granted to executing code.The newly created permission object replaces the UnresolvedPermission, which is removed.Note that the getName method for an UnresolvedPermission returns the type (class name) for the underlying permission that has not been resolved."},
{"description": "Unchecked exception thrown when an attempt is made to invoke a network operation upon an unresolved socket address."},
{"description": "This exception is thrown if an entry in the keystore cannot be recovered."},
{"description": "Thrown by an implementation of Instrumentation.redefineClasses when one of the specified classes cannot be modified."},
{"description": "This exception is thrown if a key in the keystore cannot be recovered."},
{"description": "Unmarshaller implemented as SAX ContentHandler.Applications can use this interface to use their JAXB provider as a component in an XML pipeline.xmlReader.parse(new InputSource( new FileInputStream( XML_FILE ) ) ); MyObject myObject= (MyObject)unmarshallerHandler.getResult(); This interface is reusable: even if the user fails to unmarshal an object, s/he can still start a new round of unmarshalling."},
{"description": "A class that contains user exceptions returned by the server.When the client uses the DII to make an invocation, any user exception returned from the server is enclosed in an Any object contained in the UnknownUserException object.This is available from the Environment object returned by the method Request.env."},
{"description": "Checked exception thrown when an input character (or byte) sequence is valid but cannot be mapped to an output byte (or character) sequence."},
{"description": "An UnmarshalException can be thrown while unmarshalling the parameters or results of a remote method call if any of the following conditions occur: if an exception occurs while unmarshalling the call header if the protocol for the return value is invalid if a java.io.IOException occurs unmarshalling parameters (on the server side) or the return value (on the client side).if a java.lang.ClassNotFoundException occurs during unmarshalling parameters or return values if no skeleton can be loaded on the server-side; note that skeletons are required in the 1.1 stub protocol, but not in the 1.2 stub protocol.if the method hash is invalid (i.e., missing method).if there is a failure to create a remote reference object for a remote object's stub when it is unmarshalled."},
{"description": "This class enables pre and post processing of an instance of a JAXB mapped class as XML data is unmarshalled into it.The event callbacks are called when unmarshalling XML content into a JAXBElement instance or a JAXB mapped class that represents a complex type definition.The event callbacks are not called when unmarshalling to an instance of a Java datatype that represents a simple type definition.External listener is one of two different mechanisms for defining unmarshal event callbacks."},
{"description": "This exception indicates that an error has occurred while performing an unmarshal operation that prevents the JAXB Provider from completing the operation.The ValidationEventHandler can cause this exception to be thrown during the unmarshal operations."},
{"description": "The Unmarshaller class governs the process of deserializing XML data into newly created Java content trees, optionally validating the XML data as it is unmarshalled.It provides an overloading of unmarshal methods for many different input kinds.InputStream is = new FileInputStream( \"nosferatu.xml\" ); JAXBContext jc = JAXBContext.newInstance>...\" ); Object o = u.unmarshal( new StreamSource( new StringReader( xmlStr.toString() ) ) ); Unmarshalling from a org.w3c.dom.Node: JAXBContext jc = JAXBContext.newInstance( \"com.acme.foo\" ); Unmarshaller u = jc.createUnmarshaller(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setNamespaceAware(true); DocumentBuilder db = dbf.newDocumentBuilderFile( \"nosferatu.xml\")); Object o = u.unmarshal( doc ); Unmarshalling from a javax.xml.transform.sax.SAXSource using a client specified validating SAX2.0 parser: // configure a validating SAX2.0 parser (Xerces2)// turn off the JAXB provider's default validation mechanism to //; Unmarshalling XML Data Unmarshalling can deserialize XML data that represents either an entire XML document or a subtree of an XML document.Typically, it is sufficient to use the unmarshalling methods described by Unmarshal root element that is declared globally.These unmarshal methods utilize JAXBContext's mapping of global XML element declarations and type definitions to JAXB mapped classes to initiate the unmarshalling of the root element of XML data.When the JAXBContext's mappings are not sufficient to unmarshal the root element of XML data, the application can assist the unmarshalling process by using the unmarshal by declaredType methods.These methods are useful for unmarshalling XML data where the root element corresponds to a local element declaration in the schema.If the unmarshal process is unable to unmarshal the root of XML content to a JAXB mapped object, a fatal error is reported that terminates processing by throwing JAXBException.Unmarshal a root element that is globally declared The unmarshal methods that do not have an declaredType parameter use JAXBContext to unmarshal the root element of an XML data.The JAXBContext instance is the one that was used to create this Unmarshaller.The JAXBContext instance maintains a mapping of globally declared XML element and type definition names to JAXB mapped classes.The unmarshal method checks if JAXBContext has a mapping from the root element's XML name and/or @xsi:If it does, it umarshalls the XML data using the appropriate JAXB mapped class.Note that when the root element name is unknown and the root element has an @xsi:type, the XML data is unmarshalled using that JAXB mapped class as the value of a JAXBElement.When the JAXBContext object does not have a mapping for the root element's name nor its @xsi:type, if it exists, then the unmarshal operation will abort immediately by throwing a UnmarshalException.This exception scenario can be worked around by using the unmarshal by declaredType methods described in the next subsection.The unmarshal methods with a declaredType parameter enable an application to deserialize a root element of XML data, even when there is no mapping in JAXBContext of the root element's XML name.The unmarshaller unmarshals the root element using the application provided mapping specified as the declaredType parameter.Note that even when the root element's element name is mapped by JAXBContext, the declaredType parameter overrides that mapping for deserializing the root element when using these unmarshal methods.Additionally, when the root element of XML data has an xsi:type attribute and that attribute's value references a type definition that is mapped to a JAXB mapped class by JAXBContext, that the root element's xsi:type attribute takes precedence over the unmarshal methods declaredType parameter.These methods always return a JAXBElement<declaredType> instance.The table below shows how the properties of the returned JAXBElement instance are set.Unmarshal By Declared Type returned JAXBElement JAXBElement Property Value name xml element name value instanceof declaredType declaredType unmarshal method declaredType parameter scope null (actual scope is unknown)The following is an example of unmarshal by declaredType method.File( \"nosferatu.xml\")); Element fooSubtree = ...; // traverse DOM till reach xml element foo, constrained by a // local element declaration in schema.FooType is the JAXB mapping of the type of local element declaration foo.; Support for SAX2.0 Compliant Parsers A client application has the ability to select the SAX2.0 compliant parser of their choice.Even though the JAXB Provider's default parser is not required to be SAX2.0 compliant, all providers are required to allow a client application to specify their own SAX2.0 parser.Some providers may require the client application to specify the SAX2.0 parser at schema compile time.A client application can enable or disable JAXP 1.3 validation mechanism via the setSchema(javax.xml.validation.Sophisticated clients can specify their own validating SAX 2.0 compliant parser and bypass the JAXP 1.3 validation mechanism using the unmarshal(Source) API.Since unmarshalling invalid XML content is defined in JAXB 2.0, the Unmarshaller default validation event handler was made more lenient than in JAXB 1.0.When schema-derived code generated by JAXB 1.0 binding compiler is registered with JAXBContext, the default unmarshal validation handler is DefaultValidationEventHandler and it terminates the marshal operation after encountering either a fatal error or an error.For a JAXB 2.0 client application, there is no explicitly defined default validation handler and the default event handling only terminates the unmarshal operation after encountering a fatal error.There currently are not any properties required to be supported by all JAXB Providers on Unmarshaller.However, some providers may support their own set of provider specific properties.The Unmarshaller provides two styles of callback mechanisms that allow application specific processing during key points in the unmarshalling process.In 'class defined' event callbacks, application specific code placed in JAXB mapped classes is triggered during unmarshalling. 'Class defined' event callback methods allow any JAXB mapped class to specify its own specific callback methods by defining methods with the following method signature:This method is called immediately after the object is created and before the unmarshalling of this // object begins.The callback provides an opportunity to initialize JavaBean properties prior to unmarshalling.void beforeUnmarshal(Unmarshaller, Object parent); //This method is called after all the properties (except IDREF) are unmarshalled for this object, //but before this object is set to the parent object.; The class defined callback methods should be used when the callback method requires access to non-public methods and/or fields of the class.The external listener callback mechanism enables the registration of a Unmarshaller.The external listener receives all callback events, allowing for more centralized processing than per class defined callback methods.The external listener receives events when unmarshalling proces is marshalling to a JAXB element or to JAXB mapped class.The 'class defined' and external listener event callback methods are independent of each other, both can be called for one event.The invocation ordering when both listener callback methods exist is defined in Unmarshaller.An event callback method throwing an exception terminates the current unmarshal process."},
{"description": "Indicates that an unknown kind of type was encountered.This can occur if the language evolves and new kinds of types are added to the TypeMirror hierarchy.May be thrown by a type visitor to indicate that the visitor was created for a prior version of the language."},
{"description": "An UnknownObjectException is thrown by methods of classes and interfaces in the java.rmi.activation package when the ActivationID parameter to the method is determined to be invalid.An ActivationID is invalid if it is not currently known by the ActivationSystem.An ActivationID is obtained by the ActivationSystem.registerObject method.An ActivationID is also obtained during the Activatable.register call."},
{"description": "Either the MIME type returned by a URL connection does not make sense, or the application is attempting to write to a read-only URL connection."},
{"description": "Thrown to indicate that the IP address of a host could not be determined."},
{"description": "Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown."},
{"description": "Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown."},
{"description": "An UnknownGroupException is thrown by methods of classes and interfaces in the java.rmi.activation package when the ActivationGroupID parameter to the method is determined to be invalid, i.e., not known by the ActivationSystem.An UnknownGroupException is also thrown if the ActivationGroupID in an ActivationDesc refers to a group that is not registered with the ActivationSystem"},
{"description": "An UnknownHostException is thrown if a java.net.UnknownHostException occurs while creating a connection to the remote host for a remote method call."},
{"description": "The org.omg.CORBA.portable.UnknownException is used for reporting unknown exceptions between ties and ORBs and between ORBs and stubs.It provides a Java representation of an UNKNOWN system exception that has an UnknownExceptionInfo service context.If the CORBA system exception org.omg.CORBA.portable.UnknownException is thrown, then the stub does one of the following: (1) Translates it to org.omg.CORBA.UNKNOWN.(2) Translates it to the nested exception that the UnknownException contains."},
{"description": "Superclass of exceptions which indicate that an unknown kind of entity was encountered.This situation can occur if the language evolves and new kinds of constructs are introduced.Subclasses of this exception may be thrown by visitors to indicate that the visitor was created for a prior version of the language.A common superclass for those exceptions allows a single catch block to have code handling them uniformly."},
{"description": "Thrown when an unknown but serious exception has occurred in the Java Virtual Machine."},
{"description": "Indicates that an unknown kind of annotation value was encountered.This can occur if the language evolves and new kinds of annotation values can be stored in an annotation.May be thrown by an annotation value visitor to indicate that the visitor was created for a prior version of the language."},
{"description": "Indicates that an unknown kind of element was encountered.This can occur if the language evolves and new kinds of elements are added to the Element hierarchy.May be thrown by an element visitor to indicate that the visitor was created for a prior version of the language."},
{"description": "An UnexpectedException is thrown if the client of a remote method call receives, as a result of the call, a checked exception that is not among the checked exception types declared in the throws clause of the method in the remote interface."},
{"description": "This exception is raised if an operation implementation throws a non-CORBA exception (such as an exception specific to the implementation's programming language), or if an operation raises a user exception that does not appear in the operation's raises expression.UNKNOWN is also raised if the server returns a system exception that is unknown to the client.a later version of CORBA than the client and new system exceptions have been added to the later version.)It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "As of the RELEASE_7 source version, union types can appear as the type of a multi-catch exception parameter."},
{"description": "Used for exporting a remote object with JRMP and obtaining a stub that communicates to the remote object.Stubs are either generated at runtime using dynamic proxy objects, or they are generated statically at build time, typically using the rmic tool.Support for statically generated stubs is deprecated.This includes the API in this class that requires the use of static stubs, as well as the runtime support for loading static stubs.Generating stubs dynamically is preferred, using one of the five non-deprecated ways of exporting objects as listed below.There are six ways to export remote objects:The fourth technique, exportObject(Remote), always uses statically generated stubs and is deprecated.The other five techniques all use the following approach: if the java.rmi.server.ignoreStubClasses property is true (case insensitive) or if a static stub cannot be found, stubs are generated dynamically using Proxy objects.The default value of the java.rmi.server.ignoreStubClasses property is false.Statically generated stubs are typically pregenerated from the remote object's class using the rmic tool.A static stub is loaded and an instance of that stub class is constructed as described below.A \"root class\" is determined as follows: if the remote object's class directly implements an interface that extends Remote, then the remote object's class is the root class; otherwise, the root class is the most derived superclass of the remote object's class that directly implements an interface that extends Remote.The name of the stub class to load is determined by concatenating the binary name of the root class with the suffix _Stub.The stub class is loaded by name using the class loader of the root class.The stub class must extend RemoteStub and must have a public constructor that has one parameter of type RemoteRef.Finally, an instance of the stub class is constructed with a RemoteRef.If the appropriate stub class could not be found, or if the stub class could not be loaded, or if a problem occurs creating the stub instance, a StubNotFoundException is thrown.Stubs are dynamically generated by constructing an instance of a Proxy with the following characteristics: The proxy's class is defined by the class loader of the remote object's class.The proxy implements all the remote interfaces implemented by the remote object's class.The proxy's invocation handler is a RemoteObjectInvocationHandler instance constructed with a RemoteRef."},
{"description": "UndoManager manages a list of UndoableEdits, providing a way to undo or redo the appropriate edits.There are two ways to add edits to an UndoManager.Add the edit directly using the addEdit method, or add the UndoManager to a bean that supports UndoableEditListener.The following examples creates an UndoManager and adds it as an UndoableEditListener to a JTextField:= ...; tf.getDocument().addUndoableEditListener(undoManager); UndoManager maintains an ordered list of edits and the index of the next edit in that list.The index of the next edit is either the size of the current list of edits, or if undo has been invoked it corresponds to the index of the last significant edit that was undone.When undo is invoked all edits from the index of the next edit to the last significant edit are undone, in reverse order.For example, consider an UndoManager consisting of the following edits:A b c D. Edits with a upper-case letter in bold are significant, those in lower-case and italicized are insignificant.As shown in figure 1, if D was just added, the index of the next edit will be 4.The last significant edit is A, so that invoking undo again invokes undo on c, b, and A, in that order, setting the index of the next edit to 0, as shown in the following figure.Continuing with the previous example if redo were invoked, redo would in turn be invoked on A, b and c.In addition the index of the next edit is set to 3 (as shown in figure 2).Continuing with the previous example, if a new edit, e, is added the edit D is removed from the list (after having die invoked on it).If c is not incorporated by the next edit (c.addEdit(e) returns true), or replaced by it (e.replaceEdit(c) returns true), the new edit is added after c, as shown in the following figure.Once end has been invoked on an UndoManager the superclass behavior is used for all UndoableEdit methods.Unlike the rest of Swing, this class is thread safe.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class provides an implementation of LazyValue which can be used to delay loading of the Class for the instance to be created.It also avoids creation of an anonymous inner class for the LazyValue subclass.Both of these improve performance at the time that a a Look and Feel is loaded, at the cost of a slight performance reduction the first time createValue is called (since Reflection APIs are used)."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "An UndoableEdit represents an edit.UndoableEdit is designed to be used with the UndoManager.As UndoableEdits are generated by an UndoableEditListener they are typically added to the UndoManager.When an UndoableEdit is added to an UndoManager the following occurs (assuming end has not been called on the UndoManager): If the UndoManager contains edits it will call addEdit on the current edit passing in the new edit as the argument.If addEdit returns true the new edit is assumed to have been incorporated into the current edit and the new edit will not be added to the list of current edits.Edits can use addEdit as a way for smaller edits to be incorporated into a larger edit and treated as a single edit.If addEdit returns false replaceEdit is called on the new edit with the current edit passed in as the argument.This is the inverse of addEdit \u0097 if the new edit returns true from replaceEdit, the new edit replaces the current edit.The UndoManager makes use of isSignificant to determine how many edits should be undone or redone.The UndoManager will undo or redo all insignificant edits (isSignificant returns false) between the current edit and the last or next significant edit.addEdit and replaceEdit can be used to treat multiple edits as a single edit, returning false from isSignificant allows for treating can be used to have many smaller edits undone or redone at once.Similar functionality can also be done using the addEdit method."},
{"description": "Thrown by a method invocation on a proxy instance if its invocation handler's invoke method throws a checked exception (a Throwable that is not assignable to RuntimeException or Error) that is not assignable to any of the exception types declared in the throws clause of the method that was invoked on the proxy instance and dispatched to the invocation handler.An UndeclaredThrowableException instance contains the undeclared checked exception that was thrown by the invocation handler, and it can be retrieved with the getUndeclaredThrowable() method.UndeclaredThrowableException extends RuntimeException, so it is an unchecked exception that wraps a checked exception.As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.The \"undeclared checked exception that was thrown by the invocation handler\" that may be provided at construction time and accessed via the getUndeclaredThrowable() method is now known as the cause, and may be accessed via the Throwable.getCause() method, as well as the aforementioned \"legacy method.\""},
{"description": "The UIEvent interface provides specific contextual information associated with User Interface events."},
{"description": "This class enables one to store an entry in the defaults table that isn't constructed until the first time it's looked up with one of the getXXX(key) methods.Lazy values are useful for defaults that are expensive to construct or are seldom retrieved.The first time a LazyValue is retrieved its \"real value\" is computed by calling LazyValue.createValue() and the real value is used to replace the LazyValue in the UIDefaults table.Here's an example of a LazyValue that constructs a Border:LazyValue() { public Object createValue(UIDefaults table) { return new BorderFactory.createLoweredBevelBorder(); } }; uiDefaultsTable.put(\"MyBorder\", borderLazyValue);"},
{"description": "This class enables one to store an entry in the defaults table that's constructed each time it's looked up with one of the getXXX(key) methods.Here's an example of an ActiveValue that constructs a DefaultListCellRenderer:ActiveValue() { public Object createValue(UIDefaults table) { return new DefaultListCellRenderer(); } }; uiDefaultsTable.put(\"MyRenderer\", cellRendererActiveValue);"},
{"description": "LazyInputMap will create a InputMap in its createValue method.The bindings are passed in in the constructor.The bindings are an array with the even number entries being string KeyStrokes (eg \"alt SPACE\") and the odd number entries being the value to use in the InputMap (and the key in the ActionMap)."},
{"description": "Applications can set/get default values via the UIManager.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Classes implementing this interface are used to operate on a type when the kind of type is unknown at compile time.When a visitor is passed to a type's accept method, the visitXYZ method most applicable to that type is invoked.Classes implementing this interface may or may not throw a NullPointerException if the additional parameter p is null; see documentation of the implementing class for details.It is possible that methods will be added to this interface to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, visitor classes directly implementing this interface may be source incompatible with future versions of the platform.To avoid this source incompatibility, visitor implementations are encouraged to instead extend the appropriate abstract visitor class that implements this interface.However, an API should generally use this visitor interface as the type for parameters, return type, etc.Note that methods to accommodate new language constructs could be added in a source compatible way if they were added as default methods.However, default methods are only available on Java SE 8 and higher releases and the javax.lang.model.* packages bundled in Java SE 8 are required to also be runnable on Java SE 7.Therefore, default methods cannot be used when extending javax.lang.model.However, default methods may be used in subsequent revisions of the javax.lang.model.* packages that are only required to run on Java SE 8 and higher platform versions."},
{"description": "A UID represents an identifier that is unique over time with respect to the host it is generated on, or one of 216 \"well-known\" identifiers.The UID() constructor can be used to generate an identifier that is unique over time with respect to the host it is generated on.The UID(short) constructor can be used to create one of 216 well-known identifiers.A UID instance contains three primitive values: unique, an int that uniquely identifies the VM that this UID was generated in, with respect to its host and at the time represented by the time value (an example implementation of the unique value would be a process identifier), or zero for a well-known UID time, a long equal to a time (as returned by System.currentTimeMillis())at which the VM that this UID was generated in was alive, or zero for a well-known UID count, a short to distinguish UIDs generated in the same VM with the same time value An independently generated UID instance is unique over time with respect to the host it is generated on as long as the host requires more than one millisecond to reboot and its system clock is never set backward.A globally unique identifier can be constructed by pairing a UID instance with a unique host identifier, such as an IP address."},
{"description": "A type variable may be explicitly declared by a type parameter of a type, method, or constructor.A type variable may also be declared implicitly, as by the capture conversion of a wildcard type argument (see chapter 5 of The Java\u2122 Language Specification)."},
{"description": "Compatibility Note: Methods may be added to this interface in future releases of the platform."},
{"description": "TypeVariable is the common superinterface for type variables of kinds.A type variable is created the first time it is needed by a reflective method, as specified in this package.If a type variable t is referenced by a type (i.e, class, interface or annotation type) T, and T is declared by the nth enclosing class of T (see JLS 8.1.2), then the creation of t requires the resolution (see JVMS 5) of the ith enclosing class of T, for i = 0 to n, inclusive.Creating a type variable must not cause the creation of its bounds.Repeated creation of a type variable has no effect.Multiple objects may be instantiated at run-time to represent a given type variable.Even though a type variable is created only once, this does not imply any requirement to cache instances representing the type variable.However, all instances representing a type variable must be equal() to each other.As a consequence, users of type variables must not rely on the identity of instances of classes implementing this interface."},
{"description": "Thrown when an application tries to access a type using a string representing the type's name, but no definition for the type with the specified name can be found.This exception differs from ClassNotFoundException in that ClassNotFoundException is a checked exception, whereas this exception is unchecked.In particular, this exception can be thrown by the API used to read annotations reflectively."},
{"description": "TypeMismatch is thrown by dynamic any accessor methods when type of the actual contents do not match what is trying to be accessed."},
{"description": "For types XYZ that may have more than one kind, the visitXYZ methods in this class delegate to the visitXYZKind method corresponding to the first argument's kind.The visitXYZKind methods call defaultAction, passing their arguments to defaultAction's corresponding parameters.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The TypeVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new type kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "Types include primitive types, declared types (class and interface types), array types, type variables, and the null type.Also represented are wildcard type arguments, the signature and return types of executables, and pseudo-types corresponding to packages and to the keyword void.Types should be compared using the utility methods in Types.There is no guarantee that any particular type will always be represented by the same object.Using instanceof is not necessarily a reliable idiom for determining the effective class of an object in this modeling hierarchy since an implementation may choose to have a single object implement multiple TypeMirror subinterfaces."},
{"description": "Note that it is possible additional type kinds will be added to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language."},
{"description": "This class provides access to the type information determined by ValidatorHandler.Some schema languages, such as W3C XML Schema, encourages a validator to report the \"type\" it assigns to each attribute/element.Those applications who wish to access this type information can invoke methods defined on this \"interface\" to access such type information.Implementation of this \"interface\" can be obtained through the ValidatorHandler.getTypeInfoProvider() method."},
{"description": "For types XYZ that may have more than one kind, the visitXYZ methods in this class delegate to the visitXYZKind method corresponding to the first argument's kind.The visitXYZKind methods call defaultAction, passing their arguments to defaultAction's corresponding parameters.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The TypeVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new type kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "For types XYZ that may have more than one kind, the visitXYZ methods in this class delegate to the visitXYZKind method corresponding to the first argument's kind.The visitXYZKind methods call defaultAction, passing their arguments to defaultAction's corresponding parameters.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The TypeVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new type kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "The class that defines the constants that are used to identify generic SQL types, called JDBC types."},
{"description": "The TypeInfo interface represents a type referenced from Element or Attr nodes, specified in the schemas associated with the document.The type is a pair of a namespace URI and name properties, and depends on the document's schema.If the document's schema is an XML DTD [XML 1.0], the values are computed as follows: If this type is referenced from an Attr node, typeNamespace is \"http://www.w3.org/TR/REC-xml\" andtypeName represents the [attribute type] property in the [XML Information Set] .If there is no declaration for the attribute, typeNamespace and typeName are null.If this type is referenced from an Element node, typeNamespace and typeName are null.If the document's schema is an XML Schema [XML Schema Part 1] , the values are computed as follows using the post-schema-validation infoset contributions (also called PSVI contributions):If the [validity] property exists AND is \"invalid\" or \"notKnown\": the {target namespace} and {name} properties of the declared type if available, otherwise null.Note: At the time of writing, the XML Schema specification does not require exposing the declared type.Thus, DOM implementations might choose not to provide type information if validity is not valid.If [member type definition] exists: If {name} is not absent, then expose {name} and {target namespace} properties of the [member type definition] property; Otherwise, expose the namespace and local name of the corresponding anonymous type name.property exists: If {name} is not absent, then expose {name} and {target namespace} properties of the [type definition] property; Otherwise, expose the namespace and local name of the corresponding anonymous type name.If the [member type definition anonymous] exists: If it is false, then expose [member type definition name] and [member type definition namespace] properties; Otherwise, expose the namespace and local name of the corresponding anonymous type name.If the [type definition anonymous] exists: If it is false, then expose [type definition name] and [type definition namespace] properties; Otherwise, expose the namespace and local name of the corresponding anonymous type name.Note: Other schema languages are outside the scope of the W3C and therefore should define how to represent their type systems using TypeInfo."},
{"description": "This exception indicates that a violation of a dynamically checked type constraint was detected.This exception can be thrown by the generated setter methods of the schema derived Java content classes.However, since fail-fast validation is an optional feature for JAXB Providers to support, not all setter methods will throw this exception when a type constraint is violated.If this exception is throw while invoking a fail-fast setter, the value of the property is guaranteed to remain unchanged, as if the setter were never called."},
{"description": "A Holder class for a TypeCode object that is used to store \"out\" and \"inout\" parameters in IDL operations.If an IDL operation signature has an IDL TypeCode as an \"out\" or \"inout\" parameter, the programmer must pass an instance of TypeCodeHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myTypeCodeHolder is an instance of TypeCodeHolder, the value stored in its value field can be accessed with myTypeCodeHolder.value."},
{"description": "Note that an enum type is a kind of class and an annotation type is a kind of interface.While a TypeElement represents a class or interface element, a DeclaredType represents a class or interface type, the latter being a use (or invocation) of the former.The distinction is most apparent with generic types, for which a single element can define a whole family of types.For example, the element java.util.Set corresponds to the parameterized types java.util.Set<String> and java.util.Set<Number> (and many others), and to the raw type java.util.Set.Each method of this interface that returns a list of elements will return them in the order that is natural for the underlying source of program information.For example, if the underlying source of information is Java source code, then the elements will be returned in source code order."},
{"description": "A type parameter declares a TypeVariable."},
{"description": "This class defines the Service Provider Interface (SPI) for the TrustManagerFactory class.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular trust manager factory."},
{"description": "TypeCode objects are used: in the Dynamic Invocation Interface -- to indicate the types of the actual arguments or the type of the return value.NamedValue objects are used to represent arguments and return values.One of their components is an Any object, which in turn has as one of its components a TypeCode object.by an Interface Repository to represent the type specifications that are part of many OMG IDL declarations The representation of a TypeCode object is opaque, but abstractly, a TypeCode object consists of: a kind field, which is set to an instance of the class TCKind zero or more additional fields appropriate for the particular kind.For example, the TypeCode object describing the OMG IDL type 1ong has kind TCKind.tk_long and no additional fields.The TypeCode describing OMG IDL type sequence<boolean, 10> has a kind field with the value TCKind.tk_sequence and also fields with the values boolean and 10 for the type of sequence elements and the length of the sequence.TypeCode objects can be obtained in various ways: from a call to the methodAny.insert_X, where X is a basic IDL type.This method creates a TypeCode object for type X and assigns it to the Any object's type field.from invocations of methods in the ORB class For example, the following creates a TypeCode object for a string with a maximum of 30 characters:org.omg.CORBA.TypeCode tcString = orb.create_string_tc(30); The following creates a TypeCode object for an array of five strings:; The following creates a TypeCode object for an interface named \"Account\": org.omg.CORBA.TypeCode tcInterface = orb.create_interface_tc( \"thisId\", \"Account\"); as the return value from the _type method in Holder classes for user-defined IDL types.These Holder classes are generated by the idltojava compiler.from a CORBA Interface Repository Most of the methods in the class TypeCode are accessors, and the information contained in a TypeCode object is specific to a particular type.Therefore, methods must be invoked only on the kind of type codes to which they apply.If an accessor method tries to access information from an inappropriate kind of type code, it will throw the exception TypeCodePackage.For example, if the method discriminator_type is called on anything other than a union, it will throw BadKind because only unions have a discriminator.The following list shows which methods apply to which kinds of type codes: These methods may be invoked on all TypeCode kinds:equal kind These methods may be invoked on objref, struct, union, enum, alias, exception, value, value_box, native, and abstract_interface:id name These methods may be invoked on struct, union, enum, and exception:member_count member_name These methods may be invoked on struct, union, and exception: member_type(int index)These methods may be invoked on union: member_label discriminator_type default_indexThese methods may be invoked on string, sequence, and array:length These methods may be invoked on alias, sequence, array, and value_box: content_type Unlike other CORBA pseudo-objects, TypeCode objects can be passed as general IDL parameters.Java IDL extends the CORBA specification to allow all operations permitted on a struct TypeCode to be permitted on an exception TypeCode as well."},
{"description": "Type is the common superinterface for all types in the Java programming language.These include raw types, parameterized types, array types, type variables and primitive types."},
{"description": "This is the base interface for JSSE trust managers.TrustManagers are responsible for managing the trust material that is used when making trust decisions, and for deciding whether credentials presented by a peer should be accepted.TrustManagers are created by either using a TrustManagerFactory, or by implementing one of the TrustManager subclasses."},
{"description": "The listener that's notified when a tree expands or collapses a node."},
{"description": "This class represents a \"most-trusted CA\", which is used as a trust anchor for validating X.509 certification paths.A most-trusted CA includes the public key of the CA, the CA's name, and any constraints upon the set of paths which may be validated using this key.These parameters can be specified in the form of a trusted X509Certificate or as individual parameters.That is, multiple threads may concurrently invoke the methods defined in this class on a single TrustAnchor object (or more than one) with no ill effects.Requiring TrustAnchor objects to be immutable and thread-safe allows them to be passed around to various pieces of code without worrying about coordinating access.This stipulation applies to all public fields and methods of this class and any added or overridden by subclasses."},
{"description": "The elements are ordered using their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used.This implementation provides guaranteed log(n) time cost for the basic operations (add, remove and contains).Note that the ordering maintained by a set (whether or not an explicit comparator is provided) must be consistent with equals if it is to correctly implement the Set interface.This is so because the Set interface is defined in terms of the equals operation, but a TreeSet instance performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the set, equal.The behavior of a set is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Set interface.If multiple threads access a tree set concurrently, and at least one of the threads modifies the set, it must be synchronized externally.This is typically accomplished by synchronizing on some object that naturally encapsulates the set.If no such object exists, the set should be \"wrapped\" using the Collections.synchronizedSortedSet method.This is best done at creation time, to prevent accidental unsynchronized access to the set: SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...)); The iterators returned by this class's iterator method are fail-fast:if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException.Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast iterators throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.This class is a member of the Java Collections Framework."},
{"description": "This interface represents the current state of the selection for the tree component.The state of the tree selection is characterized by a set of TreePaths, and optionally a set of integers.The mapping from TreePath to integer is done by way of an instance of RowMapper.It is not necessary for a TreeSelectionModel to have a RowMapper to correctly operate, but without a RowMapper getSelectionRows will return null.A TreeSelectionModel can be configured to allow only one path (SINGLE_TREE_SELECTION) a number of contiguous paths (CONTIGUOUS_TREE_SELECTION) or a number of discontiguous paths (DISCONTIGUOUS_TREE_SELECTION).In the absence of a RowMapper CONTIGUOUS_TREE_SELECTION and DISCONTIGUOUS_TREE_SELECTION behave the same, that is they allow any number of paths to be contained in the TreeSelectionModel.For a selection model of CONTIGUOUS_TREE_SELECTION any time the paths are changed (setSelectionPath, addSelectionPath ...) the TreePaths are again checked to make they are contiguous.A check of the TreePaths can also be forced by invoking resetRowSelection.How a set of discontiguous TreePaths is mapped to a contiguous set is left to implementors of this interface to enforce a particular policy.Implementations should combine duplicate TreePaths that are added to the selection.[] paths = new TreePath[] { treePath, treePath }; treeSelectionModel.setSelectionPaths(paths); should result in only one path being selected: treePath, and not two copies of treePath.The lead TreePath is the last path that was added (or set).The lead row is then the row that corresponds to the TreePath as determined from the RowMapper."},
{"description": "The listener that's notified when the selection in a TreeSelectionModel changes."},
{"description": "Defines the interface for an object that listens to changes in a TreeModel."},
{"description": "TreePath represents an array of objects that uniquely identify the path to a node in a tree.The elements of the array are ordered with the root as the first element of the array.For example, a file on the file system is uniquely identified based on the array of parent directories and the name of the file.The path /tmp/foo/bar could be represented by a TreePath as new TreePath(new Object[] {\"tmp\", \"foo\", \"bar\"}).TreePath is used extensively by JTree and related classes.For example, JTree represents the selection as an array of TreePaths.When used with JTree, the elements of the path are the objects returned from the TreeModel.When JTree is paired with DefaultTreeModel, the elements of the path are TreeNodes.The following example illustrates extracting the user object from the selection of a JTree: DefaultMutableTreeNode root = ...; DefaultTreeModel model = new DefaultTreeModel(root); JTree tree = new JTree(model); ...getUserObject(); Subclasses typically need override only getLastPathComponent, and getParentPath.As JTree internally creates TreePaths at various points, it's generally not useful to subclass TreePath and use with JTree.While TreePath is serializable, a NotSerializableException is thrown if any elements of the path are not serializable.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "An event that characterizes a change in the current selection.The change is based on any number of paths.TreeSelectionListeners will generally query the source of the event for the new selected status of each potentially changed row.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Defines the requirements for an object that can be used as a tree node in a JTree.Implementations of TreeNode that override equals will typically need to override hashCode as well."},
{"description": "JTree and its related classes make extensive use of TreePaths for identifying nodes in the TreeModel.If a TreeModel returns the same object, as compared by equals, at two different indices under the same parent than the resulting TreePath objects will be considered equal as well.Some implementations may assume that if two TreePaths are equal, they identify the same node.In other words, if getChild for a given parent returns the same Object (as determined by equals) problems may result, and it is recommended you avoid doing this.Similarly JTree and its related classes place TreePaths in Maps.As such if a node is requested twice, the return values must be equal (using the equals method) and have the same hashCode."},
{"description": "This class acts as a factory for trust managers based on a source of trust material.Each trust manager manages a specific type of trust material for use by secure sockets.The trust material is based on a KeyStore and/or provider specific sources."},
{"description": "A Red-Black tree based NavigableMap implementation.The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used.This implementation provides guaranteed log(n) time cost for the containsKey, get, put and remove operations.Algorithms are adaptations of those in Cormen, Leiserson, and Rivest's Introduction to Algorithms.Note that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, must be consistent with equals if this sorted map is to correctly implement the Map interface.This is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, from the standpoint of the sorted map, equal.The behavior of a sorted map is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Map interface.If multiple threads access a map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally.(A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with an existing key is not a structural modification.)This is typically accomplished by synchronizing on some object that naturally encapsulates the map.If no such object exists, the map should be \"wrapped\" using the Collections.synchronizedSortedMap method.This is best done at creation time, to prevent accidental unsynchronized access to the map:TreeMap(...)); The iterators returned by the iterator method of the collections returned by all of this class's \"collection view methods\" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException.Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast iterators throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.Entry pairs returned by methods in this class and its views represent snapshots of mappings at the time they were produced.They do not support the Entry.setValue method.(Note however that it is possible to change mappings in the associated map using put.)This class is a member of the Java Collections Framework."},
{"description": "The source returned by getSource will be an instance of JTree.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Defines the requirements for an object that displays a tree node.See How to Use Trees in The Java Tutorial for an example of implementing a tree cell renderer that displays custom icons."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The listener that's notified when a tree expands or collapses a node."},
{"description": "The message type determines which icon will be displayed in the caption of the message, and a possible system sound a message may generate upon showing."},
{"description": "A TrayIcon object represents a tray icon that can be added to the system tray.A TrayIcon can have a tooltip (text), an image, a popup menu, and a set of listeners associated with it.A TrayIcon can generate various MouseEvents and supports adding corresponding listeners to receive notification of these events.TrayIcon processes some of the events by itself.For example, by default, when the right-mouse click is performed on the TrayIcon it displays the specified popup menu.When the mouse hovers over the TrayIconNote: When the MouseEvent is dispatched to its registered listeners its component property will be set to null.The source property will be set to this TrayIcon.Note: A well-behaved TrayIcon implementation will assign different gestures to showing a popup menu and selecting a tray icon.A TrayIcon can generate an ActionEvent.On some platforms, this occurs when the user selects the tray icon using either the mouse or keyboard.If a SecurityManager is installed, the AWTPermission accessSystemTray must be granted in order to create a TrayIcon.Otherwise the constructor will throw a SecurityException."},
{"description": "Exception thrown when the ORB attempted to reach an object and failed.It is not an indication that an object does not exist.Instead, it simply means that no further determination of an object's status was possible because it could not be reached.This exception is raised if an attempt to establish a connection fails, for example, because the server or the implementation repository is down.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "The Transparency interface defines the common transparency modes for implementing classes."},
{"description": "A Transmitter sends MidiEvent objects to one or more Receivers.Common MIDI transmitters include sequencers and MIDI input ports."},
{"description": "Each instance of TransformService supports a specific transform or canonicalization algorithm and XML mechanism type.XPATH2, \"DOM\"); TransformService implementations are registered and loaded using the Provider mechanism.Each TransformService service provider implementation should include a MechanismType service attribute that identifies the XML mechanism type that it supports.For example, a service provider that supports the XPath Filter 2 Transform and DOM mechanism would be specified in the Provider subclass as: put(\"TransformService.\"XPATH2 + \" MechanismType\", \"DOM\"); TransformService implementations that support the DOM mechanism type must abide by the DOM interoperability requirements defined in the DOM Mechanism Requirements section of the API overview.Once a TransformService has been created, it can be used to process Transform or CanonicalizationMethod objects.If the Transform or CanonicalizationMethod exists in XML form (for example, when validating an existing XMLSignature), the init(XMLStructure, XMLCryptoContext) method must be first called to initialize the transform and provide document context (even if there are no parameters).Alternatively, if the Transform or CanonicalizationMethod is being created from scratch, the init(TransformParameterSpec) method is called to initialize the transform with parameters and the marshalParams method is called to marshal the parameters to XML and provide the transform with document context.Finally, the transform method is called to perform the transformation.The static methods of this class are guaranteed to be thread-safe.Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.However, this is not true for the non-static methods defined by this class.Unless otherwise documented by a specific provider, threads that need to access a single TransformService instance concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating a different TransformService instance need not synchronize."},
{"description": "Indicates that an attribute called \"transient\" should be declared with the given value when the Introspector constructs a PropertyDescriptor or EventSetDescriptor classes associated with the annotated code element.A true value for the \"transient\" attribute indicates to encoders derived from Encoder that this feature should be ignored.The Transient annotation may be be used in any of the methods that are involved in a FeatureDescriptor subclass to identify the transient feature in the annotated class and its subclasses.Normally, the method that starts with \"get\" is the best place to put the annotation and it is this declaration that takes precedence in the case of multiple annotations being defined for the same feature.To declare a feature non-transient in a class whose superclass declares it transient, use @Transient(false).In all cases, the Introspector decides if a feature is transient by referring to the annotation on the most specific superclass.If no Transient annotation is present in any superclass the feature is not transient."},
{"description": "Indicates an exceptional condition that occurred while executing a transform algorithm.A TransformException can contain a cause: another throwable that caused this TransformException to get thrown."},
{"description": "The purpose of this interface is to group (and provide type safety for) all transform parameter specifications.All transform parameter specifications must implement this interface."},
{"description": "A TransformerHandler listens for SAX ContentHandler parse events and transforms them to a Result."},
{"description": "This class specifies an exceptional condition that occurred during the transformation process."},
{"description": "An instance of this abstract class can transform a source tree into a result tree.An instance of this class can be obtained with the TransformerFactory.newTransformer method.This instance may then be used to process XML from a variety of sources and write the transformation output to a variety of sinks.An object of this class may not be used in multiple threads running concurrently.Different Transformers may be used concurrently by different threads.Parameters and output properties are preserved across transformations."},
{"description": "Thrown when a problem with configuration with the Transformer Factories exists.This error will typically be thrown when the class of a transformation factory specified in the system properties cannot be found or instantiated."},
{"description": "A TransformerFactory instance can be used to create Transformer and Templates objects.This property names a concrete subclass of the TransformerFactory abstract class."},
{"description": "The TransformAttribute class provides an immutable wrapper for a transform so that it is safe to use as an attribute."},
{"description": "The XML Schema Definition is defined as: <element name=\"Transform\" type=\"dsA Transform instance may be created by invoking the newTransform method of the XMLSignatureFactory class."},
{"description": "A BlockingQueue in which producers may wait for consumers to receive elements.A TransferQueue may be useful for example in message passing applications in which producers sometimes (using method transfer(E))await receipt of elements by consumers invoking take or poll, while at other times enqueue elements (via method put) without waiting for receipt.Non-blocking and time-out versions of tryTransfer are also available.A TransferQueue may also be queried, via hasWaitingConsumer(), whether there are any threads waiting for items, which is a converse analogy to a peek operation.Like other blocking queues, a TransferQueue may be capacity bounded.If so, an attempted transfer operation may initially block waiting for available space, and/or subsequently block waiting for reception by a consumer.This interface is a member of the Java Collections Framework."},
{"description": "This class encapsulates all relevant details of a clipboard or drag and drop transfer, and also allows for customizing aspects of the drag and drop experience.The main purpose of this class is to provide the information needed by a developer to determine the suitability of a transfer or to import the data contained within.But it also doubles as a controller for customizing properties during drag and drop, such as whether or not to show the drop location, and which drop action to use.Developers typically need not create instances of this class.Instead, they are something provided by the DnD implementation to certain methods in TransferHandler."},
{"description": "This is a base class that only encapsulates a point.Components supporting drop may provide subclasses of this containing more information.Developers typically shouldn't create instances of, or extend, this class.Instead, these are something provided by the DnD implementation by TransferSupport instances and by components with a getDropLocation() method."},
{"description": "Defines the interface for classes that can be used to provide data for a transfer operation."},
{"description": "This class is used to handle the transfer of a Transferable to and from Swing components.The Transferable is used to represent data that is exchanged via a cut, copy, or paste to/from a clipboard.It is also used in drag-and-drop operations to represent a drag from a component, and a drop to a component.Swing provides functionality that automatically supports cut, copy, and paste keyboard bindings that use the functionality provided by an implementation of this class.Swing also provides functionality that automatically supports drag and drop that uses the functionality provided by an implementation of this class.The Swing developer can concentrate on specifying the semantics of a transfer primarily by setting the transferHandler property on a Swing component.This class is implemented to provide a default behavior of transferring a component property simply by specifying the name of the property in the constructor.For example, to transfer the foreground color from one component to another either via the clipboard or a drag and drop operation a TransferHandler can be constructed with the string \"foreground\".The built in support will use the color returned by getForeground as the source of the transfer, and setForeground for the target of a transfer."},
{"description": "This exception indicates that a request carried a null transaction context, but the target object requires an activate transaction."},
{"description": "A specialized interface that facilitates an extension of the standard SyncProvider abstract class so that it has finer grained transaction control.If one or more disconnected RowSet objects are participating in a global transaction, they may wish to coordinate their synchronization commits to preserve data integrity and reduce the number of synchronization exceptions.If this is the case, an application should set the CachedRowSet constant COMMIT_ON_ACCEPT_CHANGES to false and use the commit and rollback methods defined in this interface to manage transaction boundaries."},
{"description": "This exception indicates that the transaction associated with processing of the request has been rolled back, or marked to roll back.Thus the requested operation either could not be performed or was not performed because further computation on behalf of the transaction would be fruitless"},
{"description": "Exception indicates that the request carried a null transaction context, but an active transaction is required.It contains a minor code, which gives information about what caused the exception, and a completion status.It may also contain a string describing the exception.The OMG Transaction Service specfication has details."},
{"description": "The CORBA TRANSACTION_MODE exception is thrown by the client ORB if it detects a mismatch between the InvocationPolicy in the IOR and the chosen invocation path (i.e, direct or routed invocation).It contains a minor code, which gives information about what caused the exception, and a completion status.It may also contain a string describing the exception.The OMG CORBA core 2.4 specification has details."},
{"description": "Exception thrown when the transaction associated with the request has already been rolled back or marked to roll back.Thus, the requested operation either could not be performed or was not performed because further computation on behalf of the transaction would be fruitless.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "The CORBA TRANSACTION_UNAVAILABLE exception is thrown by the ORB when it cannot process a transaction service context because its connection to the Transaction Service has been abnormally terminated.It contains a minor code, which gives information about what caused the exception, and a completion status.It may also contain a string describing the exception.The OMG CORBA core 2.4 specification has details."},
{"description": "A MIDI track is an independent stream of MIDI events (time-stamped MIDI data) that can be stored along with other tracks in a standard MIDI file.The MIDI specification allows only 16 channels of MIDI data, but tracks are a way to get around this limitation.A MIDI file can contain any number of tracks, each containing its own stream of up to 16 channels of MIDI data.A Track occupies a middle level in the hierarchy of data played by a Sequencer: sequencers play sequences, which contain tracks, which contain MIDI events.A sequencer may provide controls that mute or solo individual tracks.The timing information and resolution for a track is controlled by and stored in the sequence containing the track.A given Track is considered to belong to the particular Sequence that maintains its timing.For this reason, a new (empty) track is created by calling the Sequence.createTrack() method, rather than by directly invoking a Track constructor.The Track class provides methods to edit the track by adding or removing MidiEvent objects from it.These operations keep the event list in the correct time order.Methods are also included to obtain the track's size, in terms of either the number of events it contains or its duration in ticks."},
{"description": "The TooManyListenersException Exception is used as part of the Java Event model to annotate and implement a unicast special case of a multicast Event Source.The presence of a \"throws TooManyListenersException\" clause on any given concrete implementation of the normally multicast \"void addXyzEventListener\" event listener registration pattern is used to annotate that interface as implementing a unicast Listener special case, that is, that one and only one Listener may be registered on the particular event listener source concurrently."},
{"description": "ToolTipManager contains numerous properties for configuring how long it will take for the tooltips to become visible, and how long till they hide.Consider a component that has a different tooltip based on where the mouse is, such as JTree.When the mouse moves into the JTree and over a region that has a valid tooltip, the tooltip will become visible after initialDelay milliseconds.If the mouse is over a region that has a valid tooltip, and the tooltip is currently visible, when the mouse moves to a region that doesn't have a valid tooltip the tooltip will be hidden.If the mouse then moves back into a region that has a valid tooltip within reshowDelay milliseconds, the tooltip will immediately be shown, otherwise the tooltip will be shown again after initialDelay milliseconds."},
{"description": "Common interface for tools that can be invoked from a program.A tool is traditionally a command line program such as a compiler.The set of tools available with a platform is defined by the vendor.Tools can be located using ServiceLoader.load(Class)."},
{"description": "This class is the abstract superclass of all actual implementations of the Abstract Window Toolkit.Subclasses of the Toolkit class are used to bind the various components to particular native toolkit implementations.Many GUI events may be delivered to user asynchronously, if the opposite is not specified explicitly.This fact means that if the state of a component is set, and then the state immediately queried, the returned value may not yet reflect the requested change.This behavior includes, but is not limited to: Scrolling to a specified position.For example, calling ScrollPane.setScrollPosition and then getScrollPosition may return an incorrect value if the original request has not yet been processed.For more information, see Timing Focus Transfers, a section in The Swing Tutorial.Calling setVisible(true) on a Window, Frame or Dialog may occur asynchronously.Calls to setSize, setBounds or setLocation on a Window, Frame or Dialog are forwarded to the underlying window management system and may be ignored or modified.Most applications should not call any of the methods in this class directly.The methods defined by Toolkit are the \"glue\" that joins the platform-independent classes in the java.awt package with their counterparts in java.awt.peer."},
{"description": "This class complements the functionality of ServiceLoader."},
{"description": "Represents a function that accepts two arguments and produces a long-valued result.This is the long-producing primitive specialization for BiFunction.This is a functional interface whose functional method is applyAsLong(Object, Object)."},
{"description": "Represents a function that accepts two arguments and produces an int-valued result.This is the int-producing primitive specialization for BiFunction.This is a functional interface whose functional method is applyAsInt(Object, Object)."},
{"description": "Represents a function that produces an int-valued result.This is the int-producing primitive specialization for Function.This is a functional interface whose functional method is applyAsInt(Object)."},
{"description": "Represents a function that accepts two arguments and produces a double-valued result.This is the double-producing primitive specialization for BiFunction.This is a functional interface whose functional method is applyAsDouble(Object, Object)."},
{"description": "An abstract class for service providers that provide localized time zone names for the TimeZone class.The localized time zone names available from the implementations of this class are also the source for the DateFormatSymbols.getZoneStrings() method."},
{"description": "A class which implements an arbitrary border with the addition of a String title in a specified position and justification.If the border, font, or color property values are not specified in the constructor or by invoking the appropriate set methods, the property values will be defined by the current look and feel, using the following property names in the Defaults Table:\"TitledBorder.border\" \"TitledBorder.font\" \"TitledBorder.titleColor\" Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The timer MBean sends out an alarm at a specified time that wakes up all the listeners registered to receive timer notifications.This class manages a list of dated timer notifications.A method allows users to add/remove as many notifications as required.When a timer notification is emitted by the timer and becomes obsolete, it is automatically removed from the list of timer notifications.Additional timer notifications can be added into regularly repeating notifications.Note: When sending timer notifications, the timer updates the notification sequence number irrespective of the notification type.The timer service relies on the system date of the host where the Timer class is loaded.Listeners may receive untimely notifications if their host has a different system date.To avoid such problems, synchronize the system date of all host machines where timing is needed.The default behavior for periodic notifications is fixed-delay execution, as specified in Timer.Notification listeners are potentially all executed in the same thread.Therefore, they should execute rapidly to avoid holding up other listeners or perturbing the regularity of fixed-delay executions."},
{"description": "Tasks may be scheduled for one-time execution, or for repeated execution at regular intervals.Corresponding to each Timer object is a single background thread that is used to execute all of the timer's tasks, sequentially.If a timer task takes excessive time to complete, it \"hogs\" the timer's task execution thread.This can, in turn, delay the execution of subsequent tasks, which may \"bunch up\" and execute in rapid succession when (and if)After the last live reference to a Timer object goes away and all outstanding tasks have completed execution, the timer's task execution thread terminates gracefully (and becomes subject to garbage collection).By default, the task execution thread does not run as a daemon thread, so it is capable of keeping an application from terminating.If a caller wants to terminate a timer's task execution thread rapidly, the caller should invoke the timer's cancel method.If the timer's task execution thread terminates unexpectedly, for example, because its stop method is invoked, any further attempt to schedule a task on the timer will result in an IllegalStateException, as if the timer's cancel method had been invoked.This class is thread-safe: multiple threads can share a single Timer object without the need for external synchronization.This class does not offer real-time guarantees: it schedules tasks using the Object.wait(long) method.Java 5.0 introduced the java.util.concurrent package and one of the concurrency utilities therein is the ScheduledThreadPoolExecutor which is a thread pool for repeatedly executing tasks at a given rate or delay.It is effectively a more versatile replacement for the Timer/TimerTask combination, as it allows multiple service threads, accepts various time units, and doesn't require subclassing TimerTask (just implement Runnable).Configuring ScheduledThreadPoolExecutor with one thread makes it equivalent to Timer.Implementation note: This class scales to large numbers of concurrently scheduled tasks (thousands should present no problem).Internally, it uses a binary heap to represent its task queue, so the cost to schedule a task is O(log n), where n is the number of concurrently scheduled tasks.Implementation note: All constructors start a timer thread."},
{"description": "This exception is thrown when a method does not terminate within the specified time limit.This can happen, for example, if the user specifies that the method should take no longer than 10 seconds, and the method fails to complete with 10 seconds.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "An interface for objects that wish to be informed when tiles of a WritableRenderedImage become modifiable by some writer via a call to getWritableTile, and when they become unmodifiable via the last call to releaseWritableTile."},
{"description": "Defines methods which all RMI-IIOP server side ties must implement."},
{"description": "TIMEOUT is raised when no delivery has been made and the specified time-to-live period has been exceeded.It is a standard system exception because time-to-live QoS can be applied to any invocation."},
{"description": "Represents a function that produces a double-valued result.This is the double-producing primitive specialization for Function.This is a functional interface whose functional method is applyAsDouble(Object)."},
{"description": "A thin wrapper around the java.util.Date class that allows the JDBC API to identify this as an SQL TIME value.The Time class adds formatting and parsing operations to support the JDBC escape syntax for time values.The date components should be set to the \"zero epoch\" value of January 1, 1970 and should not be accessed."},
{"description": "Represents a function that produces a long-valued result.This is the long-producing primitive specialization for Function.This is a functional interface whose functional method is applyAsLong(Object)."},
{"description": "The Throwable class is the superclass of all errors and exceptions in the Java language.Only objects that are instances of this class (or one of its subclasses) are thrown by the Java Virtual Machine or can be thrown by the Java throw statement.Similarly, only this class or one of its subclasses can be the argument type in a catch clause.For the purposes of compile-time checking of exceptions, Throwable and any subclass of Throwable that is not also a subclass of either RuntimeException or Error are regarded as checked exceptions.Instances of two subclasses, Error and Exception, are conventionally used to indicate that exceptional situations have occurred.Typically, these instances are freshly created in the context of the exceptional situation so as to include relevant information (such as stack trace data).A throwable contains a snapshot of the execution stack of its thread at the time it was created.It can also contain a message string that gives more information about the error.Over time, a throwable can suppress other throwables from being propagated.Finally, the throwable can also contain a cause: another throwable that caused this throwable to be constructed.The recording of this causal information is referred to as the chained exception facility, as the cause can, itself, have a cause, and so on, leading to a \"chain\" of exceptions, each caused by another.One reason that a throwable may have a cause is that the class that throws it is built atop a lower layered abstraction, and an operation on the upper layer fails due to a failure in the lower layer.It would be bad design to let the throwable thrown by the lower layer propagate outward, as it is generally unrelated to the abstraction provided by the upper layer.Further, doing so would tie the API of the upper layer to the details of its implementation, assuming the lower layer's exception was a checked exception.Throwing a \"wrapped exception\" (i.e., an exception containing a cause) allows the upper layer to communicate the details of the failure to its caller without incurring either of these shortcomings.It preserves the flexibility to change the implementation of the upper layer without changing its API (in particular, the set of exceptions thrown by its methods).A second reason that a throwable may have a cause is that the method that throws it must conform to a general-purpose interface that does not permit the method to throw the cause directly.For example, suppose a persistent collection conforms to the Collection interface, and that its persistence is implemented atop java.io.Suppose the internals of the add method can throw an IOException.The implementation can communicate the details of the IOException to its caller while conforming to the Collection interface by wrapping the IOException in an appropriate unchecked exception.(The specification for the persistent collection should indicate that it is capable of throwing such exceptions.)A cause can be associated with a throwable in two ways: via a constructor that takes the cause as an argument, or via the initCause(Throwable) method.New throwable classes that wish to allow causes to be associated with them should provide constructors that take a cause and delegate (perhaps indirectly) to one of the Throwable constructors that takes a cause.Because the initCause method is public, it allows a cause to be associated with any throwable, even a \"legacy throwable\" whose implementation predates the addition of the exception chaining mechanism to Throwable.By convention, class Throwable and its subclasses have two constructors, one that takes no arguments and one that takes a String argument that can be used to produce a detail message.Further, those subclasses that might likely have a cause associated with them should have two more constructors, one that takes a Throwable (the cause), and one that takes a String (the detail message) and a Throwable (the cause)."},
{"description": "A handler for rejected tasks that silently discards the rejected task."},
{"description": "A handler for rejected tasks that discards the oldest unhandled request and then retries execute, unless the executor is shut down, in which case the task is discarded."},
{"description": "A handler for rejected tasks that throws a RejectedExecutionException."},
{"description": "An ExecutorService that executes each submitted task using one of possibly several pooled threads, normally configured using Executors factory methods.Thread pools address two different problems: they usually provide improved performance when executing large numbers of asynchronous tasks, due to reduced per-task invocation overhead, and they provide a means of bounding and managing the resources, including threads, consumed when executing a collection of tasks.Each ThreadPoolExecutor also maintains some basic statistics, such as the number of completed tasks.To be useful across a wide range of contexts, this class provides many adjustable parameters and extensibility hooks.However, programmers are urged to use the more convenient Executors factory methods Executors.newCachedThreadPool()Core and maximum pool sizes A ThreadPoolExecutor will automatically adjust the pool size (see getPoolSize())When a new task is submitted in method execute(Runnable), and fewer than corePoolSize threads are running, a new thread is created to handle the request, even if other worker threads are idle.If there are more than corePoolSize but less than maximumPoolSize threads running, a new thread will be created only if the queue is full.By setting corePoolSize and maximumPoolSize the same, you create a fixed-size thread pool.MAX_VALUE, you allow the pool to accommodate an arbitrary number of concurrent tasks.Most typically, core and maximum pool sizes are set only upon construction, but they may also be changed dynamically using setCorePoolSize(int) and setMaximumPoolSize(int).On-demand construction By default, even core threads are initially created and started only when new tasks arrive, but this can be overridden dynamically using method prestartCoreThread() or prestartAllCoreThreads().You probably want to prestart threads if you construct the pool with a non-empty queue.Creating new threads New threads are created using a ThreadFactory.If not otherwise specified, a Executors.defaultThreadFactory() is used, that creates threads to all be in the same ThreadGroup and with the same NORM_PRIORITY priority and non-daemon status.By supplying a different ThreadFactory, you can alter the thread's name, thread group, priority, daemon status, etc.If a ThreadFactory fails to create a thread when asked by returning null from newThread, the executor will continue, but might not be able to execute any tasks.Threads should possess the \"modifyThread\" RuntimePermission.If worker threads or other threads using the pool do not possess this permission, service may be degraded: configuration changes may not take effect in a timely manner, and a shutdown pool may remain in a state in which termination is possible but not completed.Keep-alive times If the pool currently has more than corePoolSize threads, excess threads will be terminated if they have been idle for more than the keepAliveTime (see getKeepAliveTime(TimeUnit)).This provides a means of reducing resource consumption when the pool is not being actively used.This parameter can also be changed dynamically using method setKeepAliveTime(long, TimeUnit).NANOSECONDS effectively disables idle threads from ever terminating prior to shut down.By default, the keep-alive policy applies only when there are more than corePoolSize threads.But method allowCoreThreadTimeOut(boolean) can be used to apply this time-out policy to core threads as well, so long as the keepAliveTime value is non-zero.Queuing Any BlockingQueue may be used to transfer and hold submitted tasks.The use of this queue interacts with pool sizing: If fewer than corePoolSize threads are running, the Executor always prefers adding a new thread rather than queuing.If corePoolSize or more threads are running, the Executor always prefers queuing a request rather than adding a new thread.If a request cannot be queued, a new thread is created unless this would exceed maximumPoolSize, in which case, the task will be rejected.There are three general strategies for queuing: Direct handoffs.A good default choice for a work queue is a SynchronousQueue that hands off tasks to threads without otherwise holding them.Here, an attempt to queue a task will fail if no threads are immediately available to run it, so a new thread will be constructed.This policy avoids lockups when handling sets of requests that might have internal dependencies.Direct handoffs generally require unbounded maximumPoolSizes to avoid rejection of new submitted tasks.This in turn admits the possibility of unbounded thread growth when commands continue to arrive on average faster than they can be processed.Using an unbounded queue (for example a LinkedBlockingQueue without a predefined capacity) will cause new tasks to wait in the queue when all corePoolSize threads are busy.(And the value of the maximumPoolSize therefore doesn't have any effect.)This may be appropriate when each task is completely independent of others, so tasks cannot affect each others execution; for example, in a web page server.While this style of queuing can be useful in smoothing out transient bursts of requests, it admits the possibility of unbounded work queue growth when commands continue to arrive on average faster than they can be processed.A bounded queue (for example, an ArrayBlockingQueue) helps prevent resource exhaustion when used with finite maximumPoolSizes, but can be more difficult to tune and control.Queue sizes and maximum pool sizes may be traded off for each other:Using large queues and small pools minimizes CPU usage, OS resources, and context-switching overhead, but can lead to artificially low throughput.If tasks frequently block (for example if they are I/O bound), a system may be able to schedule time for more threads than you otherwise allow.Use of small queues generally requires larger pool sizes, which keeps CPUs busier but may encounter unacceptable scheduling overhead, which also decreases throughput.Rejected tasks New tasks submitted in method execute(Runnable) will be rejected when the Executor has been shut down, and also when the Executor uses finite bounds for both maximum threads and work queue capacity, and is saturated.In either case, the execute method invokes the RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor) method of its RejectedExecutionHandler.Four predefined handler policies are provided: In the default ThreadPoolExecutor.AbortPolicy, the handler throws a runtime RejectedExecutionException upon rejection.CallerRunsPolicy, the thread that invokes execute itself runs the task.This provides a simple feedback control mechanism that will slow down the rate that new tasks are submitted.DiscardOldestPolicy, if the executor is not shut down, the task at the head of the work queue is dropped, and then execution is retried (which can fail again, causing this to be repeated.)It is possible to define and use other kinds of RejectedExecutionHandler classes.Doing so requires some care especially when policies are designed to work only under particular capacity or queuing policies.Hook methods This class provides protected overridable beforeExecute(Thread, Runnable) and afterExecute(Runnable, Throwable) methods that are called before and after execution of each task.These can be used to manipulate the execution environment; for example, reinitializing ThreadLocals, gathering statistics, or adding log entries.Additionally, method terminated() can be overridden to perform any special processing that needs to be done once the Executor has fully terminated.If hook or callback methods throw exceptions, internal worker threads may in turn fail and abruptly terminate.Queue maintenance Method getQueue() allows access to the work queue for purposes of monitoring and debugging.Use of this method for any other purpose is strongly discouraged.Two supplied methods, remove(Runnable) and purge() are available to assist in storage reclamation when large numbers of queued tasks become cancelled.Finalization A pool that is no longer referenced in a program AND has no remaining threads will be shutdown automatically.If you would like to ensure that unreferenced pools are reclaimed even if users forget to call shutdown(), then you must arrange that unused threads eventually die, by setting appropriate keep-alive times, using a lower bound of zero core threads and/or setting allowCoreThreadTimeOut(boolean).Most extensions of this class override one or more of the protected hook methods.For example, here is a subclass that adds a simple pause/resume feature:class PausableThreadPoolExecutor extends ThreadPoolExecutor { private boolean isPaused; private ReentrantLock pauseLock = new ReentrantLock(); private Condition unpaused = pauseLock.newCondition(); public PausableThreadPoolExecutor(...){ super(...); } protected void beforeExecute(Thread t, Runnable r) { super.beforeExecute(t, r); pauseLock.lock(); try { while (isPaused) unpaused.await(); } catch (InterruptedException ie) { t.interrupt(); } finally { pauseLock.unlock(); } } public void pause() { pauseLock.lock(); try { isPaused = true; } finally { pauseLock.unlock(); } } public void resume() { pauseLock.lock(); try { isPaused = false; unpaused.signalAll(); } finally { pauseLock.unlock(); } } }"},
{"description": "The ThreadPolicyValue can have the following values.The ORB is responsible for assigning requests for an ORB- controlled POA to threads.SINGLE_THREAD_MODEL - Requests for a single-threaded POA are processed sequentially."},
{"description": "Blocking operations for which a timeout is specified need a means to indicate that the timeout has occurred.For many such operations it is possible to return a value that indicates timeout; when that is not possible or desirable then TimeoutException should be declared and thrown."},
{"description": "A Java virtual machine has a single instance of the implementation class of this interface.This instance implementing this interface is an MXBean that can be obtained by calling the ManagementFactory.getThreadMXBean() method or from the platform MBeanServer method.The ObjectName for uniquely identifying the MXBean for the thread system within an MBeanServer is: java.lang:type=Threading It can be obtained by calling the PlatformManagedObject.getObjectName() method.Thread ID Thread ID is a positive long value returned by calling the Thread.getId() method for a thread.The thread ID is unique during its lifetime.Some methods in this interface take a thread ID or an array of thread IDs as the input parameter and return per-thread information.A Java virtual machine implementation may support measuring the CPU time for the current thread, for any thread, or for no threads.The isThreadCpuTimeSupported() method can be used to determine if a Java virtual machine supports measuring of the CPU time for any thread.The isCurrentThreadCpuTimeSupported() method can be used to determine if a Java virtual machine supports measuring of the CPU time for the current thread.A Java virtual machine implementation that supports CPU time measurement for any thread will also support that for the current thread.The CPU time provided by this interface has nanosecond precision but not necessarily nanosecond accuracy.A Java virtual machine may disable CPU time measurement by default.The isThreadCpuTimeEnabled() and setThreadCpuTimeEnabled(boolean) methods can be used to test if CPU time measurement is enabled and to enable/disable this support respectively.Enabling thread CPU measurement could be expensive in some Java virtual machine implementations.Thread Contention Monitoring Some Java virtual machines may support thread contention monitoring.When thread contention monitoring is enabled, the accumulated elapsed time that the thread has blocked for synchronization or waited for notification will be collected and returned in the ThreadInfo object.The isThreadContentionMonitoringSupported() method can be used to determine if a Java virtual machine supports thread contention monitoring.The thread contention monitoring is disabled by default.The setThreadContentionMonitoringEnabled(boolean) method can be used to enable thread contention monitoring.Some Java virtual machines may support monitoring of object monitor usage and ownable synchronizer usage.The getThreadInfo(long[], boolean, boolean) and dumpAllThreads(boolean, boolean) methods can be used to obtain the thread stack trace and synchronization information including which lock a thread is blocked to acquire or waiting on and which locks the thread currently owns.The ThreadMXBean interface provides the findMonitorDeadlockedThreads() and findDeadlockedThreads() methods to find deadlocks in the running application."},
{"description": "The ThreadPolicy specifies the threading model used with the created POA.The default is ORB_CTRL_MODEL."},
{"description": "The ThreadPolicy specifies the threading model used with the created POA.The default is ORB_CTRL_MODEL."},
{"description": "A random number generator isolated to the current thread.Like the global Random generator used by the Math class, a ThreadLocalRandom is initialized with an internally generated seed that may not otherwise be modified.When applicable, use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention.Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.Usages of this class should typically be of the form: ThreadLocalRandom.current().nextX(...) (where X is Int, Long, etc).When all usages are of this form, it is never possible to accidently share a ThreadLocalRandom across multiple threads.This class also provides additional commonly used bounded random generation methods.Instances of ThreadLocalRandom are not cryptographically secure.Additionally, default-constructed instances do not use a cryptographically random seed unless the system property java.util.secureRandomSeed is set to true."},
{"description": "This class provides thread-local variables.These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable.ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).For example, the class below generates unique identifiers local to each thread.id is assigned the first time it invokes ThreadId.get() and remains unchanged on subsequent calls.(); } }; // Returns the current thread's unique ID, assigning it if necessary public static int get() { return threadId.get(); } } Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist)."},
{"description": "ThreadInfo contains the information about a thread including: General thread information Thread ID.The object upon which the thread is blocked due to: waiting to enter a synchronization block/method, or waiting to be notified in a Object.wait method, or parking due to a LockSupport.park call.The ID of the thread that owns the object that the thread is blocked.The number of times that the thread has blocked for synchronization or waited for notification.The accumulated elapsed time that the thread has blocked for synchronization or waited for notification since thread contention monitoring was enabled.Some Java virtual machine implementation may not support this.The ThreadMXBean.isThreadContentionMonitoringSupported() method can be used to determine if a Java virtual machine supports this.This thread information class is designed for use in monitoring of the system, not for synchronization control.MXBean Mapping ThreadInfo is mapped to a CompositeData with attributes as specified in the from method."},
{"description": "A thread group represents a set of threads.In addition, a thread group can also include other thread groups.The thread groups form a tree in which every thread group except the initial thread group has a parent.A thread is allowed to access information about its own thread group, but not to access information about its thread group's parent thread group or any other thread groups."},
{"description": "An object that creates new threads on demand.Using thread factories removes hardwiring of calls to new Thread, enabling applications to use special thread subclasses, priorities, etc.The simplest implementation of this interface is just: class SimpleThreadFactory implements ThreadFactory { public Thread newThread(Runnable r) { return new Thread(r); } } The Executors.defaultThreadFactory() method provides a more useful simple implementation, that sets the created thread context to known values before returning it."},
{"description": "A handler for rejected tasks that runs the rejected task directly in the calling thread of the execute method, unless the executor has been shut down, in which case the task is discarded."},
{"description": "An instance of ThreadDeath is thrown in the victim thread when the (deprecated)An application should catch instances of this class only if it must clean up after being terminated asynchronously.If ThreadDeath is caught by a method, it is important that it be rethrown so that the thread actually dies.The top-level error handler does not print out a message if ThreadDeath is never caught.The class ThreadDeath is specifically a subclass of Error rather than Exception, even though it is a \"normal occurrence\", because many applications catch all occurrences of Exception and then discard the exception."},
{"description": "A thread can be in one of the following states:NEW A thread that has not yet started is in this state.RUNNABLE A thread executing in the Java virtual machine is in this state.A thread that is blocked waiting for a monitor lock is in this state.A thread that is waiting indefinitely for another thread to perform a particular action is in this state.A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.A thread that has exited is in this state.A thread can be in only one state at a given point in time.These states are virtual machine states which do not reflect any operating system thread states."},
{"description": "Interface for handlers invoked when a Thread abruptly terminates due to an uncaught exception.When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler's uncaughtException method, passing the thread and the exception as arguments.If a thread has not had its UncaughtExceptionHandler explicitly set, then its ThreadGroup object acts as its UncaughtExceptionHandler.If the ThreadGroup object has no special requirements for dealing with the exception, it can forward the invocation to the default uncaught exception handler."},
{"description": "A thread is a thread of execution in a program.The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.Every thread has a priority.Threads with higher priority are executed in preference to threads with lower priority.Each thread may or may not also be marked as a daemon.When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class).The Java Virtual Machine continues to execute threads until either of the following occurs: The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method.There are two ways to create a new thread of execution.One is to declare a class to be a subclass of Thread.This subclass should override the run method of class Thread.An instance of the subclass can then be allocated and started.For example, a thread that computes primes larger than a stated value could be written as follows: class PrimeThread extends Thread { long minPrime; PrimeThread(long minPrime) { this.minPrime = minPrime; } public void run() { // compute primes larger than minPrime \u00a0.\u00a0.\u00a0. }} The following code would then create a thread and start it running: PrimeThread p = new PrimeThread(143); p.start(); The other way to create a thread is to declare a class that implements the Runnable interface.That class then implements the run method.An instance of the class can then be allocated, passed as an argument when creating Thread, and started.The same example in this other style looks like the following: class PrimeRun implements Runnable { long minPrime; PrimeRun(long minPrime) { this.minPrime = minPrime; } public void run() { // compute primes larger than minPrime \u00a0.\u00a0.\u00a0. }} The following code would then create a thread and start it running:PrimeRun p = new PrimeRun(143); new Thread(p).start(); Every thread has a name for identification purposes.More than one thread may have the same name.If a name is not specified when a thread is created, a new name is generated for it.Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown."},
{"description": "The Thai Buddhist calendar system has two eras.The current era, for years from 1 onwards, is known as the 'Buddhist' era.year-of-era era proleptic-year ISO proleptic-year 2BE2-542 1BE1-543 1BEFORE_BE0-544 2BEFORE_BE-1-545 Do not use ordinal() to obtain the numeric representation of ThaiBuddhistEra."},
{"description": "This chronology defines the rules of the Thai Buddhist calendar system.This calendar system is primarily used in Thailand.Dates are aligned such that 2484-01-01 (Buddhist) is 1941-01-01 (ISO).era - There are two eras, the current 'Buddhist' (ERA_BE) and the previous era (ERA_BEFORE_BE).year-of-era - The year-of-era for the current era increases uniformly from the epoch at year one.For the previous era the year increases from one as time goes backwards.The value for the current era is equal to the ISO proleptic-year plus 543.The proleptic year is the same as the year-of-era for the current era.For the previous era, years have zero, then negative values.The value is equal to the ISO proleptic-year plus 543.The ThaiBuddhist month-of-year exactly matches ISO.day-of-month - The ThaiBuddhist day-of-month exactly matches ISO.day-of-year - The ThaiBuddhist day-of-year exactly matches ISO.The ThaiBuddhist leap-year pattern exactly matches ISO, such that the two calendars are never out of step."},
{"description": "The TexturePaint class provides a way to fill a Shape with a texture that is specified as a BufferedImage.The size of the BufferedImage object should be small because the BufferedImage data is copied by the TexturePaint object.At construction time, the texture is anchored to the upper left corner of a Rectangle2D that is specified in user space.Texture is computed for locations in the device space by conceptually replicating the specified Rectangle2D infinitely in all directions in user space and mapping the BufferedImage to each replicated Rectangle2D."},
{"description": "This date operates using the Thai Buddhist calendar.This calendar system is primarily used in Thailand.Dates are aligned such that 2484-01-01 (Buddhist) is 1941-01-01 (ISO).This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of ThaiBuddhistDate may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "Text styles define three sizes for the formatted text - 'full', 'short' and 'narrow'.Each of these three sizes is available in both 'standard' and 'stand-alone' variations.The difference between the three sizes is obvious in most languages.the 'full' month is 'January', the 'short' month is 'Jan' and the 'narrow' month is 'J'.For example, 'January', 'June' and 'July' all have the 'narrow' text 'J'.The difference between the 'standard' and 'stand-alone' forms is trickier to describe as there is no difference in English.However, in other languages there is a difference in the word used when the text is used alone, as opposed to in a complete date.For example, the word used for a month when used alone in a date picker is different to the word used for month in association with a day and year in a date."},
{"description": "Class TextSyntax is an abstract base class providing the common implementation of all attributes whose value is a string.The text attribute includes a locale to indicate the natural language.Thus, a text attribute always represents a localized string."},
{"description": "The TextMeasurer class provides the primitive operations needed for line break: measuring up to a given advance, determining the advance of a range of characters, and generating a TextLayout for a range of characters.It also provides methods for incremental editing of paragraphs.A TextMeasurer object is constructed with an AttributedCharacterIterator representing a single paragraph of text.These values define the range of indexes to use in calls to the TextMeasurer.For example, calls to get the advance of a range of text or the line break of a range of text must use indexes between the beginning and end index values.Calls to insertChar and deleteChar reset the TextMeasurer to use the beginning index and end index of the AttributedCharacterIterator passed in those calls.Most clients will use the more convenient LineBreakMeasurer, which implements the standard line break policy (placing as many words as will fit on each line)."},
{"description": "Underlying security services instantiate and pass a TextOutputCallback to the handle method of a CallbackHandler to display information messages, warning messages and error messages."},
{"description": "Underlying security services instantiate and pass a TextInputCallback to the handle method of a CallbackHandler to retrieve generic text information."},
{"description": "TextLayout is an immutable graphical representation of styled character data.It provides the following capabilities: implicit bidirectional analysis and reordering, cursor positioning and movement, including split cursors for mixed directional text, highlighting, including both logical and visual highlighting for mixed directional text, multiple baselines (roman, hanging, and centered), hit testing, justification, default font substitution, metric information such as ascent, descent, and advance, and rendering A TextLayout object can be rendered using its draw method.TextLayout can be constructed either directly or through the use of a LineBreakMeasurer.When constructed directly, the source text represents a single paragraph.LineBreakMeasurer allows styled text to be broken into lines that fit within a particular width.TextLayout construction logically proceeds as follows: paragraph attributes are extracted and examined, text is analyzed for bidirectional reordering, and reordering information is computedif needed, text is segmented into style runs fonts are chosen for style runs, first by using a font if the attribute TextAttribute.FONT is present, otherwise by computing a default font using the attributes that have been defined if text is on multiple baselines, the runs or subruns are further broken into subruns sharing a common baseline, glyphvectors are generated for each run using the chosen font, final bidirectional reordering is performed on the glyphvectors All graphical information returned from a TextLayout object's methods is relative to the origin of the TextLayout, which is the intersection of the TextLayout object's baseline with its left edge.Also, coordinates passed into a TextLayout object's methods are assumed to be relative to the TextLayout object's origin.Clients usually need to translate between a TextLayout object's coordinate system and the coordinate system in another object (such as a Graphics object).TextLayout objects are constructed from styled text, but they do not retain a reference to their source text.Thus, changes in the text previously used to generate a TextLayout do not affect the TextLayout.Three methods on a TextLayout object (getNextRightHit, getNextLeftHit, and hitTestChar) return instances of TextHitInfo.The offsets contained in these TextHitInfo objects are relative to the start of the TextLayout, not to the text used to create the TextLayout.Similarly, TextLayout methods that accept TextHitInfo instances as parameters expect the TextHitInfo object's offsets to be relative to the TextLayout, not to any underlying text storage model.Examples: Constructing and drawing a TextLayout and its bounding rectangle:; TextLayout layout = new TextLayout(\"This is a string\", font, frc); layout.draw(g, (float)loc.getX(), (float)loc.getY());bounds.setRect(bounds.getX()+loc.getX(), bounds.getY()+loc.getY(), bounds.getWidth(), bounds.getHeight()); g.draw(bounds); Hit-testing a TextLayout (determining which character is at a particular graphical location):(click.getX() - loc.getX()), (float) (click.getY() - loc.getY())); Responding to a right-arrow key press: int insertionIndex = ...; TextHitInfo next = layout.getNextRightHit(insertionIndex);selStart, selLimit should be relative to the layout, // not to the source text int selStart = ..., selLimit = ...; Color selectionColor = ...; Shape selection = layout.getLogicalHighlightShape(selStart, selLimit); // selection may consist of disjoint areas // graphics is assumed to be tranlated to origin of layout g.setColor(selectionColor); g.fill(selection); Drawing a visually contiguous selection range.The selection range may correspond to more than one substring in the source text.The ranges of the corresponding source text substrings can be obtained with getLogicalRangesForVisualSelection(): TextHitInfo selStart = ..., selLimit = ...; Shape selection = layout.getVisualHighlightShape(selStart, selLimit); g.setColor(selectionColor); g.fill(selection); int[] ranges = getLogicalRangesForVisualSelection(selStart, selLimit);// ranges[0], ranges[1] is the first selection range, //, ranges[3] is the second selection range, etc.Note: Font rotations can cause text baselines to be rotated, and multiple runs with different rotations can cause the baseline to bend or zig-zag.In order to account for this (rare) possibility, some APIs are specified to return metrics and take parameters 'in baseline-relative coordinates' (e.g. ascent, advance), and others are in 'in standard coordinates' (e.g. getBounds).Values in baseline-relative coordinates map the 'x' coordinate to the distance along the baseline, (positive x is forward along the baseline), and the 'y' coordinate to a distance along the perpendicular to the baseline at 'x' (positive y is 90 degrees clockwise from the baseline vector).Values in standard coordinates are measured along the x and y axes, with 0,0Documentation for each relevant API indicates what values are in what coordinate system.In general, measurement-related APIs are in baseline-relative coordinates, while display-related APIs are in standard coordinates."},
{"description": "This class contains one method, getStrongCaret, which is used to specify the policy that determines the strong caret in dual-caret text.The strong caret is used to move the caret to the left or right.Instances of this class can be passed to getCaretShapes, getNextLeftHit and getNextRightHit to customize strong caret selection.getStrongCaret should inspect the two TextHitInfo arguments and choose one of them as the strong caret.Most clients do not need to use this class."},
{"description": "The class that is interested in processing a text event implements this interface.The object created with that class is then registered with a component using the component's addTextListener method.When the component's text changes, the listener object's textValueChanged method is invoked."},
{"description": "A TextField object is a text component that allows for the editing of a single line of text.For example, the following image depicts a frame with four text fields of varying widths.Two of these text fields display the predefined text \"Hello\".Here is the code that produces these four text fields:// predefined text displayed tf3 = new TextField(\"Hello!\"); // predefined text in 30 columns tf4 = new TextField(\"Hello\", 30); Every time the user types a key in the text field, one or more key events are sent to the text field.A KeyEvent may be one of three types: keyPressed, keyReleased, or keyTyped.The properties of a key event indicate which of these types it is, as well as additional information about the event, such as what modifiers are applied to the key event and the time at which the event occurred.The key event is passed to every KeyListener or KeyAdapter object which registered to receive such events using the component's addKeyListener method.(KeyAdapter objects implement the KeyListener interface.)It is also possible to fire an ActionEvent.If action events are enabled for the text field, they may be fired by pressing the Return key.The TextField class's processEvent method examines the action event and passes it along to processActionEvent.The latter method redirects the event to any ActionListener objects that have registered to receive action events generated by this text field."},
{"description": "The TextHitInfo class represents a character position in a text model, and a bias, or \"side,\" of the character.Biases are either leading (the left edge, for a left-to-right character) or trailing (the right edge, for a left-to-right character).Instances of TextHitInfo are used to specify caret and insertion positions within text.TextHitInfo is used primarily by TextLayout and clients of TextLayout.Clients of TextLayout query TextHitInfo instances for an insertion offset, where new text is inserted into the text model.The insertion offset is equal to the character position in the TextHitInfo if the bias is leading, and one character after if the bias is trailing.The insertion offset for TextHitInfo.trailing(1) is 2.Sometimes it is convenient to construct a TextHitInfo with the same insertion offset as an existing one, but on the opposite character.The getOtherHit method constructs a new TextHitInfo with the same insertion offset as an existing one, with a hit on the character on the other side of the insertion offset.Calling getOtherHit on trailing(1) would return leading(2).In general, getOtherHit for trailing(n) returns leading(n+1) and getOtherHit for leading(n) returns trailing(n-1).= ...; Point2D.Float hitPoint = ...; TextHitInfo hitInfo = layout.hitTestChar(hitPoint.x, hitPoint.y); int insPoint = hitInfo.getInsertionIndex(); // insPoint is relative to layout; may need to adjust for use // in a text model"},
{"description": "This high-level event is generated by an object (such as a TextComponent) when its text changes.The event is passed to every TextListener object which registered to receive such events using the component's addTextListener method.The object that implements the TextListener interface gets this TextEvent when the event occurs.The listener is spared the details of processing individual mouse movements and key strokesInstead, it can process a \"meaningful\" (semantic) event like \"text changed\".An unspecified behavior will be caused if the id parameter of any particular TextEvent instance is not in the range from TEXT_FIRST to TEXT_LAST."},
{"description": "A TextArea object is a multi-line region that displays text.It can be set to allow editing or to be read-only.The following image shows the appearance of a text area: This text area could be created by the following line of code: new TextArea(\"Hello\", 5, 40);"},
{"description": "An Action implementation useful for key bindings that are shared across a number of different text components.Because the action is shared, it must have a way of getting it's target to act upon.This class provides support to try and find a text component to operate on.The preferred way of getting the component to act upon is through the ActionEvent that is received.If the Object returned by getSource can be narrowed to a text component, it will be used.This is determined by being used in conjunction with a JTextController which arranges to share that information with a TextAction.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "If there is no markup inside an element's content, the text is contained in a single object implementing the Text interface that is the only child of the element.If there is markup, it is parsed into the information items (elements, comments, etc.) and Text nodes that form the list of children of the element.When a document is first made available via the DOM, there is only one Text node for each block of text.Users may create adjacent Text nodes that represent the contents of a given element without any intervening markup, but should be aware that there is no way to represent the separations between these nodes in XML or HTML, so they will not (in general) persist between DOM editing sessions.The Node.normalize() method merges any such adjacent Text objects into a single node for each block of text.No lexical check is done on the content of a Text node and, depending on its position in the document, some characters must be escaped during serialization using character references; e.g. the characters \"<&\"if the textual content is part of an element or of an attribute, the character sequence \"]]"},
{"description": "The TextAttribute class defines attribute keys and attribute values used for text rendering.TextAttribute instances are used as attribute keys to identify attributes in Font, TextLayout, AttributedCharacterIterator, and other classes handling text attributes.Other constants defined in this class can be used as attribute values.For each text attribute, the documentation provides: the type of its value, the relevant predefined constants, if any the default effect if the attribute is absent the valid values if there are limitations a description of the effect.Values The values of attributes must always be immutable.Where value limitations are given, any value outside of that set is reserved for future use; the value will be treated as the default.The value null is treated the same as the default value and results in the default behavior.If the value is not of the proper type, the attribute will be ignored.The identity of the value does not matter, only the actual value.WEIGHT_BOLD and new Float(2.0) indicate the same WEIGHT.Attribute values of type Number (used for WEIGHT, WIDTH, POSTURE, SIZE, JUSTIFICATION, and TRACKING) can vary along their natural range and are not restricted to the predefined constants.Number.floatValue() is used to get the actual value from the Number.The values for WEIGHT, WIDTH, and POSTURE are interpolated by the system, which can select the 'nearest available' font or use other techniques to approximate the user's request.Summary of attributes Key Value Type Principal Constants Default Value FAMILY String See Font DIALOG, DIALOG_INPUT, SERIF, SANS_SERIF, and MONOSPACED.12.0 TRANSFORM TransformAttribute See TransformAttribute IDENTITY TransformAttribute.none null (do not override font resolution)none null (draw text using font glyphs)none null (use current graphics paint)BACKGROUND Paint none null (do not render background)LIGATURES Integer LIGATURES_ON 0 (do not form optional ligatures)"},
{"description": "Measurement of time is built on units, such as years, months, days, hours, minutes and seconds.Implementations of this interface represent those units.An instance of this interface represents the unit itself, rather than an amount of the unit.See Period for a class that represents an amount in terms of the common units.The most commonly used units are defined in ChronoUnit.Further units are supplied in IsoFields.Units can also be written by application code by implementing this interface.The unit works using double dispatch.Client code calls methods on a date-time like LocalDateTime which check if the unit is a ChronoUnit.If it is, then the date-time must handle it.Otherwise, the method call is re-dispatched to the matching method in this interface."},
{"description": "The TextComponent class is the superclass of any component that allows the editing of some text.A text component embodies a string of text.The TextComponent class defines a set of methods that determine whether or not this text is editable.If the component is editable, it defines another set of methods that supports a text insertion caret.In addition, the class defines methods that are used to maintain a current selection from the text.The text selection, a substring of the component's text, is the target of editing operations.It is also referred to as the selected text."},
{"description": "Queries are a key tool for extracting information from temporal objects.They exist to externalize the process of querying, permitting different approaches, as per the strategy design pattern.Examples might be a query that checks if the date is the day before February 29th in a leap year, or calculates the number of days to your next birthday.The TemporalField interface provides another mechanism for querying temporal objects.That interface is limited to returning a long.By contrast, queries can return any type.There are two equivalent ways of using a TemporalQuery.The first is to invoke the method on this interface directly.The second is to use TemporalAccessor.query(TemporalQuery): //these two lines are equivalent, but the second approach is recommended temporal = thisQuery.queryFrom(temporal); temporal = temporal.query(thisQuery); It is recommended to use the second approach, query(TemporalQuery), as it is a lot clearer to read in code.The most common implementations are method references, such as LocalDate::from and ZoneId::from.Additional common queries are provided as static methods in TemporalQueries."},
{"description": "Date and time is expressed using fields which partition the time-line into something meaningful for humans.Implementations of this interface represent those fields.The most commonly used units are defined in ChronoField.Further fields are supplied in IsoFields, WeekFields and JulianFields.Fields can also be written by application code by implementing this interface.The field works using double dispatch.Client code calls methods on a date-time like LocalDateTime which check if the field is a ChronoField.If it is, then the date-time must handle it.Otherwise, the method call is re-dispatched to the matching method in this interface."},
{"description": "This class provides common implementations of TemporalQuery.These are defined here as they must be constants, and the definition of lambdas does not guarantee that.By assigning them once here, they become 'normal' Java constants.Queries are a key tool for extracting information from temporal objects.They exist to externalize the process of querying, permitting different approaches, as per the strategy design pattern.Examples might be a query that checks if the date is the day before February 29th in a leap year, or calculates the number of days to your next birthday.The TemporalField interface provides another mechanism for querying temporal objects.That interface is limited to returning a long.By contrast, queries can return any type.There are two equivalent ways of using a TemporalQuery.The first is to invoke the method on this interface directly.The second is to use TemporalAccessor.query(TemporalQuery): //these two lines are equivalent, but the second approach is recommended temporal = thisQuery.queryFrom(temporal); temporal = temporal.query(thisQuery); It is recommended to use the second approach, query(TemporalQuery), as it is a lot clearer to read in code.The most common implementations are method references, such as LocalDate::from and ZoneId::from."},
{"description": "This is the base interface type for amounts of time.An amount is distinct from a date or time-of-day in that it is not tied to any specific point on the time-line.The amount can be thought of as a Map of TemporalUnit to long, exposed via getUnits() and get(TemporalUnit).A simple case might have a single unit-value pair, such as \"6 hours\".A more complex case may have multiple unit-value pairs, such as \"7 years, 3 months and 5 days\".There are two common implementations.Period is a date-based implementation, storing years, months and days.Duration is a time-based implementation, storing seconds and nanoseconds, but providing some access using other duration based units such as minutes, hours and fixed 24-hour days.This interface is a framework-level interface that should not be widely used in application code.Instead, applications should create and pass around instances of concrete types, such as Period and Duration."},
{"description": "Adjusters are a key tool for modifying temporal objects.They exist to externalize the process of adjustment, permitting different approaches, as per the strategy design pattern.Examples might be an adjuster that sets the date avoiding weekends, or one that sets the date to the last day of the month.There are two equivalent ways of using a TemporalAdjuster.The first is to invoke the method on the interface directly.The second is to use Temporal.with(TemporalAdjuster): //these two lines are equivalent, but the second approach is recommended temporal = thisAdjuster.adjustInto(temporal); temporal = temporal.with(thisAdjuster); It is recommended to use the second approach, with(TemporalAdjuster), as it is a lot clearer to read in code.This class contains a standard set of adjusters, available as static methods.These include: finding the first or last day of the month finding the first day of next month finding the first or last day of the year finding the first day of next year finding the first or last day-of-week within a month, such as \"first Wednesday in June\" finding the next or previous day-of-week, such as \"next Thursday\""},
{"description": "A representation of a node whose value is text.A Text object may represent text that is content or text that is a comment."},
{"description": "This is the base interface type for date, time and offset objects that are complete enough to be manipulated using plus and minus.It is implemented by those classes that can provide and manipulate information as fields or queries.Most date and time information can be represented as a number.These are modeled using TemporalField with the number held using a long to handle large values.Year, month and day-of-month are simple examples of fields, but they also include instant and offsets.Two pieces of date/time information cannot be represented by numbers, the chronology and the time-zone.These can be accessed via queries using the static methods defined on TemporalQuery.This interface is a framework-level interface that should not be widely used in application code.Instead, applications should create and pass around instances of concrete types, such as LocalDate.There are many reasons for this, part of which is that implementations of this interface may be in calendar systems other than ISO.When to implement A class should implement this interface if it meets three criteria: it provides access to date/time/offset information, as per TemporalAccessorthe set of fields are contiguous from the largest to the smallest the set of fields are complete, such that no other field is needed to define the valid range of values for the fields that are represented Four examples make this clear: LocalDate implements this interface as it represents a set of fields that are contiguous from days to forever and require no external information to determine the validity of each date.It is therefore able to implement plus/minus correctly.LocalTime implements this interface as it represents a set of fields that are contiguous from nanos to within days and require no external information to determine validity.It is able to implement plus/minus correctly, by wrapping around the day.MonthDay, the combination of month-of-year and day-of-month, does not implement this interface.While the combination is contiguous, from days to months within years, the combination does not have sufficient information to define the valid range of values for day-of-month.As such, it is unable to implement plus/minus correctly.The combination day-of-week and day-of-month (\"Friday the 13th\") should not implement this interface.It does not represent a contiguous set of fields, as days to weeks overlaps days to months."},
{"description": "Adjusters are a key tool for modifying temporal objects.They exist to externalize the process of adjustment, permitting different approaches, as per the strategy design pattern.Examples might be an adjuster that sets the date avoiding weekends, or one that sets the date to the last day of the month.There are two equivalent ways of using a TemporalAdjuster.The first is to invoke the method on this interface directly.The second is to use Temporal.with(TemporalAdjuster): //these two lines are equivalent, but the second approach is recommended temporal = thisAdjuster.adjustInto(temporal); temporal = temporal.with(thisAdjuster); It is recommended to use the second approach, with(TemporalAdjuster), as it is a lot clearer to read in code.The TemporalAdjusters class contains a standard set of adjusters, available as static methods.These include: finding the first or last day of the month finding the first day of next month finding the first or last day of the year finding the first day of next year finding the first or last day-of-week within a month, such as \"first Wednesday in June\" finding the next or previous day-of-week, such as \"next Thursday\""},
{"description": "A SAX ContentHandler that may be used to process SAX parse events (parsing transformation instructions) into a Templates object.Note that TemplatesHandler does not need to implement LexicalHandler."},
{"description": "An object that implements this interface is the runtime representation of processed transformation instructions.Templates must be threadsafe for a given instance over multiple threads running concurrently, and may be used multiple times in a given session."},
{"description": "The Java mapping of the IDL enum TCKind, which specifies the kind of a TypeCode object.There is one kind for each primitive and essential IDL data type.The class TCKind consists of: a set of int constants, one for each kind of IDL data type.These int constants make it possible to use a switch statement.The value field for each TCKind instance is initialized with the int constant that corresponds with the IDL data type that the instance represents.org.omg.CORBA.TCKind.from_int( org.omg.CORBA.TCKind._tk_string); The variable k represents the TCKind instance for the IDL type string, which is tk_string.the method value for accessing the _value field of a TCKind constant Example: int i = org.omg.CORBA.TCKind.tk_char.value(); The variable i represents 9, the value for the IDL data type char.The value field of a TCKind instance is the CDR encoding used for a TypeCode object in an IIOP message."},
{"description": "This class is used to associate an emitted notification with the listener ID to which it is targeted."},
{"description": "Indicates the contexts in which an annotation type is applicable.The declaration contexts and type contexts in which an annotation type may be applicable are specified in JLS 9.6.4.1, and denoted in source code by enum constants of java.lang.annotation.ElementType.If an @Target meta-annotation is not present on an annotation type T , then an annotation of type T may be written as a modifier for any declaration except a type parameter declaration.If an @Target meta-annotation is present, the compiler will enforce the usage restrictions indicated by ElementType enum constants, in line with JLS 9.7.4.For example, this @Target meta-annotation indicates that the declared type is itself a meta-annotation type.It can only be used on annotation type declarations: @Target(ElementType.} This @Target meta-annotation indicates that the declared type is intended solely for use as a member type in complex annotation type declarations.It cannot be used to annotate anything directly: @Target} It is a compile-time error for a single ElementType constant to appear more than once in an @Target annotation.For example, the following @Target meta-annotation is illegal: @Target({ElementType."},
{"description": "This is the base interface type for date, time and offset objects.It is implemented by those classes that can provide information as fields or queries.Most date and time information can be represented as a number.These are modeled using TemporalField with the number held using a long to handle large values.Year, month and day-of-month are simple examples of fields, but they also include instant and offsets.Two pieces of date/time information cannot be represented by numbers, the chronology and the time-zone.These can be accessed via queries using the static methods defined on TemporalQuery.A sub-interface, Temporal, extends this definition to one that also supports adjustment and manipulation on more complete temporal objects.This interface is a framework-level interface that should not be widely used in application code.Instead, applications should create and pass around instances of concrete types, such as LocalDate.There are many reasons for this, part of which is that implementations of this interface may be in calendar systems other than ISO."},
{"description": "A target data line is a type of DataLine from which audio data can be read.The most common example is a data line that gets its data from an audio capture device.(The device is implemented as a mixer that writes to the target data line.)Note that the naming convention for this interface reflects the relationship between the line and its mixer.From the perspective of an application, a target data line may act as a source for audio data.The target data line can be obtained from a mixer by invoking the getLine method of Mixer with an appropriate DataLine.The TargetDataLine interface provides a method for reading the captured data from the target data line's buffer.Applications that record audio should read data from the target data line quickly enough to keep the buffer from overflowing, which could cause discontinuities in the captured data that are perceived as clicks.Applications can use the available method defined in the DataLine interface to determine the amount of data currently queued in the data line's buffer.If the buffer does overflow, the oldest queued data is discarded and replaced by new data."},
{"description": "The methods define how white space is interpreted around the tag."},
{"description": "The TabularType class is the open type class whose instances describe the types of TabularData values."},
{"description": "The TabularData interface specifies the behavior of a specific type of complex open data objects which represent tabular data structures."},
{"description": "The TabularDataSupport class is the open data class which implements the TabularData and the Map interfaces, and which is internally based on a hash map data structure."},
{"description": "A TabSet is comprised of many TabStops.It offers methods for locating the closest TabStop to a given position and finding all the potential TabStops.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class encapsulates a single tab stop (basically as tab stops are thought of by RTF).A tab stop is at a specified distance from the left margin, aligns text in a specified way, and has a specified leader.TabStops are immutable, and usually contained in TabSets.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Implements View interface for a table, that is composed of an element structure where the child elements of the element this view is responsible for represent rows and the child elements of the row elements are cells.The cell elements can have an arbitrary element structure under them, which will be built with the ViewFactory returned by the getViewFactory method. \u00a0 This is implemented as a hierarchy of boxes, the table itself is a vertical box, the rows are horizontal boxes, and the cells are vertical boxes.The cells are allowed to span multiple columns and rows.By default, the table can be thought of as being formed over a grid (i.e. somewhat like one would find in gridbag layout), where table cells can request to span more than one grid cell.The default horizontal span of table cells will be based upon this grid, but can be changed by reimplementing the requested span of the cell(i.e. table cells can have independant spans if desired)."},
{"description": "TableStringConverter is used to convert objects from the model into strings.This is useful in filtering and searching when the model returns objects that do not have meaningful toString implementations."},
{"description": "This interface defines the method required by any object that would like to be a renderer for cells in a JTable."},
{"description": "This interface defines the method any object that would like to be an editor of values for components such as JListBox, JComboBox, JTree, or JTable needs to implement."},
{"description": "The SystemFlavorMap is a configurable map between \"natives\" (Strings), which correspond to platform-specific data formats, and \"flavors\" (DataFlavors), which correspond to platform-independent MIME types.This mapping is used by the data transfer subsystem to transfer data between Java and native applications, and between Java applications in separate VMs."},
{"description": "A TableColumn represents all the attributes of a column in a JTable, such as width, resizability, minimum and maximum width.In addition, the TableColumn provides slots for a renderer and an editor that can be used to display and edit the values in this column.It is also possible to specify renderers and editors on a per type basis rather than a per column basis - see the setDefaultRenderer method in the JTable class.This default mechanism is only used when the renderer (or editor) in the TableColumn is null.The modelIndex is the column in the TableModel, which will be queried for the data values for the cells in this column.As the column moves around in the view this modelIndex does not change.Note: Some implementations may assume that all TableColumnModels are unique, therefore we would recommend that the same TableColumn instance not be added more than once to a TableColumnModel.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The SystemTray class represents the system tray for a desktop.On Microsoft Windows it is referred to as the \"Taskbar Status Area\", on Gnome it is referred to as the \"Notification Area\", on KDE it is referred to as the \"System Tray\".The system tray is shared by all applications running on the desktop.On some platforms the system tray may not be present or may not be supported, in this case getSystemTrayTo detect whether the system tray is supported, use isSupported().The SystemTray may contain one or more TrayIcons, which are added to the tray using the add(java.awt.TrayIcon consists of an image, a popup menu and a set of associated listeners.Every Java application has a single SystemTray instance that allows the app to interface with the system tray of the desktop while the app is running.The SystemTray instance can be obtained from the getSystemTray() method.An application may not create its own instance of SystemTray.The following code snippet demonstrates how to access and customize the system tray:new MenuItem(...); defaultItem.addActionListener(listener); popup.add(defaultItem); /// ... add other items // construct a TrayIcon trayIcon =// add the tray image try { tray.add(trayIcon);} catch (AWTException e) { System.err.println(e); } // ... } else { // disable tray option in your application or // perform other actions ... } // ...the application state has changed - update the image if (trayIcon != null)"},
{"description": "Interface for Views that have size dependent upon tabs."},
{"description": "For systems which support the dynamic update of the system colors (when the user changes the colors) the actual RGB values of these symbolic colors will also change dynamically.In order to compare the \"current\" RGB value of a SystemColor object with a non-symbolic Color object, getRGB should be used rather than equals.Note that the way in which these system colors are applied to GUI objects may vary slightly from platform to platform since GUI objects may be rendered differently on each platform.System color values may also be available through the getDesktopProperty method on java.awt.Toolkit."},
{"description": "These exceptions may be thrown as a result of any CORBA operation invocation and may also be returned by many standard CORBA API methods.The standard exceptions contain a minor code, allowing more detailed specification, and a completion status.This class is subclassed to generate each one of the set of standard ORB exceptions.SystemException extends java.lang.RuntimeException; thus none of the SystemException exceptions need to be declared in signatures of the Java methods mapped from operations in IDL interfaces."},
{"description": "The System class contains several useful class fields and methods.Among the facilities provided by the System class are standard input, standard output, and error output streams; access to externally defined properties and environment variables; a means of loading files and libraries; and a utility method for quickly copying a portion of an array."},
{"description": "SynthUI is used to fetch the SynthContext for a particular Component."},
{"description": "A SysexMessage object represents a MIDI system exclusive message.When a system exclusive message is read from a MIDI file, it always has a defined length.Data from a system exclusive message from a MIDI file should be stored in the data array of a SysexMessage as follows: the system exclusive message status byte (0xF0 or 0xF7), all message data bytes, and finally the end-of-exclusive flag (0xF7).The length reported by the SysexMessage object is therefore the length of the system exclusive data plus two: one byte for the status byte and one for the end-of-exclusive flag.As dictated by the Standard MIDI Files specification, two status byte values are legal for a SysexMessage read from a MIDI file: 0xF0:System Exclusive message (same as in MIDI wire protocol) 0xF7: Special System Exclusive message When Java Sound is used to handle system exclusive data that is being received using MIDI wire protocol, it should place the data in one or more SysexMessages.In this case, the length of the system exclusive data is not known in advance; the end of the system exclusive data is marked by an end-of-exclusive flag (0xF7) in the MIDI wire byte stream. 0xF0The first SysexMessage object containing data for a particular system exclusive message should have the status value 0xF0.If this message contains all the system exclusive data for the message, it should end with the status byte 0xF7Otherwise, additional system exclusive data should be sent in one or more SysexMessages with a status value of 0xF7.The SysexMessage containing the last of the data for the system exclusive message should end with the value 0xF7If system exclusive data from SysexMessages objects is being transmitted using MIDI wire protocol, only the initial 0xF0 status byte, the system exclusive data itself, andthe final 0xF7 (EOX) byte should be propagated; any 0xF7 status bytes used to indicate that a SysexMessage contains continuing system exclusive data should not be propagated via MIDI wire protocol."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "In this implementation the default UI is extended to act as a simple view factory.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Factory used for obtaining SynthStyles.Each of the Synth ComponentUIs will call into the current SynthStyleFactory to obtain a SynthStyle for each of the distinct regions they have.The following example creates a custom SynthStyleFactory that returns a different style based on the Region: class MyStyleFactory extends SynthStyleFactory { public SynthStyle getStyle(JComponent c,TREE) { return treeStyle; } return defaultStyle; } } SynthLookAndFeel laf = new SynthLookAndFeel"},
{"description": "SynthStyle is a set of style properties.Each SynthUI references at least one SynthStyle that is obtained using a SynthStyleFactory.You typically don't need to interact with this class directly, rather you will load a Synth File Format file into SynthLookAndFeel that will create a set of SynthStyles."},
{"description": "Looks up the selectedTabPadInsets property from the Style, which represents additional insets for the selected tab."},
{"description": "SynthPainter is used for painting portions of JComponents.At a minimum each JComponent has two paint methods: one for the border and one for the background.Some JComponents have more than one Region, and as a consequence more paint methods.Instances of SynthPainter are obtained from the SynthStyle.getPainter(javax.swing.plaf.synth.You typically supply a SynthPainter by way of Synth's file format.The following example registers a painter for all JButtons that will render the image myImage.png: <style id=\"buttonStyle\"> <imagePainter path=\"myImage.png\" sourceInsets=\"2 2 2 2\" paintCenter=\"true\" stretch=\"true\"/> <insets top=\"2> <bind style=\"buttonStyle\" type=\"REGION\" key=\"button\"/> SynthPainter is abstract in so far as it does no painting, all the methods are empty.While none of these methods are typed to throw an exception, subclasses can assume that valid arguments are passed in, and if not they can throw a NullPointerException or IllegalArgumentException in response to invalid arguments."},
{"description": "SynthLookAndFeel provides the basis for creating a customized look and feel.SynthLookAndFeel does not directly provide a look, all painting is delegated.You need to either provide a configuration file, by way of the load(java.io.This class implements Serializable as a side effect of it extending BasicLookAndFeel.An attempt to serialize it will result in NotSerializableException."},
{"description": "A Synthesizer generates sound.This usually happens when one of the Synthesizer's MidiChannel objects receives a noteOn message, either directly or via the Synthesizer object.Many Synthesizers support Receivers, through which MIDI events can be delivered to the Synthesizer.In such cases, the Synthesizer typically responds by sending a corresponding message to the appropriate MidiChannel, or by processing the event itself if the event isn't one of the MIDI channel messages.The Synthesizer interface includes methods for loading and unloading instruments from soundbanks.An instrument is a specification for synthesizing a certain type of sound, whether that sound emulates a traditional instrument or is some kind of sound effect or other imaginary sound.A soundbank is a collection of instruments, organized by bank and program number (via the instrument's Patch object).Different Synthesizer classes might implement different sound-synthesis techniques, meaning that some instruments and not others might be compatible with a given synthesizer.Also, synthesizers may have a limited amount of memory for instruments, meaning that not every soundbank and instrument can be used by every synthesizer, even if the synthesis technique is compatible.To see whether the instruments from a certain soundbank can be played by a given synthesizer, invoke the isSoundbankSupported method of Synthesizer.Loading\" an instrument means that that instrument becomes available for synthesizing notes.The instrument is loaded into the bank and program location specified by its Patch object.Loading does not necessarily mean that subsequently played notes will immediately have the sound of this newly loaded instrument.For the instrument to play notes, one of the synthesizer's MidiChannel objects must receive (or have received) a program-change message that causes that particular instrument's bank and program number to be selected."},
{"description": "Not all Components support all states.A Component will at least be in one of the primary states.That is, the return value from SynthContext.getComponentState() will at least be one of ENABLED, MOUSE_OVER, PRESSED or DISABLED, and may also contain FOCUSED, SELECTED or DEFAULT."},
{"description": "A SynthContext should only be considered valid for the duration of the method it is passed to.In other words you should not cache a SynthContext that is passed to you and expect it to remain valid."},
{"description": "This exception is created by a SyncProvider abstract class extension if it encounters violations in reading from or writing to the originating data source.If it is implemented to do so, the SyncProvider object may also create a SyncResolver object and either initialize the SyncProviderException object with it at construction time or set it with the SyncProvider object at a later time.The method acceptChanges will throw this exception after the writer has finished checking for conflicts and has found one or more conflicts.An application may catch a SyncProviderException object and call its getSyncResolver method to get its SyncResolver object.This SyncResolver object will mirror the RowSet object that generated the exception, except that it will contain only the values from the data source that are in conflict.All other values in the SyncResolver object will be null.The SyncResolver object may be used to examine and resolve each conflict in a row and then go to the next row with a conflict to repeat the procedure.A SyncProviderException object may or may not contain a description of the condition causing the exception.The inherited method getMessage may be called to retrieve the description if there is one."},
{"description": "The synchronization mechanism that provides reader/writer capabilities for disconnected RowSet objects.A SyncProvider implementation is a class that extends the SyncProvider abstract class.A SyncProvider implementation is identified by a unique ID, which is its fully qualified class name.This name must be registered with the SyncFactory SPI, thus making the implementation available to all RowSet implementations.The factory mechanism in the reference implementation uses this name to instantiate the implementation, which can then provide a RowSet object with its reader (a javax.sql.RowSetReader object) and its writer (a javax.sql.RowSetWriter object).The Jdbc RowSet Implementations specification provides two reference implementations of the SyncProvider abstract class: RIOptimisticProvider and RIXMLProvider.The RIOptimisticProvider can set any RowSet implementation with a RowSetReader object and a RowSetWriter object.However, only the RIXMLProvider implementation can set an XmlReader object and an XmlWriter object.A WebRowSet object uses the XmlReader object to read data in XML format to populate itself with that data.It uses the XmlWriter object to write itself to a stream or java.io.Writer object in XML format.1.0 Naming Convention for Implementations As a guide to naming SyncProvider implementations, the following should be noted: The name for a SyncProvider implementation is its fully qualified class name.It is recommended that vendors supply a SyncProvider implementation in a package named providers.For instance, if a vendor named Fred, Inc. offered a SyncProvider implementation, you could have the following:com.fred.providers.HighAvailabilityProvider The following line of code uses the fully qualified name to register this implementation with the SyncFactory static instance.( \"com.fred.providers.HighAvailabilityProvider\"); The default SyncProvider object provided with the reference implementation uses the following name: com.sun.rowset.providers.RIOptimisticProviderA vendor can register a SyncProvider implementation class name with Oracle Corporation by sending email to jdbc@sun.com.Oracle will maintain a database listing the available SyncProvider implementations for use with compliant RowSet implementations.This database will be similar to the one already maintained to list available JDBC drivers.Vendors should refer to the reference implementation synchronization providers for additional guidance on how to implement a new SyncProvider implementation.How a RowSet Object Gets Its Provider A disconnected Rowset object may get access to a SyncProvider object in one of the following two ways:Using a constructor CachedRowSet crs = new CachedRowSet( \"com.fred.providers.HighAvailabilitySyncProvider\"); Using the setSyncProvider method CachedRowSet crs = new CachedRowSet(); crs.setSyncProvider(\"com.fred.providers.HighAvailabilitySyncProvider\"); By default, the reference implementations of the RowSet synchronization providers are always available to the Java platform.If no other pluggable synchronization providers have been correctly registered, the SyncFactory will automatically generate an instance of the default SyncProvider reference implementation.Thus, in the preceding code fragment, if no implementation named com.fred.providers.HighAvailabilitySyncProvider has been registered with the SyncFactory instance, crs will be assigned the default provider in the reference implementation, which is com.sun.rowset.providers.RIOptimisticProvider.If an update between a disconnected RowSet object and a data source violates the original query or the underlying data source constraints, this will result in undefined behavior for all disconnected RowSet implementations and their designated SyncProvider implementations.Not defining the behavior when such violations occur offers greater flexibility for a SyncProvider implementation to determine its own best course of action.A SyncProvider implementation may choose to implement a specific handler to handle a subset of query violations.However if an original query violation or a more general data source constraint violation is not handled by the SyncProvider implementation, all SyncProvider objects must throw a SyncProviderException.It is possible for any disconnected or connected RowSet object to be populated from an SQL query that is formulated originally from an SQL VIEW.While in many cases it is possible for an update to be performed to an underlying view, such an update requires additional metadata, which may vary.The SyncProvider class provides two constants to indicate whether an implementation supports updating an SQL VIEW.NONUPDATABLE_VIEW_SYNC - Indicates that a SyncProvider implementation does not support synchronization with an SQL VIEW as the underlying source of data for the RowSet object.UPDATABLE_VIEW_SYNC - Indicates that a SyncProvider implementation supports synchronization with an SQL VIEW as the underlying source of data.The default is for a RowSet object not to be updatable if it was populated with data from an SQL VIEW.The SyncProvider class provides three sets of constants that are used as return values or parameters for SyncProvider methods.SyncProvider objects may be implemented to perform synchronization between a RowSet object and its underlying data source with varying degrees of of care.The first group of constants indicate how synchronization is handled.For example, GRADE_NONE indicates that a SyncProvider object will not take any care to see what data is valid and will simply write the RowSet data to the data source.GRADE_MODIFIED_AT_COMMIT indicates that the provider will check only modified data for validity.Other grades check all data for validity or set locks when data is modified or loaded.GRADE_LOCK_WHEN_LOADED Constants to indicate what locks are set on the data source SyncProvider.DATASOURCE_DB_LOCK Constants to indicate whether a SyncProvider object can perform updates to an SQL VIEWThese constants are explained in the preceding section (4.0)."},
{"description": "Defines a framework that allows applications to use a manual decision tree to decide what should be done when a synchronization conflict occurs.Although it is not mandatory for applications to resolve synchronization conflicts manually, this framework provides the means to delegate to the application when conflicts arise.Note that a conflict is a situation where the RowSet object's original values for a row do not match the values in the data source, which indicates that the data source row has been modified since the last synchronization.Note also that a RowSet object's original values are the values it had just prior to the the last synchronization, which are not necessarily its initial values.A SyncResolver object is a specialized RowSet object that implements the SyncResolver interface.It may operate as either a connected RowSet object (an implementation of the JdbcRowSet interface) or a connected RowSet object (an implementation of the CachedRowSet interface or one of its subinterfaces).The reference implementation for SyncResolver implements the CachedRowSet interface, but other implementations may choose to implement the JdbcRowSet interface to satisfy particular needs.After an application has attempted to synchronize a RowSet object with the data source (by calling the CachedRowSet method acceptChanges), and one or more conflicts have been found, a rowset's SyncProvider object creates an instance of SyncResolver.This new SyncResolver object has the same number of rows and columns as the RowSet object that was attempting the synchronization.The SyncResolver object contains the values from the data source that caused the conflict(s) and null for all other values.In addition, it contains information about each conflict.Getting and Using a SyncResolver Object When the method acceptChanges encounters conflicts, the SyncProvider object creates a SyncProviderException object and sets it with the new SyncResolver object.The method acceptChanges will throw this exception, which the application can then catch and use to retrieve the SyncResolver object it contains.The following code snippet uses the SyncProviderException method getSyncResolver to get the SyncResolver object resolver.spe.getSyncResolver(); ... } } With resolver in hand, an application can use it to get the information it contains about the conflict or conflicts.A SyncResolver object such as resolver keeps track of the conflicts for each row in which there is a conflict.It also places a lock on the table or tables affected by the rowset's command so that no more conflicts can occur while the current conflicts are being resolved.The following kinds of information can be obtained from a SyncResolver object: What operation was being attempted when a conflict occurred The SyncProvider interface defines four constants describing states that may occur.Three constants describe the type of operation (update, delete, or insert) that a RowSet object was attempting to perform when a conflict was discovered, and the fourth indicates that there is no conflict.These constants are the possible return values when a SyncResolver object calls the method getStatus.; The value in the data source that caused a conflict A conflict exists when a value that a RowSet object has changed and is attempting to write to the data source has also been changed in the data source since the last synchronization.An application can call the SyncResolver method getConflictValue to retrieve the value in the data source that is the cause of the conflict because the values in a SyncResolver object are the conflict values from the data source.java.lang.Object conflictValue = resolver.getConflictValue(2); Note that the column in resolver can be designated by the column number, as is done in the preceding line of code, or by the column name.With the information retrieved from the methods getStatus and getConflictValue, the application may make a determination as to which value should be persisted in the data source.The application then calls the SyncResolver method setResolvedValue, which sets the value to be persisted in the RowSet object and also in the data source.resolver.setResolvedValue(\"DEPT\", 8390426); In the preceding line of code, the column name designates the column in the RowSet object that is to be set with the given value.The column number can also be used to designate the column.An application calls the method setResolvedValue after it has resolved all of the conflicts in the current conflict row and repeats this process for each conflict row in the SyncResolver object.Navigating a SyncResolver Object Because a SyncResolver object is a RowSet object, an application can use all of the RowSet methods for moving the cursor to navigate a SyncResolver object.For example, an application can use the RowSet method next to get to each row and then call the SyncResolver method getStatus to see if the row contains a conflict.In a row with one or more conflicts, the application can iterate through the columns to find any non-null values, which will be the values from the data source that are in conflict.To make it easier to navigate a SyncResolver object, especially when there are large numbers of rows with no conflicts, the SyncResolver interface defines the methods nextConflictand previousConflict, which move only to rows that contain at least one conflict value.Then an application can call the SyncResolver method getConflictValue, supplying it with the column number, to get the conflict value itself.The code fragment in the next section gives an example.The following code fragment demonstrates how a disconnected RowSet object crs might attempt to synchronize itself with the underlying data source and then resolve the conflicts.In the try block, crs calls the method acceptChanges, passing it the Connection object con.If there are no conflicts, the changes in crs are simply written to the data source.However, if there is a conflict, the method acceptChanges throws a SyncProviderException object, and the catch block takes effect.In this example, which illustrates one of the many ways a SyncResolver object can be used, the SyncResolver method nextConflict is used in a while loop.The loop will end when nextConflict returns false, which will occur when there are no more conflict rows in the SyncResolver object resolver.In This particular code fragment, resolver looks for rows that have update conflicts (rows with the status SyncResolver.UPDATE_ROW_CONFLICT), and the rest of this code fragment executes only for rows where conflicts occurred because crs was attempting an update.After the cursor for resolver has moved to the next conflict row that has an update conflict, the method getRow indicates the number of the current row, and the cursor for the CachedRowSet object crs is moved to the comparable row in crs.By iterating through the columns of that row in both resolver and crs, the conflicting values can be retrieved and compared to decide which one should be persisted.In this code fragment, the value in crs is the one set as the resolved value, which means that it will be used to overwrite the conflict value in the data source.which should be the resolved value (the value to persist) resolvedValue = crsValue; resolver.setResolvedValue(j, resolvedValue); } } } } }"},
{"description": "A blocking queue in which each insert operation must wait for a corresponding remove operation by another thread, and vice versa.A synchronous queue does not have any internal capacity, not even a capacity of one.You cannot peek at a synchronous queue because an element is only present when you try to remove it; you cannot insert an element (using any method) unless another thread is trying to remove it; you cannot iterate as there is nothing to iterate.The head of the queue is the element that the first queued inserting thread is trying to add to the queue; if there is no such queued thread then no element is available for removal and poll() will return null.This queue does not permit null elements.Synchronous queues are similar to rendezvous channels used in CSP and Ada.They are well suited for handoff designs, in which an object running in one thread must sync up with an object running in another thread in order to hand it some information, event, or task.This class supports an optional fairness policy for ordering waiting producer and consumer threads.By default, this ordering is not guaranteed.However, a queue constructed with fairness set to true grants threads access in FIFO order.This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces.This class is a member of the Java Collections Framework."},
{"description": "The Service Provider Interface (SPI) mechanism that generates SyncProvider instances to be used by disconnected RowSet objects.The SyncProvider instances in turn provide the javax.sql.RowSetReader object the RowSet object needs to populate itself with data and the javax.sql.RowSetWriter object it needs to propagate changes to its data back to the underlying data source.Because the methods in the SyncFactory class are all static, there is only one SyncFactory object per Java VM at any one time.This ensures that there is a single source from which a RowSet implementation can obtain its SyncProvider implementation.1.0 Overview The SyncFactory class provides an internal registry of available synchronization provider implementations (SyncProvider objects).The following line of code gets an enumeration of the providers currently registered.(); All standard RowSet implementations must provide at least two providers: an optimistic provider for use with a CachedRowSet implementation or an implementation derived from it an XML provider, which is used for reading and writing XML, such as with WebRowSet objects Note that the JDBC RowSet Implementations include the SyncProvider implementations RIOptimisticProvider and RIXmlProvider, which satisfy this requirement.The SyncFactory class provides accessor methods to assist applications in determining which synchronization providers are currently registered with the SyncFactory.Other methods let RowSet persistence providers be registered or de-registered with the factory mechanism.This allows additional synchronization provider implementations to be made available to RowSet objects at run time.Applications can apply a degree of filtering to determine the level of synchronization that a SyncProvider implementation offers.The following criteria determine whether a provider is made available to a RowSet object: If a particular provider is specified by a RowSet object, and the SyncFactory does not contain a reference to this provider, a SyncFactoryException is thrown stating that the synchronization provider could not be found.If a RowSet implementation is instantiated with a specified provider and the specified provider has been properly registered, the requested provider is supplied.If a RowSet object does not specify a SyncProvider implementation and no additional SyncProvider implementations are available, the reference implementation providers are supplied.2.0 Registering SyncProvider Implementations Both vendors and developers can register SyncProvider implementations using one of the following mechanisms.Using the command line The name of the provider is supplied on the command line, which will add the provider to the system properties.The reference implementation is targeted to ship with J2SE 1.5, which will include an additional resource file that may be edited by hand.Here is an example of the properties file included in the reference implementation: #Default JDBC RowSet sync providers listingThe SyncFactory checks this file and registers the SyncProvider implementations that it contains.A developer or vendor can add other implementations to this file.For example, here is a possible addition: rowset.provider.classname.2=com.fred.providers.HighAvailabilityProvider rowset.provider.vendor.2=Fred, Inc. rowset.provider.version.2=1.0 Using a JNDI Context Available providers can be registered on a JNDI context, and the SyncFactory will attempt to load SyncProvider implementations from that JNDI context.For example, the following code fragment registers a provider implementation on a JNDI context.This is something a deployer would normally do.In this example, MyProvider is being registered on a CosNaming namespace, which is the namespace used by J2EE resources.INITIAL_CONTEXT_FACTORY, \"CosNaming\"); Context ctx = new InitialContext(svrEnv); com.fred.providers.MyProvider = new MyProvider(); ctx.rebind(\"providers/MyProvider\", syncProvider); Next, an application will register the JNDI context with the SyncFactory instance.This allows the SyncFactory to browse within the JNDI context looking for SyncProvider implementations.PROVIDER_URL, \"iiop://hostname/providers\"); Context ctx = new InitialContext(appEnv); SyncFactory.registerJNDIContext(ctx); If a RowSet object attempts to obtain a MyProvider object, the SyncFactory will try to locate it.First it searches for it in the system properties, then it looks in the resource files, and finally it checks the JNDI context that has been set.The SyncFactory instance verifies that the requested provider is a valid extension of the SyncProvider abstract class and then gives it to the RowSet object.In the following code fragment, a new CachedRowSet object is created and initialized with env, which contains the binding to MyProvider.new Hashtable(); env.put(SyncFactory.ROWSET_SYNC_PROVIDER, \"com.fred.providers.MyProvider\"); CachedRowSet crs = new com.sun.rowset.CachedRowSetImpl(env); Further details on these mechanisms are available in the javax.sql.rowset.spi package specification."},
{"description": "Several background threads can be used to execute such tasks.However, the exact strategy of choosing a thread for any particular SwingWorker is unspecified and should not be relied on.When writing a multi-threaded application using Swing, there are two constraints to keep in mind: (refer to Concurrency in Swing for more details):Time-consuming tasks should not be run on the Event Dispatch Thread.Swing components should be accessed on the Event Dispatch Thread only.These constraints mean that a GUI application with time intensive computing needsThis involves inter-thread communication which can be tricky to implement.SwingWorker is designed for situations where you need to have a long running task run in a background thread and provide updates to the UI either when done, or while processing.Subclasses of SwingWorker must implement the doInBackground() method to perform the background computation.Workflow There are three threads involved in the life cycle of a SwingWorker : Current thread:The execute() method is called on this thread.It schedules SwingWorker for the execution on a worker thread and returns immediately.One can wait for the SwingWorker to complete using the get methods.The doInBackground() method is called on this thread.To notify PropertyChangeListeners about bound properties changes use the firePropertyChange and getPropertyChangeSupport() methods.By default there are two bound properties available: state and progress.Event Dispatch Thread: All Swing related activities occur on this thread.SwingWorker invokes the process and done() methods and notifies any PropertyChangeListeners on this thread.Often, the Current thread is the Event Dispatch Thread.Before the doInBackground method is invoked on a worker thread, SwingWorker notifies any PropertyChangeListeners about the state property change to StateValue.Then SwingWorker notifies any PropertyChangeListeners about the state property change to StateValue.Executing a SwingWorker more than once will not result in invoking the doInBackground method twice.The following example illustrates the simplest use case.Some processing is done in the background and when done you update a Swing component.Say we want to find the \"Meaning of Life\" and display the result in a JLabel.final JLabel label; class MeaningOfLifeFinder extends SwingWorker<String, Object> { @Override public String doInBackground() { return findTheMeaningOfLife(); } @Override protected void done() { try { label.setText(get());The next example is useful in situations where you wish to process data as it is ready on the Event Dispatch Thread.Now we want to find the first N prime numbers and display the results in a JTextArea.While this is computing, we want to update our progress in a JProgressBar.Finally, we also want to print the prime numbers to System.out.* numbers.size() / numbersToFind); } } return numbers; } @Override protected void process(List<Integer> chunks) { for (int number : chunks) { textArea.append(number + \"\\n\"); } } } JTextArea textArea = new JTextArea(); final JProgressBar; task.addPropertyChangeListener( new PropertyChangeListener() { public void propertyChange(PropertyChangeEvent evt) { if (\"progress\".equals(evt.getPropertyName())) { progressBar.setValue((Integer)evt.getNewValue()); } } }); task.execute(); System.out.println(task.get()); //prints all prime numbers we have got Because SwingWorker implementsRunnable, a SwingWorker can be submitted to an Executor for execution."},
{"description": "A SwitchPoint is an object which can publish state transitions to other threads.A switch point is initially in the valid state, but may at any time be changed to the invalid state.A switch point can combine a guarded pair of method handles into a guarded delegator.The guarded delegator is a method handle which delegates to one of the old method handles.The state of the switch point determines which of the two gets the delegation.A single switch point may be used to control any number of method handles.(Indirectly, therefore, it can control any number of call sites.)This is done by using the single switch point as a factory for combining any number of guarded method handle pairs into guarded delegators.When a guarded delegator is created from a guarded pair, the pair is wrapped in a new methodhandle M, which is permanently associated with the switch point that created it.Each pair consists of a target T and a fallback F.While the switch point is valid, invocations to M are delegated to T. After it is invalidated, invocations are delegated to F. Invalidation is global and immediate, as if the switch point contained a volatile boolean variable consulted on every call to M. The invalidation is also permanent, which means the switch point can change state only once.The switch point will always delegate to F after being invalidated.At that point guardWithTest may ignore T and return F.Here is an example of a switch point in action:; SwitchPoint spt = new SwitchPoint(); assert(!spt.hasBeenInvalidated()); // the following steps may be repeated to re-use the same switch point:assert(spt.hasBeenInvalidated()); assertEquals(\"hodmet\", (String) worker.invokeExact(\"met\", \"hod\")); Discussion: Switch points are useful without subclassing.This may be useful in order to associate application-specific invalidation logic with the switch point.Notice that there is no permanent association between a switch point and the method handles it produces and consumes.The garbage collector may collect method handles produced or consumed by a switch point independently of the lifetime of the switch point itself.Implementation Note: A switch point behaves as if implemented on top of MutableCallSite, approximately as follows: public class SwitchPoint { private static final MethodHandle K_true = MethodHandles.constant(boolean.class, true), K_false = MethodHandles.constant(boolean.class, false); private final MutableCallSite mcs; private final MethodHandle mcsInvoker; public SwitchPoint() { this.mcs = new MutableCallSite(K_true); this.mcsInvoker =mcsInvoker is of type ()boolean.Target and fallback may take any arguments, but must have the same type.(); for (SwitchPoint spt : spts) mcss.add(spt.mcs); for (MutableCallSite mcs : mcss) mcs.setTarget(K_false); MutableCallSite.syncAll(mcss.toArray(new MutableCallSite[0])); } }"},
{"description": "This subclass of java.beans.PropertyChangeSupport is almost identical in functionality.The only difference is if constructed with SwingPropertyChangeSupport(sourceBean, true)it ensures listeners are only ever notified on the Event Dispatch Thread."},
{"description": "Indicates that the named compiler warnings should be suppressed in the annotated element (and in all program elements contained in the annotated element).Note that the set of warnings suppressed in a given element is a superset of the warnings suppressed in all containing elements.For example, if you annotate a class to suppress one warning and annotate a method to suppress another, both warnings will be suppressed in the method.As a matter of style, programmers should always use this annotation on the most deeply nested element where it is effective.If you want to suppress a warning in a particular method, you should annotate that method rather than its class."},
{"description": "An annotation used to indicate what annotation types an annotation processor supports.The Processor.getSupportedAnnotationTypes() method can construct its result from the value of this annotation, as done by AbstractProcessor.getSupportedAnnotationTypes().Only strings conforming to the grammar should be used as values."},
{"description": "There is no requirement that a new or distinct result be returned each time the supplier is invoked.This is a functional interface whose functional method is get()."},
{"description": "Interface SupportedValuesAttribute is a tagging interface which a printing attribute class implements to indicate the attribute describes the supported values for another attribute.For example, if a Print Service instance supports the Copies attribute, the Print Service instance will have a CopiesSupported attribute, which is a SupportedValuesAttribute giving the legal values a client may specify for the Copies attribute."},
{"description": "An annotation used to indicate what options an annotation processor supports.The Processor.getSupportedOptions() method can construct its result from the value of this annotation, as done by AbstractProcessor.getSupportedOptions().Only strings conforming to the grammar should be used as values."},
{"description": "An annotation used to indicate the latest source version an annotation processor supports.The Processor.getSupportedSourceVersion() method can construct its result from the value of this annotation, as done by AbstractProcessor.getSupportedSourceVersion()."},
{"description": "A SubjectDomainCombiner updates ProtectionDomains with Principals from the Subject associated with this SubjectDomainCombiner."},
{"description": "A SubjectDelegationPermission contains a name (also referred to as a \"target name\") but no actions list; you either have the named permission or you don't.The target name is the name of the authorization principal classname followed by a period and the authorization principal name, that is \"PrincipalClassName.An asterisk may appear by itself, or if immediately preceded by a \".*\" and \"javax.management.remote.JMXPrincipal.delegate\" are valid target names.The first one denotes any principal name from any principal class, the second one denotes any principal name of the concrete principal class javax.management.remote.JMXPrincipal and the third one denotes a concrete principal name delegate of the concrete principal class javax.management.remote.JMXPrincipal."},
{"description": "A Subject represents a grouping of related information for a single entity, such as a person.Such information includes the Subject's identities as well as its security-related attributes (passwords and cryptographic keys, for example).Subjects may potentially have multiple identities.Each identity is represented as a Principal within the Subject.Principals simply bind names to a Subject.For example, a Subject that happens to be a person, Alice, might have two Principals: one which binds \"Alice Bar\", the name on her driver license, to the Subject, and another which binds, \"999-99-9999\", the number on her student identification card, to the Subject.Both Principals refer to the same Subject even though each has a different name.A Subject may also own security-related attributes, which are referred to as credentials.Sensitive credentials that require special protection, such as private cryptographic keys, are stored within a private credential Set.Credentials intended to be shared, such as public key certificates or Kerberos server tickets are stored within a public credential Set.Different permissions are required to access and modify the different credential Sets.For example: Subject subject; Principal principal; Object credential; // add a Principal and credential to the Subject subject.getPrincipals().add(principal); subject.getPublicCredentials().add(credential); This Subject class implements Serializable.While the Principals associated with the Subject are serialized, the credentials associated with the Subject are not.Note that the java.security.Principal class does not implement Serializable.Therefore all concrete Principal implementations associated with Subjects must implement Serializable."},
{"description": "Implementations of this class enable views to present the CSS formatting while not knowing anything about how the CSS values are being cached.As a delegate of Views, this object is responsible for the insets of a View and making sure the background is maintained according to the CSS attributes."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Implementations of this class enable views to present the CSS formatting while not knowing anything about how the CSS values are being cached."},
{"description": "The StyleSheet is used to translate the HTML model into visual characteristics.This enables views to be customized by a look-and-feel, multiple views over the same model can be rendered differently, etc.This can be thought of as a CSS rule repository.The key for CSS attributes is an object of type CSS.Attribute.The type of the value is up to the StyleSheet implementation, but the toString method is required to return a string representation of CSS value.The primary entry point for HTML View implementations to get their attributes is the getViewAttributes method.This should be implemented to establish the desired policy used to associate attributes with the view.Each HTMLEditorKit (i.e. and therefore each associated JEditorPane) can have its own StyleSheet, but by default one sheet will be shared by all of the HTMLEditorKit instances.HTMLDocument instance can also have a StyleSheet, which holds the document-specific CSS specifications.In order for Views to store less state and therefore be more lightweight, the StyleSheet can act as a factory for painters that handle some of the rendering tasks.This allows implementations to determine what they want to cache and have the sharing potentially at the level that a selector is common to multiple views.Since the StyleSheet may be used by views over multiple documents and typically the HTML attributes don't effect the selector being used, the potential for sharing is significant.The rules are stored as named styles, and other information is stored to translate the context of an element to a rule quickly.The following code fragment will display the named styles, and therefore the CSS rules contained. \u00a0 \u00a0 import java.util.*; \u00a0 \u00a0 public class ShowStyles { \u00a0 \u00a0 public static void main(String[] args) { \u00a0 HTMLEditorKit kit = new HTMLEditorKit(); \u00a0 HTMLDocument doc = (HTMLDocument) kit.createDefaultDocument(); \u00a0 StyleSheet styles = doc.getStyleSheet(); \u00a0 \u00a0 Enumeration rules = styles.getStyleNames(); \u00a0 while (rules.hasMoreElements()) { \u00a0 String name = (String) rules.nextElement(); \u00a0 Style rule = styles.getStyle(name); \u00a0 System.out.println(rule.toString()); \u00a0 } \u00a0 System.exit(0); \u00a0 } \u00a0 } \u00a0 The semantics for when a CSS style should overide visual attributes defined by an element are not well defined.red> makes the body have a red background.But if the html file also contains the CSS rule body { background:blue } it becomes less clear as to what color the background of the body should be.The current implementation gives visual attributes defined in the element the highest precedence, that is they are always checked before any styles.Therefore, in the previous example the background would have a red color as the body element defines the background color to be red.As already mentioned this supports CSS.We don't support the full CSS spec.Refer to the javadoc of the CSS class to see what properties we support.The two major CSS parsing related concepts we do not currently support are pseudo selectors, such as A:link { color: red }, and the important modifier.It can be replaced with alternative implementations that are complete.Future versions of this class will provide better CSS support."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This sets the StyleConstants.This is done by calling StyledDocument.setCharacterAttributes on the styled document associated with the target JEditorPane.If the target text component is specified as the source of the ActionEvent and there is a command string, the command string will be interpreted as the foreground color.It will be interpreted by called Color.decode, and should therefore be legal input for that method.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This will use the size specified as the command string on the ActionEvent if there is one, otherwise the size that was initialized with will be used.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This will use the family specified as the command string on the ActionEvent if there is one, otherwise the family that was initialized with will be used.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This sets the StyleConstants.This is done by calling StyledDocument.setParagraphAttributes on the styled document associated with the target JEditorPane.If the target text component is specified as the source of the ActionEvent and there is a command string, the command string will be interpreted as an integer that should be one of the legal values for the StyleConstants.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This is the set of things needed by a text component to be a reasonably functioning editor for some type of text document.This implementation provides a default implementation which treats text as styled text and provides a minimal set of actions for editing styled text."},
{"description": "An action that assumes it's being fired on a JEditorPane with a StyledEditorKit (or subclass) installed.This has some convenience methods for causing character or paragraph level attribute changes.The convenience methods will throw an IllegalArgumentException if the assumption of a StyledDocument, a JEditorPane, or a StyledEditorKit fail to be true.The component that gets acted upon by the action will be the source of the ActionEvent if the source can be narrowed to a JEditorPane type.If neither of these are the case, the action cannot be performed.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class determines the lifetime of a group of resources by being a container that holds caches for various resources such as font and color that get reused by the various style definitions.This can be shared by multiple documents if desired to maximize the sharing of related resources.This class also provides efficient support for small sets of attributes and compresses them by sharing across uses and taking advantage of their immutable nature.Since many styles are replicated, the potential for sharing is significant, and copies can be extremely cheap.Larger sets reduce the possibility of sharing, and therefore revert automatically to a less space-efficient implementation.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This is a typesafe enumeration of the well-known attributes that contribute to a paragraph style.These are aliased by the outer class for general presentation."},
{"description": "This is a typesafe enumeration of the well-known attributes that contribute to a character style.These are aliased by the outer class for general presentation."},
{"description": "This is a typesafe enumeration of the well-known attributes that contribute to a font.These are aliased by the outer class for general presentation."},
{"description": "A collection of well known or common attribute keys and methods to apply to an AttributeSet or MutableAttributeSet to get/set the properties in a typesafe manner.The paragraph attributes form the definition of a paragraph to be rendered.All sizes are specified in points (such as found in postscript), a device independent measure."},
{"description": "A delegate is an instance of a class that implements this interface and provides a replacement implementation for all the methods of javax.rmi.CORBA.Stub.If delegation is enabled, each stub has an associated delegate.Delegates are enabled by providing the delegate's class name as the value of the javax.rmi.CORBA.StubClass system property."},
{"description": "Base class from which all RMI-IIOP stubs must inherit."},
{"description": "A Struct object contains a value for each attribute of the SQL structured type that it represents.By default, an instance ofStruct is valid as long as the application has a reference to it.All methods on the Struct interface must be fully implemented if the JDBC driver supports the data type."},
{"description": "Describes a member of an IDL struct in the Interface Repository, including the name of the struct member, the type of the struct member, and the typedef that represents the IDL type of the struct member described the struct member object."},
{"description": "A StubNotFoundException is thrown if a valid stub class could not be found for a remote object when it is exported.A StubNotFoundException may also be thrown when an activatable object is registered via the java.rmi.activation.Activatable.register method."},
{"description": "A class which implements a border of an arbitrary stroke.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The Stroke interface allows a Graphics2D object to obtain a Shape that is the decorated outline, or stylistic representation of the outline, of the specified Shape.Stroking a Shape is like tracing its outline with a marking pen of the appropriate size and shape.The area where the pen would place ink is the area enclosed by the outline Shape.The methods of the Graphics2D interface that use the outline Shape returned by a Stroke object include draw and any other methods that are implemented in terms of that method, such as drawLine, drawRect, drawRoundRect, drawOval, drawArc, drawPolyline, and drawPolygon.The objects of the classes implementing Stroke must be read-only because Graphics2D does not clone these objects either when they are set as an attribute with the setStroke method or when the Graphics2D object is itself cloned.If a Stroke object is modified after it is set in the Graphics2D context then the behavior of subsequent rendering would be undefined."},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "A character stream that collects its output in a string buffer, which can then be used to construct a string.Closing a StringWriter has no effect.The methods in this class can be called after the stream has been closed without generating an IOException."},
{"description": "Represents strings that are arguments to relational constraints."},
{"description": "The string tokenizer class allows an application to break a string into tokens.The tokenization method is much simpler than the one used by the StreamTokenizer class.The StringTokenizer methods do not distinguish among identifiers, numbers, and quoted strings, nor do they recognize and skip comments.The set of delimiters (the characters that separate tokens) may be specified either at creation time or on a per-token basis.An instance of StringTokenizer behaves in one of two ways, depending on whether it was created with the returnDelims flag having the value true or false: If the flag is false, delimiter characters serve to separate tokens.A token is a maximal sequence of consecutive characters that are not delimiters.A token is thus either one delimiter character, or a maximal sequence of consecutive characters that are not delimiters.A StringTokenizer object internally maintains a current position within the string to be tokenized.Some operations advance this current position past the characters processed.A token is returned by taking a substring of the string that was used to create the StringTokenizer object.The following is one example of the use of the tokenizer.The code: StringTokenizer st = new StringTokenizer(\"this is a test\"); while (st.hasMoreTokens()) { System.out.println(st.nextToken()); } prints the following output: this is a test StringTokenizer is a legacy class that is retained for compatibility reasons although its use is discouraged in new code.It is recommended that anyone seeking this functionality use the split method of String or the java.util.regex package instead.The following example illustrates how the String.split method can be used to break up a string into its basic tokens: String[] result =\"this is a test\".split(\"\\\\s\"); for (int x=0; x<result.length; x++) System.out.println(result[x]); prints the following output: this is a test"},
{"description": "Since these are typically used to associate character and paragraph styles with the element, operations for this are provided.Other customized attributes that get associated with the element will effectively be name-value pairs that live in a hierarchy and if a name (key) is not found locally, the request is forwarded to the parent.Commonly used attributes are separated out to facilitate alternative implementations that are more efficient."},
{"description": "This is a typesafe enumeration of the well-known attributes that contribute to a color.These are aliased by the outer class for general presentation."},
{"description": "StringName is the Stringified Name, Array of Name Components represented as a String."},
{"description": "A character stream whose source is a string."},
{"description": "This class represents the string form of the address of a communications end-point.It consists of a type that describes the communication mechanism and a string contents specific to that communication mechanism.The format and interpretation of the address type and the contents of the address are based on the agreement of three parties: the client that uses the address, the object/server that can be reached using the address, and the administrator or program that creates the address.An example of a string reference address is a host name.Another example of a string reference address is a URL.Multithreaded access to a single StringRefAddr need not be synchronized."},
{"description": "A Transferable which implements the capability required to transfer a String.This Transferable properly supports DataFlavor.stringFlavor and all equivalent flavors.Support for DataFlavor.plainTextFlavor and all equivalent flavors is deprecated."},
{"description": "A Holder class for a String that is used to store \"out\" and \"inout\" parameters in IDL operations.If an IDL operation signature has an IDL string as an \"out\" or \"inout\" parameter, the programmer must pass an instance of StringHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myStringHolder is an instance of StringHolder, the value stored in its value field can be accessed with myStringHolder.value."},
{"description": "StringCharacterIterator implements the CharacterIterator protocol for a String.The StringCharacterIterator class iterates over the entire String."},
{"description": "Thrown by String methods to indicate that an index is either negative or greater than the size of the string.For some methods such as the charAt method, this exception also is thrown when the index is equal to the size of the string."},
{"description": "A string monitor sends notifications as follows: if the attribute value matches the string to compare value, a match notification is sent.Subsequent matchings of the string to compare values do not cause further notifications unless the attribute value differs from the string to compare value.if the attribute value differs from the string to compare value, a differ notification is sent.Subsequent differences from the string to compare value do not cause further notifications unless the attribute value matches the string to compare value."},
{"description": "Content interface that is a brute force implementation that is useful for relatively small documentsIt manages the character content as a simple character array.This buffer does not scale up to large sizes.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "StringJoiner is used to construct a sequence of characters separated by a delimiter and optionally starting with a supplied prefix and ending with a supplied suffix.Prior to adding something to the StringJoiner, its sj.toString() method will, by default, return prefix + suffix.This can be used, for example, when creating a string using set notation to indicate an empty set, i.e. \"{}\", where the prefix is \"{\", the suffix is \"}\" and nothing has been added to the StringJoiner."},
{"description": "This class provides an API compatible with StringBuffer, but with no guarantee of synchronization.This class is designed for use as a drop-in replacement for StringBuffer in places where the string buffer was being used by a single thread (as is generally the case).Where possible, it is recommended that this class be used in preference to StringBuffer as it will be faster under most implementations.The principal operations on a StringBuilder are the append and insert methods, which are overloaded so as to accept data of any type.Each effectively converts a given datum to a string and then appends or inserts the characters of that string to the string builder.The append method always adds these characters at the end of the builder; the insert method adds the characters at a specified point.For example, if z refers to a string builder object whose current contents are \"start\", then the method call z.append(\"le\") would cause the string builder to contain \"startle\", whereas z.insert(4, \"le\") would alter the string builder to contain \"starlet\".In general, if sb refers to an instance of a StringBuilder, then sb.append(x) has the same effect as sb.insert(sb.length(), x).Every string builder has a capacity.As long as the length of the character sequence contained in the string builder does not exceed the capacity, it is not necessary to allocate a new internal buffer.Instances of StringBuilder are not safe for use by multiple threads.Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown."},
{"description": "This class does not properly convert characters into bytes.As of JDK\u00a01.1, the preferred way to create a stream from a string is via the StringReader class."},
{"description": "The class StrictMath contains methods for performing basic numeric operations such as the elementary exponential, logarithm, square root, and trigonometric functions.To help ensure portability of Java programs, the definitions of some of the numeric functions in this package require that they produce the same results as certain published algorithms.These algorithms are available from the well-known network library netlib as the package \"Freely Distributable Math Library,\" fdlibm.These algorithms, which are written in the C programming language, are then to be understood as executed with all floating-point operations following the rules of Java floating-point arithmetic.The Java math library is defined with respect to fdlibm version 5.3.Where fdlibm provides more than one definition for a function (such as acos), use the \"IEEE 754 core function\" version (residing in a file whose name begins with the letter e).The methods which require fdlibm semantics are sin, cos, tan, asin, acos, atan, exp, log, log10, cbrt, atan2, pow, sinh, cosh, tanh, hypot, expm1, and log1p.The platform uses signed two's complement integer arithmetic with int and long primitive types.The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation.The best practice is to choose the primitive type and algorithm to avoid overflow.In cases where the size is int or long and overflow errors need to be detected, the methods addExact, subtractExact, multiplyExact, and toIntExact throw an ArithmeticException when the results overflow.For other arithmetic operations such as divide, absolute value, increment, decrement, and negation overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate."},
{"description": "This class is mostly for library writers presenting stream views of data structures; most static stream methods intended for end users are in the various Stream classes."},
{"description": "Note: Due to their internal use of either a Reader or InputStream instance, StreamSource instances may only be used once."},
{"description": "A string buffer is like a String, but can be modified.At any point in time it contains some particular sequence of characters, but the length and content of the sequence can be changed through certain method calls.String buffers are safe for use by multiple threads.The methods are synchronized where necessary so that all the operations on any particular instance behave as if they occur in some serial order that is consistent with the order of the method calls made by each of the individual threads involved.The principal operations on a StringBuffer are the append and insert methods, which are overloaded so as to accept data of any type.Each effectively converts a given datum to a string and then appends or inserts the characters of that string to the string buffer.The append method always adds these characters at the end of the buffer; the insert method adds the characters at a specified point.For example, if z refers to a string buffer object whose current contents are \"start\", then the method call z.append(\"le\") would cause the string buffer to contain \"startle\", whereas z.insert(4, \"le\") would alter the string buffer to contain \"starlet\".In general, if sb refers to an instance of a StringBuffer, then sb.append(x) has the same effect as sb.insert(sb.length(), x).Whenever an operation occurs involving a source sequence (such as appending or inserting from a source sequence), this class synchronizes only on the string buffer performing the operation, not on the source.Note that while StringBuffer is designed to be safe to use concurrently from multiple threads, if the constructor or the append or insert operation is passed a source sequence that is shared across threads, the calling code must ensure that the operation has a consistent and unchanging view of the source sequence for the duration of the operation.This could be satisfied by the caller holding a lock during the operation's call, by using an immutable source sequence, or by not sharing the source sequence across threads.Every string buffer has a capacity.As long as the length of the character sequence contained in the string buffer does not exceed the capacity, it is not necessary to allocate a new internal buffer array.Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown.As of release JDK 5, this class has been supplemented with an equivalent class designed for use by a single thread, StringBuilder.The StringBuilder class should generally be used in preference to this one, as it supports all of the same operationsbut it is faster, as it performs no synchronization."},
{"description": "This is the base class for deriving an XMLStreamReader filter This class is designed to sit between an XMLStreamReader and an application's XMLStreamReader.By default each method does nothing but call the corresponding method on the parent interface."},
{"description": "The String class represents character strings.All string literals in Java programs, such as \"abc\", are implemented as instances of this class.String buffers support mutable strings.For example: String str = \"abc\"; is equivalent to: char data[] = {'a', 'b', 'c'}; String str = new String(data); Here are some more examples of how strings can be used: System.out.println(\"abc\"); String cde = \"cde\";System.out.println(\"abc\" + cde); String c = \"abc\".substring(2,3); String d = cde.substring(1, 2); The class String includes methods for examining individual characters of the sequence, for comparing strings, for searching strings, for extracting substrings, and for creating a copy of a string with all characters translated to uppercase or to lowercase.Case mapping is based on the Unicode Standard version specified by the Character class.The Java language provides special support for the string concatenation operator (\u00a0+\u00a0), and for conversion of other objects to strings.String concatenation is implemented through the StringBuilder(or StringBuffer) class and its append method.String conversions are implemented through the method toString, defined by Object and inherited by all classes in Java.Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown.A String represents a string in the UTF-16 format in which supplementary characters are represented by surrogate pairs (see the section Unicode Character Representations in the Character class for more information).Index values refer to char code units, so a supplementary character uses two positions in a String.The String class provides methods for dealing with Unicode code points (i.e., characters), in addition to those for dealing with Unicode code units (i.e., char values)."},
{"description": "Acts as an holder for a transformation result, which may be XML, plain Text, HTML, or some other form of markup."},
{"description": "A StreamPrintServiceFactory is the factory for StreamPrintService instances, which can print to an output stream in a particular document format described as a mime type.A typical output document format may be Postscript(TM).This class is implemented by a service and located by the implementation using the SPI JAR File specification.Applications locate instances of this class by calling the lookupStreamPrintServiceFactories(DocFlavor, String) method.Applications can use a StreamPrintService obtained from a factory in place of a PrintService which represents a physical printer device."},
{"description": "This class extends PrintService and represents a print service that prints data in different formats to a client-provided output stream.This is principally intended for services where the output format is a document type suitable for viewing or archiving.The output format must be declared as a mime type.This is equivalent to an output document flavor where the representation class is always \"java.io.OutputStream\" An instance of the StreamPrintService class is obtained from a StreamPrintServiceFactory instance.Note that a StreamPrintService is different from a PrintService, which supports a Destination attribute.A StreamPrintService always requires an output stream, whereas a PrintService optionally accepts a Destination.A StreamPrintService has no default destination for its formatted output.Additionally a StreamPrintService is expected to generateoutput in a format useful in other contexts.StreamPrintService's are not expected to support the Destination attribute."},
{"description": "Stream based logging Handler.This is primarily intended as a base class or support class to be used in implementing other logging Handlers.LogRecords are published to a given java.io.OutputStream.Configuration: By default each StreamHandler is initialized using the following LogManager configuration properties where <handler-name> refers to the fully-qualified class name of the handler.If properties are not defined (or have invalid values) then the specified default values are used.<handler-name>.filter specifies the name of a Filter class to use (defaults to no Filter).<handler-name>.encoding the name of the character set encoding to use (defaults to the default platform encoding).For example, the properties for StreamHandler would be:For a custom handler, e.g. com.foo.MyHandler, the properties would be: com.foo.MyHandler.level=INFO com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter"},
{"description": "This interface declares a simple filter interface that one can create to filter XMLStreamReaders"},
{"description": "Thrown when control information that was read from an object stream violates internal consistency checks."},
{"description": "Defines the base type for all non-boxed IDL valuetypes that are not custom marshaled.All value types implement ValueBase either directly or indirectly by implementing either the StreamableValue or CustomValue interface."},
{"description": "The ORB treats all generated Holders as Streamable to invoke the methods for marshalling and unmarshalling."},
{"description": "This allows the creation of a Stream by generating elements individually and adding them to the Builder (without the copying overhead that comes from using an ArrayList as a temporary buffer.)A stream builder has a lifecycle, which starts in a building phase, during which elements can be added, and then transitions to a built phase, after which elements may not be added.The built phase begins when the build() method is called, which creates an ordered Stream whose elements are the elements that were added to the stream builder, in the order they were added."},
{"description": "The StreamTokenizer class takes an input stream and parses it into \"tokens\", allowing the tokens to be read one at a time.The parsing process is controlled by a table and a number of flags that can be set to various states.The stream tokenizer can recognize identifiers, numbers, quoted strings, and various comment styles.Each byte read from the input stream is regarded as a character in the range '\\u0000' through '\\u00FF'.The character value is used to look up five possible attributes of the character: white space, alphabetic, numeric, string quote, and comment character.Each character can have zero or more of these attributes.In addition, an instance has four flags.These flags indicate: Whether line terminators are to be returned as tokens or treated as white space that merely separates tokens.Whether the characters of identifiers are converted to lowercase.A typical application first constructs an instance of this class, sets up the syntax tables, and then repeatedly loops calling the nextToken method in each iteration of the loop until it returns the value TT_EOF."},
{"description": "The following example illustrates an aggregate operation using Stream and IntStream: int sum = widgets.stream(); In this example, widgets is a Collection<Widget>.We create a stream of Widget objects via Collection.stream(), filter it to produce a stream containing only the red widgets, and then transform it into a stream of int values representing the weight of each red widget.Then this stream is summed to produce a total weight.In addition to Stream, which is a stream of object references, there are primitive specializations for IntStream, LongStream, and DoubleStream, all of which are referred to as \"streams\" and conform to the characteristics and restrictions described here.To perform a computation, stream operations are composed into a stream pipeline.A stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more intermediate operations (which transform a stream into another stream, such as filter(Predicate)), and a terminal operation (which produces a result or side-effect, such as count() or forEach(Consumer)).Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed.Collections and streams, while bearing some superficial similarities, have different goals.Collections are primarily concerned with the efficient management of, and access to, their elements.By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source.However, if the provided stream operations do not offer the desired functionality, the BaseStream.iterator() and BaseStream.spliterator() operations can be used to perform a controlled traversal.A stream pipeline, like the \"widgets\" example above, can be viewed as a query on the stream source.Unless the source was explicitly designed for concurrent modification (such as a ConcurrentHashMap), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried.Most stream operations accept parameters that describe user-specified behavior, such as the lambda expressionTo preserve correct behavior, these behavioral parameters: must be non-interfering (they do not modify the stream source); and in most cases must be stateless (their result should not depend on any state that might change during execution of the stream pipeline).Such parameters are always instances of a functional interface such as Function, and are often lambda expressions or method references.Unless otherwise specified these parameters must be non-null.A stream should be operated on (invoking an intermediate or terminal stream operation) only once.This rules out, for example, \"forked\" streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream.A stream implementation may throw IllegalStateException if it detects that the stream is being reused.However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases.Streams have a BaseStream.close() method and implement AutoCloseable, but nearly all stream instances do not actually need to be closed after use.Generally, only streams whose source is an IO channel (such as those returned by Files.lines(Path, Charset)) will require closing.Most streams are backed by collections, arrays, or generating functions, which require no special resource management.(If a stream does require closing, it can be declared as a resource in a try-with-resources statement.)Stream pipelines may execute either sequentially or in parallel.This execution mode is a property of the stream.Streams are created with an initial choice of sequential or parallel execution.(For example, Collection.stream() creates a sequential stream, and Collection.parallelStream() creates a parallel one.)This choice of execution mode may be modified by the BaseStream.sequential() or BaseStream.parallel() methods, and may be queried with the BaseStream.isParallel() method."},
{"description": "The object used for executing a static SQL statement and returning the results it produces.By default, only one ResultSet object per Statement object can be open at the same time.Therefore, if the reading of one ResultSet object is interleaved with the reading of another, each must have been generated by different Statement objects.All execution methods in the Statement interface implicitly close a current ResultSet object of the statement if an open one exists."},
{"description": "StAXSource can be used in all cases that accept a Source, e.g. Transformer, Validator which accept Source as input.StAXSources are consumed during processing and are not reusable."},
{"description": "A StatementEvent is sent to all StatementEventListeners which were registered with a PooledConnection.This occurs when the driver determines that a PreparedStatement that is associated with the PooledConnection has been closed or the driver determines is invalid."},
{"description": "StAXResult can be used in all cases that accept a Result, e.g. Transformer, Validator which accept Result as input."},
{"description": "An object that registers to be notified of events that occur on PreparedStatements that are in the Statement pool.The JDBC 3.0 specification added the maxStatements ConnectionPooledDataSource property to provide a standard mechanism for enabling the pooling of PreparedStatements and to specify the size of the statement pool.However, there was no way for a driver to notify an external statement pool when a PreparedStatement becomes invalid.For some databases, a statement becomes invalid if a DDL operation is performed that affects the table.For example an application may create a temporary table to do some work on the table and then destroy it.It may later recreate the same table when it is needed again.Some databases will invalidate any prepared statements that reference the temporary table when the table is dropped.Similar to the methods defined in the ConnectionEventListener interface, the driver will call the StatementEventListener.statementErrorOccurred method prior to throwing any exceptions when it detects a statement is invalid.The driver will also call the StatementEventListener.statementClosed method when a PreparedStatement is closed.Methods which allow a component to register a StatementEventListener with a PooledConnection have been added to the PooledConnection interface."},
{"description": "A Statement object represents a primitive statement in which a single method is applied to a target and a set of arguments - as in \"a.setFoo(b)\".Note that where this example uses names to denote the target and its argument, a statement object does not require a name space and is constructed with the values themselves.The statement object associates the named method with its environment as a simple set of values: the target and an array of argument values."},
{"description": "This interface represents a factory for obtaining the state of an object for binding.The JNDI framework allows for object implementations to be loaded in dynamically via object factories.For example, when looking up a printer bound in the name space, if the print service binds printer names to References, the printer Reference could be used to create a printer object, so that the caller of lookup can directly operate on the printer object after the lookup.An ObjectFactory is responsible for creating objects of a specific type.In the above example, you may have a PrinterObjectFactory for creating Printer objects.For the reverse process, when an object is bound into the namespace, JNDI provides state factories.Continuing with the printer example, suppose the printer object is updated and rebound: ctx.rebind(\"inky\", printer); The service provider for ctx uses a state factory to obtain the state of printer for binding into its namespace.A state factory for the Printer type object might return a more compact object for storage in the naming system.A state factory must implement the StateFactory interface.In addition, the factory class must be public and must have a public constructor that accepts no parameters.The getStateToBind() method of a state factory may be invoked multiple times, possibly using different parameters.StateFactory is intended for use with service providers that implement only the Context interface.DirStateFactory is intended for use with service providers that implement the DirContext interface."},
{"description": "StateEditable defines the interface for objects that can have their state undone/redone by a StateEdit."},
{"description": "StateEdit is a general edit for objects that change state.Objects being edited must conform to the StateEditable interface.This edit class works by asking an object to store it's state in Hashtables before and after editing occurs.Upon undo or redo the object is told to restore it's state from these Hashtables.// Modify the object myObject.someStateModifyingMethod(); // \"end\" the edit when you are done modifying the object newEdit.end();Note that when a StateEdit ends, it removes redundant state from the Hashtables - A state Hashtable is not guaranteed to contain all keys/values placed into it when the state is stored!"},
{"description": "This class implements the LDAPv3 Extended Request for StartTLS as defined in Lightweight Directory Access Protocol (v3)The object identifier for StartTLS is 1.3.6.1.4.1.1466.20037 and no extended request value is defined.StartTlsRequest/StartTlsResponse are used to establish a TLS connection over the existing LDAP connection associated with the JNDI context on which extendedOperation() is invoked.Typically, a JNDI program uses these classes as follows."},
{"description": "Synth provides several built in states, which are: Enabled Mouse Over Pressed Disabled Focused Selected DefaultHowever, there are many more states that could be described in a LookAndFeel, and it would be nice to style components differently based on these different states.For example, a progress bar could be \"indeterminate\".It would be very convenient to allow this to be defined as a \"state\".This class, State, is intended to be used for such situations.It returns true if the given JComponent is \"in this state\", false otherwise.This method will be called many times in performance sensitive loops.For example, the following might be an implementation of a custom \"Indeterminate\" state for JProgressBars:public final class IndeterminateState extends State<JProgressBar> { public IndeterminateState()"},
{"description": "This class implements the LDAPv3 Extended Response for StartTLS as defined in Lightweight Directory Access Protocol (v3)The object identifier for StartTLS is 1.3.6.1.4.1.1466.20037 and no extended response value is defined.The Start TLS extended request and response are used to establish a TLS connection over the existing LDAP connection associated with the JNDI context on which extendedOperation() is invoked.Typically, a JNDI program uses the StartTLS extended request and response classes as follows."},
{"description": "The StartElement interface provides access to information about start elements.A StartElement is reported for each Start Tag in the document."},
{"description": "The name of each socket option defined by this class is its field name.In this release, the socket options defined here are used by network channels in the channels package."},
{"description": "An MBean whose management interface is determined by reflection on a Java interface.This class brings more flexibility to the notion of Management Interface in the use of Standard MBeans.Straightforward use of the patterns for Standard MBeans described in the JMX Specification means that there is a fixed relationship between the implementation class of an MBean and its management interface (i.e., if the implementation class is Thing, the management interface must be ThingMBean).This class makes it possible to keep the convenience of specifying the management interface with a Java interface, without requiring that there be any naming relationship between the implementation and interface classes.By making a DynamicMBean out of an MBean, this class makes it possible to select any interface implemented by the MBean as its management interface, provided that it complies with JMX patterns (i.e., attributes defined by getter/setter etc...).This class also provides hooks that make it possible to supply custom descriptions and names for the MBeanInfo returned by the DynamicMBean interface.Using this class, an MBean can be created with any implementation class name Impl and with a management interface defined (as for current Standard MBeans) by any interface Intf, in one of two general ways:StandardMBean mbean = new StandardMBean(impl, Intf.class, false); mbs.registerMBean(mbean, objectName); Subclassing StandardMBean: public class Impl extends StandardMBean implements Intf { public Impl() { super(Intf.class, false); } // implement methods of Intf } [...].... Impl impl = new Impl(); mbs.registerMBean(impl, objectName); In either case, the class Impl must implement the interface Intf.Standard MBeans based on the naming relationship between implementation and interface classes are of course still available.This class may also be used to construct MXBeans.The usage is exactly the same as for Standard MBeans except that in the examples above, the false parameter to the constructor or super(...) invocation is instead true."},
{"description": "File manager based on java.io.File.A common way to obtain an instance of this class is using getStandardFileManager, for example:ToolProvider.getSystemJavaCompiler(); DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<JavaFileObject>(); StandardJavaFileManager fm = compiler.getStandardFileManager(diagnostics, null, null); This file manager creates file objects representing regular files, zip file entries, or entries in similar file system based containers.Any file object returned from a file manager implementing this interface must observe the following behavior: File names need not be canonical.For file objects representing regular files the method FileObject.delete() is equivalent to File.delete(), the method FileObject.getLastModified() is equivalent to File.lastModified(), the methods FileObject.getCharContent(boolean), FileObject.openInputStream(), and FileObject.openReader(boolean) must succeed if the following would succeed (ignoring encoding issues):new FileInputStream(new File(fileObject.toUri())) and the methods FileObject.openOutputStream(), and FileObject.openWriter() must succeed if the following would succeed (ignoring encoding issues):The URI returned from FileObject.toUri() must be absolute (have a schema), and must have a normalized path component which can be resolved without any process-specific context such as the current directory (file names must be absolute).According to these rules, the following URIs, for example, are allowed: file:///C:/Documents%20and%20Settings/UncleBob/BobsApp/Test.java jar:///C:/Documents%20and%20Settings/UncleBob/lib/vendorA.jar!com/vendora/LibraryClass.class Whereas these are not (reason in parentheses): file:Test.java (the file name is relative and depend on the current directory) jar:lib/vendorA.jar!com/vendora/LibraryClass.class (the first half of the path depends on the current directory, whereas the component after ! is legal) Test.java(this URI depends on the current directory and does not have a schema) jar:///C:/Documents%20and%20Settings/UncleBob/BobsApp/.."},
{"description": "An MBean whose management interface is determined by reflection on a Java interface, and that emits notifications.The following example shows how to use the public constructor StandardEmitterMBean(implementation, mbeanInterface, emitter) to create an MBean emitting notifications with any implementation class name Impl, with a management interface defined (as for current Standard MBeans) by any interface Intf, and with any implementation of the interface NotificationEmitter.The example uses the class NotificationBroadcasterSupport as an implementation of the interface NotificationEmitter."},
{"description": "These charsets are guaranteed to be available on every implementation of the Java platform."},
{"description": "The state of a StampedLock consists of a version and mode.Lock acquisition methods return a stamp that represents and controls access with respect to a lock state; \"try\" versions of these methods may instead return the special value zero to represent failure to acquire access.Lock release and conversion methods require stamps as arguments, and fail if they do not match the state of the lock.The three modes are: Writing.Method writeLock() possibly blocks waiting for exclusive access, returning a stamp that can be used in method unlockWrite(long) to release the lock.Untimed and timed versions of tryWriteLock are also provided.When the lock is held in write mode, no read locks may be obtained, and all optimistic read validations will fail.Method readLock() possibly blocks waiting for non-exclusive access, returning a stamp that can be used in method unlockRead(long) to release the lock.Untimed and timed versions of tryReadLock are also provided.Method tryOptimisticRead() returns a non-zero stamp only if the lock is not currently held in write mode.Method validate(long) returns true if the lock has not been acquired in write mode since obtaining a given stamp.This mode can be thought of as an extremely weak version of a read-lock, that can be broken by a writer at any time.The use of optimistic mode for short read-only code segments often reduces contention and improves throughput.Optimistic read sections should only read fields and hold them in local variables for later use after validation.Fields read while in optimistic mode may be wildly inconsistent, so usage applies only when you are familiar enough with data representations to check consistency and/or repeatedly invoke method validate().For example, such steps are typically required when first reading an object or array reference, and then accessing one of its fields, elements or methods.This class also supports methods that conditionally provide conversions across the three modes.For example, method tryConvertToWriteLock(long) attempts to \"upgrade\" a mode, returning a valid write stamp if (1) already in writing mode (2) in reading modeand there are no other readers or (3) in optimistic mode and the lock is available.The forms of these methods are designed to help reduce some of the code bloat that otherwise occurs in retry-based designs.StampedLocks are designed for use as internal utilities in the development of thread-safe components.Their use relies on knowledge of the internal properties of the data, objects, and methods they are protecting.They are not reentrant, so locked bodies should not call other unknown methods that may try to re-acquire locks (although you may pass a stamp to other methods that can use or convert it).The use of read lock modes relies on the associated code sections being side-effect-free.Unvalidated optimistic read sections cannot call methods that are not known to tolerate potential inconsistencies.Stamps use finite representations, and are not cryptographically secure (i.e., a valid stamp may be guessable).Stamp values may recycle after (no sooner than) one year of continuous operation.A stamp held without use or validation for longer than this period may fail to validate correctly.StampedLocks are serializable, but always deserialize into initial unlocked state, so they are not useful for remote locking.The scheduling policy of StampedLock does not consistently prefer readers over writers or vice versa.All \"try\" methods are best-effort and do not necessarily conform to any scheduling or fairness policy.A zero return from any \"try\" method for acquiring or converting locks does not carry any information about the state of the lock; a subsequent invocation may succeed.Because it supports coordinated usage across multiple lock modes, this class does not directly implement the Lock or ReadWriteLock interfaces.However, a StampedLock may be viewed asReadLock(), asWriteLock(), or asReadWriteLock() in applications requiring only the associated set of functionality.The following illustrates some usage idioms in a class that maintains simple two-dimensional points.The sample code illustrates some try/catch conventions even though they are not strictly needed here because no exceptions can occur in their bodies.class Point { private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) { // an exclusively locked method long stamp = sl.writeLock(); try { x += deltaX; y += deltaY; } finally { sl.unlockWrite(stamp); } } double distanceFromOrigin() { //"},
{"description": "Each element represents a single stack frame.All stack frames except for the one at the top of the stack represent a method invocation.The frame at the top of the stack represents the execution point at which the stack trace was generated.Typically, this is the point at which the throwable corresponding to the stack trace was created."},
{"description": "This class extends Sockets and provides secure socket using protocols such as the \"Secure Sockets Layer\" (SSL) or IETF \"Transport Layer Security\" (TLS) protocols.Such sockets are normal stream sockets, but they add a layer of security protections over the underlying network transport protocol, such as TCP.Those protections include: Integrity Protection.SSL protects against modification of messages by an active wiretapper.In most modes, SSL provides peer authentication.Servers are usually authenticated, and clients may be authenticated as requested by servers.In most modes, SSL encrypts data being sent between client and server.This protects the confidentiality of data, so that passive wiretappers won't see sensitive data such as financial information or personal information of many kinds.These kinds of protection are specified by a \"cipher suite\", which is a combination of cryptographic algorithms used by a given SSL connection.During the negotiation process, the two endpoints must agree on a ciphersuite that is available in both environments.If there is no such suite in common, no SSL connection can be established, and no data can be exchanged.The cipher suite used is established by a negotiation process called \"handshaking\".The goal of this process is to create or rejoin a \"session\", which may protect many connections over time.After handshaking has completed, you can access session attributes by using the getSession method.The initial handshake on this connection can be initiated in one of three ways: calling startHandshake which explicitly begins handshakes, or any attempt to read or write application data on this socket causes an implicit handshake, or a call to getSession tries to set up a session if there is no currently valid session, and an implicit handshake is done.If handshaking fails for any reason, the SSLSocket is closed, and no further communications can be done.There are two groups of cipher suites which you will need to know about when managing cipher suites:Supported cipher suites: all the suites which are supported by the SSL implementation.This list is reported using getSupportedCipherSuites.Enabled cipher suites, which may be fewer than the full set of supported suites.This group is set using the setEnabledCipherSuites method, and queried using the getEnabledCipherSuites method.Initially, a default set of cipher suites will be enabled on a new socket that represents the minimum suggested configuration.Implementation defaults require that only cipher suites which authenticate servers and provide confidentiality be enabled by default.Only if both sides explicitly agree to unauthenticated and/or non-private (unencrypted) communications will such a ciphersuite be selected.When SSLSockets are first created, no handshaking is done so that applications may first set their communication preferences: what cipher suites to use, whether the socket should be in client or server mode, etc.However, security is always provided by the time that application data is sent over the connection.You may register to receive event notification of handshake completion.This involves the use of two additional classes.HandshakeCompletedEvent objects are passed to HandshakeCompletedListener instances, which are registered by users of this API.SSLSockets are created by SSLSocketFactorys, or by accepting a connection from a SSLServerSocket.A SSL socket must choose to operate in the client or server mode.This will determine who begins the handshaking process, as well as which messages should be sent by each party.Each connection must have one client and one server, or handshaking will not progress properly.Once the initial handshaking has started, a socket can not switch between client and server modes, even when performing renegotiations."},
{"description": "The Stack class represents a last-in-first-out (LIFO) stack of objects.It extends class Vector with five operations that allow a vector to be treated as a stack.The usual push and pop operations are provided, as well as a method to peek at the top item on the stack, a method to test for whether the stack is empty, and a method to search the stack for an item and discover how far it is from the top.When a stack is first created, it contains no items.A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class."},
{"description": "SSLSocketFactorys create SSLSockets."},
{"description": "A SSLSessionContext represents a set of SSLSessions associated with a single entity.For example, it could be associated with a server or client who participates in many sessions concurrently.Not all environments will contain session contexts.There are SSLSessionContext parameters that affect how sessions are stored: Sessions can be set to expire after a specified time limit.The number of sessions that can be stored in context can be limited.A session can be retrieved based on its session id, and all sessionid's in a SSLSessionContext can be listed."},
{"description": "This interface is implemented by objects which want to know when they are being bound or unbound from a SSLSession.When either event occurs via SSLSession.putValue(String, Object) or SSLSession.removeValue(String), the event is communicated through a SSLSessionBindingEvent identifying the session."},
{"description": "This event is propagated to a SSLSessionBindingListener.When a listener object is bound or unbound to an SSLSession by SSLSession.putValue(String, Object) or SSLSession.removeValue(String), objects which implement the SSLSessionBindingListener will be receive an event of this type.The event's name field is the key in which the listener is being bound or unbound."},
{"description": "In SSL, sessions are used to describe an ongoing relationship between two entities.Each SSL connection involves one session at a time, but that session may be used on many connections between those entities, simultaneously or sequentially.The session used on a connection may also be replaced by a different session.Sessions are created, or rejoined, as part of the SSL handshaking protocol.Sessions may be invalidated due to policies affecting security or resource usage, or by an application explicitly calling invalidate.Session management policies are typically used to tune performance.In addition to the standard session attributes, SSL sessions expose these read-only attributes: Peer Identity.Sessions are between a particular client and a particular server.The identity of the peer may have been established as part of session setup.Peers are generally identified by X.509 certificate chains.Cipher suites describe the kind of cryptographic protection that's used by connections in a particular session.All connections in a session are between the same two hosts.The address of the host on the other side of the connection is available.Invalidation may also be done implicitly, when faced with certain kinds of errors."},
{"description": "This class extends ServerSockets and provides secure server sockets using protocols such as the Secure Sockets Layer (SSL) or Transport Layer Security (TLS) protocols.Instances of this class are generally created using a SSLServerSocketFactory.The primary function of SSLServerSockets is to create SSLSockets by accepting connections.SSLServerSockets contain several pieces of state data which are inherited by the SSLSocket at socket creation.These include the enabled cipher suites and protocols, whether client authentication is necessary, and whether created sockets should begin handshaking in client or server mode.The state inherited by the created SSLSocket can be overriden by calling the appropriate methods."},
{"description": "An SslRMIServerSocketFactory instance is used by the RMI runtime in order to obtain server sockets for RMI calls via SSL.This class creates SSL sockets using the default SSLSocketFactory (see SSLSocketFactory.getDefault()) or the default SSLServerSocketFactory(see SSLServerSocketFactory.getDefault()) unless the constructor taking an SSLContext is used in which case the SSL sockets are created using the SSLSocketFactory returned by SSLContext.getSocketFactory() or the SSLServerSocketFactory returned by SSLContext.getServerSocketFactory().When an SSLContext is not supplied all the instances of this class share the same keystore, and the same truststore (when client authentication is required by the server).This behavior can be modified by supplying an already initialized SSLContext instance."},
{"description": "Normally this indicates a flaw in one of the protocol implementations."},
{"description": "When the peer was not able to identify itself (for example; no certificate, the particular cipher suite being used does not support authentication, or no peer authentication was established during SSL handshaking)"},
{"description": "Encapsulates parameters for an SSL/TLS connection.The parameters are the list of ciphersuites to be accepted in an SSL/TLS handshake, the list of protocols to be allowed, the endpoint identification algorithm during SSL/TLS handshaking, the Server Name Indication (SNI), the algorithm constraints and whether SSL/TLS servers should request or require client authentication, etc.SSLParameters can be created via the constructors in this class.Objects can also be obtained using the getSSLParameters() methods in SSLSocket and SSLServerSocket and SSLEngine or the getDefaultSSLParameters() and getSupportedSSLParameters() methods in SSLContext.SSLParameters can be applied to a connection via the methods SSLSocket.setSSLParameters() and SSLServerSocket.setSSLParameters() and SSLEngine.setSSLParameters()."},
{"description": "Normally, this indicates misconfiguration of the server or client SSL certificate and private key."},
{"description": "An SslRMIClientSocketFactory instance is used by the RMI runtime in order to obtain client sockets for RMI calls via SSL.This class implements RMIClientSocketFactory over the Secure Sockets Layer (SSL) or Transport Layer Security (TLS) protocols.This class creates SSL sockets using the default SSLSocketFactory (see SSLSocketFactory.getDefault()).All instances of this class are functionally equivalent.In particular, they all share the same truststore, and the same keystore when client authentication is required by the server.This behavior can be modified in subclasses by overriding the createSocket(String,int) method; in that case, equals and hashCode may also need to be overridden.The value of this system property is a string that is a comma-separated list of SSL/TLS cipher suites to enable.If the system property javax.rmi.ssl.client.enabledProtocols is specified, the createSocket(String,int) method will call SSLSocket.setEnabledProtocols(String[]) before returning the socket.The value of this system property is a string that is a comma-separated list of SSL/TLS protocol versions to enable."},
{"description": "This class is for various network permissions.An SSLPermission contains a name (also referred to as a \"target name\") but no actions list; you either have the named permission or you don't.The target name is the name of the network permission (see below).The naming convention follows the hierarchical property naming convention.Also, an asterisk may appear at the end of the name, following a \".*\" and \"*\" signify a wildcard match, while \"*foo\" and \"a*b\" do not.The following table lists all the possible SSLPermission target names, and for each provides a description of what the permission allows and a discussion of the risks of granting code the permission.What the Permission Allows Risks of Allowing this Permission setHostnameVerifierThe ability to set a callback which can decide whether to allow a mismatch between the host being connected to by an HttpsURLConnection and the common name field in server certificate.Malicious code can set a verifier that monitors host names visited by HttpsURLConnection requests or that allows server certificates with invalid common names.Malicious code may monitor sessions which have been established with SSL peers or might invalidate sessions to slow down performance.The ability to set the default SSL context Malicious code can set a context that monitors the opening of connections or the plaintext data that is transmitted."},
{"description": "Indicates that the client and server could not negotiate the desired level of security."},
{"description": "This class is the general class of exceptions produced by failed SSL-related operations."},
{"description": "The Status value does not reflect the state of a SSLEngine handshake currently in progress.The SSLEngineResult's HandshakeStatus should be consulted for that information."},
{"description": "This class defines the Service Provider Interface (SPI) for the SSLContext class.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular SSL context."},
{"description": "A class which enables secure communications using protocols such as the Secure Sockets Layer (SSL) or IETF RFC 2246The secure communications modes include: Integrity Protection.SSL/TLS protects against modification of messages by an active wiretapper.In most modes, SSL/TLS provides peer authentication.Servers are usually authenticated, and clients may be authenticated as requested by servers.In most modes, SSL/TLS encrypts data being sent between client and server.This protects the confidentiality of data, so that passive wiretappers won't see sensitive data such as financial information or personal information of many kinds.These kinds of protection are specified by a \"cipher suite\", which is a combination of cryptographic algorithms used by a given SSL connection.During the negotiation process, the two endpoints must agree on a cipher suite that is available in both environments.If there is no such suite in common, no SSL connection can be established, and no data can be exchanged.The cipher suite used is established by a negotiation process called \"handshaking\".The goal of this process is to create or rejoin a \"session\", which may protect many connections over time.After handshaking has completed, you can access session attributes by using the getSession() method.The SSLSocket class provides much of the same security functionality, but all of the inbound and outbound data is automatically transported using the underlying Socket, which by design uses a blocking model.While this is appropriate for many applications, this model does not provide the scalability required by large servers.The primary distinction of an SSLEngine is that it operates on inbound and outbound byte streams, independent of the transport mechanism.It is the responsibility of the SSLEngine user to arrange for reliable I/O transport to the peer.By separating the SSL/TLS abstraction from the I/O transport mechanism, the SSLEngine can be used for a wide variety of I/O types, such as non-blocking I/O (polling), selectable non-blocking I/O, Socket and the traditional Input/OutputStreams, local ByteBuffers or byte arrays, future asynchronous I/O models , and so on.At a high level, the SSLEngine appears thus: app data | ^ || | v || +----+-----|-----+----+ | | | | SSL|Engine | wrap()| OUTBOUND | INBOUND | | | | +----+-----|-----+----+ | | ^ | | | v | net data Application data (also known as plaintext or cleartext) is data which is produced or consumed by an application.Its counterpart is network data, which consists of either handshaking and/or ciphertext (encrypted) data, and destined to be transported via an I/O mechanism.Inbound data is data which has been received from the peer, and outbound data is destined for the peer.(In the context of an SSLEngine, the term \"handshake data\" is taken to mean any data exchanged to establish and control a secure connection.Handshake data includes the SSL/TLS messages \"alert\", \"change_cipher_spec,\" and \"handshake.\")There are five distinct phases to an SSLEngine.During this phase, an application may set any SSLEngine-specific settings (enabled cipher suites, whether the SSLEngine should handshake in client or server mode, and so on).Once handshaking has begun, though, any new settings (except client/server mode, see below) will be used for the next handshake.Initial Handshake - The initial handshake is a procedure by which the two peers exchange communication parameters until an SSLSession is established.Application data can not be sent during this phase.Once the communication parameters have been established and the handshake is complete, application data may flow through the SSLEngine.Outbound application messages are encrypted and integrity protected, and inbound messages reverse the process.Rehandshaking - Either side may request a renegotiation of the session at any time during the Application Data phase.New handshaking data can be intermixed among the application data.Before starting the rehandshake phase, the application may reset the SSL/TLS communication parameters such as the list of enabled ciphersuites and whether to use client authentication, but can not change between client/server modes.As before, once handshaking has begun, any new SSLEngine configuration settings will not be used until the next handshake.Closure - When the connection is no longer needed, the application should close the SSLEngine and should send/receive any remaining messages to the peer before closing the underlying transport mechanism.An SSLEngine is created by calling SSLContext.createSSLEngine() from an initialized SSLContext.These methods all trigger the initial handshake.Data moves through the engine by calling wrap() or unwrap() on outbound or inbound data, respectively.Depending on the state of the SSLEngine, a wrap() call may consume application data from the source buffer and may produce network data in the destination buffer.The outbound data may contain application and/or handshake data.A call to unwrap() will examine the source buffer and may advance the handshake if the data is handshaking information, or may place application data in the destination buffer if the data is application.The state of the underlying SSL/TLS algorithm will determine when data is consumed and produced.Calls to wrap() and unwrap() return an SSLEngineResult which indicates the status of the operation, and (optionally) how to interact with the engine to make progress.The SSLEngine produces/consumes complete SSL/TLS packets only, and does not store application data internally between calls to wrap()/unwrap().Thus input and output ByteBuffers must be sized appropriately to hold the maximum record that can be produced.Calls to SSLSession.getPacketBufferSize() and SSLSession.getApplicationBufferSize() should be used to determine the appropriate buffer sizes.The size of the outbound application data buffer generally does not matter.If buffer conditions do not allow for the proper consumption/production of data, the application must determine (via SSLEngineResult) and correct the problem, and then try the call again.For example, unwrap() will return a SSLEngineResult.BUFFER_OVERFLOW result if the engine determines that there is not enough destination buffer space available.Applications should call SSLSession.getApplicationBufferSize() and compare that value with the space available in the destination buffer, enlarging the buffer if necessary.BUFFER_UNDERFLOW, the application should call SSLSession.getPacketBufferSize() to ensure that the source buffer has enough room to hold a record (enlarging if necessary), and then obtain more inbound data.Could attempt to drain the dst buffer of any already obtained // data, but we'll just increase it to the size needed.break; BUFFER_UNDERFLOW: int netSize = engine.getSession().getPacketBufferSize(); // Resize buffer if needed.Unlike SSLSocket, all methods of SSLEngine are non-blocking.SSLEngine implementations may require the results of tasks that may take an extended period of time to complete, or may even block.For example, a TrustManager may need to connect to a remote certificate validation service, or a KeyManager might need to prompt a user to determine which certificate to use as part of client authentication.Additionally, creating cryptographic signatures and verifying them can be slow, seemingly blocking.For any operation which may potentially block, the SSLEngine will create a Runnable delegated task.When SSLEngineResult indicates that a delegated task result is needed, the application must call getDelegatedTask() to obtain an outstanding delegated task and call its run() method (possibly using a different thread depending on the compute strategy).The application should continue obtaining delegated tasks until no more exist, and try the original operation again.At the end of a communication session, applications should properly close the SSL/TLS link.The SSL/TLS protocols have closure handshake messages, and these messages should be communicated to the peer before releasing the SSLEngine and closing the underlying transport mechanism.A close can be initiated by one of: an SSLException, an inbound closure handshake message, or one of the close methods.In all cases, closure handshake messages are generated by the engine, and wrap() should be repeatedly called until the resulting SSLEngineResult's status returns \"CLOSED\", or isOutboundDone() returns true.All data obtained from the wrap() method should be sent to the peer.closeOutbound() is used to signal the engine that the application will not be sending any more data.A peer will signal its intent to close by sending its own closure handshake message.After this message has been received and processed by the local SSLEngine's unwrap() call, the application can detect the close by calling unwrap() and looking for a SSLEngineResult with status \"CLOSED\", or if isInboundDone() returns true.If for some reason the peer closes the communication link without sending the proper SSL/TLS closure message, the application can detect the end-of-stream and can signal the engine via closeInbound() that there will no more inbound messages to process.Some applications might choose to require orderly shutdown messages from a peer, in which case they can check that the closure was generated by a handshake message and not by an end-of-stream condition.There are two groups of cipher suites which you will need to know about when managing cipher suites:Supported cipher suites: all the suites which are supported by the SSL implementation.This list is reported using getSupportedCipherSuites().Enabled cipher suites, which may be fewer than the full set of supported suites.This group is set using the setEnabledCipherSuites(String []) method, and queried using the getEnabledCipherSuites() method.Initially, a default set of cipher suites will be enabled on a new engine that represents the minimum suggested configuration.Implementation defaults require that only cipher suites which authenticate servers and provide confidentiality be enabled by default.Only if both sides explicitly agree to unauthenticated and/or non-private (unencrypted) communications will such a cipher suite be selected.Each SSL/TLS connection must have one client and one server, thus each endpoint must decide which role to assume.This choice determines who begins the handshaking process as well as which type of messages should be sent by each party.The method setUseClientMode(boolean) configures the mode.Once the initial handshaking has started, an SSLEngine can not switch between client and server modes, even when performing renegotiations.Applications might choose to process delegated tasks in different threads.All future delegated tasks will be processed using this context: that is, all access control decisions will be made using the context captured at engine creation.There are two concurrency issues to be aware of: The wrap() and unwrap() methods may execute concurrently of each other.The SSL/TLS protocols employ ordered packets.Applications must take care to ensure that generated packets are delivered in sequence.If packets arrive out-of-order, unexpected or fatal results may occur.For example: synchronized (outboundLock) { sslEngine.wrap(src, dst); outboundQueue.put(dst); } As a corollary, two threads must not attempt to call the same method (either wrap() or unwrap()) concurrently, because there is no way to guarantee the eventual packet ordering."},
{"description": "A SSLEngine provides a means for establishing secure communication sessions between two peers.SSLEngine operations typically consume bytes from an input buffer and produce bytes in an output buffer.This class provides operational result values describing the state of the SSLEngine, including indications of what operations are needed to finish an ongoing handshake.Lastly, it reports the number of bytes consumed and produced as a result of this operation."},
{"description": "Instances of this class represent a secure socket protocol implementation which acts as a factory for secure socket factories or SSLEngines.This class is initialized with an optional set of key and trust managers and source of secure random bytes.Every implementation of the Java platform is required to support the following standard SSLContext protocol:This protocol is described in the SSLContext section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other algorithms are supported."},
{"description": "XML is a built-in type that stores an XML value as a column value in a row of a database table.An SQLXML object is valid for the duration of the transaction in which it was created.The SQLXML interface provides methods for accessing the XML value as a String, a Reader or Writer, or as a Stream.The XML value may also be accessed through a Source or set as a Result, which are used with XML Parser APIs such as DOM, SAX, and StAX, as well as with XSLT transforms and XPath evaluations.Methods in the interfaces ResultSet, CallableStatement, and PreparedStatement, such as getSQLXML allow a programmer to access an XML value.In addition, this interface has methods for updating an XML value.The XML value of the SQLXML instance may be obtained as a BinaryStream using SQLXML sqlxml = resultSet.getSQLXML(column);DocumentBuilderFactory.newInstance().newDocumentBuilder(); Document result = parser.parse(binaryStream); or to parse an XML value with a SAX parser to your handler:(); parser.parse(binaryStream, myHandler); or to parse an XML value with a StAX parser: XMLInputFactory factory = XMLInputFactory.newInstance(); XMLStreamReader streamReader = factory.createXMLStreamReader(binaryStream); Because databases may use an optimized representation for the XML, accessing the value through getSource() and setResult() can lead to improved processing performance without serializing to a stream representation and parsing the XML.; xslt.transform(source, result); or, to evaluate an XPath expression on the XML value:(); DOMSource domSource = sqlxml.getSource(DOMSource.class); Document document = (Document) domSource.getNode(); String expression = \"/foo/@bar\"; String barValue = xpath.evaluate(expression, document); To set the XML value to be the result of an XSLT transform: File sourceFile = new File(\"source.xml\"); Transformer xslt; xslt.transform(streamSource, result); Any Source can be transformed to a Result using the identity transform specified by calling newTransformer():Result result = new StreamResult(System.out); identity.transform(source, result); To create a DOMSource from a DOMResult: DOMSource domSource = new DOMSource(domResult.getNode()); Incomplete or invalid XML values may cause an SQLException when set or the exception may occur when execute() occurs.All streams must be closed before execute() occurs or an SQLException will be thrown.Reading and writing XML values to or from an SQLXML object can happen at most once.The conceptual states of readable and not readable determine if one of the reading APIs will return a value or throw an exception.The conceptual states of writable and not writable determine if one of the writing APIs will set a value or throw an exception.The state moves from readable to not readable once free() or any of the reading APIs are called: getBinaryStream(),Implementations may also change the state to not writable when this occurs.The state moves from writable to not writeable once free() or any of the writing APIs are called: setBinaryStream(), setCharacterStream(), setResult(), and setString().Implementations may also change the state to not readable when this occurs.All methods on the SQLXML interface must be fully implemented if the JDBC driver supports the data type."},
{"description": "An exception that provides information on database access warnings.Warnings are silently chained to the object whose method caused it to be reported.Warnings may be retrieved from Connection, Statement, and ResultSet objects.Trying to retrieve a warning on a connection after it has been closed will cause an exception to be thrown.Similarly, trying to retrieve a warning on a statement after it has been closed or on a result set after it has been closed will cause an exception to be thrown.Note that closing a statement also closes a result set that it might have produced."},
{"description": "An object that is used to identify a generic SQL type, called a JDBC type or a vendor specific data type."},
{"description": "The subclass of SQLException thrown when the timeout specified by Statement.setQueryTimeout, DriverManager.setLoginTimeout, DataSource.setLoginTimeout,XADataSource.setLoginTimeout has expired.This exception does not correspond to a standard SQLState."},
{"description": "The subclass of SQLException is thrown in situations where a previously failed operation might be able to succeed when the operation is retried without any intervention by application-level functionality."},
{"description": "The subclass of SQLException thrown when the SQLState class value is '40', or under vendor-specified conditions.This indicates that the current statement was automatically rolled back by the database because of deadlock or other transaction serialization failures.Please consult your driver vendor documentation for the vendor-specified conditions for which this Exception may be thrown."},
{"description": "This indicates that the connection operation that failed might be able to succeed if the operation is retried without any application-level changes.Please consult your driver vendor documentation for the vendor-specified conditions for which this Exception may be thrown."},
{"description": "The subclass of SQLException thrown in situations where a previously failed operation might be able to succeed if the application performs some recovery steps and retries the entire transaction or in the case of a distributed transaction, the transaction branch.At a minimum, the recovery operation must include closing the current connection and getting a new connection."},
{"description": "The driver uses this interface internally, and its methods are never directly invoked by an application programmer.When an application calls the method PreparedStatement.setObject, the driver checks to see whether the value to be written is a UDT with a custom mapping.If it is, there will be an entry in a type map containing the Class object for the class that implements SQLData for this UDT.If the value to be written is an instance of SQLData, the driver will create an instance of SQLOutputImpl and pass it to the method SQLData.writeSQL.The method writeSQL in turn calls the appropriate SQLOutputImpl.writeXXX methods to write data from the SQLData object to the SQLOutputImpl output stream as the representation of an SQL user-defined type."},
{"description": "The subclass of SQLException thrown when an instance where a retry of the same operation would fail unless the cause of the SQLException is corrected."},
{"description": "This indicates that the connection operation that failed will not succeed if the operation is retried without the cause of the failure being corrected.Please consult your driver vendor documentation for the vendor-specified conditions for which this Exception may be thrown."},
{"description": "The subclass of SQLException thrown when the SQLState class value is '28', or under vendor-specified conditions.This indicates that the authorization credentials presented during connection establishment are not valid.Please consult your driver vendor documentation for the vendor-specified conditions for which this Exception may be thrown."},
{"description": "The permission for which the SecurityManager will check when code that is running an application with a SecurityManager enabled, calls the DriverManager.deregisterDriver method, DriverManager.setLogWriter method, DriverManager.setLogStream (deprecated) method, SyncFactory.setJNDIContext method, SyncFactory.setLogger method, Connection.setNetworktimeout method, or the Connection.abort method.If there is no SQLPermission object, these methods throw a java.lang.SecurityException as a runtime exception.A SQLPermission object contains a name (also referred to as a \"target name\") but no actions list; there is either a named permission or there is not.The target name is the name of the permission (see below).The naming convention follows the hierarchical property naming convention.In addition, an asterisk may appear at the end of the name, following a \".\", or by itself, to signify a wildcard match.and * signify a wildcard match, while *loadLibrary and a*b do not.The following table lists all the possible SQLPermission target names.The table gives a description of what the permission allows and a discussion of the risks of granting code the permission.What the Permission Allows Risks of Allowing this Permission setLog Setting of the logging stream This is a dangerous permission to grant.The contents of the log may contain usernames and passwords, SQL statements, and SQL data.callAbort Allows the invocation of the Connection method abort Permits an application to terminate a physical connection to a database.setSyncFactory Allows the invocation of the SyncFactory methods setJNDIContext and setLogger Permits an application to specify the JNDI context from which the SyncProvider implementations can be retrieved from and the logging object to be used by the SyncProvider implementation.Allows the invocation of the Connection method setNetworkTimeout Permits an application to specify the maximum period a Connection or objects created from the Connection will wait for the database to reply to any one request.Allows the invocation of the DriverManager method deregisterDriver Permits an application to remove a JDBC driver from the list of registered Drivers and release its resources."},
{"description": "The subclass of SQLException thrown when the SQLState class value is '42', or under vendor-specified conditions.This indicates that the in-progress query has violated SQL syntax rules.Please consult your driver vendor documentation for the vendor-specified conditions for which this Exception may be thrown."},
{"description": "This interface, used only for custom mapping, is used by the driver, and its methods are never directly invoked by a programmer.When an object of a class implementing the interface SQLData is passed as an argument to an SQL statement, the JDBC driver calls the method SQLData.getSQLType to determine the kind of SQL datum being passed to the database.The driver then creates an instance of SQLOutput and passes it to the method SQLData.writeSQL.The method writeSQL in turn calls the appropriate SQLOutput writer methods writeBoolean, writeCharacterStream, and so on) to write data from the SQLData object to the SQLOutput output stream as the representation of an SQL user-defined type."},
{"description": "The subclass of SQLException thrown when the SQLState class value is '23', or under vendor-specified conditions.Please consult your driver vendor documentation for the vendor-specified conditions for which this Exception may be thrown."},
{"description": "An SQLInputImpl object is an input stream that contains a stream of values that are the attributes of a UDT.This class is used by the driver behind the scenes when the method getObject is called on an SQL structured or distinct type that has a custom mapping; a programmer never invokes SQLInputImpl methods directly.They are provided here as a convenience for those who write RowSet implementations.The SQLInputImpl class provides a set of reader methods analogous to the ResultSet getter methods.These methods make it possible to read the values in an SQLInputImpl object.The method wasNull is used to determine whether the the last value read was SQL NULL.When the method getObject is called with an object of a class implementing the interface SQLData, the JDBC driver calls the method SQLData.getSQLType to determine the SQL type of the UDT being custom mapped.The driver creates an instance of SQLInputImpl, populating it with the attributes of the UDT.The driver then passes the input stream to the method SQLData.readSQL, which in turn calls the SQLInputImpl reader methods to read the attributes from the input stream."},
{"description": "An input stream that contains a stream of values representing an instance of an SQL structured type or an SQL distinct type.This interface, used only for custom mapping, is used by the driver behind the scenes, and a programmer never directly invokes SQLInput methods.The reader methods (readLong, readBytes, and so on) provide a way for an implementation of the SQLData interface to read the values in an SQLInput object.And as described in SQLData, calls to reader methods must be made in the order that their corresponding attributes appear in the SQL definition of the type.The method wasNull is used to determine whether the last value read was SQL NULL.When the method getObject is called with an object of a class implementing the interface SQLData, the JDBC driver calls the method SQLData.getSQLType to determine the SQL type of the user-defined type (UDT) being custom mapped.The driver creates an instance of SQLInput, populating it with the attributes of the UDT.The driver then passes the input stream to the method SQLData.readSQL, which in turn calls the SQLInput reader methods in its implementation for reading the attributes from the input stream."},
{"description": "An exception that provides information on a database access error or other errors.Each SQLException provides several kinds of information: a string describing the error.This is used as the Java Exception message, available via the method getMesasge.a \"SQLstate\" string, which follows either the XOPEN SQLstate conventions or the SQL:2003 conventions.The values of the SQLState string are described in the appropriate spec.The DatabaseMetaData method getSQLStateType can be used to discover whether the driver returns the XOPEN type or the SQL:2003 type.an integer error code that is specific to each vendor.Normally this will be the actual error code returned by the underlying database.This can be used to provide additional error information."},
{"description": "The subclass of SQLException thrown when the SQLState class value is '0A'( the value is 'zero' A).This indicates that the JDBC driver does not support an optional JDBC feature.Optional JDBC features can fall into the fallowing categories:no support for an optional featureno support for an optional overloaded methodno support for an optional mode for a method."},
{"description": "The subclass of SQLException is thrown when one or more client info properties could not be set on a Connection.In addition to the information provided by SQLException, a SQLClientInfoException provides a list of client info properties that were not set.For those databases, it is possible that some of the client info properties had been set even though the Connection.setClientInfo method threw an exception.An application can use the getFailedProperties method to retrieve a list of client info properties that were not set.The properties are identified by passing a Map<String,ClientInfoStatus> to the appropriate SQLClientInfoException constructor."},
{"description": "The subclass of SQLException thrown when the SQLState class value is '22', or under vendor-specified conditions.This indicates various data errors, including but not limited to data conversion errors, division by 0, and invalid arguments to functions.Please consult your driver vendor documentation for the vendor-specified conditions for which this Exception may be thrown."},
{"description": "The class object for a class implementing the SQLData interface will be entered in the appropriate Connection object's type map along with the SQL name of the UDT for which it is a custom mapping.Typically, a SQLData implementation will define a field for each attribute of an SQL structured type or a single field for an SQL DISTINCT type.When the UDT is retrieved from a data source with the ResultSet.getObject method, it will be mapped as an instance of this class.A programmer can operate on this class instance just as on any other object in the Java programming language and then store any changes made to it by calling the PreparedStatement.setObject method, which will map it back to the SQL type.It is expected that the implementation of the class for a custom mapping will be done by a tool.In a typical implementation, the programmer would simply supply the name of the SQL UDT, the name of the class to which it is being mapped, and the names of the fields to which each of the attributes of the UDT is to be mapped.The tool will use this information to implement the SQLData.readSQL and SQLData.writeSQL methods.The readSQL method calls the appropriate SQLInput methods to read each attribute from an SQLInput object, and the writeSQL method calls SQLOutput methods to write each attribute back to the data source via an SQLOutput object.An application programmer will not normally call SQLData methods directly, and the SQLInput and SQLOutput methods are called internally by SQLData methods, not by application code."},
{"description": "A SpringLayout lays out the children of its associated container according to a set of constraints.Each constraint, represented by a Spring object, controls the vertical or horizontal distance between two component edges.The edges can belong to any child of the container, or to the container itself.For example, the allowable width of a component can be expressed using a constraint that controls the distance between the west (left) and east (right) edges of the component.The allowable y coordinates for a component can be expressed by constraining the distance between the north (top) edge of the component and the north edge of its container.Every child of a SpringLayout-controlled container, as well as the container itself, has exactly one set of constraints associated with it.These constraints are represented by a SpringLayout.By default, SpringLayout creates constraints that make their associated component have the minimum, preferred, and maximum sizes returned by the component's Component.getMinimumSize(), Component.getPreferredSize(), and Component.getMaximumSize() methods.The x and y positions are initially not constrained, so that until you constrain them the Component will be positioned at 0,0 relative to the Insets of the parent Container.You can change a component's constraints in several ways.You can use one of the putConstraint methods to establish a spring linking the edges of two components within the same container.Or you can get the appropriate SpringLayout.Constraints object using getConstraints and then modify one or more of its springs.Or you can get the spring for a particular edge of a component using getConstraint, and modify it.You can also associate your own SpringLayout.Constraints object with a component by specifying the constraints object when you add the component to its container (using Container.add(Component, Object)).The Spring object representing each constraint has a minimum, preferred, maximum, and current value.The current value of the spring is somewhere between the minimum and maximum values, according to the formula given in the Spring.sum(javax.swing.When the minimum, preferred, and maximum values are the same, the current value is always equal to them; this inflexible spring is called a strut.You can create struts using the factory method Spring.constant(int).The Spring class also provides factory methods for creating other kinds of springs, including springs that depend on other springs.In a SpringLayout, the position of each edge is dependent on the position of just one other edge.If a constraint is subsequently added to create a new binding for an edge, the previous binding is discarded and the edge remains dependent on a single edge.Springs should only be attached between edges of the container and its immediate children; the behavior of the SpringLayout when presented with constraints linking the edges of components from different containers (either internal or external) is undefined.SpringLayout vs. Other Layout Managers Note: Unlike many layout managers, SpringLayout doesn't automatically set the location of the components it manages.If you hand-code a GUI that uses SpringLayout, remember to initialize component locations by constraining the west/east and north/south locations.Depending on the constraints you use, you may also need to set the size of the container explicitly.Despite the simplicity of SpringLayout, it can emulate the behavior of most other layout managers.For some features, such as the line breaking provided by FlowLayout, you'll need to create a special-purpose subclass of the Spring class.SpringLayout also provides a way to solve many of the difficult layout problems that cannot be solved by nesting combinations of Boxes.That said, SpringLayout honors the LayoutManager2 contract correctly and so can be nested with other layout managers -- a technique that can be preferable to creating the constraints implied by the other layout managers.The asymptotic complexity of the layout operation of a SpringLayout is linear in the number of constraints (and/or components).Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A Constraints object holds the constraints that govern the way a component's size and position change in a container controlled by a SpringLayout.A Constraints object is like a Rectangle, in that it has x, y, width, and height properties.In the Constraints object, however, these properties have Spring values instead of integers.In addition, a Constraints object can be manipulated as four edges -- north, south, east, and west -- using the constraint property.The following formulas are always true for a Constraints object (here WEST and x are synonyms, as are and NORTH and y): EAST =* For example, if you have specified the WIDTH and WEST (X) location the EAST is calculated as WEST + WIDTH.If you instead specified the WIDTH and EAST locations the WEST(X) location is then calculated as EAST - WIDTH.[RELATIVE_BASELINE is a private constraint that is set automatically when the SpringLayout.constructor is called or when a constraints object is registered with a SpringLayout object.]Note: In this document, operators represent methods in the Spring class.For example, \"a + b\" is equal to Spring.sum(a, b), and \"a - b\" is equal to Spring.sum(a, Spring.minus(b)).Because a Constraints object's properties -- representing its edges, size, and location -- can all be set independently and yet are interrelated, a Constraints object can become over-constrained.For example, if the WEST, WIDTH and EAST edges are all set, steps must be taken to ensure that the first of the formulas above holds.To do this, the Constraints object throws away the least recently set constraint so as to make the formulas hold."},
{"description": "An instance of the Spring class holds three properties that characterize its behavior: the minimum, preferred, and maximum values.Each of these properties may be involved in defining its fourth, value, property based on a series of rules.An instance of the Spring class can be visualized as a mechanical spring that provides a corrective force as the spring is compressed or stretched away from its preferred value.This force is modelled as linear function of the distance from the preferred value, but with two different constants -- one for the compressional force and one for the tensional one.Those constants are specified by the minimum and maximum values of the spring such that a spring at its minimum value produces an equal and opposite force to that which is created when it is at its maximum value.The difference between the preferred and minimum values, therefore, represents the ease with which the spring can be compressed and the difference between its maximum and preferred values, indicates the ease with which the Spring can be extended.We define the \"+\", \"-\", max, and min operators on Springs so that, in each case, the result is a Spring whose characteristics bear a useful mathematical relationship to its constituent springs.A Spring can be treated as a pair of intervals with a single common point: the preferred value.The following rules define some of the arithmetic operators that can be applied to intervals ([a, b] refers to the interval from a to b, where a <= b).If we denote Springs as [a, b, c], where a <= b <=c, we can define the same arithmetic operators on Springs: [a1, b1, c1] + [a2, b2, c2] =With both intervals and Springs we can define \"-\" and min in terms of negation: X - Y =For the static methods in this class that embody the arithmetic operators, we do not actually perform the operation in question as that would snapshot the values of the properties of the method's arguments at the time the static method is called.Instead, the static methods create a new Spring instance containing references to the method's arguments so that the characteristics of the new spring track the potentially changing characteristics of the springs from which it was made.This is a little like the idea of a lazy value in a functional language.If you are implementing a SpringLayout you can find further information and examples in How to Use SpringLayout, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "To implement a spliterator an extending class need only implement Spliterator.The extending class should override Spliterator.LongConsumer) forEach} if it can provide a more performant implementation."},
{"description": "An abstract Spliterator that implements trySplit to permit limited parallelism.An extending class need only implement tryAdvance.The extending class should override forEach if it can provide a more performant implementation."},
{"description": "OfInt that implements trySplit to permit limited parallelism.To implement a spliterator an extending class need only implement Spliterator.The extending class should override Spliterator.IntConsumer) forEach} if it can provide a more performant implementation."},
{"description": "A Spliterator specialized for long values."},
{"description": "A generator of uniform pseudorandom values applicable for use in (among other contexts) isolated parallel computations that may generate subtasks.Class SplittableRandom supports methods for producing pseudorandom numbers of type int, long, and double with similar usages as for class Random but differs in the following ways: Series of generated values pass the DieHarder suite testing independence and uniformity properties of random number generators.These tests validate only the methods for certain types and ranges, but similar properties are expected to hold, at least approximately, for others as well.The period (length of any series of generated values before it repeats) is at least 264.Method split() constructs and returns a new SplittableRandom instance that shares no mutable state with the current instance.However, with very high probability, the values collectively generated by the two objects have the same statistical properties as if the same quantity of values were generated by a single thread using a single SplittableRandom object.Instances of SplittableRandom are not thread-safe.They are designed to be split, not shared, across threads.For example, a fork/join-style computation using random numbers might include a construction of the form new Subtask(aSplittableRandom.split()).fork().This class provides additional methods for generating random streams, that employ the above techniques when used in stream.parallel() mode.Instances of SplittableRandom are not cryptographically secure.Additionally, default-constructed instances do not use a cryptographically random seed unless the system property java.util.secureRandomSeed is set to true."},
{"description": "A Spliterator specialized for primitive values."},
{"description": "OfDouble that implements trySplit to permit limited parallelism.To implement a spliterator an extending class need only implement Spliterator.The extending class should override Spliterator.DoubleConsumer) forEach} if it can provide a more performant implementation."},
{"description": "A Spliterator specialized for double values."},
{"description": "The source of elements covered by a Spliterator could be, for example, an array, a Collection, an IO channel, or a generator function.A Spliterator may traverse elements individually (tryAdvance()) or sequentially in bulkA Spliterator may also partition off some of its elements (using trySplit()) as another Spliterator, to be used in possibly-parallel operations.Operations using a Spliterator that cannot split, or does so in a highly imbalanced or inefficient manner, are unlikely to benefit from parallelism.Traversal and splitting exhaust elements; each Spliterator is useful for only a single bulk computation.A Spliterator also reports a set of characteristics() of its structure, source, and elements from among ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, and SUBSIZED.These may be employed by Spliterator clients to control, specialize or simplify computation.For example, a Spliterator for a Collection would report SIZED, a Spliterator for a Set would report DISTINCT, and a Spliterator for a SortedSet would also report SORTED.Characteristics are reported as a simple unioned bit set.Some characteristics additionally constrain method behavior; for example if ORDERED, traversal methods must conform to their documented ordering.New characteristics may be defined in the future, so implementors should not assign meanings to unlisted values.A Spliterator that does not report IMMUTABLE or CONCURRENT is expected to have a documented policy concerning: when the spliterator binds to the element source; and detection of structural interference of the element source detected after binding.A late-binding Spliterator binds to the source of elements at the point of first traversal, first split, or first query for estimated size, rather than at the time the Spliterator is created.A Spliterator that is not late-binding binds to the source of elements at the point of construction or first invocation of any method.Modifications made to the source prior to binding are reflected when the Spliterator is traversed.After binding a Spliterator should, on a best-effort basis, throw ConcurrentModificationException if structural interference is detected.Spliterators that do this are called fail-fast.The bulk traversal method (forEachRemaining()) of a Spliterator may optimize traversal and check for structural interference after all elements have been traversed, rather than checking per-element and failing immediately.Spliterators can provide an estimate of the number of remaining elements via the estimateSize() method.Ideally, as reflected in characteristic SIZED, this value corresponds exactly to the number of elements that would be encountered in a successful traversal.However, even when not exactly known, an estimated value value may still be useful to operations being performed on the source, such as helping to determine whether it is preferable to split further or traverse the remaining elements sequentially.Despite their obvious utility in parallel algorithms, spliterators are not expected to be thread-safe; instead, implementations of parallel algorithms using spliterators should ensure that the spliterator is only used by one thread at a time.This is generally easy to attain via serial thread-confinement, which often is a natural consequence of typical parallel algorithms that work by recursive decomposition.A thread calling trySplit() may hand over the returned Spliterator to another thread, which in turn may traverse or further split that Spliterator.The behaviour of splitting and traversal is undefined if two or more threads operate concurrently on the same spliterator.If the original thread hands a spliterator off to another thread for processing, it is best if that handoff occurs before any elements are consumed with tryAdvance(), as certain guarantees (such as the accuracy of estimateSize() for SIZED spliterators) are only valid before traversal has begun.Primitive subtype specializations of Spliterator are provided for int, long, and double values.Such boxing may undermine any performance advantages gained by using the primitive specializations.To avoid boxing, the corresponding primitive-based methods should be used.IntConsumer) should be used in preference to Spliterator.Traversal of primitive values using boxing-based methods tryAdvance() and forEachRemaining() does not affect the order in which the values, transformed to boxed values, are encountered."},
{"description": "A Spliterator specialized for int values."},
{"description": "The splash screen can be displayed at application startup, before the Java Virtual Machine (JVM) starts.The splash screen is displayed as an undecorated window containing an image.You can use GIF, JPEG, or PNG files for the image.Animation is supported for the GIF format, while transparency is supported both for GIF and PNG.The window is positioned at the center of the screen.The position on multi-monitor systems is not specified.It is platform and implementation dependent.The splash screen window is closed automatically as soon as the first window is displayed by Swing/AWT (may be also closed manually using the Java API, see below).If your application is packaged in a jar file, you can use the \"SplashScreen-Image\" option in a manifest file to show a splash screen.The path should not have a leading slash.For example, in the manifest.mf file: Manifest-Version: 1.0 Main-Class: Test SplashScreen-Image: filename.gif If the Java implementation provides the command-line interface and you run your application by using the command line or a shortcut, use the Java application launcher option to show a splash screen.The Oracle reference implementation allows you to specify the splash screen image location with the -splash: option.The command line interface has higher precedence over the manifest setting.The splash screen will be displayed as faithfully as possible to present the whole splash screen image given the limitations of the target platform and display.It is implied that the specified image is presented on the screen \"as is\", i.e. preserving the exact color values as specified in the image file.Under certain circumstances, though, the presented image may differ, e.g. when applying color dithering to present a 32 bits per pixel (bpp) image on a 16 or 8 bpp screen.The native platform display configuration may also affect the colors of the displayed image (e.g. color profiles, etc.)The SplashScreen class provides the API for controlling the splash screen.This class may be used to close the splash screen, change the splash screen image, get the splash screen native window position/size, and paint in the splash screen.It cannot be used to create the splash screen.You should use the options provided by the Java implementation for that.Only a single instance of this class can exist, and it may be obtained by using the getSplashScreen() static method.In case the splash screen has not been created at application startup via the command line or manifest file option, the getSplashScreen method returns null."},
{"description": "The upper and lower bounds of the sequence are defined by properties called minimum and maximum.The size of the increase or decrease computed by the nextValue and previousValue methods is defined by a property called stepSize.The minimum and maximum properties can be null to indicate that the sequence has no lower or upper limit.All of the properties in this class are defined in terms of two generic types: Number and Comparable, so that all Java numeric types may be accommodated.Internally, there's only support for values whose type is one of the primitive Number types: Double, Float, Long, Integer, Short, or Byte.To create a SpinnerNumberModel for the integer range zero to one hundred, with fifty as the initial value, one could write: Integer value = new Integer(50); Integer min = new Integer(0); Integer max = new Integer(100); Integer step = new Integer(1); SpinnerNumberModel model =; int fifty = model.getNumber().intValue(); Spinners for integers and doubles are common, so special constructors for these cases are provided.For example to create the model in the previous example, one could also write: SpinnerNumberModel model =new SpinnerNumberModel(50, 0, 100, 1); This model inherits a ChangeListener."},
{"description": "Indicates whether the requested sort of search results was successful or not.When the result code indicates success then the results have been sorted as requested.Otherwise the sort was unsuccessful and additional details regarding the cause of the error may have been provided by the server.The code sample in SortControl shows how this class may be used.This class implements the LDAPv3 Response Control for server-side sorting as defined in RFC 2891.The control's value has the following ASN.1 definition:timelimit reached before -- sorting was completed strongAuthRequired (8), -- refused to return sorted -- results via insecure -- protocol adminLimitExceeded (11), -- too many matching entries -- for the server to sort noSuchAttribute (16), -- unrecognized attribute -- type in sort key inappropriateMatching (18), -- unrecognized or inappro- -- priate matching rule in -- sort key insufficientAccessRights (50), -- refused to return sorted -- results to this client busy (51), -- too busy to process unwillingToPerform (53), -- unable to sort other (80) }, attributeType [0] AttributeType OPTIONAL }"},
{"description": "SortOrder is an enumeration of the possible sort orderings."},
{"description": "This class implements a sort key which is used by the LDAPv3 Control for server-side sorting of search results as defined in RFC 2891."},
{"description": "A simple implementation of SpinnerModel whose values are defined by an array or a List.new SpinnerListModel(Arrays.asList(days).subList(1, 8)); This class only stores a reference to the array or List so if an element of the underlying sequence changes, it's up to the application to notify the ChangeListeners by calling fireStateChanged.This model inherits a ChangeListener."},
{"description": "This model is similar to ListModel however there are some important differences: The number of sequence elements isn't necessarily bounded.The model doesn't support indexed random access to sequence elements.Only three sequence values are accessible at a time: current, next and previous.A SpinnerModel has three properties, only the first is read/write.nextValue The following element or null if value is the last element of the sequence.The preceding element or null if value is the first element of the sequence.When the the value property changes, ChangeListeners are notified.SpinnerModel may choose to notify the ChangeListeners under other circumstances."},
{"description": "A FocusTraversalPolicy that determines traversal order by sorting the Components of a focus traversal cycle based on a given Comparator.Portions of the Component hierarchy that are not visible and displayable will not be included.By default, SortingFocusTraversalPolicy implicitly transfers focus down- cycle.That is, during normal focus traversal, the Component traversed after a focus cycle root will be the focus-cycle-root's default Component to focus.This behavior can be disabled using the setImplicitDownCycleTraversal method.By default, methods of this class with return a Component only if it is visible, displayable, enabled, and focusable.Subclasses can modify this behavior by overriding the accept method.This policy takes into account focus traversal policy providers.When searching for first/last/next/previous Component, if a focus traversal policy provider is encountered, its focus traversal policy is used to perform the search operation."},
{"description": "A Set that further provides a total ordering on its elements.The elements are ordered using their natural ordering, or by a Comparator typically provided at sorted set creation time.The set's iterator will traverse the set in ascending element order.Several additional operations are provided to take advantage of the ordering.(This interface is the set analogue of SortedMap.)All elements inserted into a sorted set must implement the Comparable interface (or be accepted by the specified comparator).Attempts to violate this restriction will cause the offending method or constructor invocation to throw a ClassCastException.Note that the ordering maintained by a sorted set (whether or not an explicit comparator is provided) must be consistent with equals if the sorted set is to correctly implement the Set interface.This is so because the Set interface is defined in terms of the equals operation, but a sorted set performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the sorted set, equal.The behavior of a sorted set is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Set interface.All general-purpose sorted set implementation classes should provide four \"standard\" constructors: 1)A void (no arguments) constructor, which creates an empty sorted set sorted according to the natural ordering of its elements.A constructor with a single argument of type Comparator, which creates an empty sorted set sorted according to the specified comparator.A constructor with a single argument of type Collection, which creates a new sorted set with the same elements as its argument, sorted according to the natural ordering of the elements.A constructor with a single argument of type SortedSet, which creates a new sorted set with the same elements and the same ordering as the input sorted set.There is no way to enforce this recommendation, as interfaces cannot contain constructors.Note: several methods return subsets with restricted ranges.Such ranges are half-open, that is, they include their low endpoint but not their high endpoint (where applicable).If you need a closed range (which includes both endpoints), and the element type allows for calculation of the successor of a given value, merely request the subrange from lowEndpoint to successor(highEndpoint).For example, suppose that s is a sorted set of strings.sub = s.subSet(low, high+\"\\0\"); A similar technique can be used to generate an open range (which contains neither endpoint).s.subSet(low+\"\\0\", high); This interface is a member of the Java Collections Framework."},
{"description": "A Map that further provides a total ordering on its keys.The map is ordered according to the natural ordering of its keys, or by a Comparator typically provided at sorted map creation time.This order is reflected when iterating over the sorted map's collection views (returned by the entrySet, keySet and values methods).Several additional operations are provided to take advantage of the ordering.(This interface is the map analogue of SortedSet.)All keys inserted into a sorted map must implement the Comparable interface (or be accepted by the specified comparator).Furthermore, all such keys must be mutually comparable: k1.compareTo(k2) (or comparator.compare(k1, k2)) must not throw a ClassCastException for any keys k1 and k2 in the sorted map.Attempts to violate this restriction will cause the offending method or constructor invocation to throw a ClassCastException.Note that the ordering maintained by a sorted map (whether or not an explicit comparator is provided) must be consistent with equals if the sorted map is to correctly implement the Map interface.This is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, from the standpoint of the sorted map, equal.The behavior of a tree map is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Map interface.All general-purpose sorted map implementation classes should provide four \"standard\" constructors.It is not possible to enforce this recommendation though as required constructors cannot be specified by interfaces.The expected \"standard\" constructors for all sorted map implementations are: A void (no arguments) constructor, which creates an empty sorted map sorted according to the natural ordering of its keys.A constructor with a single argument of type Comparator, which creates an empty sorted map sorted according to the specified comparator.A constructor with a single argument of type Map, which creates a new map with the same key-value mappings as its argument, sorted according to the keys' natural ordering.A constructor with a single argument of type SortedMap, which creates a new sorted map with the same key-value mappings and the same ordering as the input sorted map.Note: several methods return submaps with restricted key ranges.Such ranges are half-open, that is, they include their low endpoint but not their high endpoint (where applicable).If you need a closed range (which includes both endpoints), and the key type allows for calculation of the successor of a given key, merely request the subrange from lowEndpoint to successor(highEndpoint).For example, suppose that m is a map whose keys are strings.The following idiom obtains a view containing all of the key-value mappings in m whose keys are between low and high, inclusive:= m.subMap(low, high+\"\\0\"); A similar technique can be used to generate an open range (which contains neither endpoint).The following idiom obtains a view containing all of the key-value mappings in m whose keys are between low and high, exclusive:= m.subMap(low+\"\\0\", high); This interface is a member of the Java Collections Framework."},
{"description": "Requests that the results of a search operation be sorted by the LDAP server before being returned.The sort criteria are specified using an ordered list of one or more sort keys, with associated sort parameters.Search results are sorted at the LDAP server according to the parameters supplied in the sort control and then returned to the requestor.If sorting is not supported at the server (and the sort control is marked as critical)Handle the entry's response controls (if any) if (entry instanceof HasControls) {Close the LDAP association ctx.close(); ... This class implements the LDAPv3 Request Control for server-side sorting as defined in RFC 2891.The control's value has the following ASN.1 definition:"},
{"description": "Soft reference objects, which are cleared at the discretion of the garbage collector in response to memory demand.Soft references are most often used to implement memory-sensitive caches.Suppose that the garbage collector determines at a certain point in time that an object is softly reachable.At that time it may choose to clear atomically all soft references to that object and all soft references to any other softly-reachable objects from which that object is reachable through a chain of strong references.At the same time or at some later time it will enqueue those newly-cleared soft references that are registered with reference queues.All soft references to softly-reachable objects are guaranteed to have been cleared before the virtual machine throws an OutOfMemoryError.Otherwise no constraints are placed upon the time at which a soft reference will be cleared or the order in which a set of such references to different objects will be cleared.Virtual machine implementations are, however, encouraged to bias against clearing recently-created or recently-used soft references.Direct instances of this class may be used to implement simple caches; this class or derived subclasses may also be used in larger data structures to implement more sophisticated caches.As long as the referent of a soft reference is strongly reachable, that is, is actually in use, the soft reference will not be cleared.Thus a sophisticated cache can, for example, prevent its most recently used entries from being discarded by keeping strong referents to those entries, leaving the remaining entries to be discarded at the discretion of the garbage collector."},
{"description": "Signals that a timeout has occurred on a socket read or accept."},
{"description": "A class which implements a raised or lowered bevel with softened corners.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class represents access to a network via sockets.A SocketPermission consists of a host specification and a set of \"actions\" specifying ways to connect to that host.The host is specified as host =The host is expressed as a DNS name, as a numerical IP address, or as \"localhost\" (for the local machine).The wildcard \"*\" may be included once in a DNS name host specification.If it is included, it must be in the leftmost position, as in \"*.sun.com\".The format of the IPv6reference should follow that specified in RFC\u00a02732\"[\" IPv6address \"]\" For example, you can construct a SocketPermission instance as the following:(); if (inetaddress instanceof Inet6Address) { sp = new SocketPermission(\"[\" + hostAddress + \"]:\" + port, action); } else { sp = new SocketPermission(hostAddress + \":\" + port, action); } or String host = url.getHost(); sp = new SocketPermission(host + \":\" + port, action); The full uncompressed form of an IPv6 literal address is also valid.A port specification of the form \"N-\", where N is a port number, signifies all ports numbered N and above, while a specification of the form \"-N\" indicates all ports numbered N and below.The special port value 0 refers to the entire ephemeral port range.This is a fixed range of ports a system may use to allocate dynamic ports from.The possible ways to connect to the host are acceptThe \"listen\" action is only meaningful when used with \"localhost\" and means the ability to bind to a specified port.The \"resolve\" action is implied when any of the other actions are present.The action \"resolve\" refers to host/ip name service lookups.The actions string is converted to lowercase before processing.As an example of the creation and meaning of SocketPermissions, note that if the following permission: p1 = new SocketPermission(\"puffin.eng.sun.com:7777\", \"connect,accept\"); is granted to some code, it allows that code to connect to port 7777 on puffin.eng.sun.com, and to accept connections on that port.Similarly, if the following permission: p2 = new SocketPermission(\"localhost:1024-\", \"accept,connect,listen\"); is granted to some code, it allows that code to accept connections on, connect to, or listen on any port between 1024 and 65535 on the local host.Note: Granting code permission to accept or make connections to remote hosts may be dangerous because malevolent code can then more easily transfer and share confidential data among parties who may not otherwise have access to the data."},
{"description": "This interface is implemented by: SocketImpl and DatagramSocketImpl.Subclasses of these should override the methods of this interface in order to support their own options.The methods and constants which specify options in this interface are for implementation only.If you're not subclassing SocketImpl or DatagramSocketImpl, you won't use these directly.There are type-safe methods to get/set each of these options in Socket, ServerSocket, DatagramSocket and MulticastSocket."},
{"description": "This interface defines a factory for socket implementations.It is used by the classes Socket and ServerSocket to create actual socket implementations."},
{"description": "In the channels package, the NetworkChannel interface defines the setOption and getOption methods to set and query the channel's socket options."},
{"description": "Thrown to indicate that there is an error creating or accessing a Socket."},
{"description": "The abstract class SocketImpl is a common superclass of all classes that actually implement sockets.It is used to create both client and server sockets.A \"plain\" socket implements these methods exactly as described, without attempting to go through a firewall or proxy."},
{"description": "LogRecords are published to a network stream connection.By default the XMLFormatter class is used for formatting.By default each SocketHandler is initialized using the following LogManager configuration properties where <handler-name> refers to the fully-qualified class name of the handler.If properties are not defined (or have invalid values) then the specified default values are used.<handler-name>.filter specifies the name of a Filter class to use (defaults to no Filter).<handler-name>.encoding the name of the character set encoding to use (defaults to the default platform encoding).<handler-name>.host specifies the target host name to connect to (no default).For example, the properties for SocketHandler would be: java.util.logging.SocketHandler.level=INFO java.util.logging.SocketHandler.formatter=java.util.logging.SimpleFormatterFor a custom handler, e.g. com.foo.MyHandler, the properties would be: com.foo.MyHandler.level=INFO com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter"},
{"description": "This class creates sockets.It may be subclassed by other factories, which create particular subclasses of sockets and thus provide a general framework for the addition of public socket-level functionality.Socket factories are a simple way to capture a variety of policies related to the sockets being constructed, producing such sockets in a way which does not require special configuration of the code which asks for the sockets: Due to polymorphism of both factories and sockets, different kinds of sockets can be used by the same application code just by passing it different kinds of factories.Factories can themselves be customized with parameters used in socket construction.So for example, factories could be customized to return sockets with different networking timeouts or security parameters already configured.The sockets returned to the application can be subclasses of java.net.Socket, so that they can directly expose new APIs for features such as compression, security, record marking, statistics collection, or firewall tunneling.Factory classes are specified by environment-specific configuration mechanisms.For example, the getDefault method could return a factory that was appropriate for a particular user or applet, and a framework could use a factory customized to its own purposes."},
{"description": "A socket channel is created by invoking one of the open methods of this class.It is not possible to create a channel for an arbitrary, pre-existing socket.An attempt to invoke an I/O operation upon an unconnected channel will cause a NotYetConnectedException to be thrown.A socket channel can be connected by invoking its connect method; once connected, a socket channel remains connected until it is closed.Whether or not a socket channel is connected may be determined by invoking its isConnected method.Socket channels support non-blocking connection:\u00a0A socket channel may be created and the process of establishing the link to the remote socket may be initiated via the connect method for later completion by the finishConnect method.Whether or not a connection operation is in progress may be determined by invoking the isConnectionPending method.Socket channels support asynchronous shutdown, which is similar to the asynchronous close operation specified in the Channel class.If the input side of a socket is shut down by one thread while another thread is blocked in a read operation on the socket's channel, then the read operation in the blocked thread will complete without reading any bytes and will return -1.If the output side of a socket is shut down by one thread while another thread is blocked in a write operation on the socket's channel, then the blocked thread will receive an AsynchronousCloseException.Socket options are configured using the setOption method.Socket channels support the following options: Option Name Description SO_SNDBUFThe size of the socket send buffer SO_RCVBUFThe size of the socket receive bufferSO_KEEPALIVE Keep connectionSO_LINGER Linger on close if data is present (when configured in blocking mode only)Socket channels are safe for use by multiple concurrent threads.They support concurrent reading and writing, though at most one thread may be reading and at most one thread may be writing at any given time.The connect and finishConnect methods are mutually synchronized against each other, and an attempt to initiate a read or write operation while an invocation of one of these methods is in progress will block until that invocation is complete."},
{"description": "The interface SOAPMessageContext provides access to the SOAP message for either RPC request or response."},
{"description": "As transmitted on the \"wire\", a SOAP message is an XML document or a MIME message whose first body part is an XML/SOAP document.A SOAPMessage object consists of a SOAP part and optionally one or more attachment parts.The SOAP part for a SOAPMessage object is a SOAPPart object, which contains information used for message routing and identification, and which can contain application-specific content.All data in the SOAP Part of a message must be in XML format.A new SOAPMessage object contains the following by default: A SOAPPart object A SOAPEnvelope object A SOAPBody object A SOAPHeader objectThe SOAP part of a message can be retrieved by calling the method SOAPMessage.getSOAPPart().The SOAPEnvelope object is retrieved from the SOAPPart object, and the SOAPEnvelope object is used to retrieve the SOAPBody and SOAPHeader objects.; In addition to the mandatory SOAPPart object, a SOAPMessage object may contain zero or more AttachmentPart objects, each of which contains application-specific data.The SOAPMessage interface provides methods for creating AttachmentPart objects and also for adding them to a SOAPMessage object.A party that has received a SOAPMessage object can examine its contents by retrieving individual attachment parts.Unlike the rest of a SOAP message, an attachment is not required to be in XML format and can therefore be anything from simple text to an image file.Consequently, any message content that is not in XML format must be in an AttachmentPart object.A MessageFactory object may create SOAPMessage objects with behavior that is specialized to a particular implementation or application of SAAJ.For instance, a MessageFactory object may produce SOAPMessage objects that conform to a particular Profile such as ebXML.In this case a MessageFactory object might produce SOAPMessage objects that are initialized with ebXML headers.In order to ensure backward source compatibility, methods that are added to this class after version 1.1 of the SAAJ specification are all concrete instead of abstract and they all have default implementations.Unless otherwise noted in the JavaDocs for those methods the default implementations simply throw an UnsupportedOperationException and the SAAJ implementation code must override them with methods that provide the specified behavior.Legacy client code does not have this restriction, however, so long as there is no claim made that it conforms to some later version of the specification than it was originally written for.A legacy class that extends the SOAPMessage class can be compiled and/or run against succeeding versions of the SAAJ API without modification.If such a class was correctly implemented then it will continue to behave correctly relative to the version of the specification against which it was written."},
{"description": "This class represents a Socket Address with no protocol attachment.As an abstract class, it is meant to be subclassed with a specific, protocol dependent, implementation.It provides an immutable object used by sockets for binding, connecting, or as returned values."},
{"description": "All messages are required to have a SOAP part, so when a SOAPMessage object is created, it will automatically have a SOAPPart object.A SOAPPart object is a MIME part and has the MIME headers Content-Id, Content-Location, and Content-Type.Because the value of Content-Type must be \"text/xml\", a SOAPPart object automatically has a MIME header of Content-Type with its value set to \"text/xml\".The value must be \"text/xml\" because content in the SOAP part of a message must be in XML format.Content that is not of type\"text/xml\" must be in an AttachmentPart object rather than in the SOAPPart object.When a message is sent, its SOAP part must have the MIME header Content-Type set to \"text/xml\".Or, from the other perspective, the SOAP part of any message that is received must have the MIME header Content-Type with a value of \"text/xml\".A client can access the SOAPPart object of a SOAPMessage object by calling the method SOAPMessage.getSOAPPart.The following line of code, in which message is a SOAPMessage object, retrieves the SOAP part of a message.SOAPPart soapPart = message.getSOAPPart(); A SOAPPart object contains a SOAPEnvelope object, which in turn contains a SOAPBody object and a SOAPHeader object.The SOAPPart method getEnvelope can be used to retrieve the SOAPEnvelope object."},
{"description": "This class implements client sockets (also called just \"sockets\").A socket is an endpoint for communication between two machines.The actual work of the socket is performed by an instance of the SocketImpl class.An application, by changing the socket factory that creates the socket implementation, can configure itself to create sockets appropriate to the local firewall."},
{"description": "The immediate children of a SOAPHeader object can be represented only as SOAPHeaderElement objects.A SOAPHeaderElement object can have other SOAPElement objects as its children."},
{"description": "A SOAP header element consists of XML data that affects the way the application-specific content is processed by the message provider.For example, transaction semantics, authentication information, and so on, can be specified as the content of a SOAPHeader object.A SOAPEnvelope object contains an empty SOAPHeader object by default.If the SOAPHeader object, which is optional, is not needed, it can be retrieved and deleted with the following line of code.The variable se is a SOAPEnvelope object.se.getHeader().detachNode(); A SOAPHeader object is created with the SOAPEnvelope method addHeader.This method, which creates a new header and adds it to the envelope, may be called only after the existing header has been removed.se.getHeader().detachNode(); SOAPHeader sh = se.addHeader(); A SOAPHeader object can have only SOAPHeaderElement objects as its immediate children.The method addHeaderElement creates a new HeaderElement object and adds it to the SOAPHeader object.In the following line of code, the argument to the method addHeaderElement is a Name object that is the name for the new HeaderElement object."},
{"description": "The SOAPHandler class extends Handler to provide typesafety for the message context parameter and add a method to obtain access to the headers that may be processed by the handler."},
{"description": "An element in the SOAPBody object that contains error and/or status information.This information may relate to errors in the SOAPMessage object or to problems that are not related to the content in the message itself.Problems not related to the message itself are generally errors in processing, such as the inability to communicate with an upstream server.Depending on the protocol specified while creating the MessageFactory instance, a SOAPFault has sub-elements as defined in the SOAP 1.1/SOAP 1.2 specification."},
{"description": "The Detail interface is a SOAPFaultElement.Content is added to a SOAPFaultElement using the SOAPElement method addTextNode."},
{"description": "The SOAPFaultException exception represents a SOAP 1.1 or 1.2 fault.A SOAPFaultException wraps a SAAJ SOAPFault that manages the SOAP-specific representation of faults.The createFault method of javax.xml.soap.SOAPFactory may be used to create an instance of javax.xml.soap.SOAPFault for use with the constructor.SOAPBinding contains an accessor for the SOAPFactory used by the binding instance.Note that the value of getFault is the only part of the exception used when searializing a SOAP fault."},
{"description": "A SOAPException object may contain a String that gives the reason for the exception, an embedded Throwable object, or both.This class provides methods for retrieving reason messages and for retrieving the embedded Throwable object.Typical reasons for throwing a SOAPException object are problems such as difficulty setting a header, not being able to send a message, and not being able to get a connection with the provider.Reasons for embedding a Throwable object include problems such as input/output errors or a parsing problem, such as an error in parsing a header."},
{"description": "SOAPFactory is a factory for creating various objects that exist in the SOAP XML tree.SOAPFactory can be used to create XML fragments that will eventually end up in the SOAP part.These fragments can be inserted as children of the SOAPHeaderElement or SOAPBodyElement or SOAPEnvelope or other SOAPElement objects.SOAPFactory also has methods to create javax.xml.soap.Detail objects as well as java.xml.soap.Name objects."},
{"description": "By default, a SOAPMessage object is created with a SOAPPart object that has a SOAPEnvelope object.The SOAPEnvelope object by default has an empty SOAPBody object and an empty SOAPHeader object.The SOAPBody object is required, and the SOAPHeader object, though optional, is used in the majority of cases.A client can access the SOAPHeader and SOAPBody objects by calling the methods SOAPEnvelope.getHeaderThe following lines of code use these two methods after starting with the SOAPMessage object message to get the SOAPPart object sp, which is then used to get the SOAPEnvelope object se.; It is possible to change the body or header of a SOAPEnvelope object by retrieving the current one, deleting it, and then adding a new body or header.The javax.xml.soap.Node method deleteNode deletes the XML element (node) on which it is called.For example, the following line of code deletes the SOAPBody object that is retrieved by the method getBody.se.getBody().detachNode(); To create a SOAPHeader object to replace the one that was removed, a client uses the method SOAPEnvelope.addHeader, which creates a new header and adds it to the SOAPEnvelope object.Similarly, the method addBody creates a new SOAPBody object and adds it to the SOAPEnvelope object.The following code fragment retrieves the current header, removes it, and adds a new one.Then it retrieves the current body, removes it, and adds a new one.se.getHeader().detachNode(); SOAPHeader sh = se.addHeader(); se.getBody().detachNode(); SOAPBody sb = se.addBody(); It is an error to add a SOAPBody or SOAPHeader object if one already exists.The SOAPEnvelope interface provides three methods for creating Name objects.One method creates Name objects with a local name, a namespace prefix, and a namesapce URI.The second method creates Name objects with a local name and a namespace prefix, and the third creates Name objects with just a local name.The following line of code, in which se is a SOAPEnvelope object, creates a new Name object with all three."},
{"description": "An object representing an element of a SOAP message that is allowed but not specifically prescribed by a SOAP specification.This interface serves as the base interface for those objects that are specifically prescribed by a SOAP specification.Methods in this interface that are required to return SAAJ specific objects may \"silently\" replace nodes in the tree as required to successfully return objects of the correct type."},
{"description": "Implementation of this class is optional.If SOAPConnectionFactory.newInstance() throws an UnsupportedOperationException then the implementation does not support the SAAJ communication infrastructure.Otherwise SOAPConnection objects can be created by calling createConnection() on the newly created SOAPConnectionFactory object."},
{"description": "A point-to-point connection that a client can use for sending messages directly to a remote party (represented by a URL, for instance).Some implementations may not implement this interface in which case the call to SOAPConnectionFactory.newInstance()A client can obtain a SOAPConnection object using a SOAPConnectionFactory object as in the following example: SOAPConnectionFactory factory = SOAPConnectionFactory.newInstance(); SOAPConnection con = factory.createConnection(); A SOAPConnection object can be used to send messages directly to a URL following the request/response paradigm.That is, messages are sent using the method call, which sends the message and then waits until it gets a reply."},
{"description": "A SOAPBodyElement object represents the contents in a SOAPBody object.The SOAPFault interface is a SOAPBodyElement object that has been defined.A new SOAPBodyElement object can be created and added to a SOAPBody object with the SOAPBody method addBodyElement.In the following line of code, sb is a SOAPBody object, and myName is a Name object."},
{"description": "An object that represents the contents of the SOAP body element in a SOAP message.A SOAP body element consists of XML data that affects the way the application-specific content is processed.A SOAPBody object contains SOAPBodyElement objects, which have the content for the SOAP body.A SOAPFault object, which carries status and/or error information, is an example of a SOAPBodyElement object."},
{"description": "The SOAPBinding interface is an abstraction for the SOAP binding."},
{"description": "Instances of this class represent a server name of type host_name in a Server Name Indication (SNI) extension.As described in section 3, \"Server Name Indication\", of TLS Extensions (RFC 6066), \"HostName\" contains the fully qualified DNS hostname of the server, as understood by the client.The encoded server name value of a hostname is represented as a byte string using ASCII encoding without a trailing dot.This allows the support of Internationalized Domain Names (IDN) through the use of A-labels (the ASCII-Compatible Encoding (ACE) form of a valid string of Internationalized Domain Names for Applications (IDNA)) defined in RFC 5890."},
{"description": "Instances of this class represent a server name in a Server Name Indication (SNI) extension.The SNI extension is a feature that extends the SSL/TLS protocols to indicate what server name the client is attempting to connect to during handshaking.Subclasses should not provide methods that can change the state of an instance once it has been created."},
{"description": "Instances of this class represent a matcher that performs match operations on an SNIServerName instance.Servers can use Server Name Indication (SNI) information to decide if specific SSLSocket or SSLEngine instances should accept a connection.For example, when multiple \"virtual\" or \"name-based\" servers are hosted on a single underlying network address, the server application can use SNI information to determine whether this server is the exact server that the client wants to access.Instances of this class can be used by a server to verify the acceptable server names of a particular type, such as host names.Subclasses should not provide methods that can change the state of an instance once it has been created."},
{"description": "Skeletons are no longer required for remote method calls in the Java 2 platform v1.2 and greater."},
{"description": "A SizeSequence object efficiently maintains an ordered list of sizes and corresponding positions.One situation for which SizeSequence might be appropriate is in a component that displays multiple rows of unequal size.In this case, a single SizeSequence object could be used to track the heights and Y positions of all rows.Another example would be a multi-column component, such as a JTable, in which the column sizes are not all equal.The JTable might use a single SizeSequence object to store the widths and X positions of all the columns.The JTable could then use the SizeSequence object to find the column corresponding to a certain position.The JTable could update the SizeSequence object whenever one or more column sizes changed.The following figure shows the relationship between size and position data for a multi-column component.In the figure, the first index (0) corresponds to the first column, the second index (1) to the second column, and so on.The first column's position starts at 0, and the column occupies size0 pixels, where size0 is the value returned by getSize(0).Thus, the first column ends at size0 - 1.The second column then begins at the position size0 and occupies size1 (getSize(1)) pixels.Note that a SizeSequence object simply represents intervals along an axis.In our examples, the intervals represent height or width in pixels.However, any other unit of measure (for example, time in days) could be just as valid.Implementation Notes Normally when storing the size and position of entries, one would choose between storing the sizes or storing their positions instead.The two common operations that are needed during rendering are: getIndex(position) and setSize(index, size).Whichever choice of internal format is made one of these operations is costly when the number of entries becomes large.If sizes are stored, finding the index of the entry that encloses a particular position is linear in the number of entries.If positions are stored instead, setting the size of an entry at a particular index requires updating the positions of the affected entries, which is also a linear calculation.Like the above techniques this class holds an array of N integers internally but uses a hybrid encoding, which is halfway between the size-based and positional-based approaches.The result is a data structure that takes the same space to store the information but can perform most operations in Log(N) time instead of O(N), where N is the number of entries in the list.Two operations that remain O(N) in the number of entries are the insertEntries and removeEntries methods, both of which are implemented by converting the internal array to a set of integer sizes, copying it into the new array, and then reforming the hybrid representation in place."},
{"description": "All size and position calculation methods are class methods that take arrays of SizeRequirements as arguments.The SizeRequirements class supports two types of layout:tiled The components are placed end-to-end, starting either at coordinate 0 (the leftmost or topmost position) or at the coordinate representing the end of the allocated span (the rightmost or bottommost position).aligned The components are aligned as specified by each component's X or Y alignment value.Each SizeRequirements object contains information about either the width (and X alignment) or height (and Y alignment) of a single component or a group of components: minimum The smallest reasonable width/height of the component or component group, in pixels.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Skeletons are no longer required for remote method calls in the Java 2 platform v1.2 and greater."},
{"description": "Class Size2DSyntax is an abstract base class providing the common implementation of all attributes denoting a size in two dimensions.A two-dimensional size attribute's value consists of two items, the X dimension and the Y dimension.A two-dimensional size attribute may be constructed by supplying the two values and indicating the units in which the values are measured.Methods are provided to return a two-dimensional size attribute's values, indicating the units in which the values are to be returned.The two most common size units are inches (in) and millimeters (mm), and exported constants INCH and MM are provided for indicating those units.Design A two-dimensional size attribute's X and Y dimension values are stored internally as integers in units of micrometers (\u00b5m), where 1 micrometer = 10-6 meter =This permits dimensions to be represented exactly to a precision of 1/1000 mm (= 1 \u00b5m) or 1/100 inch (= 254 \u00b5m).If fractional inches are expressed in negative powers of two, this permits dimensions to be represented exactly to a precision of 1/8 inch (= 3175 \u00b5m) but not 1/16 inch (because 1/16 inch does not equal an integral number of \u00b5m).Storing the dimensions internally in common units of \u00b5m lets two size attributes be compared without regard to the units in which they were created; for example, 8.5 in will compare equal to 215.9 mm, as they both are stored as 215900 \u00b5m.For example, a lookup service can match resolution attributes based on equality of their serialized representations regardless of the units in which they were created.Using integers for internal storage allows precise equality comparisons to be done, which would not be guaranteed if an internal floating point representation were used.Note that if you're looking for U.S. letter sized media in metric units, you have to search for a media size of 215.9 x 279.4 mm; rounding off to an integral 216 x 279 mm will not match.The exported constant INCH is actually the conversion factor by which to multiply a value in inches to get the value in \u00b5m.Likewise, the exported constant MM is the conversion factor by which to multiply a value in mm to get the value in \u00b5m.A client can specify a resolution value in units other than inches or mm by supplying its own conversion factor.However, since the internal units of \u00b5m was chosen with supporting only the external units of inch and mm in mind, there is no guarantee that the conversion factor for the client's units will be an exact integer.If the conversion factor isn't an exact integer, resolution values in the client's units won't be stored precisely."},
{"description": "Skeletons are no longer required for remote method calls in the Java 2 platform v1.2 and greater."},
{"description": "A model that supports at most one indexed selection."},
{"description": "SimpleTimeZone is a concrete subclass of TimeZone that represents a time zone for use with a Gregorian calendar.The class holds an offset from GMT, called raw offset, and start and end rules for a daylight saving time schedule.Since it only holds single values for each, it cannot handle historical changes in the offset from GMT and the daylight saving schedule, except that the setStartYear method can specify the year when the daylight saving time schedule starts in effect.To construct a SimpleTimeZone with a daylight saving time schedule, the schedule can be described with a set of rules, start-rule and end-rule.A day when daylight saving time starts or ends is specified by a combination of month, day-of-month, and day-of-week values.The month value is represented by a Calendar MONTH field value, such as Calendar.The day-of-week value is represented by a Calendar DAY_OF_WEEK value, such as SUNDAY.The meanings of value combinations are as follows.To specify a day of week on or after an exact day of month, set the month to an exact month value, day-of-month to the day on or after which the rule is applied, and day-of-week to a negative DAY_OF_WEEK field value.For example, to specify the last Wednesday on or before the 21st of March, set month to MARCH, day-of-month is -21 and day-of-week is -WEDNESDAY.The time of the day at which daylight saving time starts or ends is specified by a millisecond value within the day.There are three kinds of modes to specify the time: WALL_TIME, STANDARD_TIME and UTC_TIME.For example, if daylight saving time ends at 2:00 am in the wall clock time, it can be specified by 7200000 milliseconds in the WALL_TIME mode.In this case, the wall clock time for an end-rule means the same thing as the daylight time.The following are examples of parameters for constructing time zone objects.DST starts: at 2:00am in standard time //DST ends: at 2:00am in daylight time //+1:00 // DST starts: at 1:00am in UTC time //DST ends: at 1:00am in UTC time //These parameter rules are also applicable to the set rule methods, such as setStartRule."},
{"description": "This class represents pixel data packed such that the N samples which make up a single pixel are stored in a single data array element, and each data data array element holds samples for only one pixel.This class supports TYPE_BYTE, TYPE_USHORT, TYPE_INT data types.All data array elements reside in the first bank of a DataBuffer.Scanline stride is the number of data array elements between a given sample and the corresponding sample in the same column of the next scanline.Bit masks are the masks required to extract the samples representing the bands of the pixel.Bit offsets are the offsets in bits into the data array element of the samples representing the bands of the pixel.The following code illustrates extracting the bits of the sample representing band b for pixel x,y from DataBuffer data: int sample ="},
{"description": "Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The TypeVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new simple type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The TypeVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new simple type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "For constructs introduced in RELEASE_7 and later, visitUnknown is called instead.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The TypeVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new simple type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "The SimpleType class is the open type class whose instances describe all open data values which are neither arrays, nor CompositeData values, nor TabularData values.It predefines all its possible instances as static fields, and has no public constructor.Given a SimpleType instance describing values whose Java class name is className, the internal fields corresponding to the name and description of this SimpleType instance are also set to className.In other words, its methods getClassName, getTypeName and getDescription all return the same string value className."},
{"description": "This class is designed to be subclassed and used as a basis for JavaFileObject implementations.Subclasses can override the implementation and specification of any method of this class as long as the general contract of JavaFileObject is obeyed."},
{"description": "Methods in this class may be overridden subject to their general contract."},
{"description": "The summary will typically be 1 or 2 lines.The SimpleFormatter is initialized with the format string specified in the java.util.logging.SimpleFormatter.format property to format the log messages.This property can be defined in the logging properties configuration file or as a system property.If this property is set in both the logging properties and system properties, the format string specified in the system property will be used."},
{"description": "For constructs introduced in RELEASE_7 and later, visitUnknown is called instead.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The ElementVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new simple element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The ElementVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new simple element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The ElementVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new simple element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "This exception is thrown when a method produces a result that exceeds a size-related limit.This can happen, for example, if the result contains more objects than the user requested, or when the size of the result exceeds some implementation-specific limit.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Visit methods call defaultAction(java.lang.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The AnnotationValueVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new simple annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "This is a support class to make it easier for people to provide BeanInfo classes.It defaults to providing \"noop\" information, and can be selectively overriden to provide more explicit information on chosen topics.When the introspector sees the \"noop\" values, it will apply low level introspection and design patterns to automatically analyze the target bean."},
{"description": "Visit methods call defaultAction passing their arguments to defaultAction's corresponding parameters.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The AnnotationValueVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new simple annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "Visit methods call defaultAction passing their arguments to defaultAction's corresponding parameters.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The AnnotationValueVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new simple annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "SimpleDateFormat is a concrete class for formatting and parsing dates in a locale-sensitive manner.It allows for formatting (date \u2192 text), parsing (text \u2192 date), and normalization.SimpleDateFormat allows you to start by choosing any user-defined patterns for date-time formatting.However, you are encouraged to create a date-time formatter with either getTimeInstance, getDateInstance, or getDateTimeInstance in DateFormat.Each of these class methods can return a date/time formatter initialized with a default format pattern.You may modify the format pattern using the applyPattern methods as desired.Date and Time Patterns Date and time formats are specified by date and time pattern strings.Within date and time pattern strings, unquoted letters from 'A' to 'Z' and from 'a' to 'z' are interpreted as pattern letters representing the components of a date or time string.Text can be quoted using single quotes (') to avoid interpretation. \"''\" represents a single quote.All other characters are not interpreted; they're simply copied into the output string during formatting or matched against the input string during parsing.The following pattern letters are defined (all other characters from 'A' to 'Z' and from 'a' to 'z' are reserved): Letter Date or Time Component Presentation Examples; Jul; 07 w Week in year Number 27 W Week in month Number 2 D Day in year Number 189 d Day in month Number 10 F Day of week in month Number 2 E Day name in week Text Tuesday; Tue u Day number of week-08:00 Pattern letters are usually repeated, as their number determines the exact presentation:For formatting, if the number of pattern letters is 4 or more, the full form is used; otherwise a short or abbreviated form is used if available.For parsing, both forms are accepted, independent of the number of pattern letters.For formatting, the number of pattern letters is the minimum number of digits, and shorter numbers are zero-padded to this amount.For parsing, the number of pattern letters is ignored unless it's needed to separate two adjacent fields.Year: If the formatter's Calendar is the Gregorian calendar, the following rules are applied.For formatting, if the number of pattern letters is 2, the year is truncated to 2 digits; otherwise it is interpreted as a number.For parsing, if the number of pattern letters is more than 2, the year is interpreted literally, regardless of the number of digits.\" parses to Jan 11, 12 A.D. For parsing with the abbreviated year pattern (\"y\" or \"yy\"), SimpleDateFormat must interpret the abbreviated year relative to some century.It does this by adjusting dates to be within 80 years before and 20 years after the time the SimpleDateFormat instance is created.For example, using a pattern of \"MM/dd/yy\" and a SimpleDateFormat instance created on Jan 1, 1997, the string \"01/11/12\" would be interpreted as Jan 11, 2012 while the string \"05/04/64\" would be interpreted as May 4, 1964.During parsing, only strings consisting of exactly two digits, as defined by Character.isDigit(char), will be parsed into the default century.Any other numeric string, such as a one digit string, a three or more digit string, or a two digit string that isn't all digits (for example, \"-1\"), is interpreted literally.So \"01/02/3\" or \"01/02/003\" are parsed, using the same pattern, as Jan 2, 3 AD.For both formatting and parsing, if the number of pattern letters is 4 or more, a calendar specific long form is used.If week year 'Y' is specified and the calendar doesn't support any week years, the calendar year ('y') is used instead.The support of week years can be tested with a call to getCalendar().isWeekDateSupported().Month: If the number of pattern letters is 3 or more, the month is interpreted as text; otherwise, it is interpreted as a number.Letter M produces context-sensitive month names, such as the embedded form of names.If a DateFormatSymbols has been set explicitly with constructor SimpleDateFormat(String, DateFormatSymbols) or method setDateFormatSymbols(DateFormatSymbols), the month names given by the DateFormatSymbols are used.Letter L produces the standalone form of month names.General time zone: Time zones are interpreted as text if they have names.For time zones representing a GMT offset value, the following syntax is used: GMTOffsetTimeZone: GMT Sign Hours : Minutes Sign: one of + - Hours: Digit Digit Digit Minutes:one of 0 1 2 3 4 5 6 7 8 9 Hours must be between 0 and 23, and Minutes must be between 00 and 59.The format is locale independent and digits must be taken from the Basic Latin block of the Unicode standard.For parsing, RFC 822 time zones are also accepted.For formatting, the RFC 822 4-digit time zone format is used: RFC822TimeZone:Digit Digit TwoDigitHours must be between 00 and 23.Other definitions are as for general time zones.: The number of pattern letters designates the format for both formatting and parsing as followsMinutes Z Other definitions are as for general time zones or RFC 822 time zones.For formatting, if the offset value from GMT is 0, \"Z\" is produced.If the number of pattern letters is 1, any fraction of an hour is ignored.For example, if the pattern is \"X\" and the time zone is \"GMT+05:30\", \"+05\" is produced.For parsing, \"Z\" is parsed as the UTC time zone designator.If the number of pattern letters is 4 or more, IllegalArgumentException is thrown when constructing a SimpleDateFormat or applying a pattern.SimpleDateFormat also supports localized date and time pattern strings.In these strings, the pattern letters described above may be replaced with other, locale dependent, pattern letters.SimpleDateFormat does not deal with the localization of text other than the pattern letters; that's up to the client of the class.The following examples show how date and time patterns are interpreted in the U.S. locale.The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.:mm:ss z\" 2001.07.04 AD at 12:08:56 PDT \"EEE, MMM d, ''yy\" Wed, Jul 4, '01 \"h:mm a\" 12:08 PM \"It is recommended to create separate format instances for each thread.If multiple threads access a format concurrently, it must be synchronized externally."},
{"description": "This class is an implementation of interface Doc that can be used in many common printing requests.It can handle all of the presently defined \"pre-defined\" doc flavors defined as static variables in the DocFlavor class.In particular this class implements certain required semantics of the Doc specification as follows: constructs a stream for the service if requested and appropriate.ensures the same object is returned for each call on a method.ensures multiple threads can access the Doc performs some validation of that the data matches the doc flavor.Clients who want to re-use the doc object in other jobs, or need a MultiDoc will not want to use this class.If the print data is a stream, or a print job requests data as a stream, then SimpleDoc does not monitor if the service properly closes the stream after data transfer completion or job termination.Clients may prefer to use provide their own implementation of doc that adds a listener to monitor job completion and to validate that resources such as streams are freed (ie closed)."},
{"description": "The formatting engine allows the positive and negative signs of numbers to be controlled using this enum."},
{"description": "Its functionality has been replaced by java.security.KeyStore, the java.security.cert package, and java.security.Principal."},
{"description": "SignedObject is a class for the purpose of creating authentic runtime objects whose integrity cannot be compromised without being detected.More specifically, a SignedObject contains another Serializable object, the (to-be-)signed object and its signature.The signed object is a \"deep copy\" (in serialized form) of an original object.Once the copy is made, further manipulation of the original object has no side effect on the copy.The underlying signing algorithm is designated by the Signature object passed to the constructor and the verify method.A typical usage for signing is the following:Signature signingEngine = Signature.getInstance(algorithm, provider); SignedObject so = new SignedObject(myobject, signingKey, signingEngine); A typical usage for verification is the following (having received SignedObject so):Signature verificationEngine = Signature.getInstance(algorithm, provider); if (so.verify(publickey, verificationEngine)) try { Object myobj = so.getObject();First, there is no need to initialize the signing or verification engine, as it will be re-initialized inside the constructor and the verify method.Secondly, for verification to succeed, the specified public key must be the public key corresponding to the private key used to generate the SignedObject.More importantly, for flexibility reasons, the constructor and verify method allow for customized signature engines, which can implement signature algorithms that are not installed formally as part of a crypto provider.However, it is crucial that the programmer writing the verifier code be aware what Signature engine is being used, as its own implementation of the verify method is invoked to verify a signature.In other words, a malicious Signature may choose to always return true on verification in an attempt to bypass a security check.The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-256.The algorithm is specified using the same convention as that for signatures.The DSA algorithm using the SHA-256 message digest algorithm can be specified, for example, as \"SHA256withDSA\".In the case of RSA the signing algorithm could be specified as, for example, \"SHA256withRSA\".The algorithm name must be specified, as there is no default.The name of the Cryptography Package Provider is designated also by the Signature parameter to the constructor and the verify method.Each installation can be configured to use a particular provider as default.Potential applications of SignedObject include: It can be used internally to any Java runtime as an unforgeable authorization token -- one that can be passed around without the fear that the token can be maliciously modified without being detected.It can be used to sign and serialize data/object for storage outside the Java runtime (e.g., storing critical access control data on disk).Nested SignedObjects can be used to construct a logical sequence of signatures, resembling a chain of authorization and delegation."},
{"description": "The XML Schema Definition is defined as: <element name=\"SignedInfoA SignedInfo instance may be created by invoking one of the newSignedInfo methods of the XMLSignatureFactory class."},
{"description": "This class defines the Service Provider Interface (SPI) for the Signature class, which is used to provide the functionality of a digital signature algorithm.Digital signatures are used for authentication and integrity assurance of digital data..All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular signature algorithm."},
{"description": "The XML Schema Definition is defined as: <element name=\"SignaturePropertytype=\"ds:SignaturePropertyType\"/> <complexType name=\"SignaturePropertyType\" mixed=\"true\"> <choice maxOccurs=\"unbounded\"> <any namespace=\"##other\" processContents=\"lax\"/> <!> A SignatureProperty instance may be created by invoking the newSignatureProperty method of the XMLSignatureFactory class; for example: XMLSignatureFactory factory ="},
{"description": "The XML Schema Definition is defined as: <element name=\"SignatureProperties\"A SignatureProperties instance may be created by invoking the newSignatureProperties method of the XMLSignatureFactory class; for example: XMLSignatureFactory factory ="},
{"description": "The purpose of this interface is to group (and provide type safety for) all signature method parameter specifications.All signature method parameter specifications must implement this interface."},
{"description": "This class defines a lookup table object.The output of a lookup operation using an object of this class is interpreted as an unsigned short quantity.The lookup table contains short data arrays for one or more bands (or components) of an image, and it contains an offset which will be subtracted from the input values before indexing the arrays.This allows an array smaller than the native data size to be provided for a constrained input.If there is only one array in the lookup table, it will be applied to all bands."},
{"description": "Holder Files\".short that is used to store \"out\" and \"inout\" parameters in IDL operations.If an IDL operation signature has an IDL short as an \"out\" or \"inout\" parameter, the programmer must pass an instance of ShortHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myShortHolder is an instance of ShortHolder, the value stored in its value field can be accessed with myShortHolder.value."},
{"description": "This exception is thrown when an output buffer provided by the user is too short to hold the operation result."},
{"description": "The Short class wraps a value of primitive type short in an object.An object of type Short contains a single field whose type is short.In addition, this class provides several methods for converting a short to a String and a String to a short, as well as other constants and methods useful when dealing with a short."},
{"description": "The ShapeGraphicAttribute class is an implementation of GraphicAttribute that draws shapes in a TextLayout."},
{"description": "This class defines four categories of operations upon short buffers: Absolute and relative get and put methods that read and write single shorts; Relative bulk get methods that transfer contiguous sequences of shorts from this buffer into an array; and Relative bulk put methods that transfer contiguous sequences of shorts from a short array or some other short buffer into this buffer; and Methods for compacting, duplicating, and slicing a short buffer.Short buffers can be created either by allocation, which allocates space for the buffer's content, by wrapping an existing short array into a buffer, or by creating a view of an existing byte buffer.Like a byte buffer, a short buffer is either direct or non-direct.A short buffer created via the wrap methods of this class will be non-direct.A short buffer created as a view of a byte buffer will be direct if, and only if, the byte buffer itself is direct.Whether or not a short buffer is direct may be determined by invoking the isDirect method.Methods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked."},
{"description": "Class SheetCollate is a printing attribute class, an enumeration, that specifies whether or not the media sheets of each copy of each printed document in a job are to be in sequence, when multiple copies of the document are specified by the Copies attribute.When SheetCollate is COLLATED, each copy of each document is printed with the print-stream sheets in sequence.When SheetCollate is UNCOLLATED, each print-stream sheet is printed a number of times equal to the value of the Copies attribute in succession.For example, suppose a document produces two media sheets as output, Copies is 6, and SheetCollate is UNCOLLATED; in this case six copies of the first media sheet are printed followed by six copies of the second media sheet.Whether the effect of sheet collation is achieved by placing copies of a document in multiple output bins or in the same output bin with implementation defined document separation is implementation dependent.Also whether it is achieved by making multiple passes over the job or by using an output sorter is implementation dependent.If a printer does not support the SheetCollate attribute (meaning the client cannot specify any particular sheet collation), the printer must behave as though SheetCollate were always set to COLLATED.The MultipleDocumentHandling attribute describes the collation of entire documents, and the SheetCollate attribute describes the semantics of collating individual pages within a document.The effect of a SheetCollate attribute on a multidoc print job (a job with multiple documents) depends on whether all the docs have the same sheet collation specified or whether different docs have different sheet collations specified, and on the (perhaps defaulted) value of the MultipleDocumentHandling attribute.If all the docs have the same sheet collation specified, then the following combinations of SheetCollate and MultipleDocumentHandling are permitted, and the printer reports an error when the job is submitted if any other combination is specified: SheetCollateSINGLE_DOCUMENT -- All the input docs will be combined into one output document.Multiple copies of the output document will be produced with pages in collated order, i.e. pages 1, 2, 3, . .SINGLE_DOCUMENT_NEW_SHEET -- All the input docs will be combined into one output document, and the first impression of each input doc will always start on a new media sheet.Multiple copies of the output document will be produced with pages in collated order, i.e. pages 1, 2, 3, . .-- Each input doc will remain a separate output document.Multiple copies of each output document (call them A, B, . . .) will be produced with each document's pages in collated order, but the documents themselves in uncollated order, i.e. pages A1, A2, A3, . .Each input doc will remain a separate output document.Multiple copies of each output document (call them A, B, . . .) will be produced with each document's pages in collated order, with the documents themselves also in collated order, i.e. pages A1, A2, A3, . .SINGLE_DOCUMENT -- All the input docs will be combined into one output document.Multiple copies of the output document will be produced with pages in uncollated order, i.e. pages 1, 1, . .SINGLE_DOCUMENT_NEW_SHEET -- All the input docs will be combined into one output document, and the first impression of each input doc will always start on a new media sheet.Multiple copies of the output document will be produced with pages in uncollated order, i.e. pages 1, 1, . .MultipleDocumentHandling = SEPARATE_DOCUMENTS_UNCOLLATED_COPIES -- Each input doc will remain a separate output document.Multiple copies of each output document (call them A, B, . . .) will be produced with each document's pages in uncollated order, with the documents themselves also in uncollated order, i.e. pages A1, A1, . .If different docs have different sheet collations specified, then only one value of MultipleDocumentHandling is permitted, and the printer reports an error when the job is submitted if any other value is specified:MultipleDocumentHandling = SEPARATE_DOCUMENTS_UNCOLLATED_COPIES -- Each input doc will remain a separate output document.Multiple copies of each output document (call them A, B, . . .) will be produced with each document's pages in collated or uncollated order as the corresponding input doc's SheetCollate attribute specifies, and with the documents themselves in uncollated order.If document A had SheetCollate = UNCOLLATED and document B had SheetCollate =IPP Compatibility: SheetCollate is not an IPP attribute at present."},
{"description": "The Shape interface provides definitions for objects that represent some form of geometric shape.The Shape is described by a PathIterator object, which can express the outline of the Shape as well as a rule for determining how the outline divides the 2D plane into interior and exterior points.Each Shape object provides callbacks to get the bounding box of the geometry, determine whether points or rectangles lie partly or entirely within the interior of the Shape, and retrieve a PathIterator object that describes the trajectory path of the Shape outline.Definition of insideness: A point is considered to lie inside a Shape if and only if: it lies completely inside theShape boundary or it lies exactly on the Shape boundary and the space immediately adjacent to the point in the increasing X direction is entirely inside the boundary or it lies exactly on a horizontal boundary segment and the space immediately adjacent to the point in the increasing Y direction is inside the boundary.The contains and intersects methods consider the interior of a Shape to be the area it encloses as if it were filled.This means that these methods consider unclosed shapes to be implicitly closed for the purpose of determining if a shape contains or intersects a rectangle or if a shape contains a point."},
{"description": "Class Severity is a printing attribute class, an enumeration, that denotes the severity of a PrinterStateReason attribute.Instances of Severity do not appear in a Print Service's attribute set directly.Rather, a PrinterStateReasons attribute appears in the Print Service's attribute set.The PrinterStateReasons attribute contains zero, one, or more than one PrinterStateReason objects which pertain to the Print Service's status, and each PrinterStateReason object is associated with a Severity level of REPORT (least severe), WARNING, or ERROR (most severe).The printer adds a PrinterStateReason object to the Print Service's PrinterStateReasons attribute when the corresponding condition becomes true of the printer, and the printer removes the PrinterStateReason object again when the corresponding condition becomes false, regardless of whether the Print Service's overall PrinterState also changed.IPP Compatibility: Severity.toString() returns either \"error\", \"warning\", or \"report\".The string values returned by each individual PrinterStateReason and associated Severity object's toString() methods, concatenated together with a hyphen (\"-\") in between, gives the IPP keyword value for a PrinterStateReasons.The category name returned by getName() gives the IPP attribute name."},
{"description": "A collection that contains no duplicate elements.More formally, sets contain no pair of elements e1 and e2As implied by its name, this interface models the mathematical set abstraction.The Set interface places additional stipulations, beyond those inherited from the Collection interface, on the contracts of all constructors and on the contracts of the add, equals and hashCode methods.Declarations for other inherited methods are also included here for convenience.(The specifications accompanying these declarations have been tailored to the Set interface, but they do not contain any additional stipulations.)The additional stipulation on constructors is, not surprisingly, that all constructors must create a set that contains no duplicate elements (as defined above).Note: Great care must be exercised if mutable objects are used as set elements.The behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set.A special case of this prohibition is that it is not permissible for a set to contain itself as an element.Some set implementations have restrictions on the elements that they may contain.For example, some implementations prohibit null elements, and some have restrictions on the types of their elements.Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException.Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter.More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the set may throw an exception or it may succeed, at the option of the implementation.Such exceptions are marked as \"optional\" in the specification for this interface.This interface is a member of the Java Collections Framework."},
{"description": "This exception is thrown when attempting to communicate with a directory or naming service and that service is not available.It might be unavailable for different reasons.For example, the server might be too busy to service the request, or the server might not be registered to service any requests, etc.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "Services may optionally provide UIs which allow different styles of interaction in different roles.One role may be end-user browsing and setting of print options.Another role may be administering the print service.Although the Print Service API does not presently provide standardised support for administering a print service, monitoring of the print service is possible and a UI may provide for private update mechanisms.The basic design intent is to allow applications to lazily locate and initialize services only when needed without any API dependencies except in an environment in which they are used.Swing UIs are preferred as they provide a more consistent L&F and can support accessibility APIs."},
{"description": "This class is a collection of UI convenience methods which provide a graphical user dialog for browsing print services looked up through the Java Print Service API.The dialogs follow a standard pattern of acting as a continue/cancel optionfor a user as well as allowing the user to select the print service to useand specify choices such as paper size and number of copies.The dialogs are designed to work with pluggable print services though the public APIs of those print services.If a print service provides any vendor extensions these may be made accessible to the user through a vendor supplied tab panel Component.Such a vendor extension is encouraged to use Swing!The vendor extensions should return the settings as part of the AttributeSet.Applications which want to preserve the user settings should use those settings to specify the print job.Note that this class is not referenced by any other part of the Java Print Service and may not be included in profiles which cannot depend on the presence of the AWT packages."},
{"description": "The mapping of a CORBA enum tagging SET_OVERRIDE and ADD_OVERRIDE, which indicate whether policies should replace the existing policies of an Object or be added to them.CORBA.Policy[], org.omg.CORBA.SetOverrideType) takes either SetOverrideType.The method _set_policy_override creates a new Object initialized with the Policy objects supplied as the first argument.If the second argument is ADD_OVERRIDE, the new policies are added to those of the Object instance that is calling the _set_policy_override method.If SET_OVERRIDE is given instead, the existing policies are replaced with the given ones."},
{"description": "Class SetOfIntegerSyntax is an abstract base class providing the common implementation of all attributes whose value is a set of nonnegative integers.This includes attributes whose value is a single range of integers and attributes whose value is a set of ranges of integers.You can construct an instance of SetOfIntegerSyntax by giving it in \"string form.\"The string consists of zero or more comma-separated integer groups.Each integer group consists of either one integer, two integers separated by a hyphen (-), or two integers separated by a colon (:).Each integer consists of one or more decimal digits (0 through 9).Whitespace characters cannot appear within an integer but are otherwise ignored.You can also construct an instance of SetOfIntegerSyntax by giving it in \"array form.\" Array form consists of an array of zero or more integer groups where each integer group is a length-1 or length-2 array of ints; for example, int[0][], int[][]{{1}}, int[][]{{5,10}}, int[][]{{1,2},{4}}.In both string form and array form, each successive integer group gives a range of integers to be included in the set.The first integer in each group gives the lower bound of the range; the second integer in each group gives the upper bound of the range; if there is only one integer in the group, the upper bound is the same as the lower bound.If the upper bound is less than the lower bound, it denotes a null range (no values).If the upper bound is equal to the lower bound, it denotes a range consisting of a single value.If the upper bound is greater than the lower bound, it denotes a range consisting of more than one value.The ranges may appear in any order and are allowed to overlap.The union of all the ranges gives the set's contents.The SetOfIntegerSyntax object's value is actually stored in \"canonical array form.\" This is the same as array form, except there are no null ranges; the members of the set are represented in as few ranges as possible (i.e., overlapping ranges are coalesced); the ranges appear in ascending order; and each range is always represented as a length-two array of ints in the form {lower bound, upper bound}.An empty set is represented as a zero-length array.Class SetOfIntegerSyntax has operations to return the set's members in canonical array form, to test whether a given integer is a member of the set, and to iterate through the members of the set."},
{"description": "A service is a well-known set of interfaces and (usually abstract) classes.A service provider is a specific implementation of a service.The classes in a provider typically implement the interface or subclass the class defined by the service itself.Service providers are stored in one or more categories, each of which is defined by a class of interface (described by a Class object) that all of its members must implement.The set of categories may be changed dynamically.Only a single instance of a given leaf class (that is, the actual class returned by getClass(), as opposed to any inherited classes or interfaces) may be registered.That is, suppose that the com.mycompany.mypkg.GreenServiceProvider class implements the com.mycompany.mypkg.MyService interface.If a GreenServiceProvider instance is registered, it will be stored in the category defined by the MyService class.If a new instance of GreenServiceProvider is registered, it will replace the previous instance.In practice, service provider objects are usually singletons so this behavior is appropriate.To declare a service provider, a services subdirectory is placed within the META-INF directory that is present in every JAR file.This directory contains a file for each service provider interface that has one or more implementation classes present in the JAR file.For example, if the JAR file contained a class named com.mycompany.mypkg.MyServiceImpl which implements the javax.someapi.SomeService interface, the JAR file would contain a file named: META-INF/services/javax.someapi.Implementations of these interfaces should avoid complex dependencies on other classes and on native code.The usual pattern for more complex services is to register a lightweight proxy for the heavyweight service.An application may customize the contents of a registry as it sees fit, so long as it has the appropriate runtime permission."},
{"description": "Represents exceptions raised when a requested service is not supported."},
{"description": "A Holder class for a ServiceInformation object that is used to store \"out\" and \"inout\" parameters in IDL methods.If an IDL method signature has an IDL xxx as an \"out\" or \"inout\" parameter, the programmer must pass an instance of ServiceInformationHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myServiceInformationHolder is an instance of ServiceInformationHolder, the value stored in its value field can be accessed with myServiceInformationHolder.value."},
{"description": "This class is used to protect Kerberos services and the credentials necessary to access those services.There is a one to one mapping of a service principal and the credentials necessary to access the service.Therefore granting access to a service principal implicitly grants access to the credential necessary to establish a security context with the service principal.This applies regardless of whether the credentials are in a cache or acquired via an exchange with the KDC.The credential can be either a ticket granting ticket, a service ticket or a secret key from a key table.A ServicePermission contains a service principal name and a list of actions which specify the context the credential can be used within.The service principal name is the canonical name of the KerberosPrincipal supplying the service, that is the KerberosPrincipal represents a Kerberos service principal.This name is treated in a case sensitive manner.An asterisk may appear by itself, to signify any service principal.Granting this permission implies that the caller can use a cached credential (TGT, service ticket or secret key) within the context designated by the action.In the case of the TGT, granting this permission also implies that the TGT can be obtained by an Authentication Service exchange.The possible actions are: initiate - allow the caller to use the credential to initiate a security context with a service principal.accept - allow the caller to use the credential to accept security context as a particular principal.For example, to specify the permission to access to the TGT to initiate a security context the permission is constructed as follows: ServicePermission(\"krbtgt/EXAMPLE.COM@EXAMPLE.COM\", \"initiate\"); To obtain a service ticket to initiate a context with the \"host\" service the permission is constructed as follows: ServicePermission(\"host/foo.example.com@EXAMPLE.COM\", \"initiate\"); For a Kerberized server the action is \"accept\".For example, the permission necessary to access and use the secret key of the Kerberized \"host\" service (telnet and the likes) would be constructed as follows: ServicePermission(\"host/foo.example.com@EXAMPLE.COM\", \"accept\");"},
{"description": "Classes that implement this interface should be defined in order to make use of the getServiceProviders method of ServiceRegistry that takes a Filter."},
{"description": "Used to indicate whether a Provider implementation wishes to work with entire protocol messages or just with protocol message payloads."},
{"description": "An IDL struct in the CORBA module that stores information about a CORBA service available in the ORB implementation and is obtained from the ORB.get_service_information method."},
{"description": "A service id, represented as an int"},
{"description": "An object that represents an ORB service: its service_detail_type field contains the type of the ORB service, and its service_detail field contains a description of the ORB service."},
{"description": "Service delegates are used internally by Service objects to allow pluggability of JAX-WS implementations.Every Service object has its own delegate, created using the Provider.createServiceDelegate(java.net.A Service object delegates all of its instance methods to its delegate."},
{"description": "A service is a well-known set of interfaces and (usually abstract) classes.A service provider is a specific implementation of a service.The classes in a provider typically implement the interfaces and subclass the classes defined in the service itself.Service providers can be installed in an implementation of the Java platform in the form of extensions, that is, jar files placed into any of the usual extension directories.Providers can also be made available by adding them to the application's class path or by some other platform-specific means.For the purpose of loading, a service is represented by a single type, that is, a single interface or abstract class.A provider of a given service contains one or more concrete classes that extend this service type with data and code specific to the provider.The provider class is typically not the entire provider itself but rather a proxy which contains enough information to decide whether the provider is able to satisfy a particular request together with code that can create the actual provider on demand.The details of provider classes tend to be highly service-specific; no single class or interface could possibly unify them, so no such type is defined here.The only requirement enforced by this facility is that provider classes must have a zero-argument constructor so that they can be instantiated during loading.A service provider is identified by placing a provider-configuration file in the resource directory META-INF/services.The file's name is the fully-qualified binary name of the service's type.The file contains a list of fully-qualified binary names of concrete provider classes, one per line.Space and tab characters surrounding each name, as well as blank lines, are ignored.The comment character is '#' ('\\u0023', NUMBER SIGN); on each line all characters following the first comment character are ignored.The file must be encoded in UTF-8.If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates are ignored.The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself.The provider must be accessible from the same class loader that was initially queried to locate the configuration file; note that this is not necessarily the class loader from which the file was actually loaded.Providers are located and instantiated lazily, that is, on demand.A service loader maintains a cache of the providers that have been loaded so far.Each invocation of the iterator method returns an iterator that first yields all of the elements of the cache, in instantiation order, and then lazily locates and instantiates any remaining providers, adding each one to the cache in turn.The cache can be cleared via the reload method.Service loaders always execute in the security context of the caller.Trusted system code should typically invoke the methods in this class, and the methods of the iterators which they return, from within a privileged security context.Instances of this class are not safe for use by multiple concurrent threads.Unless otherwise specified, passing a null argument to any method in this class will cause a NullPointerException to be thrown.Example Suppose we have a service type com.example.CodecSet which is intended to represent sets of encoder/decoder pairs for some protocol.In this case it is an abstract class with two abstract methods: public abstract Encoder getEncoder(String encodingName); public abstract Decoder getDecoder(String encodingName); Each method returns an appropriate object or null if the provider does not support the given encoding.Typical providers support more than one encoding.If com.example.impl.StandardCodecs is an implementation of the CodecSet service then its jar file also contains a file named META-INF/services/com.example.CodecSet This file contains the single line: com.example.impl.StandardCodecs # Standard codecs The CodecSet class creates and saves a single service instance at initialization: private static ServiceLoader<CodecSet> codecSetLoader = ServiceLoader.load(CodecSet.class); To locate an encoder for a given encoding name it defines a static factory method which iterates through the known and available providers, returning only when it has located a suitable encoder or has run out of providers.public static Encoder getEncoder(String encodingName) { for (CodecSet cp : codecSetLoader)= cp.getEncoder(encodingName); if (enc != null) return enc; } return null; } A getDecoder method is defined similarly.If the class path of a class loader that is used for provider loading includes remote network URLs then those URLs will be dereferenced in the process of searching for provider-configuration files.This activity is normal, although it may cause puzzling entries to be created in web-server logs.A web server should return an HTTP 404 (Not Found) response when a requested resource does not exist.Sometimes, however, web servers are erroneously configured to return an HTTP 200 (OK) response along with a helpful HTML error page in such cases.This will cause a ServiceConfigurationError to be thrown when this class attempts to parse the HTML page as a provider-configuration file.The best solution to this problem is to fix the misconfigured web server to return the correct response code (HTTP 404) along with the HTML error page."},
{"description": "This class creates server sockets.It may be subclassed by other factories, which create particular types of server sockets.This provides a general framework for the addition of public socket-level functionality.It is the server side analogue of a socket factory, and similarly provides a way to capture a variety of policies related to the sockets being constructed.Like socket factories, server Socket factory instances have methods used to create sockets.There is also an environment specific default server socket factory; frameworks will often use their own customized factory."},
{"description": "Error thrown when something goes wrong while loading a service provider.This error will be thrown in the following situations: The format of a provider-configuration file violates the specification; An IOException occurs while reading a provider-configuration file; A concrete provider class named in a provider-configuration file cannot be found; A concrete provider class is not a subclass of the service class; A concrete provider class cannot be instantiated; or Some other kind of error occurs."},
{"description": "MESSAGE provides access to entire protocol message, PAYLOAD to protocol message payload only."},
{"description": "A server-socket channel is created by invoking the open method of this class.It is not possible to create a channel for an arbitrary, pre-existing ServerSocket.An attempt to invoke the accept method of an unbound server-socket channel will cause a NotYetBoundException to be thrown.A server-socket channel can be bound by invoking one of the bind methods defined by this class.Socket options are configured using the setOption method.Server-socket channels support the following options: Option Name Description SO_RCVBUFThe size of the socket receive buffer SO_REUSEADDR Re-use address Additional (implementation specific) options may also be supported.Server-socket channels are safe for use by multiple concurrent threads."},
{"description": "Service objects provide the client view of a Web service.Service acts as a factory of the following: Proxies for a target service endpoint.The ports available on a service can be enumerated using the getPorts method.Alternatively, you can pass a service endpoint interface to the unary getPort method and let the runtime select a compatible port.Handler chains for all the objects created by a Service can be set by means of a HandlerResolver.An Executor may be set on the service in order to gain better control over the threads used to dispatch asynchronous callbacks.For instance, thread pooling with certain parameters can be enabled by creating a ThreadPoolExecutor and registering it with the service."},
{"description": "A request Interceptor is designed to intercept the flow of a request/reply sequence through the ORB at specific points so that services can query the request information and manipulate the service contexts which are propagated between clients and servers.The primary use of request Interceptors is to enable ORB services to transfer context information between clients and servers.There are two types of request Interceptors: client-side and server-side."},
{"description": "A server socket waits for requests to come in over the network.It performs some operation based on that request, and then possibly returns a result to the requester.The actual work of the server socket is performed by an instance of the SocketImpl class.An application can change the socket factory that creates the socket implementation to configure itself to create sockets appropriate to the local firewall."},
{"description": "A request Interceptor is designed to intercept the flow of a request/reply sequence through the ORB at specific points so that services can query the request information and manipulate the service contexts which are propagated between clients and servers.The primary use of request Interceptors is to enable ORB services to transfer context information between clients and servers.There are two types of request Interceptors: client-side and server-side."},
{"description": "Request Information, accessible to server-side request interceptors.Some attributes and operations on ServerRequestInfo are not valid at all interception points.The following table shows the validity of each attribute or operation.If it is not valid, attempting to access it will result in a BAD_INV_ORDER being thrown with a standard minor code of 14. \u00a0 When ServerRequestInfo is passed to receive_request, there is an entry in the list for every argument, whether in, inout, or out.If the reply_status attribute is not LOCATION_FORWARD, accessing this attribute will throw BAD_INV_ORDER with a standard minor code of 14.If the servant locator caused a location forward, or thrown an exception, this attribute/operation may not be available in this interception point.NO_RESOURCES with a standard minor code of 1 will be thrown if it is not available.The operation is not available in this interception point because the necessary information requires access to the target object's servant, which may no longer be available to the ORB.For example, if the object's adapter is a POA that uses a ServantLocator, then the ORB invokes the interception point after it calls ServantLocator.postinvoke()."},
{"description": "Request Information, accessible to server-side request interceptors.Some attributes and operations on ServerRequestInfo are not valid at all interception points.The following table shows the validity of each attribute or operation.If it is not valid, attempting to access it will result in a BAD_INV_ORDER being thrown with a standard minor code of 14. \u00a0 When ServerRequestInfo is passed to receive_request, there is an entry in the list for every argument, whether in, inout, or out.If the reply_status attribute is not LOCATION_FORWARD, accessing this attribute will throw BAD_INV_ORDER with a standard minor code of 14.If the servant locator caused a location forward, or thrown an exception, this attribute/operation may not be available in this interception point.NO_RESOURCES with a standard minor code of 1 will be thrown if it is not available.The operation is not available in this interception point because the necessary information requires access to the target object's servant, which may no longer be available to the ORB.For example, if the object's adapter is a POA that uses a ServantLocator, then the ORB invokes the interception point after it calls ServantLocator.postinvoke()."},
{"description": "An object that captures the explicit state of a request for the Dynamic Skeleton Interface (DSI).This class, the cornerstone of the DSI, is analogous to the Request object in the DII.The ORB is responsible for creating this embodiment of a request, and delivering it to a Dynamic Implementation Routine (DIR).A dynamic servant (a DIR) is created by implementing the DynamicImplementation class, which has a single invoke method.This method accepts a ServerRequest object.The abstract class ServerRequest defines methods for accessing the method name, the arguments and the context of the request, as well as methods for setting the result of the request either as a return value or an exception.A subtlety with accessing the arguments of the request is that the DIR needs to provide type information about the expected arguments, since there is no compiled information about these.This information is provided through an NVList, which is a list of NamedValue objects.Each NamedValue object contains an Any object, which in turn has a TypeCode object representing the type of the argument.Similarly, type information needs to be provided for the response, for either the expected result or for an exception, so the methods result and except take an Any object as a parameter."},
{"description": "An ServerNotActiveException is an Exception thrown during a call to RemoteServer.getClientHost if the getClientHost method is called outside of servicing a remote method call."},
{"description": "A ServerCloneException is thrown if a remote exception occurs during the cloning of a UnicastRemoteObject.As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.The \"nested exception\" that may be provided at construction time and accessed via the public detail field is now known as the cause, and may be accessed via the Throwable.getCause() method, as well as the aforementioned \"legacy field.\"Invoking the method Throwable.initCause(Throwable) on an instance of ServerCloneException always throws IllegalStateException."},
{"description": "A ServerException is thrown as a result of a remote method invocation when a RemoteException is thrown while processing the invocation on the server, either while unmarshalling the arguments or executing the remote method itself.A ServerException instance contains the original RemoteException that occurred as its cause."},
{"description": "This policy specifies whether the created POA retains active servants in an Active Object Map."},
{"description": "This policy specifies whether the created POA retains active servants in an Active Object Map."},
{"description": "ServantRetentionPolicyValue can have the following values.RETAIN - to indicate that the POA will retain active servants in its Active Object Map.NON_RETAIN - to indicate Servants are not retained by the POA.If no ServantRetentionPolicy is specified at POA creation, the default is RETAIN."},
{"description": "This class is part of the local stub API, the purpose of which is to provide high performance calls for collocated clients and servers (i.e. clients and servers residing in the same Java VM).The local stub API is supported via three additional methods on ObjectImpl and Delegate.ORB vendors may subclass this class to return additional request state that may be required by their implementations."},
{"description": "A ServerError is thrown as a result of a remote method invocation when an Error is thrown while processing the invocation on the server, either while unmarshalling the arguments, executing the remote method itself, or marshalling the return value.A ServerError instance contains the original Error that occurred as its cause."},
{"description": "A servant manager supplies a POA with the ability to activate objects on demand when the POA receives a request targeted at an inactive object.A servant manager is registered with a POA as a callback object, to be invoked by the POA when necessary.ServantManagers can either be ServantActivators or ServantLocators.A ServantManager object must be local to the process containing the POA objects it is registered with."},
{"description": "When the POA has the NON_RETAIN policy it uses servant managers that are ServantLocators.Because the POA knows that the servant returned by this servant manager will be used only for a single request, it can supply extra information to the servant manager's operations and the servant manager's pair of operations may be able to cooperate to do something different than a ServantActivator.When the POA uses the ServantLocator interface, immediately after performing the operation invocation on the servant returned by preinvoke, the POA will invoke postinvoke on the servant manager, passing the ObjectId value and the Servant value as parameters (among others).This feature may be used to force every request for objects associated with a POA to be mediated by the servant manager."},
{"description": "When the POA has the NON_RETAIN policy it uses servant managers that are ServantLocators.Because the POA knows that the servant returned by this servant manager will be used only for a single request, it can supply extra information to the servant manager's operations and the servant manager's pair of operations may be able to cooperate to do something different than a ServantActivator.When the POA uses the ServantLocator interface, immediately after performing the operation invocation on the servant returned by preinvoke, the POA will invoke postinvoke on the servant manager, passing the ObjectId value and the Servant value as parameters (among others).This feature may be used to force every request for objects associated with a POA to be mediated by the servant manager."},
{"description": "A servant manager supplies a POA with the ability to activate objects on demand when the POA receives a request targeted at an inactive object.A servant manager is registered with a POA as a callback object, to be invoked by the POA when necessary.ServantManagers can either be ServantActivators or ServantLocators.A ServantManager object must be local to the process containing the POA objects it is registered with."},
{"description": "When the POA has the NON_RETAIN policy it uses servant managers that are ServantLocators.Because the POA knows that the servant returned by this servant manager will be used only for a single request, it can supply extra information to the servant manager's operations and the servant manager's pair of operations may be able to cooperate to do something different than a ServantActivator.When the POA uses the ServantLocator interface, immediately after performing the operation invocation on the servant returned by preinvoke, the POA will invoke postinvoke on the servant manager, passing the ObjectId value and the Servant value as parameters (among others).This feature may be used to force every request for objects associated with a POA to be mediated by the servant manager."},
{"description": "When the POA has the RETAIN policy it uses servant managers that are ServantActivators."},
{"description": "When the POA has the RETAIN policy it uses servant managers that are ServantActivators."},
{"description": "Each attribute that is not already serialized is mapped to a serialized form, and if an attribute is itself a structured type, each of its attributes that is not already serialized is mapped to a serialized form.In addition, the structured type is custom mapped to a class in the Java programming language if there is such a mapping, as are its attributes, if appropriate.The SerialStruct class provides a constructor for creating an instance from a Struct object, a method for retrieving the SQL type name of the SQL structured type in the database, and methods for retrieving its attribute values.A SerialStruct is not safe for use by multiple concurrent threads.If a SerialStruct is to be used by more than one thread then access to the SerialStruct should be controlled by appropriate synchronization."},
{"description": "In Java, the Servant type is mapped to the Java org.omg.PortableServer.Servant class.It serves as the base class for all POA servant implementations and provides a number of methods that may be invoked by the application programmer, as well as methods which are invoked by the POA itself and may be overridden by the user to control aspects of servant behavior."},
{"description": "When the POA has the RETAIN policy it uses servant managers that are ServantActivators."},
{"description": "This class is for Serializable permissions.A SerializablePermission contains a name (also referred to as a \"target name\") but no actions list; you either have the named permission or you don't.The target name is the name of the Serializable permission (see below).The following table lists all the possible SerializablePermission target names, and for each provides a description of what the permission allows and a discussion of the risks of granting code the permission.What the Permission Allows Risks of Allowing this Permission enableSubclassImplementation Subclass implementation of ObjectOutputStream or ObjectInputStream to override the default serialization or deserialization, respectively, of objectsCode can use this to serialize or deserialize classes in a purposefully malfeasant manner.For example, during serialization, malicious code can use this to purposefully store confidential private field data in a way easily accessible to attackers.Or, during deserialization it could, for example, deserialize a class with all its private fields zeroed out.This is dangerous because malicious code can replace the actual object with one which has incorrect or malignant data."},
{"description": "When the POA has the NON_RETAIN policy it uses servant managers that are ServantLocators.Because the POA knows that the servant returned by this servant manager will be used only for a single request, it can supply extra information to the servant manager's operations and the servant manager's pair of operations may be able to cooperate to do something different than a ServantActivator.When the POA uses the ServantLocator interface, immediately after performing the operation invocation on the servant returned by preinvoke, the POA will invoke postinvoke on the servant manager, passing the ObjectId value and the Servant value as parameters (among others).This feature may be used to force every request for objects associated with a POA to be mediated by the servant manager."},
{"description": "Serializability of a class is enabled by the class implementing the java.io.Serializable interface.Classes that do not implement this interface will not have any of their state serialized or deserialized.All subtypes of a serializable class are themselves serializable.The serialization interface has no methods or fields and serves only to identify the semantics of being serializable.To allow subtypes of non-serializable classes to be serialized, the subtype may assume responsibility for saving and restoring the state of the supertype's public, protected, and (if accessible) package fields.The subtype may assume this responsibility only if the class it extends has an accessible no-arg constructor to initialize the class's state.It is an error to declare a class Serializable if this is not the case.The error will be detected at runtime.During deserialization, the fields of non-serializable classes will be initialized using the public or protected no-arg constructor of the class.A no-arg constructor must be accessible to the subclass that is serializable.The fields of serializable subclasses will be restored from the stream.When traversing a graph, an object may be encountered that does not support the Serializable interface.In this case the NotSerializableException will be thrown and will identify the class of the non-serializable object.Classes that require special handling during the serialization and deserialization process must implement special methods with these exact signatures: private void writeObject(java.io.ObjectOutputStream out) throws IOException private void readObject(java.io.The writeObject method is responsible for writing the state of the object for its particular class so that the corresponding readObject method can restore it.The default mechanism for saving the Object's fields can be invoked by calling out.defaultWriteObject.The method does not need to concern itself with the state belonging to its superclasses or subclasses.State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput.The readObject method is responsible for reading from the stream and restoring the classes fields.It may call in.defaultReadObject to invoke the default mechanism for restoring the object's non-static and non-transient fields.The defaultReadObject method uses information in the stream to assign the fields of the object saved in the stream with the correspondingly named fields in the current object.This handles the case when the class has evolved to add new fields.The method does not need to concern itself with the state belonging to its superclasses or subclasses.State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput.The readObjectNoData method is responsible for initializing the state of the object for its particular class in the event that the serialization stream does not list the given class as a superclass of the object being deserialized.This may occur in cases where the receiving party uses a different version of the deserialized instance's class than the sending party, and the receiver's version extends classes that are not extended by the sender's version.This may also occur if the serialization stream has been tampered; hence, readObjectNoData is useful for initializing deserialized objects properly despite a \"hostile\" or incomplete source stream.Serializable classes that need to designate an alternative object to be used when writing an object to the stream should implement this special method with the exact signature: ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException; This writeReplace method is invoked by serialization if the method exists and it would be accessible from a method defined within the class of the object being serialized.Thus, the method can have private, protected and package-private access.Subclass access to this method follows java accessibility rules.Classes that need to designate a replacement when an instance of it is read from the stream should implement this special method with the exact signature.ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException; This readResolve method follows the same invocation rules and accessibility rules as writeReplace.The serialization runtime associates with each serializable class a version number, called a serialVersionUID, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization.If the receiver has loaded a class for the object that has a different serialVersionUID than that of the corresponding sender's class, then deserialization will result in an InvalidClassException.A serializable class can declare its own serialVersionUID explicitly by declaring a field named \"serialVersionUID\" that must be static, final, and of type long: ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L; If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the Java(TM)However, it is strongly recommended that all serializable classes explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected InvalidClassExceptions during deserialization.Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value.It is also strongly advised that explicit serialVersionUID declarations use the private modifier where possible, since such declarations apply only to the immediately declaring class--serialVersionUID fields are not useful as inherited members.Array classes cannot declare an explicit serialVersionUID, so they always have the default computed value, but the requirement for matching serialVersionUID values is waived for array classes."},
{"description": "A DATALINK value references a file outside of the underlying data source that the data source manages.RowSet implementations can use the method RowSet.getURL to retrieve a java.net.URL object, which can be used to manipulate the external data.A SerialDatalink is not safe for use by multiple concurrent threads.If a SerialDatalink is to be used by more than one thread then access to the SerialDatalink should be controlled by appropriate synchronization."},
{"description": "When the POA has the RETAIN policy it uses servant managers that are ServantActivators."},
{"description": "Assuming the Java object implements the Serializable interface, this class simply wraps the serialization process.If however, the serialization is not possible because the Java object is not immediately serializable, this class will attempt to serialize all non-static members to permit the object state to be serialized.Static or transient fields cannot be serialized; an attempt to serialize them will result in a SerialException object being thrown.Thread safety A SerialJavaObject is not safe for use by multiple concurrent threads.If a SerialJavaObject is to be used by more than one thread then access to the SerialJavaObject should be controlled by appropriate synchronization."},
{"description": "A serialized version of an Array object, which is the mapping in the Java programming language of an SQL ARRAY value.The SerialArray class provides a constructor for creating a SerialArray instance from an Array object, methods for getting the base type and the SQL name for the base type, and methods for copying all or part of a SerialArray object.In order for this class to function correctly, a connection to the data source must be available in order for the SQL Array object to be materialized (have all of its elements brought to the client server) if necessary.At this time, logical pointers to the data in the data source, such as locators, are not currently supported.A SerialArray is not safe for use by multiple concurrent threads.If a SerialArray is to be used by more than one thread then access to the SerialArray should be controlled by appropriate synchronization."},
{"description": "The SerialBlob class provides a constructor for creating an instance from a Blob object.Note that the Blob object should have brought the SQL BLOB value's data over to the client before a SerialBlob object is constructed from it.The data of an SQL BLOB value can be materialized on the client as an array of bytes (using the method Blob.getBytes) or as a stream of uninterpreted bytes (using the method Blob.getBinaryStream).SerialBlob methods make it possible to make a copy of a SerialBlob object as an array of bytes or as a stream.They also make it possible to locate a given pattern of bytes or a Blob object within a SerialBlob object and to update or truncate a Blob object.A SerialBlob is not safe for use by multiple concurrent threads.If a SerialBlob is to be used by more than one thread then access to the SerialBlob should be controlled by appropriate synchronization."},
{"description": "A serialized mapping of a Ref object, which is the mapping in the Java programming language of an SQL REF value.The SerialRef class provides a constructor for creating a SerialRef instance from a Ref object and provides methods for getting and setting the Ref object.A SerialRef is not safe for use by multiple concurrent threads.If a SerialRef is to be used by more than one thread then access to the SerialRef should be controlled by appropriate synchronization."},
{"description": "A selection key is created each time a channel is registered with a selector.A key remains valid until it is cancelled by invoking its cancel method, by closing its channel, or by closing its selector.Cancelling a key does not immediately remove it from its selector; it is instead added to the selector's cancelled-key set for removal during the next selection operation.The validity of a key may be tested by invoking its isValid method.A selection key contains two operation sets represented as integer values.Each bit of an operation set denotes a category of selectable operations that are supported by the key's channel.The interest set determines which operation categories will be tested for readiness the next timeone of the selector's selection methods is invoked.The interest set is initialized with the value given when the key is created; it may later be changed via the interestOps(int) method.The ready set identifies the operation categories for which the key's channel has been detected to be ready by the key's selector.The ready set is initialized to zero when the key is created; it may later be updated by the selector during a selection operation, but it cannot be updated directly.That a selection key's ready set indicates that its channel is ready for some operation categoryis a hint, but not a guarantee, that an operation in such a category may be performed by a thread without causing the thread to block.A ready set is most likely to be accurate immediately after the completion of a selection operation.It is likely to be made inaccurate by external events and by I/O operations that are invoked upon the corresponding channel.This class defines all known operation-set bits, but precisely which bits are supported by a given channel depends upon the type of the channel.Each subclass of SelectableChannel defines an validOps() method which returns a set identifying just those operations that are supported by the channel.An attempt to set or test an operation-set bit that is not supported by a key's channel will result in an appropriate run-time exception.It is often necessary to associate some application-specific data with a selection key, for example an object that represents the state of a higher-level protocol and handles readiness notifications in order to implement that protocol.Selection keys therefore support the attachment of a single arbitrary object to a key.An object can be attached via the attach method and then later retrieved via the attachment method.Selection keys are safe for use by multiple concurrent threads.The operations of reading and writing the interest set will, in general, be synchronized with certain operations of the selector.Exactly how this synchronization is performed is implementation-dependent: In a naive implementation, reading or writing the interest set may block indefinitely if a selection operation is already in progress; in a high-performance implementation, reading or writing the interest set may block briefly, if at all.In any case, a selection operation will always use the interest-set value that was current at the moment that the operation began."},
{"description": "A channel that can be multiplexed via a Selector.In order to be used with a selector, an instance of this class must first be registered via the register method.This method returns a new SelectionKey object that represents the channel's registration with the selector.Once registered with a selector, a channel remains registered until it is deregistered.This involves deallocating whatever resources were allocated to the channel by the selector.A channel cannot be deregistered directly; instead, the key representing its registration must be cancelled.Cancelling a key requests that the channel be deregistered during the selector's next selection operation.A key may be cancelled explicitly by invoking its cancel method.All of a channel's keys are cancelled implicitly when the channel is closed, whether by invoking its close method or by interrupting a thread blocked in an I/O operation upon the channel.If the selector itself is closed then the channel will be deregistered, and the key representing its registration will be invalidated, without further delay.A channel may be registered at most once with any particular selector.Whether or not a channel is registered with one or more selectors may be determined by invoking the isRegistered method.Selectable channels are safe for use by multiple concurrent threads.Blocking mode A selectable channel is either in blocking mode or in non-blocking mode.In blocking mode, every I/O operation invoked upon the channel will block until it completes.In non-blocking mode an I/O operation will never block and may transfer fewer bytes than were requested or possibly no bytes at all.The blocking mode of a selectable channel may be determined by invoking its isBlocking method.Newly-created selectable channels are always in blocking mode.Non-blocking mode is most useful in conjunction with selector-based multiplexing.A channel must be placed into non-blocking mode before being registered with a selector, and may not be returned to blocking mode until it has been deregistered."},
{"description": "A byte channel that maintains a current position and allows the position to be changed.A seekable byte channel is connected to an entity, typically a file, that contains a variable-length sequence of bytes that can be read and written.The channel also provides access to the current size of the entity to which the channel is connected.The size increases when bytes are written beyond its current size; the size decreases when it is truncated.The position and truncate methods which do not otherwise have a value to return are specified to return the channel upon which they are invoked.Implementations of this interface should specialize the return type so that method invocations on the implementation class can be chained."},
{"description": "This gives fast access to fragments of text without the overhead of copying around characters.This is effectively an unprotected String.The Segment implements the java.text.CharacterIterator interface to support use with the i18n support without copying text into a string."},
{"description": "This class is for security permissions.A SecurityPermission contains a name (also referred to as a \"target name\") but no actions list; you either have the named permission or you don't.The target name is the name of a security configuration parameter (see below).Currently the SecurityPermission object is used to guard access to the Policy, Security, Provider, Signer, and Identity objects.The following table lists all the possible SecurityPermission target names, and for each provides a description of what the permission allows and a discussion of the risks of granting code the permission.What the Permission Allows Risks of Allowing this Permission createAccessControlContext Creation of anThis allows someone to instantiate an AccessControlContext with a DomainCombiner.Extreme care must be taken when granting this permission.Malicious code could create a DomainCombiner that augments the set of permissions granted to code, and even grant the code AllPermission.This allows someone to retrieve an AccessControlContext's DomainCombiner.Since DomainCombiners may contain sensitive information, this could potentially lead to a privacy leak.This allows someone to query the policy via the getPermissions call, which discloses which permissions would be granted to a given CodeSource.While revealing the policy does not compromise the security of the system, it does provide malicious code with additional information which it may use to better aim an attack.It is wise not to divulge more information than necessary.Granting this permission is extremely dangerous, as malicious code may grant itself all the necessary permissions it needs to successfully mount an attack on the system.createPolicy.{policy type} Getting an instance of a Policy implementation from a provider Granting this permission enables code to obtain a Policy object.Malicious code may query the Policy object to determine what permissions have been granted to code other than itself.getProperty.{key} Retrieval of the security property with the specified key Depending on the particular key for which access has been granted, the code may have access to the list of security providers, as well as the location of the system-wide and user security policies.while revealing this information does not compromise the security of the system, it does provide malicious code with additional information which it may use to better aim an attack.setProperty.{key} Setting of the security property with the specified key This could include setting a security provider or defining the location of the system-wide security policy.Malicious code that has permission to set a new security provider may set a rogue provider that steals confidential information such as cryptographic private keys.In addition, malicious code with permission to set the location of the system-wide security policy may point it to a security policy that grants the attacker all the necessary permissions it requires to successfully mount an attack on the system.insertProvider Addition of a new provider This would allow somebody to introduce a possibly malicious provider (e.g., one that discloses the private keys passed to it) as the highest-priority provider.This would be possible because the Security object (which manages the installed providers) currently does not check the integrity or authenticity of a provider before attaching it.The \"insertProvider\" permission subsumes the \"insertProvider.{provider name}\" permission (see the section below for more information).This may change the behavior or disable execution of other parts of the program.If a provider subsequently requested by the program has been removed, execution may fail.Also, if the removed provider is not explicitly requested by the rest of the program, but it would normally be the provider chosen when a cryptography service is requested (due to its previous order in the list of providers), a different provider will be chosen instead, or no suitable provider will be found, thereby resulting in program failure.\"Clearing\" of a Provider so that it no longer contains the properties used to look up services implemented by the provider This disables the lookup of services implemented by the provider.This may thus change the behavior or disable execution of other parts of the program that would normally utilize the Provider, as described under the \"removeProvider.{provider name}\" permission.The provider properties each specify the name and location of a particular service implemented by the provider.By granting this permission, you let code replace the service specification with another one, thereby specifying a different implementation.This disables the lookup of services implemented by the provider.They are no longer accessible due to removal of the properties specifying their names and locations.This may change the behavior or disable execution of other parts of the program that would normally utilize the Provider, as described under the \"removeProvider.{provider name}\" permission.The following permissions have been superseded by newer permissions or are associated with classes that have been deprecated: Identity, IdentityScope, Signer.Use of them is discouraged.What the Permission Allows Risks of Allowing this PermissionUse of this permission is discouraged from further use because it is possible to circumvent the name restrictions by overriding the Provider.getName() method.Also, there is an equivalent level of risk associated with granting code permission to insert a provider with a specific name, or any name it chooses.Users should use the \"insertProvider\" permission instead.This would allow somebody to introduce a possibly malicious provider (e.g., one that discloses the private keys passed to it) as the highest-priority provider.This would be possible because the Security object (which manages the installed providers) currently does not check the integrity or authenticity of a provider before attaching it.Setting of the system identity scope This would allow an attacker to configure the system identity scope with certificates that should not be trusted, thereby granting applet or application code signed with those certificates privileges that would have been denied by the system's original identity scope.setIdentityPublicKey Setting of the public key for an Identity If the identity is marked as \"trusted\", this allows an attacker to introduce a different public key (e.g., its own) that is not trusted by the system's identity scope, thereby granting applet or application code signed with that public key privileges that would have been denied otherwise.This allows attackers to set the general description for an identity.This may trick applications into using a different identity than intended or may prevent applications from finding a particular identity.This allows attackers to set a certificate for an identity's public key.This is dangerous because it affects the trust relationship across the system.This public key suddenly becomes trusted to a wider audience than it otherwise would be.This allows attackers to remove a certificate for an identity's public key.This is dangerous because it affects the trust relationship across the system.printIdentity Viewing the name of a principal and optionally the scope in which it is used, and whether or not it is considered \"trusted\" in that scopeThe scope that is printed out may be a filename, in which case it may convey local system information.For example, here's a sample printout of an identity named \"carol\", who is marked not trusted in the user's identity database:It is very dangerous to allow access to a private key; private keys are supposed to be kept secret.Otherwise, code can use the private key to sign various files and claim the signature came from the Signer.This would allow an attacker to replace somebody else's (the \"target's\") keypair with a possibly weaker keypair (e.g., a keypair of a smaller keysize).This also would allow the attacker to listen in on encrypted communication between the target and its peers.The target's peers might wrap an encryption session key under the target's \"new\" public key, which would allow the attacker (who possesses the corresponding private key) to unwrap the session key and decipher the communication data encrypted under that session key."},
{"description": "The properties of this class represent the information that is present at the lambda factory site, including static metafactory arguments such as the identity of the primary functional interface method and the identity of the implementation method, as well as dynamic metafactory arguments such as values captured from the lexical scope at the time of lambda capture.Implementors of serializable lambdas, such as compilers or language runtime libraries, are expected to ensure that instances deserialize properly.One means to do so is to ensure that the writeReplace method returns an instance of SerializedLambda, rather than allowing default serialization to proceed.SerializedLambda has a readResolve method that looks for a (possibly private) static method called $deserializeLambda$(SerializedLambda) in the capturing class, invokes that with itself as the first argument, and returns the result.Lambda classes implementing $deserializeLambda$ are responsible for validating that the properties of the SerializedLambda are consistent with a lambda actually captured by that class."},
{"description": "The SerialClob class provides a constructor for creating an instance from a Clob object.Note that the Clob object should have brought the SQL CLOB value's data over to the client before a SerialClob object is constructed from it.The data of an SQL CLOB value can be materialized on the client as a stream of Unicode characters.SerialClob methods make it possible to get a substring from a SerialClob object or to locate the start of a pattern of characters.A SerialClob is not safe for use by multiple concurrent threads.If a SerialClob is to be used by more than one thread then access to the SerialClob should be controlled by appropriate synchronization."},
{"description": "This class centralizes all security properties and common security methods.One of its primary uses is to manage providers.The default values of security properties are read from an implementation-specific location, which is typically the properties file lib/security/java.security in the Java installation directory."},
{"description": "A DirectoryStream that defines operations on files that are located relative to an open directory.A SecureDirectoryStream is intended for use by sophisticated or security sensitive applications requiring to traverse file trees or otherwise operate on directories in a race-free manner.Race conditions can arise when a sequence of file operations cannot be carried out in isolation.Each of the file operations defined by this interface specify a relative path.All access to the file is relative to the open directory irrespective of if the directory is moved or replaced by an attacker while the directory is open.A SecureDirectoryStream may also be used as a virtual working directory.A SecureDirectoryStream requires corresponding support from the underlying operating system.Where an implementation supports this features then the DirectoryStream returned by the newDirectoryStream method will be a SecureDirectoryStream and must be cast to that type in order to invoke the methods defined by this interface.In the case of the default provider, and a security manager is set, then the permission checks are performed using the path obtained by resolving the given relative path against the original path of the directory (irrespective of if the directory is moved since it was opened)."},
{"description": "This class provides a cryptographically strong random number generator (RNG).A cryptographically strong random number minimally complies with the statistical random number generator tests specified in FIPS 140-2, Security Requirements for Cryptographic Modules, section 4.9.1.Additionally, SecureRandom must produce non-deterministic output.Therefore any seed material passed to a SecureRandom object must be unpredictable, and all SecureRandom output sequences must be cryptographically strong, as described in RFC 1750: Randomness Recommendations for Security.A caller obtains a SecureRandom instance via the no-argument constructor or one of the getInstance methods:(); Many SecureRandom implementations are in the form of a pseudo-random number generator (PRNG), which means they use a deterministic algorithm to produce a pseudo-random sequence from a true random seed.Other implementations may produce true random numbers, and yet others may use a combination of both techniques.Typical callers of SecureRandom invoke the following methods to retrieve random bytes: SecureRandom random = new SecureRandom(); byte bytes[] =new byte[20]; random.nextBytes(bytes); Callers may also invoke the generateSeed method to generate a given number of seed bytes (to seed other random number generators, for example): byte seed[] = random.generateSeed(20); Note: Depending on the implementation, the generateSeed and nextBytes methods may block as entropy is being gathered, for example, if they need to read from /dev/random on various Unix-like operating systems."},
{"description": "The security manager is a class that allows applications to implement a security policy.It allows an application to determine, before performing a possibly unsafe or sensitive operation, what the operation is and whether it is being attempted in a security context that allows the operation to be performed.The application can allow or disallow the operation.The SecurityManager class contains many methods with names that begin with the word check.These methods are called by various methods in the Java libraries before those methods perform certain potentially sensitive operations.The invocation of such a check method typically looks like this:{ security.checkXXX(argument, \u00a0.\u00a0.\u00a0.\u00a0); } The security manager is thereby given an opportunity to prevent completion of the operation by throwing an exception.A security manager routine simply returns if the operation is permitted, but throws a SecurityException if the operation is not permitted.The only exception to this convention is checkTopLevelWindow, which returns a boolean value.The current security manager is set by the setSecurityManager method in class System.The current security manager is obtained by the getSecurityManager method.The special method checkPermission(java.security.Permission) determines whether an access request indicated by a specified permission should be granted or denied.As of Java 2 SDK v1.2, the default implementation of each of the other check methods in SecurityManager is to call the SecurityManager checkPermission method to determine if the calling thread has permission to perform the requested operation.Note that the checkPermission method with just a single permission argument always performs security checks within the context of the currently executing thread.Sometimes a security check that should be made within a given context will actually need to be done from within a different context (for example, from within a worker thread).The getSecurityContext method and the checkPermission method that includes a context argument are provided for this situation.The getSecurityContext method returns a \"snapshot\" of the current calling context.(The default implementation returns an AccessControlContext object.)A sample call is the following:; The checkPermission method that takes a context object in addition to a permission makes access decisions based on that context, rather than on that of the current execution thread.Code within a different context can thus call that method, passing the permission and the previously-saved context object.A sample call, using the SecurityManager sm obtained as in the previous example, is the following: if (sm !=; Permissions fall into these categories: File, Socket, Net, Security, Runtime, Property, AWT, Reflect, and Serializable.The classes managing these various permission categories are java.io.FilePermission, java.net.SocketPermission, java.net.NetPermission, java.security.SecurityPermission, java.lang.RuntimePermission, java.util.PropertyPermission, java.awt.AWTPermission, java.lang.reflect.ReflectPermission, and java.io.SerializablePermission.All but the first two (FilePermission and SocketPermission) are subclasses of java.security.BasicPermission, which itself is an abstract subclass of the top-level class for permissions, which is java.security.Permission.BasicPermission defines the functionality needed for all permissions that contain a name that follows the hierarchical property naming convention (for example, \"exitVM\", \"setFactory\", \"queuePrintJob\", etc).An asterisk may appear at the end of the name, following a \".For example: \"a.*\" or \"*\" is valid, \"*a\" or \"a*b\" is not valid.FilePermission and SocketPermission are subclasses of the top-level class for permissions (java.security.Permission).Classes like these that have a more complicated name syntax than that used by BasicPermission subclass directly from Permission rather than from BasicPermission.For example, for a java.io.FilePermission object, the permission name is the path name of a file (or directory).Some of the permission classes have an \"actions\" list that tells the actions that are permitted for the object.For example, for a java.io.FilePermission object, the actions list (such as \"read, write\") specifies which actions are granted for the specified file (or for files in the specified directory).Other permission classes are for \"named\" permissions - ones that contain a name but no actions list; you either have the named permission or you don't.Note: There is also a java.security.AllPermission permission that implies all permissions.It exists to simplify the work of system administrators who might need to perform multiple tasks that require all (or numerous) permissions.This document includes, for example, a table listing the various SecurityManager check methods and the permission(s)the default implementation of each such method requires.It also contains a table of all the version 1.2 methods that require permissions, and for each such method tells which permission it requires."},
{"description": "This class defines the Service Provider Interface (SPI) for the SecureRandom class.All the abstract methods in this class must be implemented by each service provider who wishes to supply the implementation of a cryptographically strong pseudo-random number generator."},
{"description": "This class extends ClassLoader with additional support for defining classes with an associated code source and permissions which are retrieved by the system policy by default."},
{"description": "This class defines the Service Provider Interface (SPI) for the SecretKeyFactory class.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a secret-key factory for a particular algorithm.A provider should document all the key specifications supported by its secret key factory.For example, the DES secret-key factory supplied by the \"SunJCE\" provider supports DESKeySpec as a transparent representation of DES keys, and that provider's secret-key factory for Triple DES keys supports DESedeKeySpec as a transparent representation of Triple DES keys."},
{"description": "Objects that implement this interface are created with the EventQueue.createSecondaryLoop() method.The interface provides two methods, enter() and exit(), which can be used to start and stop the event loop.When the enter() method is called, the current thread is blocked until the loop is terminated by the exit() method.Also, a new event loop is started on the event dispatch thread, which may or may not be the current thread.The loop can be terminated on any thread by calling its exit() method.After the loop is terminated, the SecondaryLoop object can be reused to run a new nested event loop.A typical use case of applying this interface is AWT and Swing modal dialogs.When a modal dialog is shown on the event dispatch thread, it enters a new secondary loop.Later, when the dialog is hidden or disposed, it exits the loop, and the thread continues its execution.The following example illustrates a simple use case of secondary loops: SecondaryLoop loop; JButton jButton = new JButton(\"Button\"); jButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { Toolkit tk =Report an error } } }); class WorkerThread extends Thread { @Override public void run()"},
{"description": "This class represents an item in the NamingEnumeration returned as a result of the DirContext.search() methods.A SearchResult instance is not synchronized against concurrent multithreaded access.Multiple threads trying to access and modify a single SearchResult instance should lock the object."},
{"description": "The purpose of this interface is to group (and provide type safety for) all secret key interfaces.Provider implementations of this interface must overwrite the equals and hashCode methods inherited from Object, so that secret keys are compared based on their underlying key material and not based on reference.Implementations should override the default destroy and isDestroyed methods from the Destroyable interface to enable sensitive key information to be destroyed, cleared, or in the case where such information is immutable, unreferenced.Object) to prevent keys that have been destroyed from being serialized.Keys that implement this interface return the string RAW as their encoding format (see getFormat), and return the raw key bytes as the result of a getEncoded method call.(The getFormat and getEncoded methods are inherited from the Key parent interface.)"},
{"description": "This class specifies a secret key in a provider-independent fashion.It can be used to construct a SecretKey from a byte array, without having to go through a (provider-based)This class is only useful for raw secret keys that can be represented as a byte array and have no key parameters associated with them, e.g., DES or Triple DES keys."},
{"description": "This class enables a programmer to create an object and protect its confidentiality with a cryptographic algorithm.Given any Serializable object, one can create a SealedObject that encapsulates the original object, in serialized format (i.e., a \"deep copy\"), and seals (encrypts) its serialized contents, using a cryptographic algorithm such as AES, to protect its confidentiality.The encrypted content can later be decrypted (with the corresponding algorithm using the correct decryption key) and de-serialized, yielding the original object.Note that the Cipher object must be fully initialized with the correct algorithm, key, padding scheme, etc., before being applied to a SealedObject.The original object that was sealed can be recovered in two different ways: by using the getObject method that takes a Cipher object.This method requires a fully initialized Cipher object, initialized with the exact same algorithm, key, padding scheme, etc., that were used to seal the object.This approach has the advantage that the party who unseals the sealed object does not require knowledge of the decryption key.For example, after one party has initialized the cipher object with the required decryption key, it could hand over the cipher object to another party who then unseals the sealed object.by using one of the getObject methods that take a Key object.In this approach, the getObject method creates a cipher object for the appropriate decryption algorithm and initializes it with the given decryption key and the algorithm parameters (if any) that were stored in the sealed object.This approach has the advantage that the party who unseals the object does not need to keep track of the parameters (e.g., an IV) that were used to seal the object."},
{"description": "This class encapsulates factors that determine scope of search and what gets returned as a result of the search.A SearchControls instance is not synchronized against concurrent multithreaded access.Multiple threads trying to access and modify a single SearchControls instance should lock the object."},
{"description": "This class represents a factory for secret keys.Key factories are used to convert keys (opaque cryptographic keys of type Key) into key specifications (transparent representations of the underlying key material), and vice versa.Secret key factories operate only on secret (symmetric) keys.Key factories are bi-directional, i.e., they allow to build an opaque key object from a given key specification (key material), or to retrieve the underlying key material of a key object in a suitable format.Application developers should refer to their provider's documentation to find out which key specifications are supported by the generateSecret and getKeySpec methods.For example, the DES secret-key factory supplied by the \"SunJCE\" provider supports DESKeySpec as a transparent representation of DES keys, and that provider's secret-key factory for Triple DES keys supports DESedeKeySpec as a transparent representation of Triple DES keys.Every implementation of the Java platform is required to support the following standard SecretKeyFactory algorithms:These algorithms are described in the SecretKeyFactory section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other algorithms are supported."},
{"description": "This class represents the state of a horizontal or vertical scrollbar of a ScrollPane.Objects of this class are returned by ScrollPane methods."},
{"description": "JScrollPaneLayout is responsible for nine components: a viewport, two scrollbars, a row header, a column header, and four \"corner\" components.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A container class which implements automatic horizontal and/or vertical scrolling for a single child component.The display policy for the scrollbars can be set to: as needed:scrollbars created and shown only when needed by scrollpane always: scrollbars created and always shown by the scrollpane never: scrollbars never created or shown by the scrollpane The state of the horizontal and vertical scrollbars is represented by two ScrollPaneAdjustable objects (one for each dimension) which implement the Adjustable interface.The API provides methods to access those objects such that the attributes on the Adjustable object (such as unitIncrement, value, etc.) can be manipulated.Certain adjustable properties (minimum, maximum, blockIncrement, and visibleAmount) are set internally by the scrollpane in accordance with the geometry of the scrollpane and its child and these should not be set by programs using the scrollpane.If the scrollbar display policy is defined as \"never\", then the scrollpane can still be programmatically scrolled using the setScrollPosition() method and the scrollpane will move and clip the child's contents appropriately.This policy is useful if the program needs to create and manage its own adjustable controls.The placement of the scrollbars is controlled by platform-specific properties set by the user outside of the program.The initial size of this container is set to 100x100, but can be reset using setSize().Scrolling with the wheel on a wheel-equipped mouse is enabled by default.This can be disabled using setWheelScrollingEnabled.Wheel scrolling can be customized by setting the block and unit increment of the horizontal and vertical Adjustables.For information on how mouse wheel events are dispatched, see the class description forInsets are used to define any space used by scrollbars and any borders created by the scroll pane.getInsets() can be used to get the current value for the insets.If the value of scrollbarsAlwaysVisible is false, then the value of the insets will change dynamically depending on whether the scrollbars are currently visible or not."},
{"description": "The Scrollbar class embodies a scroll bar, a familiar user-interface object.A scroll bar provides a convenient means for allowing a user to select from a range of values.The following three vertical scroll bars could be used as slider controls to pick the red, green, and blue components of a color: Each scroll bar in this example could be created with code similar to the following:; Alternatively, a scroll bar can represent a range of values.For example, if a scroll bar is used for scrolling through text, the width of the \"bubble\" (also called the \"thumb\" or \"scroll box\") can be used to represent the amount of text that is visible.Here is an example of a scroll bar that represents a range: The value range represented by the bubble in this example is the visible amount.The horizontal scroll bar in this example could be created with code like the following: ranger = new Scrollbar(Scrollbar.; Note that the actual maximum value of the scroll bar is the maximum minus the visible amount.In the previous example, because the maximum is 300 and the visible amount is 60, the actual maximum value is 240.The range of the scrollbar track is 0 - 300.The left side of the bubble indicates the value of the scroll bar.Normally, the user changes the value of the scroll bar by making a gesture with the mouse.For example, the user can drag the scroll bar's bubble up and down, or click in the scroll bar's unit increment or block increment areas.Keyboard gestures can also be mapped to the scroll bar.Down keys are equivalent to clicking in the scroll bar's block increment and block decrement areas.When the user changes the value of the scroll bar, the scroll bar receives an instance of AdjustmentEvent.The scroll bar processes this event, passing it along to any registered listeners.Any object that wishes to be notified of changes to the scroll bar's value should implement AdjustmentListener, an interface defined in the package java.awt.event.Listeners can be added and removed dynamically by calling the methods addAdjustmentListener and removeAdjustmentListener.The AdjustmentEvent class defines five types of adjustment event, listed here:TRACK is sent out when the user drags the scroll bar's bubble.UNIT_INCREMENT is sent out when the user clicks in the left arrow of a horizontal scroll bar, or the top arrow of a vertical scroll bar, or makes the equivalent gesture from the keyboard.UNIT_DECREMENT is sent out when the user clicks in the right arrow of a horizontal scroll bar, or the bottom arrow of a vertical scroll bar, or makes the equivalent gesture from the keyboard.BLOCK_INCREMENT is sent out when the user clicks in the track, to the left of the bubble on a horizontal scroll bar, or above the bubble on a vertical scroll bar.By convention, the Page\u00a0Up key is equivalent, if the user is using a keyboard that defines a Page\u00a0Up key.BLOCK_DECREMENT is sent out when the user clicks in the track, to the right of the bubble on a horizontal scroll bar, or below the bubble on a vertical scroll bar.By convention, the Page\u00a0Down key is equivalent, if the user is using a keyboard that defines a Page\u00a0Down key.The JDK\u00a01.0 event system is supported for backwards compatibility, but its use with newer versions of the platform is discouraged.The five types of adjustment events introduced with JDK\u00a01.1 correspond to the five event types that are associated with scroll bars in previous platform versions.The following list gives the adjustment event type, and the corresponding JDK\u00a01.0 event type it replaces.TRACK replaces Event.UNIT_DECREMENT replaces Event.BLOCK_INCREMENT replaces Event.BLOCK_DECREMENT replaces Event.SCROLL_PAGE_DOWN Note: We recommend using a Scrollbar for value selection only.If you want to implement a scrollable component inside a container, we recommend you use a ScrollPane.If you use a Scrollbar for this purpose, you are likely to encounter issues with painting, key handling, sizing and positioning."},
{"description": "An interface that provides information to a scrolling container like JScrollPane.A complex component that's likely to be used as a viewing a JScrollPane viewport (or other scrolling container) should implement this interface."},
{"description": "ScriptEngineFactory is used to describe and instantiate ScriptEngines.Each class implementing ScriptEngine has a corresponding factory that exposes metadata describing the engine class.The ScriptEngineManager uses the service provider mechanism described in the Jar File Specification to obtain instances of all ScriptEngineFactories available in the current ClassLoader."},
{"description": "ScriptEngine is the fundamental interface whose methods must be fully functional in every implementation of this specification.These methods provide basic scripting functionality.Applications written to this simple interface are expected to work with minimal modifications in every implementation.It includes methods that execute scripts, and ones that set and get values.The values are key/value pairs of two types.The first type of pairs consists of those whose keys are reserved and defined in this specification or by individual implementations.The values in the pairs with reserved keys have specified meanings.The other type of pairs consists of those that create Java language Bindings, the values are usually represented in scripts by the corresponding keys or by decorated forms of them."},
{"description": "Checked exception types thrown by underlying scripting implementations must be wrapped in instances of ScriptException.The class has members to store line and column numbers and filenames if this information is available."},
{"description": "The ScriptEngineManager implements a discovery and instantiation mechanism for ScriptEngine classes and also maintains a collection of key/value pairs storing state shared by all engines created by the Manager.This class uses the service provider mechanism to enumerate all the implementations of ScriptEngineFactory.The ScriptEngineManager provides a method to return a list of all these factories as well as utility methods which look up factories on the basis of language name, file extension and mime type.The Bindings of key/value pairs, referred to as the \"Global Scope\" maintained by the manager is available to all instances of ScriptEngine created by the ScriptEngineManager.The values in the Bindings are generally exposed in all scripts."},
{"description": "Controls where a JAXB implementation puts the generates schema files.An implementation of this abstract class has to be provided by the calling application to generate schemas.This is a class, not an interface so as to allow future versions to evolve without breaking the compatibility."},
{"description": "The interface whose implementing classes are used to connect Script Engines with objects, such as scoped Bindings, in hosting applications.Each scope is a set of named attributes whose values can be set and retrieved using the ScriptContext methods.ScriptContexts also expose Readers and Writers that can be used by the ScriptEngines for input and output."},
{"description": "This exception is thrown when a method in some ways violates the schema.An example of schema violation is modifying attributes of an object that violates the object's schema definition.Another example is renaming or moving an object to a part of the namespace that violates the namespace's schema definition.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "Factory that creates SchemaFactory.This class was introduced as a part of an early proposal during the JSR-206 standardization process.The proposal was eventually abandoned but this class accidentally remained in the source tree, and made its way into the final version.This class does not participate in any JAXP 1.3 or JAXP 1.4 processing.It must not be used by users or JAXP implementations."},
{"description": "Factory that creates Schema objects.SchemaFactory is a schema compiler.It reads external representations of schemas and prepares them for validation.In other words, it is the application's responsibility to ensure that at most one thread is using a SchemaFactory object at any given moment.Implementations are encouraged to mark methods as synchronized to protect themselves from broken clients.While one of the newSchema methods is being invoked, applications may not attempt to recursively invoke the newSchema method, even from the same thread.This spec uses a namespace URI to designate a schema language.The following table shows the values defined by this specification.To be compliant with the spec, the implementation is only required to support W3C XML Schema 1.0.However, if it chooses to support other schema languages listed here, it must conform to the relevant behaviors described in this spec.Schema languages not listed here are expected to introduce their own URIs to represent themselves.The SchemaFactory class is capable of locating other implementations for other schema languages at run-time.Note that because the XML DTD is strongly tied to the parsing process and has a significant effect on the parsing process, it is impossible to define the DTD validation as a process independent from parsing.For this reason, this specification does not define the semantics for the XML DTD.This doesn't prohibit implementors from implementing it in a way they see fit, but users are warned that any DTD validation implemented on this interface necessarily deviate from the XML DTD semantics as defined in the XML 1.0."},
{"description": "An ExecutorService that can schedule commands to run after a given delay, or to execute periodically.The schedule methods create tasks with various delays and return a task object that can be used to cancel or check execution.The scheduleAtFixedRate and scheduleWithFixedDelay methods create and execute tasks that run periodically until cancelled.Commands submitted using the Executor.execute(Runnable) and ExecutorService submit methods are scheduled with a requested delay of zero.Zero and negative delays (but not periods) are also allowed in schedule methods, and are treated as requests for immediate execution.All schedule methods accept relative delays and periods as arguments, not absolute times or dates.It is a simple matter to transform an absolute time represented as a Date to the required form.For example, to schedule at a certain future date, you can use: schedule(task, date.getTime() - System.currentTimeMillis(), TimeUnit.Beware however that expiration of a relative delay need not coincide with the current Date at which the task is enabled due to network time synchronization protocols, clock drift, or other factors.The Executors class provides convenient factory methods for the ScheduledExecutorService implementations provided in this package.Here is a class with a method that sets up a ScheduledExecutorService to beep every ten seconds for an hour:"},
{"description": "A channel that can read bytes into a sequence of buffers.A scattering read operation reads, in a single invocation, a sequence of bytes into one or more of a given sequence of buffers.Scattering reads are often useful when implementing network protocols or file formats that, for example, group data into segments consisting of one or more fixed-length headers followed by a variable-length body.Similar gathering write operations are defined in the GatheringByteChannel interface."},
{"description": "A ThreadPoolExecutor that can additionally schedule commands to run after a given delay, or to execute periodically.This class is preferable to Timer when multiple worker threads are needed, or when the additional flexibility or capabilities of ThreadPoolExecutor (which this class extends) are required.Delayed tasks execute no sooner than they are enabled, but without any real-time guarantees about when, after they are enabled, they will commence.Tasks scheduled for exactly the same execution time are enabled in first-in-first-out (FIFO) order of submission.By default, such a cancelled task is not automatically removed from the work queue until its delay elapses.While this enables further inspection and monitoring, it may also cause unbounded retention of cancelled tasks.To avoid this, set setRemoveOnCancelPolicy(boolean) to true, which causes tasks to be immediately removed from the work queue at time of cancellation.Successive executions of a task scheduled via scheduleAtFixedRate or scheduleWithFixedDelay do not overlap.While different executions may be performed by different threads, the effects of prior executions happen-before those of subsequent ones.While this class inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it.In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.Additionally, it is almost never a good idea to set corePoolSize to zero or use allowCoreThreadTimeOut because this may leave the pool without threads to handle tasks once they become eligible to run.This class overrides the execute and submit methods to generate internal ScheduledFuture objects to control per-task delays and scheduling.To preserve functionality, any further overrides of these methods in subclasses must invoke superclass versions, which effectively disables additional task customization.However, this class provides alternative protected extension method decorateTask (one version each for Runnable and Callable) that can be used to customize the concrete task types used to execute commands entered via execute, submit, schedule, scheduleAtFixedRate, and scheduleWithFixedDelay.By default, a ScheduledThreadPoolExecutor uses a task type extending FutureTask.However, this may be modified or replaced using subclasses of the form: public class CustomScheduledExecutor extends ScheduledThreadPoolExecutor { static class CustomTask<V> implements RunnableScheduledFuture<V> { ... } protected <V> RunnableScheduledFuture<V> decorateTask( Runnable r, RunnableScheduledFuture<V> task) { return new CustomTask<V>(r, task); } protected <V> RunnableScheduledFuture<V> decorateTask( Callable<V> c,RunnableScheduledFuture<V> task) { return new CustomTask<V>(c, task); } // ... add constructors, etc. }"},
{"description": "This object represents a set of constraints that can be checked/ enforced against an XML document.A Schema object is thread safe and applications are encouraged to share it across many parsers in many threads.A Schema object is immutable in the sense that it shouldn't change the set of constraints once it is created.In other words, if an application validates the same document twice against the same Schema, it must always produce the same result.A Schema object is usually created from SchemaFactory.Two kinds of validators can be created from a Schema object.One is Validator, which provides highly-level validation operations that cover typical use cases.The other is ValidatorHandler, which works on top of SAX for better modularity.This specification does not refine the Object.equals(java.lang.In other words, if you parse the same schema twice, you may still get !"},
{"description": "Usually a scheduled future is the result of scheduling a task with a ScheduledExecutorService."},
{"description": "Thrown when a problem with configuration with the Schema Factories exists.This error will typically be thrown when the class of a schema factory specified in the system properties cannot be found or instantiated."},
{"description": "A simple text scanner which can parse primitive types and strings using regular expressions.A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace.The resulting tokens may then be converted into values of different types using the various next methods.For example, this code allows a user to read a number from System.in: Scanner sc = new Scanner(System.in); int i = sc.nextInt(); As another example, this code allows long types to be assigned from entries in a file myNumbers: Scanner sc = new Scanner(new File(\"myNumbers\")); while (sc.hasNextLong()) { long aLong = sc.nextLong(); } The scanner can also use delimiters other than whitespace.This example reads several items in from a string: String input = \"1 fish 2 fish red fish blue fish\"; Scanner s = new Scanner(input).useDelimiter(\"\\\\s*fish\\\\s*\"); System.out.println(s.nextInt()); System.out.println(s.nextInt()); System.out.println(s.next()); System.out.println(s.next()); s.close(); prints the following output: 1 2 red blue The same output can be generated with this code, which uses a regular expression to parse all four tokens at once:MatchResult result = s.match(); for (int i=1; i<=result.groupCount(); i++) System.out.println(result.group(i)); s.close(); The default whitespace delimiter used by a scanner is as recognized by Character.isWhitespace.The reset() method will reset the value of the scanner's delimiter to the default whitespace delimiter regardless of whether it was previously changed.A scanning operation may block waiting for input.first skip any input that matches the delimiter pattern, and then attempt to return the next token.Both hasNext and next methods may block waiting for further input.Whether a hasNext method blocks has no connection to whether or not its associated next method will block.Pattern) methods operate independently of the delimiter pattern.These methods will attempt to match the specified pattern with no regard to delimiters in the input and thus can be used in special circumstances where delimiters are not relevant.These methods may block waiting for more input.When a scanner throws an InputMismatchException, the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method.Depending upon the type of delimiting pattern, empty tokens may be returned.For example, the pattern \"\\\\s+\" will return no empty tokens since it matches multiple instances of the delimiter.The delimiting pattern \"\\\\s\" could return empty tokens since it only passes one space at a time.A scanner can read text from any object which implements the Readable interface.method throws an IOExceptionthen the scanner assumes that the end of the input has been reached.The most recent IOException thrown by the underlying readable can be retrieved via the ioException() method.When a Scanner is closed, it will close its input source if the source implements the Closeable interface.A Scanner is not safe for multithreaded use without external synchronization.Unless otherwise mentioned, passing a null parameter into any method of a Scanner will cause a NullPointerException to be thrown.A scanner will default to interpreting numbers as decimal unless a different radix has been set by using the useRadix(int) method.The reset() method will reset the value of the scanner's radix to 10 regardless of whether it was previously changed.An instance of this class is capable of scanning numbers in the standard formats as well as in the formats of the scanner's locale.A scanner's initial locale is the value returned by the Locale.getDefault(Locale.FORMAT) method; it may be changed via the useLocale(java.util.The reset() method will reset the value of the scanner's locale to the initial locale regardless of whether it was previously changed.The localized formats are defined in terms of the following parameters, which for a particular locale are taken from that locale's DecimalFormat object, df, and its and DecimalFormatSymbols object, dfs.The character used to separate thousands groups, i.e.,\u00a0dfs.getGroupingSeparator() LocalDecimalSeparator\u00a0\u00a0 The character used for the decimal point, i.e.,\u00a0dfs.getDecimalSeparator() LocalPositivePrefix\u00a0\u00a0 The string that appears before a positive number (may be empty),i.e.,\u00a0df.getPositivePrefix() LocalPositiveSuffix\u00a0\u00a0 The string that appears after a positive number (may be empty), i.e.,\u00a0df.getPositiveSuffix() LocalNegativePrefix\u00a0\u00a0 The string that appears before a negative number (may be empty), i.e.,\u00a0df.getNegativePrefix() LocalNegativeSuffix\u00a0\u00a0 The string that appears after a negative number (may be empty), i.e.,\u00a0df.getNegativeSuffix() LocalNaN\u00a0\u00a0 The string that represents not-a-number for floating-point values, i.e.,\u00a0dfs.getNaN() LocalInfinity\u00a0\u00a0 The string that represents infinity for floating-point values, i.e.,\u00a0dfs.getInfinity() Number syntax The strings that can be parsed as numbers by an instance of this class are specified in terms of the following regular-expression grammar, where Rmax is the highest digit in the radix being used(for example, Rmax is 9 in base 10).NonAsciiDigit: A non-ASCII character c for which Character.isDigit(c) returns\u00a0true Non0Digit: [1-Rmax]| LocalPositivePrefix NonNumber LocalPositiveSuffix |Decimal | HexFloat |SignedNonNumber Whitespace is not significant in the above regular expressions."},
{"description": "This class extends TransformerFactory to provide SAX-specific factory methods.It provides two types of ContentHandlers, one for creating Transformers, the other for creating Templates objects.If an application wants to set the ErrorHandler or EntityResolver for an XMLReader used during a transformation, it should use a URIResolver to return the SAXSource which provides (with getXMLReader) a reference to the XMLReader."},
{"description": "Note that XSLT requires namespace support.Attempting to transform an input source that is not generated with a namespace-aware parser may result in errors.Parsers can be made namespace aware by calling the SAXParserFactory.setNamespaceAware(boolean awareness) method."},
{"description": "Defines the API that wraps an XMLReader implementation class.In JAXP 1.0, this class wrapped the Parser interface, however this interface was replaced by the XMLReader.For ease of transition, this class continues to support the same name and interface as well as supporting new methods.An instance of this class can be obtained from the SAXParserFactory.newSAXParser() method.Once an instance of this class is obtained, XML can be parsed from a variety of input sources.These input sources are InputStreams, Files, URLs, and SAX InputSources.This static method creates a new factory instance based on a system property setting or uses the platform default if no property has been defined.The system property that controls which Factory implementation to create is named \"javax.xml.parsers.SAXParserFactory\".This property names a class that is a concrete subclass of this abstract class.As the content is parsed by the underlying parser, methods of the given HandlerBase or the DefaultHandler are called.Implementors of this class which wrap an underlaying implementation can consider using the ParserAdapter class to initially adapt their SAX1 implementation to work under this revised class."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.An XMLReader will throw this exception when it recognizes a feature or property identifier, but cannot perform the requested operation (setting a state or value).Other SAX2 applications and extensions may use this class for similar purposes."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This exception may include information for locating the error in the original XML document, as if it came from a Locator object.Note that although the application will receive a SAXParseException as the argument to the handlers in the ErrorHandler interface, the application is not actually required to throw the exception; instead, it can simply read the information in it and take a different action.Since this exception is a subclass of SAXException, it inherits the ability to wrap another exception."},
{"description": "Defines a factory API that enables applications to configure and obtain a SAX based parser to parse XML documents."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.An XMLReader will throw this exception when it finds an unrecognized feature or property identifier; SAX applications and extensions may use this class for other, similar purposes."},
{"description": "The representation of a savepoint, which is a point within the current transaction that can be referenced from the Connection.rollback method.When a transaction is rolled back to a savepoint all changes made after that savepoint are undone.Unnamed savepoints are identified by an ID generated by the underlying data source."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This class can contain basic error or warning information from either the XML parser or the application: a parser writer or application writer can subclass it to provide additional functionality.SAX handlers may throw this exception or any exception subclassed from it.If the application needs to pass through other types of exceptions, it must wrap those exceptions in a SAXException or an exception derived from a SAXException.If the parser or application needs to include information about a specific location in an XML document, it should use the SAXParseException subclass."},
{"description": "A server such an LDAP server gets an instance of this class in order to perform authentication defined by a specific SASL mechanism.Invoking methods on the SaslServer instance generates challenges according to the SASL mechanism implemented by the SaslServer.As the authentication proceeds, the instance encapsulates the state of a SASL server's authentication exchange.Here's an example of how an LDAP server might use a SaslServer.It first gets an instance of a SaslServer for the SASL mechanism requested by the client:SaslServer ss = Sasl.createSaslServer(mechanism, \"ldap\", myFQDN, props, callbackHandler); It can then proceed to use the server for authentication.For example, suppose the LDAP server received an LDAP BIND request containing the name of the SASL mechanism and an (optional) initial response.It then might use the server as follows: while (!ss.isComplete()) { try { byte[] challenge = ss.evaluateResponse(response); if (ss.isComplete()) { status = ldap.sendBindResponse(mechanism, challenge, SUCCESS); } else { status = ldap.sendBindResponse(mechanism, challenge, SASL_BIND_IN_PROGRESS); response = ldap.readBindRequest(); } } catch (SaslException e) { status = ldap.sendErrorResponse(e); break; } } if (ss.isComplete() && status == SUCCESS) { String qop ="},
{"description": "A class that implements this interface must be thread-safe and handle multiple simultaneous requests.It must also have a public constructor that accepts no argument.This interface is not normally accessed directly by a server, which will use the Sasl static methods instead.However, a particular environment may provide and install a new or different SaslServerFactory."},
{"description": "This class represents an error that has occurred when using SASL."},
{"description": "A class that implements this interface must be thread-safe and handle multiple simultaneous requests.It must also have a public constructor that accepts no argument.This interface is not normally accessed directly by a client, which will use the Sasl static methods instead.However, a particular environment may provide and install a new or different SaslClientFactory."},
{"description": "This class defines the policy of how to locate, load, and instantiate SASL clients and servers.For example, an application or library gets a SASL client by doing something like: SaslClient sc = Sasl.createSaslClient(mechanisms, authorizationId, protocol, serverName, props, callbackHandler); It can then proceed to use the instance to create an authentication connection.Similarly, a server gets a SASL server by using code that looks as follows:"},
{"description": "This class is for runtime permissions.A RuntimePermission contains a name (also referred to as a \"target name\") but no actions list; you either have the named permission or you don't.The target name is the name of the runtime permission (see below).The naming convention follows the hierarchical property naming convention.Also, an asterisk may appear at the end of the name, following a \".*\" and \"*\" signify a wildcard match, while \"*loadLibrary\" and \"a*b\" do not.The following table lists all the possible RuntimePermission target names, and for each provides a description of what the permission allows and a discussion of the risks of granting code the permission.What the Permission Allows Risks of Allowing this Permission createClassLoader Creation of a class loaderThis is an extremely dangerous permission to grant.Malicious applications that can instantiate their own class loaders could then load their own rogue classes into the system.These newly loaded classes could be placed into any protection domain by the class loader, thereby automatically granting the classes the permissions for that domain.This would grant an attacker permission to get the class loader for a particular class.This is dangerous because having access to a class's class loader allows the attacker to load other classes available to that class loader.The attacker would typically otherwise not have access to those classes.setContextClassLoader Setting of the context class loader used by a thread The context class loader is used by system code and extensions when they need to lookup resources that might not exist in the system class loader.Granting setContextClassLoader permission would allow code to change which context class loader is used for a particular thread, including system threads.enableContextClassLoaderOverride Subclass implementation of the thread context class loader methods The context class loader is used by system code and extensions when they need to lookup resources that might not exist in the system class loader.Granting enableContextClassLoaderOverride permission would allow a subclass of Thread to override the methods that are used to get or set the context class loader for a particular thread.Closing of a ClassLoader Granting this permission allows code to close any URLClassLoader that it has a reference to.The security manager is a class that allows applications to implement a security policy.Granting the setSecurityManager permission would allow code to change which security manager is used by installing a different, possibly less restrictive security manager, thereby bypassing checks that would have been enforced by the original security manager.createSecurityManager Creation of a new security manager This gives code access to protected, sensitive methods that may disclose information about other classes or the execution stack.getenv.{variable name} Reading of the value of the specified environment variable This would allow code to read the value, or determine the existence, of a particular environment variable.This is dangerous if the variable contains confidential data.exitVM.{exit status} Halting of the Java Virtual Machine with the specified exit status This allows an attacker to mount a denial-of-service attack by automatically forcing the virtual machine to halt.*\" permission is automatically granted to all code loaded from the application class path, thus enabling applications to terminate themselves.Also, the \"exitVM\" permission is equivalent to \"exitVM.shutdownHooks Registration and cancellation of virtual-machine shutdown hooks This allows an attacker to register a malicious shutdown hook that interferes with the clean shutdown of the virtual machine.This allows code to set the actual implementation for the socket, server socket, stream handler, or RMI socket factory.An attacker may set a faulty implementation which mangles the data stream.Setting of System.out, System.in, and System.err This allows changing the value of the standard system streams.An attacker may change System.in to monitor and steal user input, or may set System.err to a \"null\" OutputStream, which would hide any error messages sent to System.err.This allows an attacker to modify the behaviour of any thread in the system.stopThread Stopping of threads via calls to the Thread stop methodThis allows code to stop any thread in the system provided that it is already granted permission to access that thread.This poses as a threat, because that code may corrupt the system by killing existing threads.modifyThreadGroup modification of thread groups, e.g., via calls to ThreadGroup destroy, getParent, resume, setDaemon, setMaxPriority, stop, and suspend methods This allows an attacker to create thread groups and set their run priority.This allows code to obtain policy information for a particular code source.While obtaining policy information does not compromise the security of the system, it does give attackers additional information, such as local file names for example, to better aim an attack.getFileSystemAttributes Retrieval of file system attributes This allows code to obtain file system information such as disk usage or disk space available to the caller.This is potentially dangerous because it discloses information about the system hardware configuration and some information about the caller's privilege to write files.readFileDescriptor Reading of file descriptors This would allow code to read the particular file associated with the file descriptor read.This is dangerous if the file contains confidential data.This allows code to write to a particular file associated with the descriptor.This is dangerous because it may allow malicious code to plant viruses or at the very least, fill up your entire disk.It is dangerous to allow an applet permission to load native code libraries, because the Java security architecture is not designed to and does not prevent malicious behavior at the level of native code.accessClassInPackage.{package name} Access to the specified package via a class loader's loadClass method when that class loader calls the SecurityManager checkPackageAccess methodThis gives code access to classes in packages to which it normally does not have access.Malicious code may use these classes to help in its attempt to compromise security in the system.defineClassInPackage.{package name} Definition of classes in the specified package, via a class loader's defineClass method when that class loader calls the SecurityManager checkPackageDefinition method.This is dangerous because malicious code with this permission may define rogue classes in trusted packages like java.security or java.lang, for example.Although the code would have access to the private and protected field and method names, it would not have access to the private/protected field data and would not be able to invoke any private methods.Nevertheless, malicious code may use this information to better aim an attack.Additionally, it may invoke any public methods and/or access public fields in the class.This could be dangerous if the code would normally not be able to invoke those methods and/or access the fields because it can't cast the object to the class/interface with those methods and fields.queuePrintJob Initiation of a print job request This could print sensitive information to a printer, or simply waste paper.This allows retrieval of the stack trace information of another thread.This might allow malicious code to monitor the execution of threads and discover vulnerabilities in applications.setDefaultUncaughtExceptionHandler Setting the default handler to be used when a thread terminates abruptly due to an uncaught exception This allows an attacker to register a malicious uncaught exception handler that could interfere with termination of a thread preferencesRepresents the permission required to get access to the java.util.prefs.Preferences implementations user or system root which in turn allows retrieval or update operations within the Preferences persistent backing store.)This permission allows the user to read from or write to the preferences backing store if the user running the code has sufficient OS privileges to read/write to that backing store.The actual backing store may reside within a traditional filesystem directory or within a registry depending on the platform OS usePolicy Granting this permission disables the Java Plug-In's default security prompting behavior."},
{"description": "It wraps the actual java.lang.RuntimeException thrown."},
{"description": "A protocol library such as one for LDAP gets an instance of this class in order to perform authentication defined by a specific SASL mechanism.Invoking methods on the SaslClient instance process challenges and create responses according to the SASL mechanism implemented by the SaslClient.As the authentication proceeds, the instance encapsulates the state of a SASL client's authentication exchange.Here's an example of how an LDAP library might use a SaslClient.It first gets an instance of a SaslClient:, authorizationId, protocol, serverName, props, callbackHandler); It can then proceed to use the client for authentication.For example, an LDAP library might use the client as follows: //we're done; don't expect to send another BIND if (response !=for future // communication with server ldap.in = new SecureInputStream(sc, ldap.in); ldap.out = new SecureOutputStream(sc, ldap.out); } } If the mechanism has an initial response, the library invokes evaluateChallenge() with an empty challenge and to get initial response.Protocols such as IMAP4, which do not include an initial response with their first authentication command to the server, initiates the authentication without first calling hasInitialResponse() or evaluateChallenge().When the server responds to the command, it sends an initial challenge.For a SASL mechanism in which the client sends data first, the server should have issued a challenge with no data.This will then result in a call (on the client) to evaluateChallenge() with an empty challenge."},
{"description": "All of the newInstance methods defined on factories in SAAJ 1.3 defer to instances of this class to do the actual object creation.The implementations of newInstance() methods (in SOAPFactory and MessageFactory) that existed in SAAJ 1.2 have been updated to also delegate to the SAAJMetaFactory when the SAAJ 1.2 defined lookup fails to locate the Factory implementation class name.SAAJMetaFactory is a service provider interface.There are no public methods on this class."},
{"description": "A programmer assertion that the body of the annotated method or constructor does not perform potentially unsafe operations on its varargs parameter.In addition to the usage restrictions imposed by its @Target meta-annotation, compilers are required to implement additional usage restrictions on this annotation type; it is a compile-time error if a method or constructor declaration is annotated with a @SafeVarargs annotation, and either: the declaration is a fixed arity method or constructor the declaration is a variable arity method that is neither static nor final.Compilers are encouraged to issue warnings when this annotation type is applied to a method or constructor declaration where: The variable arity parameter has a reifiable element type, which includes primitive types, Object, and String.(The unchecked warnings this annotation type suppresses already do not occur for a reifiable element type.)The body of the method or constructor declaration performs potentially unsafe operations, such as an assignment to an element of the variable arity parameter's array that generates an unchecked warning.Some unsafe operations do not trigger an unchecked warning.For example, the aliasing in @SafeVarargs // Not actually safe!Future versions of the platform may mandate compiler errors for such unsafe operations."},
{"description": "These results should be accessed by using the getResult() method.The DOMResult.getNode() method should be avoided in almost all cases."},
{"description": "This abstract class defines an interface for extracting samples of pixels in an image.All image data is expressed as a collection of pixels.Each pixel consists of a number of samples.A sample is a datum for one band of an image and a band consists of all samples of a particular type in an image.For example, a pixel might contain three samples representing its red, green and blue components.There are three bands in the image containing this pixel.One band consists of all the red samples from all pixels in the image.The second band consists of all the green samples and the remaining band consists of all of the blue samples.The pixel can be stored in various formats.For example, all samples from a particular band can be stored contiguously or all samples from a single pixel can be stored contiguously.Subclasses of SampleModel specify the types of samples they can represent (e.g. unsigned 8-bit byte, signed 16-bit short, etc.) and may specify how the samples are organized in memory.In the Java 2D(tm) API, built-in image processing operators may not operate on all possible sample types, but generally will work for unsigned integral samples of 16 bits or less.Some operators support a wider variety of sample types.A collection of pixels is represented as a Raster, which consists of a DataBuffer and a SampleModel.The SampleModel allows access to samples in the DataBuffer and may provide low-level information that a programmer can use to directly manipulate samples and pixels in the DataBuffer.This class is generally a fall back method for dealing with images.More efficient code will cast the SampleModel to the appropriate subclass and extract the information needed to directly manipulate pixels in the DataBuffer."},
{"description": "Defines operations on the base class that represents the Sending Context of a request.The sending context provides access to information about the runtime environment of the originator of a GIOP message.For example, when a value type is marshalled on a GIOP Request message, the receiver of the value type may need to ask the sender about the CodeBase for the implementation of the value type."},
{"description": "A Java virtual machine has a single instance of the implementation class of this interface.This instance implementing this interface is an MXBean that can be obtained by calling the ManagementFactory.getRuntimeMXBean() method or from the platform MBeanServer method.The ObjectName for uniquely identifying the MXBean for the runtime system within an MBeanServer is: java.lang:type=Runtime It can be obtained by calling the PlatformManagedObject.getObjectName() method.This interface defines several convenient methods for accessing system properties about the Java virtual machine."},
{"description": "This exception will be built by the MBeanServer when a call to an MBean method throws a runtime exception."},
{"description": "Defines the base class that represents the Sending Context of a request.The sending context provides access to information about the runtime environment of the originator of a GIOP message.For example, when a value type is marshalled on a GIOP Request message, the receiver of the value type may need to ask the sender about the CodeBase for the implementation of the value type."},
{"description": "RuntimeException is the superclass of those exceptions that can be thrown during the normal operation of the Java Virtual Machine.RuntimeException and its subclasses are unchecked exceptions.Unchecked exceptions do not need to be declared in a method or constructor's throws clause if they can be thrown by the execution of the method or constructor and propagate outside the method or constructor boundary."},
{"description": "When a java.lang.Error occurs in the agent it should be caught and re-thrown as a RuntimeErrorException."},
{"description": "Successful execution of the run method causes completion of the Future and allows access to its results."},
{"description": "Every Java application has a single instance of class Runtime that allows the application to interface with the environment in which the application is running.The current runtime can be obtained from the getRuntime method.An application cannot create its own instance of this class."},
{"description": "Successful execution of the run method causes completion of the Future and allows access to its results."},
{"description": "The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread.The class must define a method of no arguments called run.This interface is designed to provide a common protocol for objects that wish to execute code while they are active.For example, Runnable is implemented by class Thread.In addition, Runnable provides the means for a class to be active while not subclassing Thread.A class that implements Runnable can run without subclassing Thread by instantiating a Thread instance and passing itself in as the target.In most cases, the Runnable interface should be used if you are only planning to override the run() method and no other Thread methods.This is important because classes should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior of the class."},
{"description": "This class specifies an RSA public key."},
{"description": "This class specifies an RSA private key."},
{"description": "This is the default implementation of RTF editing functionality.The RTF support was not written by the Swing team.In the future we hope to improve the support provided."},
{"description": "The RuleBasedCollator class is a concrete subclass of Collator that provides a simple, data-driven, table collator.With this class you can create a customized table-based Collator.RuleBasedCollator has the following restrictions for efficiency (other subclasses may be used for more complex languages) : If a special collation rule controlled by a <modifier> is specified it applies to the whole collator object.All non-mentioned characters are at the end of the collation order.The collation table is composed of a list of collation rules, where each rule is of one of three forms:<text-argument> <reset> <text-argumentThe definitions of the rule elements is as follows:Text-Argument: A text-argument is any sequence of characters, excluding special characters (that is, common whitespace characters [0009-000D, 0020] and rule syntax characters [0021-002F, 003A-0040, 005B-0060, 007B-007E]).If those characters are desired, you can put them in single quotes (e.g. ampersandNote that unquoted white space characters are ignored; e.g. b c is treated as bc.There are currently two modifiers that turn on special collation rules. '@' :If this rule is in force when a Thai vowel of the range\\U0E40-\\U0E44 precedes a Thai consonant of the range \\U0E01-\\U0E2E OR a Lao vowel of the range\\U0EC0-\\U0EC4 precedes a Lao consonant of the range \\U0E81-\\U0EAE then the vowel is placed after the consonant for collation purposes. '@': Indicates that accents are sorted backwards, as in French.The relations are the following: '<' :There is a single reset which is used primarily for contractions and expansions, but which can also be used to add a modification at the end of a set of rules.&' : Indicates that the next rule follows the position to where the reset text-argument would be sorted.This sounds more complicated than it is in practice.For example, the following are equivalent ways of expressing the same thing: a < b < c a < b & b < c a < c & a < b Notice that the order is important, as the subsequent item goes immediately after the text-argument.The following are not equivalent: a < b & a < c a < c & a < b Either the text-argument must already be present in the sequence, or some initial substring of the text-argument must be present.(e.g. \"a < b & ae < e\" is valid since \"a\" is present in the sequence before \"ae\" is reset).In this latter case, \"ae\" is not entered and treated as a single character; instead, \"e\" is sorted as if it were expanded to two characters: \"a\" followed by an \"e\".This difference appears in natural languages: in traditional Spanish \"ch\" is treated as though it contracts to a single character (expressed as \"c < ch < d\"), while in traditional German a-umlaut is treated as though it expanded to two characters (expressed as \"a,A < b,B ... &ae;\\u00e3&AE;\\u00c3\").[\\u00e3 and \\u00c3 are, of course, the escape sequences for a-umlaut.], the first rule must start with a relation (the examples we have used above are really fragments; \"a < b\" really should be \"< a < b\").If, however, the first relation is not \"<\", then all the all text-arguments up to the first \"<\" are ignorable.For example, \", - < a < b\" makes \"-\" an ignorable character, as we saw earlier in the word \"black-birds\".In the samples for different languages, you see that most accents are ignorable.Normalization and Accents RuleBasedCollator automatically processes its rule table to include both pre-composed and combining-character versions of accented characters.Even if the provided rule string contains only base characters and separate combining accent characters, the pre-composed accented characters matching all canonical combinations of characters from the rule string will be entered in the table.This allows you to use a RuleBasedCollator to compare accented strings even when the collator is set to NO_DECOMPOSITION.There are two caveats, however.First, if the strings to be collated contain combining sequences that may not be in canonical order, you should set the collator to CANONICAL_DECOMPOSITION or FULL_DECOMPOSITION to enable sorting of combining sequences.Second, if the strings contain characters with compatibility decompositions (such as full-width and half-width forms), you must use FULL_DECOMPOSITION, since the rule tables only include canonical mappings.The following are errors: A text-argument contains unquoted punctuation symbols (e.g. \"a < b-c < d\").A reset where the text-argument (or an initial substring of the text-argument) is not already in the sequence.If you produce one of these errors, a RuleBasedCollator throws a ParseException.\" To create a RuleBasedCollator object with specialized rules tailored to your needs, you construct the RuleBasedCollator with the rules contained in a String object.< x, X < y, Y < z, Z\" + \"< \\u00E6, \\u00C6\" + // Latin letter ae & AE \"< \\u00F8, \\u00D8\" + // Latin letter o & O with stroke \"< \\u00E5 = a\\u030A,\" + //// Latin letter A with ring above \" aa, AA\"; RuleBasedCollator myNorwegian = new RuleBasedCollator(Norwegian); A new collation rules string can be created by concatenating rules strings.For example, the rules returned by getRules() could be concatenated to combine multiple RuleBasedCollators.The following example demonstrates how to change the order of non-spacing accents, // old rule String oldRules = \"=\\u0301;\\u0300;\\u0302;\\u0308\" // main accents + \";\\u0327;\\u0303;\\u0304;\\u0305\" // main accents + \";\\u0306;\\u0307;\\u0309;\\u030A\" // main accents + \";\\u030B;\\u030C;\\u030D;\\u030E\" // main accents + \";\\u030F;\\u0310;\\u0311;\\u0312\" // main accents + \"< a , A ; ae, AE ; \\u00e6 , \\u00c6\" +"},
{"description": "This class specifies an RSA private key, as defined in the PKCS#1 standard, using the Chinese Remainder Theorem (CRT) information values for efficiency."},
{"description": "This class specifies the set of parameters used to generate an RSA key pair."},
{"description": "RowSorterListeners are notified of changes to a RowSorter."},
{"description": "This class represents the triplet (prime, exponent, and coefficient) inside RSA's OtherPrimeInfo structure, as defined in the PKCS#1 v2.1.The ASN.1 syntax of RSA's OtherPrimeInfo is as follows: OtherPrimeInfo ::= SEQUENCE { prime INTEGER, exponent INTEGER, coefficient INTEGER }"},
{"description": "This class specifies an RSA multi-prime private key, as defined in the PKCS#1 v2.1, using the Chinese Remainder Theorem (CRT) information values for efficiency."},
{"description": "RowSorterEvent provides notification of changes to a RowSorter.Two types of notification are possible: Type.This is typically followed by a notification of: Type.indicates the contents of the model have been transformed in some way.For example, the contents may have been sorted or filtered."},
{"description": "An extension of SQLException that provides information about database warnings set on RowSet objects.Warnings are silently chained to the object whose method call caused it to be reported.This class complements the SQLWarning class.Rowset warnings may be retrieved from JdbcRowSet, CachedRowSet\u2122, WebRowSet, FilteredRowSet, or JoinRowSet implementations.To retrieve subsequent warnings, call getNextWarning on each RowSetWarning object that is returned."},
{"description": "SortKey describes the sort order for a particular column.The column index is in terms of the underlying model, which may differ from that of the view."},
{"description": "RowSorter provides the basis for sorting and filtering.Beyond creating and installing a RowSorter, you very rarely need to interact with one directly.RowSorter's primary role is to provide a mapping between two coordinate systems: that of the view (for example a JTable) and that of the underlying data source, typically a model.The view invokes the following methods on the RowSorter:The view invokes this when the appropriate user gesture has occurred to trigger a sort.For example, the user clicked a column header in a table.The view invokes a model change method when the underlying model has changed.There may be order dependencies in how the events are delivered, so a RowSorter should not update its mapping until one of these methods is invoked.Because the view makes extensive use of the convertRowIndexToModel, convertRowIndexToView and getViewRowCount methods, these methods need to be fast.RowSorter provides notification of changes by way of RowSorterListener.Two types of notification are sent:SORT_ORDER_CHANGED \u0097 notifies listeners that the sort order has changed.This is typically followed by a notification that the sort has changed.SORTED \u0097 notifies listeners that the mapping maintained by the RowSorter has changed in some way.RowSorter implementations typically don't have a one-to-one mapping with the underlying model, but they can.For example, if a database does the sorting, toggleSortOrder might call through to the database (on a background thread), and override the mapping methods to return the argument that is passed in.Concrete implementations of RowSorter need to reference a model such as TableModel or ListModel.The view classes, such as JTable and JList, will also have a reference to the model.To avoid ordering dependencies, RowSorter implementations should not install a listener on the model.Instead the view class will call into the RowSorter when the model changes.For example, if a row is updated in a TableModel JTable invokes rowsUpdated.When the model changes, the view may call into any of the following methods:"},
{"description": "A factory API that enables applications to obtain a RowSetFactory implementation that can be used to create different types of RowSet implementations.WebRowSet wrs = rsf.createWebRowSet(); Tracing of this class may be enabled by setting the System property javax.sql.rowset.RowSetFactory.debug to any value but false."},
{"description": "An object that implements the RowSetWriter interface, called a writer.A writer may be registered with a RowSet object that supports the reader/writer paradigm.If a disconnected RowSet object modifies some of its data, and it has a writer associated with it, it may be implemented so that it calls on the writer's writeData method internally to write the updates back to the data source.In order to do this, the writer must first establish a connection with the rowset's data source.If the data to be updated has already been changed in the data source, there is a conflict, in which case the writer will not write the changes to the data source.The algorithm the writer uses for preventing or limiting conflicts depends entirely on its implementation."},
{"description": "The facility that a disconnected RowSet object calls on to populate itself with rows of data.A reader (an object implementing the RowSetReader interface) may be registered with a RowSet object that supports the reader/writer paradigm.When the RowSet object's execute method is called, it in turn calls the reader's readData method."},
{"description": "Provides implementations for the methods that set and get metadata information about a RowSet object's columns.A RowSetMetaDataImpl object keeps track of the number of columns in the rowset and maintains an internal array of column attributes for each column.A RowSet object creates a RowSetMetaDataImpl object internally in order to set and retrieve information about its columns.All metadata in a RowSetMetaDataImpl object should be considered as unavailable until the RowSet object that it describes is populated.Therefore, any RowSetMetaDataImpl method that retrieves information is defined as having unspecified behavior when it is called before the RowSet object contains data."},
{"description": "An interface that must be implemented by a component that wants to be notified when a significant event happens in the life of a RowSet object.A component becomes a listener by being registered with a RowSet object via the method RowSet.addRowSetListener.How a registered component implements this interface determines what it does when it is notified of an event."},
{"description": "The interface that a RowSet object implements in order to present itself to a RowSetReader or RowSetWriter object.The RowSetInternal interface contains methods that let the reader or writer access and modify the internal state of the rowset."},
{"description": "An object that contains information about the columns in a RowSet object.This interface is an extension of the ResultSetMetaData interface with methods for setting the values in a RowSetMetaData object.When a RowSetReader object reads data into a RowSet object, it creates a RowSetMetaData object and initializes it using the methods in the RowSetMetaData interface.Then the reader passes the RowSetMetaData object to the rowset.The methods in this interface are invoked internally when an application calls the method RowSet.execute; an application programmer would not use them directly."},
{"description": "An interface that defines the implementation of a factory that is used to obtain different types of RowSet implementations."},
{"description": "An Event object generated when an event occurs to a RowSet object.A RowSetEvent object is generated when a single row in a rowset is changed, the whole rowset is changed, or the rowset cursor moves.When an event occurs on a RowSet object, one of the RowSetListener methods will be sent to all registered listeners to notify them of the event.An Event object is supplied to the RowSetListener method so that the listener can use it to find out which RowSet object is the source of the event."},
{"description": "An SQL ROWID is a built-in type, a value of which can be thought of as an address for its identified row in a database table.Whether that address is logical or, in any respects, physical is determined by its originating data source.Methods in the interfaces ResultSet, CallableStatement, and PreparedStatement, such as getRowId and setRowId allow a programmer to access a SQL ROWID value.The RowId interface provides a method for representing the value of the ROWID as a byte array or as a String.The method getRowIdLifetime in the interface DatabaseMetaData, can be used to determine if a RowId object remains valid for the duration of the transaction in which the RowId was created, the duration of the session in which the RowId was created, or, effectively, for as long as its identified row is not deleted.In addition to specifying the duration of its valid lifetime outside its originating data source, getRowIdLifetime specifies the duration of a ROWID value's valid lifetime within its originating data source.In this, it differs from a large object, because there is no limit on the valid lifetime of a large object within its originating data source.All methods on the RowId interface must be fully implemented if the JDBC driver supports the data type."},
{"description": "An Entry object is passed to instances of RowFilter, allowing the filter to get the value of the entry's data, and thus to determine whether the entry should be shown.An Entry object contains information about the model as well as methods for getting the underlying values from the model."},
{"description": "RowFilter is used to filter out entries from the model so that they are not shown in the view.For example, a RowFilter associated with a JTable might only allow rows that contain a column with a specific string.The meaning of entry depends on the component type.For example, when a filter is associated with a JTable, an entry corresponds to a row; when associated with a JTree, an entry corresponds to a node.Subclasses must override the include method to indicate whether the entry should be shown in the view.The Entry argument can be used to obtain the values in each of the columns in that entry.The following example shows an include method that allows only entries containing one or more values starting with the string \"a\": RowFilter<Object,Object> startsWithAFilter = new RowFilter<Object,Object>() { public boolean include(Entry<?The value starts with \"a\", include it return true; } } //None of the columns start with \"a\"; return false so that this // entry is not shown return false; } }; RowFilter has two formal type parameters that allow you to create a RowFilter for a specific model.For example, the following assumes a specific model that is wrapping objects of type Person.Only Persons with an age over 20 will be shown: RowFilter<PersonModel,Integer> ageFilter = new RowFilter<PersonModel,Integer>() { public boolean include(Entry<?Age is <= 20, don't show it."},
{"description": "The interface that adds support to the JDBC API for the JavaBeans\u2122 component model.A rowset, which can be used as a JavaBeans component in a visual Bean development environment, can be created and configured at design time and executed at run time.The RowSet interface provides a set of JavaBeans properties that allow a RowSet instance to be configured to connect to a JDBC data source and read some data from the data source.A group of setter methods (setInt, setBytes, setString, and so on) provide a way to pass input parameters to a rowset's command property.This command is the SQL query the rowset uses when it gets its data from a relational database, which is generally the case.The RowSet interface supports JavaBeans events, allowing other components in an application to be notified when an event occurs on a rowset, such as a change in its value.The RowSet interface is unique in that it is intended to be implemented using the rest of the JDBC API.In other words, a RowSet implementation is a layer of software that executes \"on top\" of a JDBC driver.Implementations of the RowSet interface can be provided by anyone, including JDBC driver vendors who want to provide a RowSet implementation as part of their JDBC products.A RowSet object may make a connection with a data source and maintain that connection throughout its life cycle, in which case it is called a connected rowset.A rowset may also make a connection with a data source, get data from it, and then close the connection.A disconnected rowset may make changes to its data while it is disconnected and then send the changes back to the original source of the data, but it must reestablish a connection to do so.A disconnected rowset may have a reader (a RowSetReader object) and a writer (a RowSetWriter object) associated with it.The reader may be implemented in many different ways to populate a rowset with data, including getting data from a non-relational data source.The writer can also be implemented in many different ways to propagate changes made to the rowset's data back to the underlying data source.The RowSet interface extends the standard java.sql.ResultSet interface.The RowSetMetaData interface extends the java.sql.ResultSetMetaData interface.Thus, developers familiar with the JDBC API will have to learn a minimal number of new APIs to use rowsets.In addition, third-party software tools that work with JDBC ResultSet objects will also easily be made to work with rowsets."},
{"description": "The Float class defines a rectangle with rounded corners all specified in float coordinates."},
{"description": "The Double class defines a rectangle with rounded corners all specified in double coordinates."},
{"description": "An annotation processing tool framework will provide an annotation processor with an object implementing this interface so that the processor can query for information about a round of annotation processing."},
{"description": "A RoleUnresolvedList represents a list of RoleUnresolved objects, representing roles not retrieved from a relation due to a problem encountered when trying to access (read or write) the roles."},
{"description": "Each rounding mode indicates how the least significant returned digit of a rounded result is to be calculated.If fewer digits are returned than the digits needed to represent the exact numerical result, the discarded digits will be referred to as the discarded fraction regardless the digits' contribution to the value of the number.In other words, considered as a numerical value, the discarded fraction could have an absolute value greater than one.Each rounding mode description includes a table listing how different two-digit decimal values would round to a one digit decimal value under the rounding mode in question.The result column in the tables could be gotten by creating a BigDecimal number with the specified value, forming a MathContext object with the proper settings (precision set to 1, and the roundingMode set to the rounding mode in question), and calling round on this number with the proper MathContext.A summary table showing the results of these rounding operations for all rounding modes appears below.HALF_EVEN UNNECESSARY 5.5 6 5 6 5 6 5 6 throw ArithmeticException 2.5 3 2 3 2 3 2 2 throw ArithmeticException 1.6 2 1 2 1 2 2 2 throw ArithmeticException 1.1 2 1 2 1 1 1 1 throw ArithmeticException 1.0 1 1 1 1 1 1 1 1This enum is intended to replace the integer-based enumeration of rounding mode constants in BigDecimal (BigDecimal."},
{"description": "The RoundRectangle2D class defines a rectangle with rounded corners defined by a location (x,y), a dimension (w x h), and the width and height of an arc with which to round the corners.This class is the abstract superclass for all objects that store a 2D rounded rectangle.The actual storage representation of the coordinates is left to the subclass."},
{"description": "This interface is implemented by components that have a single JRootPane child: JDialog, JFrame, JWindow, JApplet, JInternalFrame.The methods in this interface are just covers for the JRootPane properties, e.g. getContentPane() is generally implemented like this: public Container getContentPane() { return getRootPane().getContentPane(); } This interface serves as a marker for Swing GUI builders that need to treat components like JFrame, that contain a single JRootPane, specially.For example in a GUI builder, dropping a component on a RootPaneContainer would be interpreted as frame.getContentPane().add(child).As a convenience, the standard classes that implement this interface (such as JFrame, JDialog, JWindow, JApplet, and JInternalFrame) have their add, remove, and setLayout methods overridden, so that they delegate calls to the corresponding methods of the ContentPane.For example, you can add a child component to a frame as follows: frame.add(child); instead of: frame.getContentPane().add(child); The behavior of the add and setLayout methods for JFrame, JDialog, JWindow, JApplet and JInternalFrame is controlled by the rootPaneCheckingEnabled property.If this property is true (the default), then calls to these methods are forwarded to the contentPane; if false, these methods operate directly on the RootPaneContainer.This property is only intended for subclasses, and is therefore protected."},
{"description": "Defines the requirements for an object that translates paths in the tree into display rows."},
{"description": "It provides the role name, value (if problem when trying to set the role) and an integer defining the problem (constants defined in RoleStatus).The serialVersionUID of this class is -48350262537070138L."},
{"description": "This class describes the various problems which can be encountered when accessing a role."},
{"description": "The serialVersionUID of this class is -6304063118040985512L."},
{"description": "This exception is raised when a role in a relation does not exist, or is not readable, or is not settable."},
{"description": "A RoleList represents a list of roles (Role objects).It is used as parameter when creating a relation, and when trying to set several roles in a relation (via 'setRoles()' method).It is returned as part of a RoleResult, to provide roles successfully retrieved."},
{"description": "The role value is always represented as an ArrayList collection (of ObjectNames) to homogenize the access.The serialVersionUID of this class is -279985518429862552L."},
{"description": "This exception is raised when there is no role info with given name in a given relation type."},
{"description": "A RoleInfo object summarises a role in a relation type.The serialVersionUID of this class is 2504952983494636987L."},
{"description": "This class is used to generate native system input events for the purposes of test automation, self-running demos, and other applications where control of the mouse and keyboard is needed.The primary purpose of Robot is to facilitate automated testing of Java platform implementations.Using the class to generate input events differs from posting events to the AWT event queue or AWT components in that the events are generated in the platform's native input queue.For example, Robot.mouseMove will actually move the mouse cursor instead of just generating mouse move events.Note that some platforms require special privileges or extensions to access low-level input control.If the current platform configuration does not allow input control, an AWTException will be thrown when trying to construct Robot objects.For example, X-Window systems will throw the exception if the XTEST 2.2 standard extension is not supported (or not enabled) by the X server.Applications that use Robot for purposes other than self-testing should handle these error conditions gracefully."},
{"description": "An RMISocketFactory instance is used by the RMI runtime in order to obtain client and server sockets for RMI calls.An application may use the setSocketFactory method to request that the RMI runtime use its socket factory instance instead of the default implementation.The default socket factory implementation performs a three-tiered approach to creating client sockets.First, a direct socket connection to the remote VM is attempted.If that fails (due to a firewall), the runtime uses HTTP with the explicit port number of the server.If the firewall does not allow this type of communication, then HTTP to a cgi-bin script on the server is used to POST the RMI call.The HTTP tunneling mechanisms are disabled by default.This behavior is controlled by the java.rmi.server.disableHttp property, whose default value is true.Setting this property's value to false will enable the HTTP tunneling mechanisms.The HTTP tunneling mechanisms described above, specifically HTTP with an explicit port and HTTP to a cgi-bin script, are deprecated.These HTTP tunneling mechanisms are subject to removal in a future release of the platform.The default socket factory implementation creates server sockets that are bound to the wildcard address, which accepts requests from all network interfaces."},
{"description": "An RMIServerSocketFactory instance is used by the RMI runtime in order to obtain server sockets for RMI calls.A remote object can be associated with an RMIServerSocketFactory when it is created/exported via the constructors or exportObject methods of java.rmi.server.UnicastRemoteObject and java.rmi.activation.Activatable .An RMIServerSocketFactory instance associated with a remote object is used to obtain the ServerSocket used to accept incoming calls from clients.An RMIServerSocketFactory instance can also be associated with a remote object registry so that clients can use custom socket communication with a remote object registry.An implementation of this interface should implement Object.equals(java.lang.Object) to return true when passed an instance that represents the same (functionally equivalent) server socket factory, and false otherwise (and it should also implement Object.hashCode"},
{"description": "RMI object used to establish connections to an RMI connector.There is one Remote object implementing this interface for each RMI connector.User code does not usually refer to this interface.It is specified as part of the public API so that different implementations of that API will interoperate."},
{"description": "An RMI object representing a connector server.Remote clients can make connections using the newClient(Object) method.This method returns an RMI object representing the connection.User code does not usually reference this class directly.RMI connection servers are usually created with the class RMIConnectorServer.Remote clients usually create connections either with JMXConnectorFactory or by instantiating RMIConnector.This is an abstract class.Concrete subclasses define the details of the client connection objects, such as whether they use JRMP or IIOP."},
{"description": "Application code should never directly reference this class, and RMISecurityManager no longer throws this subclass of java.lang.SecurityException."},
{"description": "An RMIServer object that is exported through JRMP and that creates client connections as RMI objects exported through JRMP.User code does not usually reference this class directly."},
{"description": "A JMX API connector server that creates RMI-based connections from remote clients.Usually, such connector servers are made using JMXConnectorServerFactory.However, specialized applications can use this class directly, for example with an RMIServerImpl object."},
{"description": "User code will not usually reference this class."},
{"description": "Usually, such connections are made using JMXConnectorFactory.However, specialized applications can use this class directly, for example with an RMIServer stub obtained without going through JNDI."},
{"description": "An RMIServerImpl that is exported through IIOP and that creates client connections as RMI objects exported through IIOP.User code does not usually reference this class directly."},
{"description": "An RMIFailureHandler can be registered via the RMISocketFactory.setFailureHandler call.The failure method of the handler is invoked when the RMI runtime is unable to create a ServerSocket to listen for incoming calls.The failure method returns a boolean indicating whether the runtime should attempt to re-create the ServerSocket."},
{"description": "An RMIClientSocketFactory instance is used by the RMI runtime in order to obtain client sockets for RMI calls.A remote object can be associated with an RMIClientSocketFactory when it is created/exported via the constructors or exportObject methods of java.rmi.server.UnicastRemoteObject and java.rmi.activation.Activatable .An RMIClientSocketFactory instance associated with a remote object will be downloaded to clients when the remote object's reference is transmitted in an RMI call.This RMIClientSocketFactory will be used to create connections to the remote object for remote method calls.An RMIClientSocketFactory instance can also be associated with a remote object registry so that clients can use custom socket communication with a remote object registry.An implementation of this interface should be serializable and should implement Object.equals(java.lang.Object) to return true when passed an instance that represents the same (functionally equivalent) client socket factory, and false otherwise (and it should also implement Object.hashCode"},
{"description": "RMIClassLoader comprises static methods to support dynamic class loading with RMI.Included are methods for loading classes from a network location (one or more URLs) and obtaining the location from which an existing class should be loaded by remote parties.These methods are used by the RMI runtime when marshalling and unmarshalling classes contained in the arguments and return values of remote method calls, and they also may be invoked directly by applications in order to mimic RMI's dynamic class loading behavior.loadClass(String,String,ClassLoader) loadProxyClass(String,String[],ClassLoader) getClassLoader(String) getClassAnnotation(Class) is provided by an instance of RMIClassLoaderSpi, the service provider interface for those methods.When one of the methods is invoked, its behavior is to delegate to a corresponding method on the service provider instance.The details of how each method delegates to the provider instance is described in the documentation for each particular method.The service provider instance is chosen as follows: If the system property java.rmi.server.RMIClassLoaderSpi is defined, then if its value equals the string \"default\", the provider instance will be the value returned by an invocation of the getDefaultProviderInstance() method, and for any other value, if a class named with the value of the property can be loaded by the system class loader (see ClassLoader.getSystemClassLoader()) and that class is assignable to RMIClassLoaderSpi and has a public no-argument constructor, then that constructor will be invoked to create the provider instance.If the property is defined but any other of those conditions are not true, then an unspecified Error will be thrown to code that attempts to use RMIClassLoader, indicating the failure to obtain a provider instance.RMIClassLoaderSpi is visible to the system class loader, then the contents of that resource are interpreted as a provider-configuration file, and the first class name specified in that file is used as the provider class name.If a class with that name can be loaded by the system class loader and that class is assignable to RMIClassLoaderSpi and has a public no-argument constructor, then that constructor will be invoked to create the provider instance.If the resource is found but a provider cannot be instantiated as described, then an unspecified Error will be thrown to code that attempts to use RMIClassLoader, indicating the failure to obtain a provider instance.Otherwise, the provider instance will be the value returned by an invocation of the getDefaultProviderInstance() method."},
{"description": "RMI object used to forward an MBeanServer request from a client to its MBeanServer implementation on the server side.There is one Remote object implementing this interface for each remote client connected to an RMI connector.User code does not usually refer to this interface.It is specified as part of the public API so that different implementations of that API will interoperate.To ensure that client parameters will be deserialized at the server side with the correct classloader, client parameters such as parameters used to invoke a method are wrapped in a MarshalledObject.An implementation of this interface must first get the appropriate class loader for the operation and its target, then deserialize the marshalled parameters with this classloader.Except as noted, a parameter that is a MarshalledObject or MarshalledObject[] must not be null; the behavior is unspecified if it is.Class loading aspects are detailed in the JMX Specification, version 1.4 PDF document.Where an aspect of the behavior of a method is not specified here, it is the same as in the corresponding MBeanServerConnection method."},
{"description": "The ReverbType class provides methods for accessing various reverberation settings to be applied to an audio signal.Reverberation simulates the reflection of sound off of the walls, ceiling, and floor of a room.Depending on the size of the room, and how absorbent or reflective the materials in the room's surfaces are, the sound might bounce around for a long time before dying away.Early reflections are the initial individual low-order reflections of the direct signal off the surfaces in the room.The late Reflections are the dense, high-order reflections that characterize the room's reverberation.The delay times for the start of these two reflection types give the listener a sense of the overall size and complexity of the room's shape and contents.The early and late reflections' intensities define the gain (in decibels) of the reflected signals as compared to the direct signal.These intensities give the listener an impression of the absorptive nature of the surfaces and objects in the room.The decay time defines how long the reverberation takes to exponentially decay until it is no longer perceptible (\"effective zero\").The set of parameters defined here may not include all aspects of reverberation as specified by some systems.For example, the Midi Manufacturer's Association (MMA) has an Interactive Audio Special Interest Group (IASIG), which has a 3-D Working Group that has defined a Level 2 Spec (I3DL2).I3DL2 supports filtering of reverberation and control of reverb density.These properties are not included in the JavaSound 1.0 definition of a reverb control.In such a case, the implementing system should either extend the defined reverb control to include additional parameters, or else interpret the system's additional capabilities in a way that fits the model described here.If implementing JavaSound on a I3DL2-compliant device: Filtering is disabled (high-frequency attenuations are set to 0.0 dB)Density parameters are set to midway between minimum and maximum The following tableshows what parameter values an implementation might use for a representative set of reverberation settings."},
{"description": "This class provides an easy way to create an ImageFilter which modifies the pixels of an image in the default RGB ColorModel.It is meant to be used in conjunction with a FilteredImageSource object to produce filtered versions of existing images.It is an abstract class that provides the calls needed to channel all of the pixel data through a single method which converts pixels one at a time in the default RGB ColorModel regardless of the ColorModel being used by the ImageProducer.The only method which needs to be defined to create a useable image filter is the filterRGB method.Here is an example of a definition of a filter which swaps the red and blue components of an image: class RedBlueSwapFilter extends RGBImageFilter { public RedBlueSwapFilter() { //The filter's operation does not depend on the // pixel's location, so IndexColorModels can be // filtered directly."},
{"description": "A RetrievalMethod object is used to convey a reference to KeyInfo information that is stored at another location.The XML schema definition is defined as: <element name=\"RetrievalMethod> A RetrievalMethod instance may be created by invoking one of the newRetrievalMethod methods of the KeyInfoFactory class, and passing it the URI identifying the location of the KeyInfo, an optional type URI identifying the type of KeyInfo, and an optional list of Transforms; for example: KeyInfoFactory factory = KeyInfoFactory.getInstance(\"DOM\"); RetrievalMethod rm = factory.newRetrievalMethod (\"#KeyValue-1\", KeyValue."},
{"description": "The constants of this enumerated type describe the various policies for retaining annotations.They are used in conjunction with the Retention meta-annotation type to specify how long annotations are to be retained."},
{"description": "RMIClassLoaderSpi is the service provider interface for RMIClassLoader.In particular, an RMIClassLoaderSpi instance provides an implementation of the following static methods of RMIClassLoader: RMIClassLoader.loadClass(URL,String) RMIClassLoader.loadClass(String,String)When one of those methods is invoked, its behavior is to delegate to a corresponding method on an instance of this class.The details of how each method delegates to the provider instance is described in the documentation for each particular method.See the documentation for RMIClassLoader for a description of how a provider instance is chosen."},
{"description": "Indicates how long annotations with the annotated type are to be retained.If no Retention annotation is present on an annotation type declaration, the retention policy defaults to RetentionPolicy.A Retention meta-annotation has effect only if the meta-annotated type is used directly for annotation.It has no effect if the meta-annotated type is used as a member type in another annotation type."},
{"description": "An object that can be used to get information about the types and properties of the columns in a ResultSet object.The following code fragment creates the ResultSet object rs, creates the ResultSetMetaData object rsmd, and uses rsmd to find out how many columns rs has and whether the first column in rs can be used in a WHERE clause."},
{"description": "The Response interface provides methods used to obtain the payload and context of a message sent in response to an operation invocation.For asynchronous operation invocations it provides additional methods to check the status of the request.methods may throw the standard set of exceptions and their cause may be a RemoteException or a WebServiceException that represents the error that occured during the asynchronous method invocation."},
{"description": "A table of data representing a database result set, which is usually generated by executing a statement that queries the database.A ResultSet object maintains a cursor pointing to its current row of data.Initially the cursor is positioned before the first row.The next method moves the cursor to the next row, and because it returns false when there are no more rows in the ResultSet object, it can be used in a while loop to iterate through the result set.A default ResultSet object is not updatable and has a cursor that moves forward only.Thus, you can iterate through it only once and only from the first row to the last row.It is possible to produce ResultSet objects that are scrollable and/or updatable.The following code fragment, in which con is a valid Connection object, illustrates how to make a result set that is scrollable and insensitive to updates by others, and that is updatable.See ResultSet fields for other options.a, b FROM TABLE2\"); // rs will be scrollable, will not show changes made by others, // and will be updatable The ResultSet interface provides getter methods (getBoolean, getLong, and so on) for retrieving column values from the current row.Values can be retrieved using either the index number of the column or the name of the column.In general, using the column index will be more efficient.Columns are numbered from 1.For maximum portability, result set columns within each row should be read in left-to-right order, and each column should be read only once.For the getter methods, a JDBC driver attempts to convert the underlying data to the Java type specified in the getter method and returns a suitable Java value.The JDBC specification has a table showing the allowable mappings from SQL types to Java types that can be used by the ResultSet getter methods.Column names used as input to getter methods are case insensitive.When a getter method is called with a column name and several columns have the same name, the value of the first matching column will be returned.The column name option is designed to be used when column names are used in the SQL query that generated the result set.For columns that are NOT explicitly named in the query, it is best to use column numbers.If column names are used, the programmer should take care to guarantee that they uniquely refer to the intended columns, which can be assured with the SQL AS clause.A set of updater methods were added to this interface in the JDBC 2.0 API (Java\u2122 2 SDK, Standard Edition, version 1.2).The comments regarding parameters to the getter methods also apply to parameters to the updater methods.The updater methods may be used in two ways: to update a column value in the current row.In a scrollable ResultSet object, the cursor can be moved backwards and forwards, to an absolute position, or to a position relative to the current row.The following code fragment updates the NAME column in the fifth row of the ResultSet object rs and then uses the method updateRow to update the data source table from which rs was derived.An updatable ResultSet object has a special row associated with it that serves as a staging area for building a row to be inserted.The following code fragment moves the cursor to the insert row, builds a three-column row, and inserts it into rs and into the data source table using the method insertRow.// updates the third column to true rs.insertRow(); rs.moveToCurrentRow(); A ResultSet object is automatically closed when the Statement object that generated it is closed, re-executed, or used to retrieve the next result from a sequence of multiple results.The number, types and properties of a ResultSet object's columns are provided by the ResultSetMetaData object returned by the ResultSet.getMetaData method."},
{"description": "The default value of the localName is the operationName as defined in WebMethod annotation appended with Response and the targetNamespace is the target namespace of the SEI.When starting from Java this annotation is used resolve overloading conflicts in document literal mode.Only the className is required in this case."},
{"description": "This interface is supplied by an ORB to a servant at invocation time and allowsthe servant to later retrieve an OutputStream for returning the invocation results."},
{"description": "An instance of such a class can be registered with the system by doing ResponseCache.setDefault(ResponseCache), and the system will call this object in order to: store resource data which has been retrieved from an external source into the cache try to fetch a requested resource that may have been stored in the cacheIf a request resource cannot be retrieved from the cache, then the protocol handlers will fetch the resource from its original location.The settings for URLConnection#useCaches controls whether the protocol is allowed to use a cached response."},
{"description": "An object that implements this interface contains the information needed to build a transformation result tree."},
{"description": "This feature clarifies the use of the wsdl:binding in a JAX-WS runtime.This feature can be used during the creation of SEI proxy, and Dispatch instances on the client side and Endpoint instances on the server side.This feature cannot be used for Service instance creation on the client side.This feature is only useful with web services that have an associated WSDL.Enabling this feature requires that a JAX-WS implementation inspect the wsdl:binding for an endpoint at runtime to make sure that all wsdl:extensions that have the required attribute set to true are understood and are being used.The following describes the affects of this feature with respect to be enabled or disabled: ENABLED:In this Mode, a JAX-WS runtime MUST assure that all required wsdl:binding extensions(including policies) are either understood and used by the runtime, or explicitly disabled by the web service application.A web service can disable a particular extension if there is a corresponding WebServiceFeature or annotation.Similarly, a web service client can disable particular extension using the corresponding WebServiceFeature while creating a proxy or Dispatch instance.The runtime MUST also make sure that binding of SEI parameters/return values respect the wsdl:binding.binding extension is in the WSDL and it is not supported by a JAX-WS runtime and it has not been explicitly turned off by the web service developer, then that JAX-WS runtime MUST behave appropriately based on whether it is on the client or server:Client: runtime MUST throw a WebServiceException no sooner than when one of the methods above is invoked but no later than the first invocation of an endpoint operation.: throw a WebServiceException and the endpoint MUST fail to deploy DISABLED: In this Mode, an implementation may choose whether to inspect the wsdl:binding or not and to what degreeFor example, one implementation may choose to behave as if this feature is enabled, another implementation may only choose to verify the SEI's parameter/return type bindings."},
{"description": "An interface for service providers that provide implementations of ResourceBundle.The default resource bundle loading behavior of the ResourceBundle.getBundle factory methods that take no ResourceBundle.Control instance can be modified with ResourceBundleControlProvider implementations.Provider implementations must be packaged using the Java Extension Mechanism as installed extensions.Any installed ResourceBundleControlProvider implementations are loaded using ServiceLoader at the ResourceBundle class loading time."},
{"description": "This class is used to allow multiple resources declarations."},
{"description": "This feature clarifies the use of the wsdl:binding in a JAX-WS runtime.This annotation MUST only be used in conjunction the javax.jws.WebService, WebServiceProvider, WebServiceRef annotations.When used with the javax.jws.WebService annotation this annotation MUST only be used on the service endpoint implementation class.When used with a WebServiceRef annotation, this annotation MUST only be used when a proxy instance is created.The injected SEI proxy, and endpoint MUST honor the values of the RespectBinding annotation.This annotation's behaviour is defined by the corresponding feature"},
{"description": "Control defines a set of callback methods that are invoked by the ResourceBundle.getBundle factory methods during the bundle loading process.Control collaborates with the factory methods for loading resource bundles.The default implementation of the callback methods provides the information necessary for the factory methods to perform the default behavior.In addition to the callback methods, the toBundleName and toResourceName methods are defined primarily for convenience in implementing the callback methods.However, the toBundleName method could be overridden to provide different conventions in the organization and packaging of localized resources.The toResourceName method is final to avoid use of wrong resource and class name separators.Two factory methods, getControl(List) and getNoFallbackControl(List), provide ResourceBundle.Control instances that implement common variations of the default bundle loading process.The formats returned by the getFormats method and candidate locales returned by the getCandidateLocales method must be consistent in all ResourceBundle.getBundle invocations for the same base bundle.Otherwise, the ResourceBundle.getBundle methods may return unintended bundles.For example, if only \"java.class\" is returned by the getFormats method for the first call to ResourceBundle.getBundle and only \"java.properties\" for the second call, then the second call will return the class-based one that has been cached during the first call.Control instance must be thread-safe if it's simultaneously used by multiple threads.ResourceBundle.getBundle does not synchronize to call the ResourceBundle.The default implementations of the methods are thread-safe.Applications can specify ResourceBundle.The following are examples of changing the default bundle loading process.The following code lets ResourceBundle.getBundle look up only properties-based resources.; Given the resource bundles in the example in the ResourceBundle.getBundle description, this ResourceBundle.getBundle call loads MyResources_fr_CH.properties whose parent is MyResources_fr.properties whose parent is MyResources.properties.The following is an example of loading XML-based bundles using Properties.loadFromXML.throw new NullPointerException(); return Arrays.asList(\"xml\"); } public ResourceBundle newBundle(String baseName, Locale locale, String format, ClassLoader loader, boolean reload) throws IllegalAccessException, InstantiationException, IOException { if (baseName ==bis.close(); } } return bundle; } }); ... private static class XMLResourceBundle extends ResourceBundle { private Properties props; XMLResourceBundle(InputStream stream) throws IOException { props = new Properties(); props.loadFromXML(stream); } protected Object handleGetObject(String key) { return props.getProperty(key); } public Enumeration<String> getKeys() { ... } }"},
{"description": "The Resource annotation marks a resource that is needed by the application.This annotation may be applied to an application component class, or to fields or methods of the component class.When the annotation is applied to a field or method, the container will inject an instance of the requested resource into the application component when the component is initialized.If the annotation is applied to the component class, the annotation declares a resource that the application will look up at runtime.Even though this annotation is not marked Inherited, deployment tools are required to examine all superclasses of any component class to discover all uses of this annotation in all superclasses.All such annotation instances specify resources that are needed by the application component.Note that this annotation may appear on private fields and methods of superclasses; the container is required to perform injection in these cases as well."},
{"description": "Resource bundles contain locale-specific objects.When your program needs a locale-specific resource, a String for example, your program can load it from the resource bundle that is appropriate for the current user's locale.In this way, you can write program code that is largely independent of the user's locale isolating most, if not all, of the locale-specific information in resource bundles.This allows you to write programs that can: be easily localized, or translated, into different languages handle multiple locales at once be easily modified later to support even more locales Resource bundles belong to families whose members share a common base name, but whose names also have additional components that identify their locales.For example, the base name of a family of resource bundles might be \"MyResources\".The family should have a default resource bundle which simply has the same name as its family - \"MyResources\" - and will be used as the bundle of last resort if a specific locale is not supported.The family can then provide as many locale-specific members as needed, for example a German one named \"MyResources_de\".Each resource bundle in a family contains the same items, but the items have been translated for the locale represented by that resource bundle.For example, both \"MyResources\" and \"MyResources_de\" may have a String that's used on a button for canceling operations.In \"MyResources\" the String may contain \"Cancel\" and in \"MyResources_de\" it may contain \"Abbrechen\".If there are different resources for different countries, you can make specializations: for example, \"MyResources_de_CH\" contains objects for the German language (de) in Switzerland (CH).If you want to only modify some of the resources in the specialization, you can do so.When your program needs a locale-specific object, it loads the ResourceBundle class using the getBundle method: ResourceBundle myResources = ResourceBundle.getBundle(\"MyResources\", currentLocale); Resource bundles contain key/value pairs.The keys uniquely identify a locale-specific object in the bundle.Here's an example of a ListResourceBundle that contains two key/value pairs: public class MyResources extends ListResourceBundle { protected Object[](e.g., \"OK\") {\"OkKey\", \"OK\"}, {\"CancelKey\", \"Cancel\"}, // END OF MATERIAL TO LOCALIZE }; } } Keys are always Strings.In this example, the keys are \"OkKey\" and \"CancelKey\".In the above example, the values are also Strings--\"OK\" and \"Cancel\"--but they don't have to be.The values can be any type of object.You retrieve an object from resource bundle using the appropriate getter method.Because \"OkKey\" and \"CancelKey\" are both strings, you would use getString to retrieve them: button1 =new Button(myResources.getString(\"CancelKey\")); The getter methods all require the key as an argument and return the object if found.If the object is not found, the getter method throws a MissingResourceException.Besides getString, ResourceBundle also provides a method for getting string arrays, getStringArray, as well as a generic getObject method for any other type of object.When using getObject, you'll have to cast the result to the appropriate type.myResources.getObject(\"intList\"); The Java Platform provides two subclasses of ResourceBundle, ListResourceBundle and PropertyResourceBundle, that provide a fairly simple way to create resources.As you saw briefly in a previous example, ListResourceBundle manages its resource as a list of key/value pairs.If ListResourceBundle or PropertyResourceBundle do not suit your needs, you can write your own ResourceBundle subclass.Your subclasses must override two methods: handleGetObject and getKeys().The implementation of a ResourceBundle subclass must be thread-safe if it's simultaneously used by multiple threads.The default implementations of the non-abstract methods in this class, and the methods in the direct known concrete subclasses ListResourceBundle and PropertyResourceBundle are thread-safe.Control class provides information necessary to perform the bundle loading process by the getBundle factory methods that take a ResourceBundle.You can implement your own subclass in order to enable non-standard resource bundle formats, change the search strategy, or define caching parameters.For the getBundle factory methods that take no ResourceBundle.Control instance, their default behavior of resource bundle loading can be modified with installed ResourceBundleControlProvider implementations.Any installed providers are detected at the ResourceBundle class loading time.If any of the providers provides a ResourceBundle.Control will be used instead of the default ResourceBundle.If there is more than one service provider installed for supporting the same base name, the first one returned from ServiceLoader will be used.Cache Management Resource bundle instances created by the getBundle factory methods are cached by default, and the factory methods return the same resource bundle instance multiple times if it has been cached.getBundle clients may clear the cache, manage the lifetime of cached resource bundle instances using time-to-live values, or specify not to cache resource bundle instances.The following is a very simple example of a ResourceBundle subclass, MyResources, that manages two resources (for a larger number of resources you would probably use a Map).Notice that you don't need to supply a value if a \"parent-level\" ResourceBundle handles the same key with the same value (as for the okKey below).(English language, United States) public class MyResources extends ResourceBundle { public Object handleGetObject(String key) { if (key.equals(\"okKey\")) return \"Ok\"; if (key.equals(\"cancelKey\")) return \"Cancel\"; return null; } public Enumeration<String> getKeys() { return Collections.enumeration(keySet()); } //Overrides handleKeySet() so that the getKeys() implementation // can rely on the keySet() value.handleKeySet() { return new HashSet<String>(Arrays.asList(\"okKey\", \"cancelKey\")); } } // German language public class MyResources_de extends MyResources { public Object{ // don't need okKey, since parent level handles it.handleKeySet() { return new HashSet<String>(Arrays.asList(\"cancelKey\")); } } You do not have to restrict yourself to using a single family of ResourceBundles.For example, you could have a set of bundles for exception messages, ExceptionResources (ExceptionResources_fr, ExceptionResources_de, ...), and one for widgets, WidgetResource (WidgetResources_fr, WidgetResources_de, ...); breaking up the resources however you like."},
{"description": "Class ResolutionSyntax is an abstract base class providing the common implementation of all attributes denoting a printer resolution.A resolution attribute's value consists of two items, the cross feed direction resolution and the feed direction resolution.A resolution attribute may be constructed by supplying the two values and indicating the units in which the values are measured.Methods are provided to return a resolution attribute's values, indicating the units in which the values are to be returned.The two most common resolution units are dots per inch (dpi) and dots per centimeter (dpcm), and exported constants DPI and DPCM are provided for indicating those units.Design A resolution attribute's cross feed direction resolution and feed direction resolution values are stored internally using units of dots per 100 inches (dphi).Storing the values in dphi rather than, say, metric units allows precise integer arithmetic conversions between dpi and dphi and between dpcm and dphi: 1 dpi =Thus, the values can be stored into and retrieved back from a resolution attribute in either units with no loss of precision.However, roundoff error will in general occur if a resolution attribute's values are created in one units and retrieved in different units; for example, 600 dpi will be rounded to 236 dpcm, whereas the true value (to five figures) is 236.22 dpcm.Storing the values internally in common units of dphi lets two resolution attributes be compared without regard to the units in which they were created; for example, 300 dpcm will compare equal to 762 dpi, as they both are stored as 76200 dphi.In particular, a lookup service can match resolution attributes based on equality of their serialized representations regardless of the units in which they were created.Again, using integers for internal storage allows precise equality comparisons to be done, which would not be guaranteed if a floating point representation were used.The exported constant DPI is actually the conversion factor by which to multiply a value in dpi to get the value in dphi.Likewise, the exported constant DPCM is the conversion factor by which to multiply a value in dpcm to get the value in dphi.A client can specify a resolution value in units other than dpi or dpcm by supplying its own conversion factor.However, since the internal units of dphi was chosen with supporting only the external units of dpi and dpcm in mind, there is no guarantee that the conversion factor for the client's units will be an exact integer.If the conversion factor isn't an exact integer, resolution values in the client's units won't be stored precisely."},
{"description": "This class is the implementation of a ModelMBean.An appropriate implementation of a ModelMBean must be shipped with every JMX Agent and the class must be named RequiredModelMBean.Java resources wishing to be manageable instantiate the RequiredModelMBean using the MBeanServer's createMBean method.The resource then sets the MBeanInfo and Descriptors for the RequiredModelMBean instance.The attributes and operations exposed via the ModelMBeanInfo for the ModelMBean are accessible from MBeans, connectors/adaptors like other MBeans.This mapping can be defined in an XML formatted file or dynamically and programmatically at runtime.Every RequiredModelMBean which is instantiated in the MBeanServer becomes manageable: its attributes and operations become remotely accessible through the connectors/adaptors connected to that MBeanServer.A Java object cannot be registered in the MBeanServer unless it is a JMX compliant MBean.By instantiating a RequiredModelMBean, resources are guaranteed that the MBean is valid.MBeanException and RuntimeOperationsException must be thrown on every public method.This allows for wrapping exceptions from distributed communications (RMI, EJB, etc.)"},
{"description": "This class represents the result of resolution of a name.It contains the object to which name was resolved, and the portion of the name that has not been resolved.A ResolveResult instance is not synchronized against concurrent multithreaded access.Multiple threads trying to access and modify a single ResolveResult instance should lock the object."},
{"description": "This interface represents an \"intermediate context\" for name resolution.The Resolver interface contains methods that are implemented by contexts that do not support subtypes of Context, but which can act as intermediate contexts for resolution purposes.A Name parameter passed to any method is owned by the caller.The service provider will not modify the object or keep a reference to it.A ResolveResult object returned by any method is owned by the caller.The caller may subsequently modify it; the service provider may not."},
{"description": "This class performs a pixel-by-pixel rescaling of the data in the source image by multiplying the sample values for each pixel by a scale factor and then adding an offset.The scaled sample values are clipped to the minimum/maximum representable in the destination image.The pseudo code for the rescaling operation is as follows: for each pixel from Source object { for each band/component of the pixel { dstElement = (srcElement*scaleFactor) + offset }} For Rasters, rescaling operates on bands.The number of sets of scaling constants may be one, in which case the same constants are applied to all bands, or it must equal the number of Source Raster bands.The number of sets of scaling constants may be one, in which case the same constants are applied to all color (but not alpha) components.Otherwise, the number of sets of scaling constants may equal the number of Source color components, in which case no rescaling of the alpha component (if present) is performed.If neither of these cases apply, the number of sets of scaling constants must equal the number of Source color components plus alpha components, in which case all color and alpha components are rescaled.BufferedImage sources with premultiplied alpha data are treated in the same manner as non-premultiplied images for purposes of rescaling.That is, the rescaling is done per band on the raw data of the BufferedImage source without regard to whether the data is premultiplied.If a color conversion is required to the destination ColorModel, the premultiplied state of both source and destination will be taken into account for this step.Images with an IndexColorModel cannot be rescaled.If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used when color conversion is required.Note that in-place operation is allowed (i.e. the source and destination can be the same object)."},
{"description": "Parsing a text string occurs in two phases.Phase 1 is a basic text parse according to the fields added to the builder.Phase 2 resolves the parsed field-value pairs into date and/or time objects.This style is used to control how phase 2, resolving, happens."},
{"description": "The RequestProcessingPolicyValue can have the following values.If the Object Id is not found in the Active Object Map, an OBJECT_NOT_EXIST exception is returned to the client.USE_DEFAULT_SERVANT - If the Object Id is not found in the Active Object Map or the NON_RETAIN policy is present, and a default servant has been registered with the POA using the set_servant operation, the request is dispatched to the default servant.If the Object Id is not found in the Active Object Map or the NON_RETAIN policy is present, and a servant manager has been registered with the POA using the set_servant_manager operation, the servant manager is given the opportunity to locate a servant or raise an exception."},
{"description": "This policy specifies how requests are processed by the created POA."},
{"description": "This policy specifies how requests are processed by the created POA."},
{"description": "Each interception point is given an object through which the Interceptor can access request information.Client-side and server-side interception points are concerned with different information, so there are two information objects: ClientRequestInfo is passed to the client-side interception points and ServerRequestInfo is passed to the server-side interception points.But there is information that is common to both, so they both inherit from a common interface: RequestInfo."},
{"description": "Each interception point is given an object through which the Interceptor can access request information.Client-side and server-side interception points are concerned with different information, so there are two information objects: ClientRequestInfo is passed to the client-side interception points and ServerRequestInfo is passed to the server-side interception points.But there is information that is common to both, so they both inherit from a common interface: RequestInfo."},
{"description": "Class RequestingUserName is a printing attribute class, a text attribute, that specifies the name of the end user that submitted the print job.A requesting user name is an arbitrary string defined by the client.The printer does not put the client-specified RequestingUserName attribute into the Print Job's attribute set; rather, the printer puts in a JobOriginatingUserName attribute.This means that services which support specifying a username with this attribute should also report a JobOriginatingUserName in the job's attribute set.Note that many print services may have a way to independently authenticate the user name, and so may state support for a requesting user name, but in practice will then report the user name authenticated by the service rather than that specified via this attribute.IPP Compatibility: The string value gives the IPP name value.The locale gives the IPP natural language.The category name returned by getName() gives the IPP attribute name."},
{"description": "The default value of the localName is the operationName, as defined in WebMethod annotation and the targetNamespace is the target namespace of the SEI.When starting from Java this annotation is used resolve overloading conflicts in document literal mode.Only the className is required in this case."},
{"description": "This class is the cornerstone of the ORB Dynamic Invocation Interface (DII), which allows dynamic creation and invocation of requests.A server cannot tell the difference between a client invocation using a client stub and a request using the DII.A Request object consists of: the name of the operation to be invoked an NVList containing arguments for the operation.Each item in the list is a NamedValue object, which has three parts: the name of the argument the value of the argument (as an Any object) the argument mode flag indicating whether the argument is for input, output, or both Request objects may also contain additional information, depending on how an operation was defined in the original IDL interface definition.For example, where appropriate, they may contain a NamedValue object to hold the return value or exception, a context, a list of possible exceptions, and a list of context strings that need to be resolved.New Request objects are created using one of the create_request methods in the Object class.In other words, a create_request method is performed on the object which is to be invoked."},
{"description": "This class extends the basic ImageFilter Class to scale an existing image and provide a source for a new image containing the resampled image.The pixels in the source image are sampled to produce pixels for an image of the specified size by replicating rows and columns of pixels to scale up or omitting rows and columns of pixels to scale down.It is meant to be used in conjunction with a FilteredImageSource object to produce scaled versions of existing images.Due to implementation dependencies, there may be differences in pixel values of an image filtered on different platforms."},
{"description": "Instances of this class are immutable and unique which means that tests for matches can be made using the == operator instead of the more expensive equals() method."},
{"description": "The annotation type java.lang.annotation.Repeatable is used to indicate that the annotation type whose declaration it (meta-)annotates is repeatable.The value of @Repeatable indicates the containing annotation type for the repeatable annotation type."},
{"description": "The RenderingHints class defines and manages collections of keys and associated values which allow an application to provide input into the choice of algorithms used by other classes which perform rendering and image manipulation services.The Graphics2D class, and classes that implement BufferedImageOp and RasterOp all provide methods to get and possibly to set individual or groups of RenderingHints keys and their associated values.When those implementations perform any rendering or image manipulation operations they should examine the values of any RenderingHints that were requested by the caller and tailor the algorithms used accordingly and to the best of their ability.Note that since these keys and values are hints, there is no requirement that a given implementation supports all possible choices indicated below or that it can respond to requests to modify its choice of algorithm.The values of the various hint keys may also interact such that while all variants of a given key are supported in one situation, the implementation may be more restricted when the values associated with other keys are modified.For example, some implementations may be able to provide several types of dithering when the antialiasing hint is turned off, but have little control over dithering when antialiasing is on.The full set of supported keys and hints may also vary by destination since runtimes may use different underlying modules to render to the screen, or to BufferedImage objects, or while printing.Implementations are free to ignore the hints completely, but should try to use an implementation algorithm that is as close as possible to the request.If an implementation supports a given algorithm when any value is used for an associated hint key, then minimally it must do so when the value for that key is the exact value that specifies the algorithm.The keys used to control the hints are all special values that subclass the associated RenderingHints.Many common hints are expressed below as static constants in this class, but the list is not meant to be exhaustive.Other hints may be created by other packages by defining new objects which subclass the Key class and defining the associated values."},
{"description": "The RenderedImageFactory interface (often abbreviated RIF) is intended to be implemented by classes that wish to act as factories to produce different renderings, for example by executing a series of BufferedImageOps on a set of sources, depending on a specific set of parameters, properties, and rendering hints."},
{"description": "The RemoteServer class is the common superclass to server implementations and provides the framework to support a wide range of remote reference semantics.Specifically, the functions needed to create and export remote objects (i.e. to make them remotely available) are provided abstractly by RemoteServer and concretely by its subclass(es)."},
{"description": "This class handles the renderable aspects of an operation with help from its associated instance of a ContextualRenderedImageFactory."},
{"description": "RenderedImage is a common interface for objects which contain or can produce image data in the form of Rasters.The image data may be stored/produced as a single tile or a regular array of tiles."},
{"description": "An adapter class that implements ImageProducer to allow the asynchronous production of a RenderableImage.The size of the ImageConsumer is determined by the scale factor of the usr2dev transform in the RenderContext.If the RenderContext is null, the default rendering of the RenderableImage is used.This class implements an asynchronous production that produces the image in one thread at one resolution.This class may be subclassed to implement versions that will render the image using several threads.These threads could render either the same image at progressively better quality, or different sections of the image at a single resolution."},
{"description": "A RenderableImage is a common interface for rendering-independent images (a notion which subsumes resolution independence).That is, images which are described and have operations applied to them independent of any specific rendering of the image.For example, a RenderableImage can be rotated and cropped in resolution-independent terms.Then, it can be rendered for various specific contexts, such as a draft preview, a high-quality screen display, or a printer, each in an optimal fashion.A RenderedImage is returned from a RenderableImage via the createRendering() method, which takes a RenderContext.Note that it is not possible to extract pixels directly from a RenderableImage.The createDefaultRendering() and createScaledRendering() methods are convenience methods that construct an appropriate RenderContext internally.All of the rendering methods may return a reference to a previously produced rendering."},
{"description": "A RenderContext encapsulates the information needed to produce a specific rendering from a RenderableImage.It contains the area to be rendered specified in rendering-independent terms, the resolution at which the rendering is to be performed, and hints used to control the rendering process.Users create RenderContexts and pass them to the RenderableImage via the createRendering method.Most of the methods of RenderContexts are not meant to be used directly by applications, but by the RenderableImage and operator classes to which it is passed.The AffineTransform parameter passed into and out of this class are cloned.Altering RenderingHints or Shape instances that are in use by instances of RenderContext may have undesired side effects."},
{"description": "This invocation handler can be used in conjunction with a dynamic proxy instance as a replacement for a pregenerated stub class.Applications are not expected to use this class directly.A remote object exported to use a dynamic proxy with UnicastRemoteObject or Activatable has an instance of this class as that proxy's invocation handler."},
{"description": "This class manages repaint requests, allowing the number of repaints to be minimized, for example by collapsing multiple requests into a single repaint for members of a component tree.Any calls to repaint on one of these will call into the appropriate addDirtyRegion method."},
{"description": "A RemoteException is the common superclass for a number of communication-related exceptions that may occur during the execution of a remote method call.Each method of a remote interface, an interface that extends java.rmi.Remote, must list RemoteException in its throws clause.As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.The \"wrapped remote exception\" that may be provided at construction time and accessed via the public detail field is now known as the cause, and may be accessed via the Throwable.getCause() method, as well as the aforementioned \"legacy field.\"Invoking the method Throwable.initCause(Throwable) on an instance of RemoteException always throws IllegalStateException."},
{"description": "The RemoteObject class implements the java.lang.Object behavior for remote objects.RemoteObject provides the remote semantics of Object by implementing methods for hashCode, equals, and toString."},
{"description": "RemoteRef represents the handle for a remote object.A RemoteStub uses a remote reference to carry out a remote method invocation to a remote object."},
{"description": "The Remote interface serves to identify interfaces whose methods may be invoked from a non-local virtual machine.Any object that is a remote object must directly or indirectly implement this interface.Only those methods specified in a \"remote interface\", an interface that extends java.rmi.Remote are available remotely.Implementation classes can implement any number of remote interfaces and can extend other remote implementation classes.RMI provides some convenience classes that remote object implementations can extend which facilitate remote object creation.These classes are java.rmi.server.UnicastRemoteObject and java.rmi.activation.Activatable.For complete details on RMI, see the RMI Specification which describes the RMI API and system."},
{"description": "This class is used for reporting locate forward exceptions and object forwardGIOP messages back to the ORB.In this case the ORB must remarshal the requestbefore trying again.Stubs which use the stream-based model shall catch the RemarshalExceptionwhich is potentially thrown from the _invoke() method of ObjectImpl.Upon catching the exception, the stub shall immediately remarshal the request by calling_request(), marshalling the arguments (if any), and then calling_invoke().The stub shall repeat this process until _invoke()returns normally or raises some exception other than RemarshalException."},
{"description": "A RelationTypeSupport object implements the RelationType interface.It represents a relation type, providing role information for each role expected to be supported in every relation of that type.A relation type includes a relation type name and a list of role infos (represented by RoleInfo objects).A relation type has to be declared in the Relation Service: - either using the createRelationType() method, where a RelationTypeSupport object will be created and kept in the Relation Service - either using the addRelationType() method where the user has to create an object implementing the RelationType interface, and this object will be used as representing a relation type in the Relation Service.The serialVersionUID of this class is 4611072955724144607L."},
{"description": "This exception is raised when there is no relation type with given name in Relation Service."},
{"description": "The RelationType interface has to be implemented by any class expected to represent a relation type."},
{"description": "A RelationSupport object is used internally by the Relation Service to represent simple relations (only roles, no properties or methods), with an unlimited number of roles, of any relation type.As internal representation, it is not exposed to the user.RelationSupport class conforms to the design patterns of standard MBean.So the user can decide to instantiate a RelationSupport object himself as a MBean (as it follows the MBean design patterns), to register it in the MBean Server, and then to add it in the Relation Service.The user can also, when creating his own MBean relation class, have it extending RelationSupport, to retrieve the implementations of required interfaces (see below).It is also possible to have in a user relation MBean class a member being a RelationSupport object, and to implement the required interfaces by delegating all to this member.RelationSupport implements the Relation interface (to be handled by the Relation Service)."},
{"description": "A RelationSupport object is used internally by the Relation Service to represent simple relations (only roles, no properties or methods), with an unlimited number of roles, of any relation type.As internal representation, it is not exposed to the user.RelationSupport class conforms to the design patterns of standard MBean.So the user can decide to instantiate a RelationSupport object himself as a MBean (as it follows the MBean design patterns), to register it in the MBean Server, and then to add it in the Relation Service.The user can also, when creating his own MBean relation class, have it extending RelationSupport, to retrieve the implementations of required interfaces (see below).It is also possible to have in a user relation MBean class a member being a RelationSupport object, and to implement the required interfaces by delegating all to this member.RelationSupport implements the Relation interface (to be handled by the Relation Service).It implements also the MBeanRegistration interface to be able to retrieve the MBean Server where it is registered (if registered as a MBean) to access to its Relation Service."},
{"description": "The Relation Service is in charge of creating and deleting relation types and relations, of handling the consistency and of providing query mechanisms."},
{"description": "This exception is raised when an access is done to the Relation Service and that one is not registered."},
{"description": "The Relation Service is in charge of creating and deleting relation types and relations, of handling the consistency and of providing query mechanisms.It implements the NotificationBroadcaster by extending NotificationBroadcasterSupport to send notifications when a relation is removed from it.It implements the NotificationListener interface to be able to receive notifications concerning unregistration of MBeans referenced in relation roles and of relation MBeans.It implements the MBeanRegistration interface to be able to retrieve its ObjectName and MBean Server."},
{"description": "This interface has to be implemented by any MBean class expected to represent a relation managed using the Relation Service.Simple relations, i.e. having only roles, no properties or methods, can be created directly by the Relation Service (represented as RelationSupport objects, internally handled by the Relation Service).If the user wants to represent more complex relations, involving properties and/or methods, he has to provide his own class implementing the Relation interface.This can be achieved either by inheriting from RelationSupport class, or by implementing the interface (fully or delegation to a RelationSupport object member).Specifying such user relation class is to introduce properties and/or methods.Those have to be exposed for remote management.So this means that any user relation class must be a MBean class."},
{"description": "A RelationNotification notification is sent when a relation is created via the Relation Service, or an MBean is added as a relation in the Relation Service, or a role is updated in a relation, or a relation is removed from the Relation Service.The serialVersionUID of this class is -6871117877523310399L."},
{"description": "A handler for tasks that cannot be executed by a ThreadPoolExecutor."},
{"description": "This class is the superclass of any exception which can be raised during relation management."},
{"description": "Exception thrown by an Executor when a task cannot be accepted for execution."},
{"description": "This exception is raised when there is no relation for a given relationid in a Relation Service."},
{"description": "Registry is a remote interface to a simple remote object registry that provides methods for storing and retrieving remote object references bound with arbitrary string names.The bind, unbind, and rebind methods are used to alter the name bindings in the registry, and the lookup and list methods are used to query the current name bindings.In its typical usage, a Registry enables RMI client bootstrapping: it provides a simple means for a client to obtain an initial reference to a remote object.Therefore, a registry's remote object implementation is typically exported with a well-known address, such as with a well-known ObjID and TCP port number (default is 1099).The LocateRegistry class provides a programmatic API for constructing a bootstrap reference to a Registry at a remote address (see the static getRegistry methods) and for creating and exporting a Registry in the current VM on a particular local address (see the static createRegistry methods).A Registry implementation may choose to restrict access to some or all of its methods (for example, methods that mutate the registry's bindings may be restricted to calls originating from the local host).If a Registry method chooses to deny access for a given invocation, its implementation may throw AccessException, which (because it extends RemoteException) will be wrapped in a ServerException when caught by a remote client.The names used for bindings in a Registry are pure strings, not parsed.A service which stores its remote reference in a Registry may wish to use a package name as a prefix in the name binding to reduce the likelihood of name collisions in the registry."},
{"description": "This exception is thrown by credentials implementing the Refreshable interface when the refresh method fails."},
{"description": "Objects such as credentials may optionally implement this interface to provide the capability to refresh itself.For example, a credential with a particular time-restricted lifespan may implement this interface to allow callers to refresh the time period for which it is valid."},
{"description": "A component may support one or more regions.Specific component regions are defined by the typesafe enumeration in this class.Regions are typically used as a way to identify the Components and areas a particular style is to apply to.Synth's file format allows you to bind styles based on the name of a Region.The name is derived from the field name of the constant: Map all characters to lowercase.Map the first character after underscores to uppercase.For example, to identify the SPLIT_PANE Region you would use SplitPane.The following shows a custom SynthStyleFactory that returns a specific style for split panes: public SynthStyle getStyle(JComponent c, Region id) {} The following xml accomplishes the same thing: <style id=\"splitPaneStyle"},
{"description": "This abstract class is used to represent a referral exception, which is generated in response to a referral such as that returned by LDAP v3 servers.A service provider provides a subclass of ReferralException by providing implementations for getReferralInfo() and getReferralContext() (and appropriate constructors and/or corresponding \"set\" methods).while (true) { try { bindings = ctx.listBindings(name); while (bindings.hasMore()) { b = bindings.next(); ... } break; } catch (ReferralException e) { ctx = e.getReferralContext(); } } ReferralException is an abstract class.Concrete implementations determine its synchronization and serialization properties.An environment parameter passed to the getReferralContext() method is owned by the caller.The service provider will not modify the object or keep a reference to it, but may keep a reference to a clone of it."},
{"description": "The following table provides a summary description of what the permission allows, and discusses the risks of granting code the permission.What the Permission Allows Risks of Allowing this Permission suppressAccessChecks ability to suppress the standard Java language access checks on fields and methods in a class; allow access not only public members but also allow access to default (package) access, protected, and private members.This is dangerous in that information (possibly confidential) and methods normally unavailable would be accessible to malicious code.This gives code access to classes in packages to which it normally does not have access and the dynamic proxy class is in the system protection domain.Malicious code may use these classes to help in its attempt to compromise security in the system."},
{"description": "An optional interface that may be provided by service provider objects that will be registered with a ServiceRegistry.If this interface is present, notification of registration and deregistration will be performed."},
{"description": "It \"wraps\" the actual java.lang.Exception thrown."},
{"description": "The mapping in the Java programming language of an SQL REF value, which is a reference to an SQL structured type value in the database.SQL REF values are stored in a table that contains instances of a referenceable SQL structured type, and each REF value is a unique identifier for one instance in that table.An SQL REF value may be used in place of the SQL structured type it references, either as a column value in a table or an attribute value in a structured type.Because an SQL REF value is a logical pointer to an SQL structured type, a Ref object is by default also a logical pointer.Thus, retrieving an SQL REF value as a Ref object does not materialize the attributes of the structured type on the client.A Ref object can be stored in the database using the PreparedStatement.setRef method.All methods on the Ref interface must be fully implemented if the JDBC driver supports the data type."},
{"description": "This class has the following properties: Acquisition order This class does not impose a reader or writer preference ordering for lock access.However, it does support an optional fairness policy.Non-fair mode (default) When constructed as non-fair (the default), the order of entry to the read and write lock is unspecified, subject to reentrancy constraints.A nonfair lock that is continuously contended may indefinitely postpone one or more reader or writer threads, but will normally have higher throughput than a fair lock.Fair mode When constructed as fair, threads contend for entry using an approximately arrival-order policy.When the currently held lock is released, either the longest-waiting single writer thread will be assigned the write lock, or if there is a group of reader threads waiting longer than all waiting writer threads, that group will be assigned the read lock.A thread that tries to acquire a fair read lock (non-reentrantly) will block if either the write lock is held, or there is a waiting writer thread.The thread will not acquire the read lock until after the oldest currently waiting writer thread has acquired and released the write lock.Of course, if a waiting writer abandons its wait, leaving one or more reader threads as the longest waiters in the queue with the write lock free, then those readers will be assigned the read lock.A thread that tries to acquire a fair write lock (non-reentrantly) will block unless both the read lock and write lock are free (which implies there are no waiting threads).(Note that the non-blocking ReentrantReadWriteLock.ReadLock.tryLock() and ReentrantReadWriteLock.WriteLock.tryLock() methods do not honor this fair setting and will immediately acquire the lock if it is possible, regardless of waiting threads.)This lock allows both readers and writers to reacquire read or write locks in the style of a ReentrantLock.Non-reentrant readers are not allowed until all write locks held by the writing thread have been released.Additionally, a writer can acquire the read lock, but not vice-versa.Among other applications, reentrancy can be useful when write locks are held during calls or callbacks to methods that perform reads under read locks.If a reader tries to acquire the write lock it will never succeed.Lock downgrading Reentrancy also allows downgrading from the write lock to a read lock, by acquiring the write lock, then the read lock and then releasing the write lock.However, upgrading from a read lock to the write lock is not possible.Condition support The write lock provides a Condition implementation that behaves in the same way, with respect to the write lock, as the Condition implementation provided by ReentrantLock.newCondition() does for ReentrantLock.This Condition can, of course, only be used with the write lock.The read lock does not support a Condition and readLock().newConditionThis class supports methods to determine whether locks are held or contended.These methods are designed for monitoring system state, not for synchronization control.Serialization of this class behaves in the same way as built-in locks: a deserialized lock is in the unlocked state, regardless of its state when serialized.Here is a code sketch showing how to perform lock downgrading after updating a cache (exception handling is particularly tricky when handling multiple locks in a non-nested fashion):Must release read lock before acquiring write lock rwl.readLock().unlock(); rwl.writeLock().lock(); try { // Recheck state because another thread might have // acquired write lock and changed state before we did.(); } finally { rwl.writeLock().unlock(); // Unlock write, still hold read } } try { use(data); } finally { rwl.readLock().unlock(); } } } ReentrantReadWriteLocks can be used to improve concurrency in some uses of some kinds of Collections.This is typically worthwhile only when the collections are expected to be large, accessed by more reader threads than writer threads, and entail operations with overhead that outweighs synchronization overhead.For example, here is a class using a TreeMap that is expected to be large and concurrently accessed.{ r.lock(); try { return m.get(key); } finally { r.unlock(); } } public String[] allKeys() { r.lock(); try { return m.keySet().toArray(); } finally { r.unlock(); } } public Data put(String key, Data value) { w.lock(); try { return m.put(key, value); } finally { w.unlock(); } } public void clear() { w.lock(); try { m.clear(); } finally { w.unlock(); } } } Implementation Notes This lock supports a maximum of 65535 recursive write locks and 65535 read locks.Attempts to exceed these limits result in Error throws from locking methods."},
{"description": "A ReentrantLock is owned by the thread last successfully locking, but not yet unlocking it.A thread invoking lock will return, successfully acquiring the lock, when the lock is not owned by another thread.The method will return immediately if the current thread already owns the lock.This can be checked using methods isHeldByCurrentThread(), and getHoldCount().The constructor for this class accepts an optional fairness parameter.Otherwise this lock does not guarantee any particular access order.Programs using fair locks accessed by many threads may display lower overall throughput (i.e., are slower; often much slower) than those using the default setting, but have smaller variances in times to obtain locks and guarantee lack of starvation.Note however, that fairness of locks does not guarantee fairness of thread scheduling.Thus, one of many threads using a fair lock may obtain it multiple times in succession while other active threads are not progressing and not currently holding the lock.Also note that the untimed tryLock() method does not honor the fairness setting.It is recommended practice to always immediately follow a call to lock with a try block, most typically in a before/after construction such as: class X { private final ReentrantLock lock = new ReentrantLock();// block until condition holds try { // ... method body } finally { lock.unlock() } }In addition to implementing the Lock interface, this class defines a number of public and protected methods for inspecting the state of the lock.Some of these methods are only useful for instrumentation and monitoring.Serialization of this class behaves in the same way as built-in locks: a deserialized lock is in the unlocked state, regardless of its state when serialized.This lock supports a maximum of 2147483647 recursive locks by the same thread.Attempts to exceed this limit result in Error throws from locking methods."},
{"description": "RectangularShape is the base class for a number of Shape objects whose geometry is defined by a rectangular frame.This class does not directly specify any specific geometry by itself, but merely provides manipulation methods inherited by a whole category of Shape objects.The manipulation methods provided by this class can be used to query and modify the rectangular frame, which provides a reference for the subclasses to define their geometry."},
{"description": "The Float class defines a rectangle specified in float coordinates."},
{"description": "The Double class defines a rectangle specified in double coordinates."},
{"description": "For a classic example, here is a task computing Fibonacci numbers: class Fibonacci extends RecursiveTask<Integer> { final int n; Fibonacci(int n); } } However, besides being a dumb way to compute Fibonacci functions (there is a simple fast linear algorithm that you'd use in practice), this is likely to perform poorly because the smallest subtasks are too small to be worthwhile splitting up.Instead, as is the case for nearly all fork/join applications, you'd pick some minimum granularity size (for example 10 here) for which you always sequentially solve rather than subdividing."},
{"description": "This class establishes conventions to parameterize resultless actions as Void ForkJoinTasks.Because null is the only valid value of type Void, methods such as join always return null upon completion.Here is a simple but complete ForkJoin sort that sorts a given long[] array:static class SortTask extends RecursiveAction { final long[] array; final int lo, hi; SortTask(longinvokeAll(new SortTask(array, lo, mid), new SortTask(array, mid, hi)); merge(lo, mid, hi); } } // implementation details follow: static final int THRESHOLD = 1000; void sortSequentially(int lo, int hi) { Arrays.sort(array, lo, hi); } void merge(int lo, int mid, int hi) { long[] buf =Arrays.copyOfRange(array, lo, mid); for (int i = 0, j = lo, k = mid; i < buf.length; j++) array[j] =buf[i++] : array[k++]; } } You could then sort anArray by creating new SortTask(anArray) and invoking it in a ForkJoinPool.As a more concrete simple example, the following task increments each element of an array: class IncrementTask extends RecursiveAction { final long[] array; final int lo, hi; IncrementTask(long[] array, int lo, int hi) { this.array = array; this.lo = lo; this.hi = hi; } protected void compute() { if (hi - lo < THRESHOLD) { for (int i = lo;>> 1; invokeAll(new IncrementTask(array, lo, mid), new IncrementTask(array, mid, hi)); } } } The following example illustrates some refinements and idioms that may lead to better performance: RecursiveActions need not be fully recursive, so long as they maintain the basic divide-and-conquer approach.Here is a class that sums the squares of each element of a double array, by subdividing out only the right-hand-sides of repeated divisions by two, and keeping track of them with a chain of next references.It uses a dynamic threshold based on method getSurplusQueuedTaskCount, but counterbalances potential excess partitioning by directly performing leaf actions on unstolen tasks rather than further subdividing.} class Applyer extends RecursiveAction { final double[] array; final int lo, hi; double result; Applyer next; // keeps track of right-hand-side tasks Applyer(double; } double atLeaf(int l, int h) { double sum = 0; for (int i = l; i < h; ++i) // perform leftmost base step sum += array[i]else { right.join(); sum += right.result; } right = right.next; } result = sum; } }"},
{"description": "The Rectangle2D class describes a rectangle defined by a location (x,y) and dimension (w x h).This class is only the abstract superclass for all objects that store a 2D rectangle.The actual storage representation of the coordinates is left to the subclass."},
{"description": "A Rectangle specifies an area in a coordinate space that is enclosed by the Rectangle object's upper-left point (x,y) in the coordinate space, its width, and its height.A Rectangle object's width and height are public fields.The constructors that create a Rectangle, and the methods that can modify one, do not prevent setting a negative value for width or height.A Rectangle whose width or height is exactly zero has location along those axes with zero dimension, but is otherwise considered empty.The isEmpty() method will return true for such a Rectangle.Methods which test if an empty Rectangle contains or intersects a point or rectangle will always return false if either dimension is zero.Methods which combine such a Rectangle with a point or rectangle will include the location of the Rectangle on that axis in the result as if the add(Point) method were being called.A Rectangle whose width or height is negative has neither location nor dimension along those axes with negative dimensions.Such a Rectangle is treated as non-existant along those axes.Such a Rectangle is also empty with respect to containment calculations and methods which test if it contains or intersects a point or rectangle will always return false.Methods which combine such a Rectangle with a point or rectangle will ignore the Rectangle entirely in generating the result.If two Rectangle objects are combined and each has a negative dimension, the result will have at least one negative dimension.Methods which affect only the location of a Rectangle will operate on its location regardless of whether or not it has a negative or zero dimension along either axis.Note that a Rectangle constructed with the default no-argument constructor will have dimensions of 0x0 and therefore be empty.That Rectangle will still have a location of (0,0) and will contribute that location to the union and add operations.Code attempting to accumulate the bounds of a set of points should therefore initially construct the Rectangle with a specifically negative width and height or it should use the first point in the set to construct the Rectangle.For example: Rectangle bounds = new Rectangle(0, 0, -1, -1); for (int i = 0; i < points.length; i++) { bounds.add(points[i]); } or if we know that the points array contains at least one point: Rectangle bounds = new Rectangle(points[0]); for (int i = 1; i < points.length; i++) { bounds.add(points[i]); } This class uses 32-bit integers to store its location and dimensions.Frequently operations may produce a result that exceeds the range of a 32-bit integer.The methods will calculate their results in a way that avoids any 32-bit overflow for intermediate results and then choose the best representation to store the final results back into the 32-bit fields which hold the location and dimensions.The location of the result will be stored into the x and y fields by clipping the true result to the nearest 32-bit value.The values stored into the width and height dimension fields will be chosen as the 32-bit values that encompass the largest part of the true result as possible.Generally this means that the dimension will be clipped independently to the range of 32-bit integers except that if the location had to be moved to store it into its pair of 32-bit fields then the dimensions will be adjusted relative to the \"best representation\" of the location.If the true result had a negative dimension and was therefore non-existant along one or both axes, the stored dimensions will be negative numbers in those axes.If the true result had a location that could be represented within the range of 32-bit integers, but zero dimension along one or both axes, then the stored dimensions will be zero in those axes."},
{"description": "A Receiver receives MidiEvent objects and typically does something useful in response, such as interpreting them to generate sound or raw MIDI output.Common MIDI receivers include synthesizers and MIDI Out ports."},
{"description": "Unchecked exception thrown when an attempt is made to read from an asynchronous socket channel and a previous read has not completed."},
{"description": "A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for writing.The read lock may be held simultaneously by multiple reader threads, so long as there are no writers.All ReadWriteLock implementations must guarantee that the memory synchronization effects of writeLock operations (as specified in the Lock interface) also hold with respect to the associated readLock.That is, a thread successfully acquiring the read lock will see all updates made upon previous release of the write lock.A read-write lock allows for a greater level of concurrency in accessing shared data than that permitted by a mutual exclusion lock.It exploits the fact that while only a single thread at a time (a writer thread) can modify the shared data, in many cases any number of threads can concurrently read the data (hence reader threads).In theory, the increase in concurrency permitted by the use of a read-write lock will lead to performance improvements over the use of a mutual exclusion lock.In practice this increase in concurrency will only be fully realized on a multi-processor, and then only if the access patterns for the shared data are suitable.Whether or not a read-write lock will improve performance over the use of a mutual exclusion lock depends on the frequency that the data is read compared to being modified, the duration of the read and write operations, and the contention for the data -that is, the number of threads that will try to read or write the data at the same time.For example, a collection that is initially populated with data and thereafter infrequently modified, while being frequently searched (such as a directory of some kind) is an ideal candidate for the use of a read-write lock.However, if updates become frequent then the data spends most of its time being exclusively locked and there is little, if any increase in concurrency.Further, if the read operations are too short the overhead of the read-write lock implementation (which is inherently more complex than a mutual exclusion lock) can dominate the execution cost, particularly as many read-write lock implementations still serialize all threads through a small section of code.Ultimately, only profiling and measurement will establish whether the use of a read-write lock is suitable for your application.Although the basic operation of a read-write lock is straight-forward, there are many policy decisions that an implementation must make, which may affect the effectiveness of the read-write lock in a given application.Examples of these policies include: Determining whether to grant the read lock or the write lock, when both readers and writers are waiting, at the time that a writer releases the write lock.Reader preference is less common as it can lead to lengthy delays for a write if the readers are frequent and long-lived as expected.Fair, or \"in-order\" implementations are also possible.Determining whether readers that request the read lock while a reader is active and a writer is waiting, are granted the read lock.Preference to the reader can delay the writer indefinitely, while preference to the writer can reduce the potential for concurrency.Determining whether the locks are reentrant: can a thread with the write lock reacquire it?Can it acquire a read lock while holding the write lock?Can the write lock be downgraded to a read lock without allowing an intervening writer?Can a read lock be upgraded to a write lock, in preference to other waiting readers or writers?You should consider all of these things when evaluating the suitability of a given implementation for your application."},
{"description": "This callback is used by SaslClient and SaslServer to retrieve realm information."},
{"description": "REBIND is raised when the current effective RebindPolicy, has a value of NO_REBIND or NO_RECONNECT and an invocation on a bound object reference results in a LocateReply message with status OBJECT_FORWARD or a Reply message with status LOCATION_FORWARD.This exception is also raised if the current effective RebindPolicy has a value of NO_RECONNECT and a connection must be reopened."},
{"description": "This callback is used by SaslClient and SaslServer to obtain a realm given a list of realm choices."},
{"description": "Unchecked exception thrown when an attempt is made to update an object associated with a read-only FileSystem."},
{"description": "The only methods that a subclass must implement are read(char[], int, int) and close().Most subclasses, however, will override some of the methods defined here in order to provide higher efficiency, additional functionality, or both."},
{"description": "A channel that can read bytes.Only one read operation upon a readable channel may be in progress at any given time.If one thread initiates a read operation upon a channel then any other thread that attempts to initiate another read operation will block until the first operation is complete.Whether or not other kinds of I/O operations may proceed concurrently with a read operation depends upon the type of the channel."},
{"description": "This class specifies the parameters used with the RC5 algorithm.The parameters consist of a version number, a rounds count, a word size, and optionally an initialization vector (IV) (only in feedback mode).This class can be used to initialize a Cipher object that implements the RC5 algorithm as supplied by RSA Security Inc., or any parties authorized by RSA Security."},
{"description": "A Readable is a source of characters.Characters from a Readable are made available to callers of the read method via a CharBuffer."},
{"description": "This class represents a relative distinguished name, or RDN, which is a component of a distinguished name as specified by RFC 2253.An example of an RDN is \"OU=Sales+CN=J.Smith\".In this example, the RDN consist of multiple attribute type/value pairs.The RDN is parsed as described in the class description for LdapName.The Rdn class represents an RDN as attribute type/value mappings, which can be viewed using Attributes.In addition, it contains convenience methods that allow easy retrieval of type and value when the Rdn consist of a single type/value pair, which is how it appears in a typical usage.It also contains helper methods that allow escaping of the unformatted attribute value and unescaping of the value formatted according to the escaping syntax defined in RFC2253.For methods that take or return attribute value as an Object, the value is either a String (in unescaped form) or a byte array.Rdn will properly parse all valid RDNs, but does not attempt to detect all possible violations when parsing invalid RDNs.It is \"generous\" in accepting invalid RDNs.The \"validity\" of a name is determined ultimately when it is supplied to an LDAP server, which may accept or reject the name based on factors such as its schema information and interoperability considerations.The following code example shows how to construct an Rdn using the constructor that takes type and value as arguments:; The last line will print cn=Juicy\\, Fruit.The unescapeValue() method can be used to unescape the escaped comma resulting in the original value \"Juicy, Fruit\".The escapeValue() method adds the escape back preceding the comma.This class can be instantiated by a string representation of the RDN defined in RFC 2253 as shown in the following code example:Rdn rdn = new Rdn(\"cn=Juicy\\\\, Fruit\"); System.out.println(rdn.toString()); The last line will print cn=Juicy\\, Fruit.Concurrent multithreaded read-only access of an instance of Rdn need not be synchronized.Unless otherwise noted, the behavior of passing a null argument to a constructor or method in this class will cause NullPointerException to be thrown."},
{"description": "Unchecked exception thrown when a content-mutation method such as put or compact is invoked upon a read-only buffer."},
{"description": "This class specifies the parameters used with the RC2 algorithm.The parameters consist of an effective key size and optionally an 8-byte initialization vector (IV) (only in feedback mode).This class can be used to initialize a Cipher object that implements the RC2 algorithm."},
{"description": "This interface describes single-input/single-output operations performed on Raster objects.It is implemented by such classes as AffineTransformOp, ConvolveOp, and LookupOp.The Source and Destination objects must contain the appropriate number of bands for the particular classes implementing this interface.This interface cannot be used to describe more sophisticated Ops such as ones that take multiple sources.Each class implementing this interface will specify whether or not it will allow an in-place filtering operation (i.e. source object equal to the destination object).Note that the restriction to single-input operations means that the values of destination pixels prior to the operation are not used as input to the filter operation."},
{"description": "The RasterFormatException is thrown if there is invalid layout information in the Raster."},
{"description": "A Raster encapsulates a DataBuffer that stores the sample values and a SampleModel that describes how to locate a given sample value in a DataBuffer.A Raster defines values for pixels occupying a particular rectangular area of the plane, not necessarily including (0, 0).The rectangle, known as the Raster's bounding rectangle and available by means of the getBounds method, is defined by minX, minY, width, and height values.The minX and minY values define the coordinate of the upper left corner of the Raster.References to pixels outside of the bounding rectangle may result in an exception being thrown, or may result in references to unintended elements of the Raster's associated DataBuffer.It is the user's responsibility to avoid accessing such pixels.A SampleModel describes how samples of a Raster are stored in the primitive array elements of a DataBuffer.Samples may be stored one per data element, as in a PixelInterleavedSampleModel or BandedSampleModel, or packed several to an element, as in a SinglePixelPackedSampleModel or MultiPixelPackedSampleModel.The SampleModel is also controls whether samples are sign extended, allowing unsigned data to be stored in signed Java data types such as byte, short, and int.Although a Raster may live anywhere in the plane, a SampleModel makes use of a simple coordinate system that starts at (0, 0).A Raster therefore contains a translation factor that allows pixel locations to be mapped between the Raster's coordinate system and that of the SampleModel.The translation from the SampleModel coordinate system to that of the Raster may be obtained by the getSampleModelTranslateX and getSampleModelTranslateY methods.A Raster may share a DataBuffer with another Raster either by explicit construction or by the use of the createChild and createTranslatedChild methods.Rasters created by these methods can return a reference to the Raster they were created from by means of the getParent method.For a Raster that was not constructed by means of a call to createTranslatedChild or createChild, getParent will return null.The createTranslatedChild method returns a new Raster that shares all of the data of the current Raster, but occupies a bounding rectangle of the same width and height but with a different starting point.For example, if the parent Raster occupied the region (10, 10) to (100, 100), and the translated Raster was defined to start at (50, 50), then pixel (20, 20) of the parent and pixel (60, 60) of the child occupy the same location in the DataBuffer shared by the two Rasters.In the first case, (-10, -10) should be added to a pixel coordinate to obtain the corresponding SampleModel coordinate, and in the second case (-50, -50) should be added.The translation between a parent and child Raster may be determined by subtracting the child's sampleModelTranslateX and sampleModelTranslateY values from those of the parent.The createChild method may be used to create a new Raster occupying only a subset of its parent's bounding rectangle (with the same or a translated coordinate system) or with a subset of the bands of its parent.The correct way to create a Raster is to use one of the static create methods defined in this class.These methods create instances of Raster that use the standard Interleaved, Banded, and Packed SampleModels and that may be processed more efficiently than a Raster created by combining an externally generated SampleModel and DataBuffer."},
{"description": "The RadialGradientPaint class provides a way to fill a shape with a circular radial color gradient pattern.The user may specify 2 or more gradient colors, and this paint will provide an interpolation between each color.The user must specify the circle controlling the gradient pattern, which is described by a center point and a radius.The user can also specify a separate focus point within that circle, which controls the location of the first color of the gradient.By default the focus is set to be the center of the circle.This paint will map the first color of the gradient to the focus point, and the last color to the perimeter of the circle, interpolating smoothly for any in-between colors specified by the user.Any line drawn from the focus point to the circumference will thus span all the gradient colors.Specifying a focus point outside of the radius of the circle will cause the rings of the gradient pattern to be centered on the point just inside the edge of the circle in the direction of the focus point.The rendering will internally use this modified location as if it were the specified focus point.The user must provide an array of floats specifying how to distribute the colors along the gradient.These values should range from 0.0 to 1.0 and act like keyframes along the gradient (they mark where the gradient should be exactly a particular color).In the event that the user does not set the first keyframe value equal to 0 and/or the last keyframe value equal to 1, keyframes will be created at these positions and the first and last colors will be replicated there.So, if a user specifies the following arrays to construct a gradient: {Color.RED}, {.3f, .7f} this will be converted to a gradient with the following keyframes: {Color.The user may also select what action the RadialGradientPaint object takes when it is filling the space outside the circle's radius by setting CycleMethod to either REFLECTION or REPEAT.The gradient color proportions are equal for any particular line drawn from the focus point.The following figure shows that the distance AB is equal to the distance BC, and the distance AD is equal to the distance DE.If the gradient and graphics rendering transforms are uniformly scaled and the user sets the focus so that it coincides with the center of the circle, the gradient color proportions are equal for any line drawn from the center.The following figure shows the distances AB, BC, AD, and DE.Note that some minor variations in distances may occur due to sampling at the granularity of a pixel.If no cycle method is specified, NO_CYCLE will be chosen by default, which means the the last keyframe color will be used to fill the remaining area.The colorSpace parameter allows the user to specify in which colorspace the interpolation should be performed, default sRGB or linearized RGB.The following code demonstrates typical usage of RadialGradientPaint, where the center and focus points are the same: Point2D center = new Point2D.Float(50, 50); float radius = 25; float[] dist = {0.0f, 0.2f, 1.0f}; Color[] colors = {Color.BLUE}; RadialGradientPaint p = new RadialGradientPaint(center, radius, dist, colors); This image demonstrates the example code above, with default (centered) focus for each of the three cycle methods: It is also possible to specify a non-centered focus point, as in the following code:Point2D center = new Point2D.Float(50, 50); float radius = 25; Point2D focus = new Point2D.Float(40, 40); float[]NO_CYCLE); This image demonstrates the previous example code, with non-centered focus for each of the three cycle methods:"},
{"description": "Class QueuedJobCount is an integer valued printing attribute that indicates the number of jobs in the printer whose JobState is either PENDING, PENDING_HELD, PROCESSING, or PROCESSING_STOPPED.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "A random access file behaves like a large array of bytes stored in the file system.There is a kind of cursor, or index into the implied array, called the file pointer; input operations read bytes starting at the file pointer and advance the file pointer past the bytes read.If the random access file is created in read/write mode, then output operations are also available; output operations write bytes starting at the file pointer and advance the file pointer past the bytes written.Output operations that write past the current end of the implied array cause the array to be extended.The file pointer can be read by the getFilePointer method and set by the seek method.It is generally true of all the reading routines in this class that if end-of-file is reached before the desired number of bytes has been read, an EOFException (which is a kind of IOException) is thrown.If any byte cannot be read for any reason other than end-of-file, an IOException other than EOFException is thrown."},
{"description": "Marker interface used by List implementations to indicate that they support fast (generally constant time) random access.The primary purpose of this interface is to allow generic algorithms to alter their behavior to provide good performance when applied to either random or sequential access lists.The best algorithms for manipulating random access lists (such as ArrayList) can produce quadratic behavior when applied to sequential access lists (such as LinkedList).Generic list algorithms are encouraged to check whether the given list is an instanceof this interface before applying an algorithm that would provide poor performance if it were applied to a sequential access list, and to alter their behavior if necessary to guarantee acceptable performance.It is recognized that the distinction between random and sequential access is often fuzzy.For example, some List implementations provide asymptotically linear access times if they get huge, but constant access times in practice.Such a List implementation should generally implement this interface.As a rule of thumb, a List implementation should implement this interface if, for typical instances of the class, this loop: for (int i=0, n=list.size(); i < n; i++) list.get(i); runs faster than this loop: for (Iterator i=list.iterator(); i.hasNext(); ) i.next(); This interface is a member of the Java Collections Framework."},
{"description": "An instance of this class is used to generate a stream of pseudorandom numbers.The class uses a 48-bit seed, which is modified using a linear congruential formula.(See Donald Knuth, The Art of Computer Programming, Volume 2, Section 3.2.1.)If two instances of Random are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers.In order to guarantee this property, particular algorithms are specified for the class Random.Java implementations must use all the algorithms shown here for the class Random, for the sake of absolute portability of Java code.However, subclasses of class Random are permitted to use other algorithms, so long as they adhere to the general contracts for all the methods.The algorithms implemented by class Random use a protected utility method that on each invocation can supply up to 32 pseudorandomly generated bits.Many applications will find the method Math.random() simpler to use.Instances of java.util.Random are threadsafe.However, the concurrent use of the same java.util.Random instance across threads may encounter contention and consequent poor performance.Instances of java.util.Random are not cryptographically secure."},
{"description": "Besides basic Collection operations, queues provide additional insertion, extraction, and inspection operations.Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation).The latter form of the insert operation is designed specifically for use with capacity-restricted Queue implementations; in most implementations, insert operations cannot fail.Summary of Queue methods Throws exception Returns special value Insert add(e) offer(e)Among the exceptions are priority queues, which order elements according to a supplied comparator, or the elements' natural ordering, and LIFO queues (or stacks) which order the elements LIFO (last-in-first-out).Whatever the ordering used, the head of the queue is that element which would be removed by a call to remove() or poll().In a FIFO queue, all new elements are inserted at the tail of the queue.Other kinds of queues may use different placement rules.Every Queue implementation must specify its ordering properties.The offer method inserts an element if possible, otherwise returning false.This differs from the Collection.add method, which can fail to add an element only by throwing an unchecked exception.The offer method is designed for use when failure is a normal, rather than exceptional occurrence, for example, in fixed-capacity (or \"bounded\") queues.The remove() and poll() methods remove and return the head of the queue.Exactly which element is removed from the queue is a function of the queue's ordering policy, which differs from implementation to implementation.The remove() and poll() methods differ only in their behavior when the queue is empty: the remove() method throws an exception, while the poll() method returns null.The Queue interface does not define the blocking queue methods, which are common in concurrent programming.These methods, which wait for elements to appear or for space to become available, are defined in the BlockingQueue interface, which extends this interface.Queue implementations generally do not allow insertion of null elements, although some implementations, such as LinkedList, do not prohibit insertion of null.Even in the implementations that permit it, null should not be inserted into a Queue, as null is also used as a special return value by the poll method to indicate that the queue contains no elements.Queue implementations generally do not define element-based versions of methods equals and hashCode but instead inherit the identitybased versions from class Object, because element-based equality is not always well-defined for queues with the same elements but different ordering properties.This interface is a member of the Java Collections Framework."},
{"description": "Instances of QueryExp are returned by the static methods of the Query class.It is possible, but not recommended, to create custom queries by implementing this interface.In that case, it is better to extend the QueryEval class than to implement the interface directly, so that the setMBeanServer(javax.management.MBeanServer) method works correctly."},
{"description": "Allows a query to be performed in the context of a specific MBean server."},
{"description": "The MBean Server can be queried for MBeans that meet a particular condition, using its queryNames or queryMBeans method.The QueryExp parameter to the method can be any implementation of the interface QueryExp, but it is usually best to obtain the QueryExp value by calling the static methods in this class.This is particularly true when querying a remote MBean Server: a custom implementation of the QueryExp interface might not be present in the remote MBean Server, but the methods in this class return only standard classes that are part of the JMX implementation.As an example, suppose you wanted to find all MBeans where the Enabled attribute is true and the Owner attribute is \"Duke\".Here is how you could construct the appropriate QueryExp by chaining together method calls:"},
{"description": "A mixin interface for an element that has a qualified name."},
{"description": "The QuadCurve2D class defines a quadratic parametric curve segment in (x,y) coordinate space.This class is only the abstract superclass for all objects that store a 2D quadratic curve segment.The actual storage representation of the coordinates is left to the subclass."},
{"description": "QName represents a qualified name as defined in the XML specifications:The value of a QName contains a Namespace URI, local part and prefix.The prefix is included in QName to retain lexical information when present in an XML input source.The prefix is NOT used in QName.equals(Object) or to compute the QName.hashCode().Equality and the hash code are defined using only the Namespace URI and local part.If not specified, the Namespace URI is set to XMLConstants.If not specified, the prefix is set to XMLConstants."},
{"description": "A character-stream reader that allows characters to be pushed back into the stream."},
{"description": "A PushbackInputStream adds functionality to another input stream, namely the ability to \"push back\" or \"unread\" one byte.This is useful in situations where it is convenient for a fragment of code to read an indefinite number of data bytes that are delimited by a particular byte value; after reading the terminating byte, the code fragment can \"unread\" it, so that the next read operation on the input stream will reread the byte that was pushed back.For example, bytes representing the characters constituting an identifier might be terminated by a byte representing an operator character; a method whose job is to read just an identifier can read until it sees the operator and then push the operator back to be re-read."},
{"description": "This interface contains no methods or constants.It merely serves to group (and provide type safety for) all public key interfaces.Note: The specialized public key interfaces extend this interface."},
{"description": "PUBLIC_MEMBER is one of the two constants of typedef Visibility used in the interface repository to identify visibility of a ValueMember type."},
{"description": "This class specifies a parameter spec for RSA-PSS signature scheme, as defined in the PKCS#1 v2.1 standard.Its ASN.1 definition in PKCS#1 standard is described below: RSASSA-PSS-params ::| { OID id-sha384 PARAMETERS NULL }| { OID id-sha512 PARAMETERS NULL }, ... -- Allows for future expansion -- }DEFAULT uses the following: message digest -- \"SHA-1\" mask generation function (mgf) -- \"MGF1\" parameters for mgf -- MGF1ParameterSpec."},
{"description": "This class specifies the source for encoding input P in OAEP Padding, as defined in the PKCS #1 standard."},
{"description": "This class is used to explicitly specify the value for encoding input P in OAEP Padding."},
{"description": "A proxy selector is a concrete sub-class of this class and is registered by invoking the setDefault method.The currently registered proxy selector can be retrieved by calling getDefault method.When a proxy selector is registered, for instance, a subclass of URLConnection class should call the select method for each URL request so that the proxy selector can decide if a direct, or proxied connection should be used.The select method returns an iterator over a collection with the preferred connection approach.If a connection cannot be established to a proxy (PROXY or SOCKS)servers then the caller should call the proxy selector's connectFailed method to notify the proxy selector that the proxy server is unavailable.The default proxy selector does enforce a set of System Properties related to proxy settings."},
{"description": "This class represents a proxy setting, typically a type (http, socks) and a socket address.A Proxy is an immutable object."},
{"description": "Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods.[] { Foo.class }, handler); A dynamic proxy class (simply referred to as a proxy class below) is a class that implements a list of interfaces specified at runtime when the class is created, with behavior as described below.A proxy interface is such an interface that is implemented by a proxy class.A proxy instance is an instance of a proxy class.Each proxy instance has an associated invocation handler object, which implements the interface InvocationHandler.A method invocation on a proxy instance through one of its proxy interfaces will be dispatched to the invoke method of the instance's invocation handler, passing the proxy instance, a java.lang.reflect.Method object identifying the method that was invoked, and an array of type Object containing the arguments.The invocation handler processes the encoded method invocation as appropriate and the result that it returns will be returned as the result of the method invocation on the proxy instance.A proxy class has the following properties: Proxy classes are public, final, and not abstract if all proxy interfaces are public.Proxy classes are non-public, final, and not abstract if any of the proxy interfaces is non-public.The unqualified name of a proxy class is unspecified.The space of class names that begin with the string \"$Proxy\" should be, however, reserved for proxy classes.A proxy class extends java.lang.reflect.Proxy.exactly the interfaces specified at its creation, in the same order.If a proxy class implements a non-public interface, then it will be defined in the same package as that interface.Otherwise, the package of a proxy class is also unspecified.Note that package sealing will not prevent a proxy class from being successfully defined in a particular package at runtime, and neither will classes already defined by the same class loader and the same package with particular signers.Since a proxy class implements all of the interfaces specified at its creation, invoking getInterfaces on its Class object will return an array containing the same list of interfaces (in the order specified at its creation), invoking getMethods on its Class object will return an array of Method objects that include all of the methods in those interfaces, and invoking getMethod will find methods in the proxy interfaces as would be expected.The Proxy.isProxyClass method will return true if it is passed a proxy class-- a class returned by Proxy.getProxyClass or the class of an object returned by Proxy.newProxyInstance-- and false otherwise.The java.security.ProtectionDomain of a proxy class is the same as that of system classes loaded by the bootstrap class loader, such as java.lang.Object, because the code for a proxy class is generated by trusted system code.This protection domain will typically be granted java.security.AllPermission.Each proxy class has one public constructor that takes one argument, an implementation of the interface InvocationHandler, to set the invocation handler for a proxy instance.Rather than having to use the reflection API to access the public constructor, a proxy instance can be also be created by calling the Proxy.newProxyInstance method, which combines the actions of calling Proxy.getProxyClass with invoking the constructor with an invocation handler.A proxy instance has the following properties:Given a proxy instance proxy and one of the interfaces implemented by its proxy class Foo, the following expression will return true:proxy instanceof Foo and the following cast operation will succeed (rather than throwing a ClassCastException):Each proxy instance has an associated invocation handler, the one that was passed to its constructor.The static Proxy.getInvocationHandler method will return the invocation handler associated with the proxy instance passed as its argument.An interface method invocation on a proxy instance will be encoded and dispatched to the invocation handler's invoke method as described in the documentation for that method.An invocation of the hashCode, equals, or toString methods declared in java.lang.Object on a proxy instance will be encoded and dispatched to the invocation handler's invoke method in the same manner as interface method invocations are encoded and dispatched, as described above.The declaring class of the Method object passed to invoke will be java.lang.Object.Other public methods of a proxy instance inherited from java.lang.Object are not overridden by a proxy class, so invocations of those methods behave like they do for instances of java.lang.Object.Methods Duplicated in Multiple Proxy Interfaces When two or more interfaces of a proxy class contain a method with the same name and parameter signature, the order of the proxy class's interfaces becomes significant.When such a duplicate method is invoked on a proxy instance, the Method object passed to the invocation handler will not necessarily be the one whose declaring class is assignable from the reference type of the interface that the proxy's method was invoked through.This limitation exists because the corresponding method implementation in the generated proxy class cannot determine which interface it was invoked through.Therefore, when a duplicate method is invoked on a proxy instance, the Method object for the method in the foremost interface that contains the method (either directly or inherited through a superinterface) in the proxy class's list of interfaces is passed to the invocation handler's invoke method, regardless of the reference type through which the method invocation occurred.If a proxy interface contains a method with the same name and parameter signature as the hashCode, equals, or toString methods of java.lang.Object, when such a method is invoked on a proxy instance, the Method object passed to the invocation handler will have java.lang.Object as its declaring class.In other words, the public, non-final methods of java.lang.Object logically precede all of the proxy interfaces for the determination of which Method object to pass to the invocation handler.Note also that when a duplicate method is dispatched to an invocation handler, the invoke method may only throw checked exception types that are assignable to one of the exception types in the throws clause of the method in all of the proxy interfaces that it can be invoked through.If the invoke method throws a checked exception that is not assignable to any of the exception types declared by the method in one of the proxy interfaces that it can be invoked through, then an unchecked UndeclaredThrowableException will be thrown by the invocation on the proxy instance.This restriction means that not all of the exception types returned by invoking getExceptionTypes on the Method object passed to the invoke method can necessarily be thrown successfully by the invoke method."},
{"description": "Runtime exception thrown when a provider of the required type cannot be found."},
{"description": "Unchecked exception thrown when an attempt is made to invoke a method on an object created by one file system provider with a parameter created by a different file system provider."},
{"description": "A runtime exception for Provider exceptions (such as misconfiguration errors or unrecoverable internal errors), which may be subclassed by Providers to throw specialized, provider-specific runtime errors."},
{"description": "It encapsulates the properties of a service and contains a factory method to obtain new implementation instances of this service.Each service has a provider that offers the service, a type, an algorithm name, and the name of the class that implements the service.Optionally, it also includes a list of alternate algorithm names for this service (aliases) and attributes, which are a map of (name, value) String pairs.This class defines the methods supportsParameter() and newInstance() which are used by the Java security framework when it searches for suitable services and instantiates them.The valid arguments to those methods depend on the type of service.Note that components outside of Java SE can define additional types of services and their behavior.Instances of this class are immutable."},
{"description": "Service endpoints may implement the Provider interface as a dynamic alternative to an SEI.Implementations are required to support Provider<Source>, Provider<SOAPMessage> and Provider<DataSource>, depending on the binding in use and the service mode.The ServiceMode annotation can be used to control whether the Provider instance will receive entire protocol messages or just message payloads."},
{"description": "This class represents a \"provider\" for the Java Security API, where a provider implements some or all parts of Java Security.Services that a provider may implement include: Algorithms (such as DSA, RSA, MD5 or SHA-1).Each provider has a name and a version number, and is configured in each runtime it is installed in.However, please note that a provider can be used to implement any security service in Java that uses a pluggable architecture with a choice of implementations that fit underneath.Some provider implementations may encounter unrecoverable internal errors during their operation, for example a failure to communicate with a security token.A ProviderException should be used to indicate such errors.The service type Provider is reserved for use by the security framework.Services of this type cannot be added, removed, or modified by applications.The following attributes are automatically placed in each Provider object:Attributes Automatically Placed in a Provider Object NameValue Provider.id name String.valueOf(provider.getName()) Provider.id version String.valueOf(provider.getVersion()"},
{"description": "Thrown to indicate that there is an error in the underlying protocol, such as a TCP error."},
{"description": "The ProtocolException class is a base class for exceptions related to a specific protocol binding.Subclasses are used to communicate protocol level fault information to clients and may be used on the server to control the protocol specific fault representation."},
{"description": "This is a support class to help build property editors.It can be used either as a base class or as a delegate."},
{"description": "The PropertyEditorManager can be used to locate a property editor for any given type name.This property editor must support the java.beans.PropertyEditor interface for editing a given object.The PropertyEditorManager uses three techniques for locating an editor for a given type.First, it provides a registerEditor method to allow an editor to be specifically registered for a given type.Second it tries to locate a suitable class by adding \"Editor\" to the full qualified classname of the given type (e.g. \"foo.bah.FozEditor\").Finally it takes the simple classname (without the package name) adds \"Editor\" to it and looks in a search-path of packages for a matching class.So for an input class foo.bah.Fred, the PropertyEditorManager would first look in its tables to see if an editor had been registered for foo.bah.Fred and if so use that.Then it will look for a foo.bah.FredEditor class.Then it will look for (say) standardEditorsPackage.Default PropertyEditors will be provided for the Java primitive types \"boolean\", \"byte\", \"short\", \"int\", \"long\", \"float\", and \"double\"; and for the classes java.lang.String."},
{"description": "This exception indicates that an error was encountered while getting or setting a property."},
{"description": "A PropertyEditor class provides support for GUIs that want to allow users to edit a property value of a given type.PropertyEditor supports a variety of different kinds of ways of displaying and updating property values.Most PropertyEditors will only need to support a subset of the different options available in this API.Simple PropertyEditors may only support the getAsText and setAsText methods and need not support (say) paintValue or getCustomEditor.More complex types may be unable to support getAsText and setAsText but will instead support paintValue and getCustomEditor.Every propertyEditor must support one or more of the three simple display styles.Thus it can either (1) support isPaintable or (2)both return a non-null String[] from getTags() and return a non-null value from getAsText or (3) simply return a non-null String from getAsText().Every property editor must support a call on setValue when the argument object is of the type for which this is the corresponding propertyEditor.In addition, each property editor must either support a custom editor, or support setAsText.Each PropertyEditor should have a null constructor."},
{"description": "The ProtectionDomain class encapsulates the characteristics of a domain, which encloses a set of classes whose instances are granted a set of permissions when being executed on behalf of a given set of Principals.A static set of permissions can be bound to a ProtectionDomain when it is constructed; such permissions are granted to the domain regardless of the Policy in force.However, to support dynamic security policies, a ProtectionDomain can also be constructed such that it is dynamically mapped to a set of permissions by the current Policy whenever a permission is checked."},
{"description": "This class is for property permissions.The name is the name of the property (\"java.home\", \"os.name\", etc).The naming convention follows the hierarchical property naming convention.Also, an asterisk may appear at the end of the name, following a \".*\" and \"*\" signify a wildcard match, while \"*java\" and \"a*b\" do not.The actions to be granted are passed to the constructor in a string containing a list of one or more comma-separated keywords.The actions string is converted to lowercase before processing.Care should be taken before granting code permission to access certain system properties.For example, granting permission to access the \"java.home\" system property gives potentially malevolent code sensitive information about the system environment (the Java installation directory).Also, granting permission to access the \"user.name\" and \"user.home\" system properties gives potentially malevolent code sensitive information about the user environment (the user's account name and home directory)."},
{"description": "A PropertyVetoException is thrown when a proposed change to a property represents an unacceptable value."},
{"description": "PropertyResourceBundle is a concrete subclass of ResourceBundle that manages resources for a locale using a set of static strings from a property file.Unlike other types of resource bundle, you don't subclass PropertyResourceBundle.Instead, you supply properties files containing the resource data.ResourceBundle.getBundle will automatically look for the appropriate properties file and create a PropertyResourceBundle that refers to it.The following example shows a member of a resource bundle family with the base name \"MyResources\".The text defines the bundle \"MyResources_de\", the German member of the bundle family.This member is based on PropertyResourceBundle, and the text therefore is the content of the file \"MyResources_de.properties\" (a related example shows how you can add bundles to this family that are implemented as subclasses of ListResourceBundle).The keys in this example are of the form \"s1\" etc.The actual keys are entirely up to your choice, so long as they are the same as the keys you use in your program to retrieve the objects from the bundle.# location of {0} in pattern s2=1 # sample disk name s3=Meine Platte # first ChoiceFormat choice s4=keine Dateien # second ChoiceFormat choice s5=The implementation of a PropertyResourceBundle subclass must be thread-safe if it's simultaneously used by multiple threads.The default implementations of the non-abstract methods in this class are thread-safe.Note: PropertyResourceBundle can be constructed either from an InputStream or a Reader, which represents a property file.Constructing a PropertyResourceBundle instance from an InputStream requires that the input stream be encoded in ISO-8859-1.In that case, characters that cannot be represented in ISO-8859-1 encoding must be represented by Unicode Escapes as defined in section 3.3 of The Java\u2122 Language Specification whereas the other constructor which takes a Reader does not have that limitation."},
{"description": "A PropertyDescriptor describes one property that a Java Bean exports via a pair of accessor methods."},
{"description": "A \"PropertyChange\" event gets fired whenever a bean changes a \"bound\" property.You can register a PropertyChangeListener with a source bean so as to be notified of any bound property updates."},
{"description": "A \"PropertyChange\" event gets delivered whenever a bean changes a \"bound\" or \"constrained\" property.A PropertyChangeEvent object is sent as an argument to the PropertyChangeListener and VetoableChangeListener methods.Normally PropertyChangeEvents are accompanied by the name and the old and new value of the changed property.If the new value is a primitive type (such as int or boolean) it must be wrapped as the corresponding java.lang.Null values may be provided for the old and the new values if their true values are not known.An event source may send a null object as the name to indicate that an arbitrary set of if its properties have changed.In this case the old and new values should also be null."},
{"description": "The Properties class represents a persistent set of properties.The Properties can be saved to a stream or loaded from a stream.Each key and its corresponding value in the property list is a string.A property list can contain another property list as its \"defaults\"; this second property list is searched if the property key is not found in the original property list.Because Properties inherits from Hashtable, the put and putAll methods can be applied to a Properties object.Their use is strongly discouraged as they allow the caller to insert entries whose keys or values are not Strings.If the store or save method is called on a \"compromised\" Properties object that contains a non-String key or value, the call will fail.Similarly, the call to the propertyNames or list method will fail if it is called on a \"compromised\" Properties object that contains a non-String key.store(OutputStream, String) methods work the same way as the load(Reader)/store(Writer, String) pair, except the input/output stream is encoded in ISO 8859-1 character encoding.Characters that cannot be directly represented in this encoding can be written using Unicode escapes as defined in section 3.3 of The Java\u2122 Language Specification; only a single 'u' character is allowed in an escape sequence.The native2ascii tool can be used to convert property files to and from other character encodings.By default the UTF-8 character encoding is used, however a specific encoding may be specified if required.Implementations are required to support UTF-8 and UTF-16 and may support other encodings.An XML properties document has the following DOCTYPE declaration: <!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"> Note that the system URI (http://java.sun.com/dtd/properties.dtd) is not accessed when exporting or importing properties; it merely serves as a string to uniquely identify the DTD, which is: <?-- DTD for properties --> <!This class is thread-safe: multiple threads can share a single Properties object without the need for external synchronization."},
{"description": "This is a utility class that can be used by beans that support bound properties.It manages a list of listeners and dispatches PropertyChangeEvents to them.You can use an instance of this class as a member field of your bean and delegate these types of work to it.The PropertyChangeListener can be registered for all properties or for a property specified by name.Here is an example of PropertyChangeSupport usage that follows the rules and recommendations laid out in the JavaBeans\u2122 specification: public class MyBean { private final PropertyChangeSupport pcs = new PropertyChangeSupport(this); public void addPropertyChangeListener(PropertyChangeListener listener) { this.pcs.addPropertyChangeListener(listener); } public void removePropertyChangeListener(PropertyChangeListener listener) { this.pcs.removePropertyChangeListener(listener); } private String value; public String getValue() { return this.value; } public void setValue(String newValue) { String oldValue = this.value; this.value = newValue; this.pcs.firePropertyChange(\"value\", oldValue, newValue); } [...] }Any non-serializable listeners will be skipped during serialization."},
{"description": "A class which extends the EventListenerProxy specifically for adding a PropertyChangeListener with a \"bound\" property.Instances of this class can be added as PropertyChangeListeners to a bean which supports firing property change events.If the object has a getPropertyChangeListeners method then the array returned could be a mixture of PropertyChangeListener and PropertyChangeListenerProxy objects."},
{"description": "If it looks like the operation will take a while, a progress dialog will be popped up.When the ProgressMonitor is created it is given a numeric range and a descriptive string.As the operation progresses, call the setProgress method to indicate how far along the [min,max] range the operation is.Initially, there is no ProgressDialog.If it is longer than millisToPopup (default 2000, 2 seconds) a ProgressDialog will be popped up.From time to time, when the Dialog box is visible, the progress bar will be updated when setProgress is called.setProgress won't always update the progress bar, it will only be done if the amount of progress is visibly significant."},
{"description": "This ProgressMonitor is normally invoked in roughly this form:; This creates a progress monitor to monitor the progress of reading the input stream.If it's taking a while, a ProgressDialog will be popped up to inform the user.If the user hits the Cancel button an InterruptedIOException will be thrown on the next read."},
{"description": "Annotation processing happens in a sequence of rounds.On each round, a processor may be asked to process a subset of the annotations found on the source and class files produced by a prior round.The inputs to the first round of processing are the initial inputs to a run of the tool; these initial inputs can be regarded as the output of a virtual zeroth round of processing.If a processor was asked to process on a given round, it will be asked to process on subsequent rounds, including the last round, even if there are no annotations for it to process.The tool infrastructure may also ask a processor to process files generated implicitly by the tool's operation.Each implementation of a Processor must provide a public no-argument constructor to be used by tools to instantiate the processor.The tool infrastructure will interact with classes implementing this interface as follows: If an existing Processor object is not being used, to create an instance of a processor the tool calls the no-arg constructor of the processor class.Next, the tool calls the init method with an appropriate ProcessingEnvironment.These methods are only called once per run, not on each round.As appropriate, the tool calls the process method on the Processor object; a new Processor object is not created for each round.If a processor object is created and used without the above protocol being followed, then the processor's behavior is not defined by this interface specification.The tool uses a discovery process to find annotation processors and decide whether or not they should be run.By configuring the tool, the set of potential processors can be controlled.For example, for a JavaCompiler the list of candidate processors to run can be set directly or controlled by a search path used for a service-style lookup.Other tool implementations may have different configuration mechanisms, such as command line options; for details, refer to the particular tool's documentation.Which processors the tool asks to run is a function of the types of the annotations present on the root elements, what annotation types a processor supports, and whether or not a processor claims the annotation types it processes.A processor will be asked to process a subset of the annotation types it supports, possibly an empty set.For a given round, the tool computes the set of annotation types that are present on the elements enclosed within the root elements.If there is at least one annotation type present, then as processors claim annotation types, they are removed from the set of unmatched annotation types.When the set is empty or no more processors are available, the round has run to completion.If there are no annotation types present, annotation processing still occurs but only universal processors which support processing all annotation types, \"*\", can claim the (empty) set of annotation types.An annotation type is considered present if there is at least one annotation of that type present on an element enclosed within the root elements of a round.For this purpose, a type parameter is considered to be enclosed by its generic element.Annotations on type uses, as opposed to annotations on elements, are ignored when computing whether or not an annotation type is present.An annotation is present if it meets the definition of being present given in AnnotatedConstruct.In brief, an annotation is considered present for the purposes of discovery if it is directly present or present via inheritance.An annotation is not considered present by virtue of being wrapped by a container annotation.Operationally, this is equivalent to an annotation being present on an element if and only if it would be included in the results of Elements.getAllAnnotationMirrors(Element) called on that element.Since annotations inside container annotations are not considered present, to properly process repeatable annotation types, processors are advised to include both the repeatable annotation type and its containing annotation type in the set of supported annotation types of a processor.Therefore, a universal processor being used to, for example, implement additional validity checksIf a processor throws an uncaught exception, the tool may cease other active annotation processors.If a processor raises an error, the current round will run to completion and the subsequent round will indicate an error was raised.Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.The tool environment is not required to support annotation processors that access environmental resources, either per round or cross-round, in a multi-threaded fashion.If the methods that return configuration information about the annotation processor return null, return other invalid input, or throw an exception, the tool infrastructure must treat this as an error condition.To be robust when running in different tool implementations, an annotation processor should have the following properties: The result of processing a given input is not a function of the presence or absence of other inputs (orthogonality).Processing the same input produces the same output (consistency).A followed by processing input B is equivalent to processing B then A (commutativity) Processing an input does not rely on the presence of the output of other annotation processors (independence)The Filer interface discusses restrictions on how processors can operate on files.Note that implementors of this interface may find it convenient to extend AbstractProcessor rather than implementing this interface directly."},
{"description": "This exception is thrown when an error occurs in accessing or processing an ICC_Profile object."},
{"description": "An interface that describes the data found in processing instructions"},
{"description": "An annotation processing tool framework will provide an annotation processor with an object implementing this interface so the processor can use facilities provided by the framework to write new files, report error messages, and find other utilities.Third parties may wish to provide value-add wrappers around the facility objects from this interface, for example a Filer extension that allows multiple processors to coordinate writing out a single source file.To enable this, for processors running in a context where their side effects via the API could be visible to each other, the tool infrastructure must provide corresponding facility objects that are .equals, Filers that are .equals, and so on.In addition, the tool invocation must be able to be configured such that from the perspective of the running annotation processors, at least the chosen subset of helper classes are viewed as being loaded by the same class loader.(Since the facility objects manage shared state, the implementation of a wrapper class must know whether or not the same base facility object has been wrapped before.)"},
{"description": "The ProcessingInstruction interface represents a \"processing instruction\", used in XML as a way to keep processor-specific information in the text of the document.No lexical check is done on the content of a processing instruction and it is therefore possible to have the character sequence \"?\" in the content, which is illegal a processing instruction per section 2.6 of [XML 1.0].The presence of this character sequence must generate a fatal error during serialization."},
{"description": "Each Redirect instance is one of the following: the special value Redirect.Each of the above categories has an associated unique Type."},
{"description": "This class is used to create operating system processes.Each ProcessBuilder instance manages a collection of process attributes.The start() method creates a new Process instance with those attributes.The start() method can be invoked repeatedly from the same instance to create new subprocesses with identical or related attributes.a command, a list of strings which signifies the external program file to be invoked and its arguments, if any.Which string lists represent a valid operating system command is system-dependent.For example, it is common for each conceptual argument to be an element in this list, but there are operating systems where programs are expected to tokenize command line strings themselves - on such a system a Java implementation might require commands to contain exactly two elements.an environment, which is a system-dependent mapping from variables to values.The initial value is a copy of the environment of the current process (see System.getenv()).The default value is the current working directory of the current process, usually the directory named by the system property user.dir.By default, the subprocess reads input from a pipe.Java code can access this pipe via the output stream returned by Process.getOutputStream().However, standard input may be redirected to another source using redirectInput.In this case, Process.getOutputStream() will return a null output stream, for which: the write methods always throw IOException the close method does nothing a destination for standard output and standard error.By default, the subprocess writes standard output and standard error to pipes.Java code can access these pipes via the input streams returned by Process.getInputStream() and Process.getErrorStream().However, standard output and standard error may be redirected to other destinations using redirectOutput and redirectError.In this case, Process.getInputStream() and/or Process.getErrorStream() will return a null input stream, for which: the read methods always return -1 the available method always returns 0 the close method does nothing a redirectErrorStream property.Initially, this property is false, meaning that the standard output and error output of a subprocess are sent to two separate streams, which can be accessed using the Process.getInputStream() and Process.getErrorStream() methods.If the value is set to true, then: standard error is merged with the standard output and always sent to the same destination (this makes it easier to correlate error messages with the corresponding output) the common destination of standard error and standard output can be redirected using redirectOutputany redirection set by the redirectError method is ignored when creating a subprocess the stream returned from Process.getErrorStreamMost error checking is performed by the start() method.It is possible to modify the state of an object so that start() will fail.For example, setting the command attribute to an empty list will not throw an exception unless start() is invoked.If multiple threads access a ProcessBuilder instance concurrently, and at least one of the threads modifies one of the attributes structurally, it must be synchronized externally.Starting a new process which uses the default working directory and environment is easy: Process p = new ProcessBuilder(\"myCommand\", \"myArg\").start(); Here is an example that starts a process with a modified working directory and environment, and redirects standard output and error to be appended to a log file:pb.environment(); env.put(\"VAR1\", \"myValue\"); env.remove(\"OTHERVAR\"); env.put(\"VAR2\", env.get(\"VAR1\") + \"suffix\"); pb.directory(new File(\"myDir\")); File log = new File(\"log\"); pb.redirectErrorStream(true); pb.redirectOutput(Redirect.appendTo(log));Process p = pb.start(); assert pb.redirectInput() == Redirect."},
{"description": "The ProcessBuilder.start() and Runtime.exec methods create a native process and return an instance of a subclass of Process that can be used to control the process and obtain information about it.The class Process provides methods for performing input from the process, performing output to the process, waiting for the process to complete, checking the exit status of the process, and destroying (killing) the process.The methods that create processes may not work well for special processes on certain native platforms, such as native windowing processes, daemon processes, Win16/DOS processes on Microsoft Windows, or shell scripts.By default, the created subprocess does not have its own terminal or console.(i.e. stdin, stdout, stderr) operations will be redirected to the parent process, where they can be accessed via the streams obtained using the methods getOutputStreamThe parent process uses these streams to feed input to and get output from the subprocess.Because some native platforms only provide limited buffer size for standard input and output streams, failure to promptly write the input stream or read the output stream of the subprocess may cause the subprocess to block, or even deadlock.The subprocess is not killed when there are no more references to the Process object, but rather the subprocess continues executing asynchronously.There is no requirement that a process represented by a Process object execute asynchronously or concurrently with respect to the Java process that owns the Process object."},
{"description": "An MLet that is not added to the ClassLoaderRepository.This class acts exactly like its parent class, MLet, with one exception.When a PrivateMLet is registered in an MBean server, it is not added to that MBean server's ClassLoaderRepository.This is true because this class implements the interface PrivateClassLoader."},
{"description": "The computation is performed by invoking AccessController.doPrivileged on the PrivilegedAction object.This interface is used only for computations that do not throw checked exceptions; computations that throw checked exceptions must use PrivilegedExceptionAction instead."},
{"description": "This exception is thrown by doPrivileged(PrivilegedExceptionAction) and doPrivileged(PrivilegedExceptionAction, AccessControlContext context) to indicate that the action being performed threw a checked exception.The exception thrown by the action can be obtained by calling the getException method.In effect, an PrivilegedActionException is a \"wrapper\" for an exception thrown by a privileged action.As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.The \"exception thrown by the privileged computation\" that is provided at construction time and accessed via the getException() method is now known as the cause, and may be accessed via the Throwable.getCause() method, as well as the aforementioned \"legacy method.\""},
{"description": "The purpose of this interface is to group (and provide type safety for) all private key interfaces.Note: The specialized private key interfaces extend this interface.Implementations should override the default destroy and isDestroyed methods from the Destroyable interface to enable sensitive key information to be destroyed, cleared, or in the case where such information is immutable, unreferenced.Object) to prevent keys that have been destroyed from being serialized."},
{"description": "PRIVATE_MEMBER is one of the two constants of typedef Visibility used in the interface repository to identify visibility of a ValueMember type."},
{"description": "Marker interface indicating that a ClassLoader should not be added to the ClassLoaderRepository.When a ClassLoader is registered as an MBean in the MBean server, it is added to the MBean server's ClassLoaderRepository unless it implements this interface."},
{"description": "Prints formatted representations of objects to a text-output stream.This class implements all of the print methods found in PrintStream.It does not contain methods for writing raw bytes, for which a program should use unencoded byte streams.Unlike the PrintStream class, if automatic flushing is enabled it will be done only when one of the println, printf, or format methods is invoked, rather than whenever a newline character happens to be output.These methods use the platform's own notion of line separator rather than the newline character.Methods in this class never throw I/O exceptions, although some of its constructors may.The client may inquire as to whether any errors have occurred by invoking checkError()."},
{"description": "The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used.A priority queue does not permit null elements.A priority queue relying on natural ordering also does not permit insertion of non-comparable objects (doing so may result in ClassCastException).The head of this queue is the least element with respect to the specified ordering.If multiple elements are tied for least value, the head is one of those elements -- ties are broken arbitrarily.A priority queue is unbounded, but has an internal capacity governing the size of an array used to store the elements on the queue.It is always at least as large as the queue size.As elements are added to a priority queue, its capacity grows automatically.The details of the growth policy are not specified.This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces.The Iterator provided in method iterator() is not guaranteed to traverse the elements of the priority queue in any particular order.If you need ordered traversal, consider using Arrays.sort(pq.toArray()).Multiple threads should not access a PriorityQueue instance concurrently if any of the threads modifies the queue.Implementation note: this implementation provides O(log(n))This class is a member of the Java Collections Framework."},
{"description": "A computation to be performed with privileges enabled, that throws one or more checked exceptions.The computation is performed by invoking AccessController.doPrivileged on the PrivilegedExceptionAction object.This interface is used only for computations that throw checked exceptions; computations that do not throw checked exceptions should use PrivilegedAction instead."},
{"description": "An unbounded blocking queue that uses the same ordering rules as class PriorityQueue and supplies blocking retrieval operations.While this queue is logically unbounded, attempted additions may fail due to resource exhaustion (causing OutOfMemoryError).This class does not permit null elements.A priority queue relying on natural ordering also does not permit insertion of non-comparable objects (doing so results in ClassCastException).This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces.The Iterator provided in method iterator() is not guaranteed to traverse the elements of the PriorityBlockingQueue in any particular order.If you need ordered traversal, consider using Arrays.sort(pq.toArray()).Also, method drainTo can be used to remove some or all elements in priority order and place them in another collection.Operations on this class make no guarantees about the ordering of elements with equal priority.If you need to enforce an ordering, you can define custom classes or comparators that use a secondary key to break ties in primary priority values.For example, here is a class that applies first-in-first-out tie-breaking to comparable elements.To use it, you would insert a new FIFOEntry(anEntry) instead of a plain entry object.class FIFOEntry<E extends Comparable<?this.entry = entry; } public E getEntry() { return entry; } public int compareTo(FIFOEntry; if (res == 0 && other.entry != this.entry) res = (seqNum < other.seqNum ? -1 : 1); return res; } } This class is a member of the Java Collections Framework."},
{"description": "This class is used to protect access to private Credentials belonging to a particular Subject.The Subject is represented by a Set of Principals.The target name of this Permission specifies a Credential class name, and a Set of Principals.The only valid value for this Permission's actions is, \"read\".The target name must abide by the following syntax: CredentialClass {PrincipalClass \"PrincipalName\"}*For example, the following permission grants access to the com.sun.PrivateCredential owned by Subjects which have a com.sun.Principal with the name, \"duke\".Note that although this example, as well as all the examples below, do not contain Codebase, SignedBy, or Principal information in the grant statement (for simplicity reasons), actual policy configurations should specify that information when appropriate., \"read\"; }; If CredentialClass is \"*\", then access is granted to all private Credentials belonging to the specified Subject.If \"PrincipalName\" is \"*\", then access is granted to the specified Credential owned by any Subject that has the specified Principal (the actual PrincipalName doesn't matter).For example, the following grants access to the a.b.Credential owned by any Subject that has an a.b.Principal.*\"\", \"read\"; }; If both the PrincipalClass and \"PrincipalName\" are \"*\", then access is granted to the specified Credential owned by any Subject.In addition, the PrincipalClass/PrincipalName pairing may be repeated: grant"},
{"description": "Implementations of this listener interface are attached to a PrintService to monitor the status of the print service."},
{"description": "Interface PrintServiceAttributeSet specifies the interface for a set of print job attributes, i.e. printing attributes that implement interface PrintServiceAttribute.In the Print Service API, the Print Service instance uses a PrintServiceAttributeSet to report the status of the print service.A PrintServiceAttributeSet is just an AttributeSet whose constructors and mutating operations guarantee an additional invariant, namely that all attribute values in the PrintServiceAttributeSet must be instances of interface PrintServiceAttribute.The add(Attribute), and addAll(AttributeSet) operations are respecified below to guarantee this additional invariant."},
{"description": "Interface PrintRequestAttributeSet specifies the interface for a set of print request attributes, i.e. printing attributes that implement interface PrintRequestAttribute.The client uses a PrintRequestAttributeSet to specify the settings to be applied to a whole print job and to all the docs in the print job.PrintRequestAttributeSet is just an AttributeSet whose constructors and mutating operations guarantee an additional invariant, namely that all attribute values in the PrintRequestAttributeSet must be instances of interface PrintRequestAttribute.The add(Attribute), and addAll(AttributeSet) operations are respecified below to guarantee this additional invariant."},
{"description": "A PrintStream adds functionality to another output stream, namely the ability to print representations of various data values conveniently.Unlike other output streams, a PrintStream never throws an IOException; instead, exceptional situations merely set an internal flag that can be tested via the checkError method.Optionally, a PrintStream can be created so as to flush automatically; this means that the flush method is automatically invoked after a byte array is written, one of the println methods is invoked, or a newline character or byte ('\\n') is written.All characters printed by a PrintStream are converted into bytes using the platform's default character encoding.The PrintWriter class should be used in situations that require writing characters rather than bytes."},
{"description": "Implementations of this class provide lookup services for print services (typically equivalent to printers) of a particular type.All implementations must be able to describe the located printers as instances of a PrintService.Typically implementations of this service class are located automatically in JAR files (see the SPI JAR file specification).These classes must be instantiable using a default constructor.Alternatively applications may explicitly register instances at runtime.Applications use only the static methods of this abstract class.The instance methods are implemented by a service provider in a subclass and the unification of the results from all installed lookup classes are reported by the static methods of this class when called by the application.A PrintServiceLookup implementor is recommended to check for the SecurityManager.checkPrintJobAccess() to deny access to untrusted code.Following this recommended policy means that untrusted code may not be able to locate any print services.Downloaded applets are the most common example of untrusted code.This check is made on a per lookup service basis to allow flexibility in the policy to reflect the needs of different lookup services.Services which are registered by registerService(PrintService) will not be included in lookup results if a security manager is installed and its checkPrintJobAccess() method denies access."},
{"description": "Class PrintServiceAttributeEvent encapsulates an event a Print Service instance reports to let the client know of changes in the print service state."},
{"description": "Interface PrintServiceAttribute is a tagging interface which a printing attribute class implements to indicate the attribute describes the status of a Print Service or some other characteristic of a Print Service.A Print Service instance adds a number of PrintServiceAttributes to a Print service's attribute set to report the Print Service's status."},
{"description": "Interface PrintService is the factory for a DocPrintJob.A PrintService describes the capabilities of a Printer and can be queried regarding a printer's supported attributes."},
{"description": "PrintJobAttribute is a tagging interface which a printing attribute class implements to indicate the attribute describes the status of a Print Job or some other characteristic of a Print Job.A Print Service instance adds a number of PrintJobAttributes to a Print Job's attribute set to report the Print Job's status.If an attribute implements PrintRequestAttribute as well as PrintJobAttribute, the client may include the attribute in a attribute set to specify the attribute's value for the Print Job."},
{"description": "Interface PrintRequestAttribute is a tagging interface which a printing attribute class implements to indicate the attribute denotes a requested setting for a print job.Attributes which are tagged with PrintRequestAttribute and are also tagged as PrintJobAttribute, represent the subset of job attributes which can be part of the specification of a job request.If an attribute implements DocAttribute as well as PrintRequestAttribute, the client may include the attribute in a Doc}'s attribute set to specify a job setting which pertains just to that doc."},
{"description": "Implementations of this listener interface should be attached to a DocPrintJob to monitor the status of the printer job.These callback methods may be invoked on the thread processing the print job, or a service created notification thread.In either case the client should not perform lengthy processing in these callbacks."},
{"description": "Class PrintJobAttributeEvent encapsulates an event a PrintService reports to let the client know that one or more printing attributes for a PrintJob have changed."},
{"description": "Implementations of this interface are attached to a DocPrintJob to monitor the status of attribute changes associated with the print job."},
{"description": "Class PrintJobEvent encapsulates common events a print job reports to let a listener know of progress in the processing of the DocPrintJob."},
{"description": "Class PrintQuality is a printing attribute class, an enumeration, that specifies the print quality that the printer uses for the job.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "Interface PrintJobAttributeSet specifies the interface for a set of print job attributes, i.e. printing attributes that implement interface PrintJobAttribute.In the Print Service API, a service uses a PrintJobAttributeSet to report the status of a print job.A PrintJobAttributeSet is just an AttributeSet whose constructors and mutating operations guarantee an additional invariant, namely that all attribute values in the PrintJobAttributeSet must be instances of interface PrintJobAttribute.The add(Attribute), and >addAll(AttributeSet) operations are respecified below to guarantee this additional invariant."},
{"description": "An abstract class which provides a print graphics context for a page."},
{"description": "An abstract class which initiates and executes a print job.It provides access to a print graphics object which renders to an appropriate print device."},
{"description": "Class PrintException encapsulates a printing-related error condition that occurred while using a Print Service instance.This base class furnishes only a string description of the error.Subclasses furnish more detailed information if applicable."},
{"description": "Class PrintEvent is the super class of all Print Service API events."},
{"description": "Class PrinterURI is a printing attribute class, a URI, that specifies the globally unique name of a printer.If it has such a name, an administrator determines a printer's URI and sets this attribute to that name.This implements the IPP printer-uri attribute.The string form returned by toString() gives the IPP printer-uri value.The category name returned by getName() gives the IPP attribute name."},
{"description": "The methods in this class are empty.This class exists as a convenience for creating listener objects.Unlike the ComponentListener interface, this abstract interface provides null methods so that you only need to define the methods you need, rather than all of the methods."},
{"description": "Class PrinterStateReasons is a printing attribute class, a set of enumeration values, that provides additional information about the printer's current state, i.e., information that augments the value of the printer's PrinterState attribute.Instances of PrinterStateReason do not appear in a Print Service's attribute set directly.Rather, a PrinterStateReasons attribute appears in the Print Service's attribute set.The PrinterStateReasons attribute contains zero, one, or more than one PrinterStateReason objects which pertain to the Print Service's status, and each PrinterStateReason object is associated with a Severity level of REPORT (least severe), WARNING, or ERROR (most severe).The printer adds a PrinterStateReason object to the Print Service's PrinterStateReasons attribute when the corresponding condition becomes true of the printer, and the printer removes the PrinterStateReason object again when the corresponding condition becomes false, regardless of whether the Print Service's overall PrinterState also changed.Class PrinterStateReasons inherits its implementation from class java.util.HashMap.Each entry in the map consists of a PrinterStateReason object (key) mapping to a Severity object (value):Unlike most printing attributes which are immutable once constructed, class PrinterStateReasons is designed to be mutable; you can add PrinterStateReason objects to an existing PrinterStateReasons object and remove them again.However, like class java.util.HashMap, class PrinterStateReasons is not multiple thread safe.If a PrinterStateReasons object will be used by multiple threads, be sure to synchronize its operations (e.g., using a synchronized map view obtained from class java.util.Collections).IPP Compatibility: The string values returned by each individual PrinterStateReason object's and the associated Severity object's toString() methods, concatenated together with a hyphen (\"-\") in between, gives the IPP keyword value.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class PrinterStateReason is a printing attribute class, an enumeration, that provides additional information about the printer's current state, i.e., information that augments the value of the printer's PrinterState attribute.Class PrinterStateReason defines standard printer state reason values.A Print Service implementation only needs to report those printer state reasons which are appropriate for the particular implementation; it does not have to report every defined printer state reason.Instances of PrinterStateReason do not appear in a Print Service's attribute set directly.Rather, a PrinterStateReasons attribute appears in the Print Service's attribute set.The PrinterStateReasons attribute contains zero, one, or more than one PrinterStateReason objects which pertain to the Print Service's status, and each PrinterStateReason object is associated with a Severity level of REPORT (least severe), WARNING, or ERROR (most severe).The printer adds a PrinterStateReason object to the Print Service's PrinterStateReasons attribute when the corresponding condition becomes true of the printer, and the printer removes the PrinterStateReason object again when the corresponding condition becomes false, regardless of whether the Print Service's overall PrinterState also changed.IPP Compatibility: The string values returned by each individual PrinterStateReason and associated Severity object's toString() methods, concatenated together with a hyphen (\"-\") in between, gives the IPP keyword value for a PrinterStateReasons.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class PrinterMoreInfoManufacturer is a printing attribute class, a URI, that is used to obtain more information about this type of device.The information obtained from this URI is intended for end user consumption.Features outside the scope of the Print Service API can be accessed from this URI (e.g., latest firmware, upgrades, service proxies, optional features available, details on color support).The information is intended to be germane to this kind of printer without regard to site specific modifications or services.In contrast, the PrinterMoreInfo attribute is used to find out more information about this specific printer rather than this general kind of printer.The string form returned by toString() gives the IPP uri value.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class PrinterState is a printing attribute class, an enumeration, that identifies the current state of a printer.Class PrinterState defines standard printer state values.A Print Service implementation only needs to report those printer states which are appropriate for the particular implementation; it does not have to report every defined printer state.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "Class PrinterResolution is a printing attribute class that specifies an exact resolution supported by a printer or to be used for a print job.This attribute assumes that printers have a small set of device resolutions at which they can operate rather than a continuum.PrinterResolution is used in multiple ways: When a client searches looking for a printer that supports the client's desired resolution exactly (no more, no less), the client specifies an instance of class PrinterResolution indicating the exact resolution the client wants.Only printers supporting that exact resolution will match the search.When a client needs to print a job using the client's desired resolution exactly (no more, no less), the client specifies an instance of class PrinterResolution as an attribute of the Print Job.This will fail if the Print Job doesn't support that exact resolution, and Fidelity is set to true.If a client wants to locate a printer supporting a resolution greater than some required minimum, then it may be necessary to exclude this attribute from a lookup request and to directly query the set of supported resolutions, and specify the one that most closely meets the client's requirements.In some cases this may be more simply achieved by specifying a PrintQuality attribute which often controls resolution.The information needed to construct an IPP \"printer-resolution\" attribute can be obtained by calling methods on the PrinterResolution object.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class PrinterName is a printing attribute class, a text attribute, that specifies the name of a printer.It is a name that is more end-user friendly than a URI.An administrator determines a printer's name and sets this attribute to that name.This name may be the last part of the printer's URI or it may be unrelated.In non-US-English locales, a name may contain characters that are not allowed in a URI.IPP Compatibility: The string value gives the IPP name value.The locale gives the IPP natural language.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class PrinterMessageFromOperator is a printing attribute class, a text attribute, that provides a message from an operator, system administrator, or \"intelligent\" process to indicate to the end user information about or status of the printer, such as why it is unavailable or when it is expected to be available.A Print Service's attribute set includes zero instances or one instance of a PrinterMessageFromOperator attribute, not more than one instance.A new PrinterMessageFromOperator attribute replaces an existing PrinterMessageFromOperator attribute, if any.In other words, PrinterMessageFromOperator is not intended to be a history log.If it wishes, the client can detect changes to a Print Service's PrinterMessageFromOperator attribute and maintain the client's own history log of the PrinterMessageFromOperator attribute values.The string value gives the IPP name value.The locale gives the IPP natural language.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class PrinterMoreInfo is a printing attribute class, a URI, that is used to obtain more information about this specific printer.For example, this could be an HTTP type URI referencing an HTML page accessible to a web browser.The information obtained from this URI is intended for end user consumption.Features outside the scope of the Print Service API can be accessed from this URI.The information is intended to be specific to this printer instance and site specific services (e.g. job pricing, services offered, end user assistance).In contrast, the PrinterMoreInfoManufacturer attribute is used to find out more information about this general kind of printer rather than this specific printer.The string form returned by toString() gives the IPP uri value.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class PrinterLocation is a printing attribute class, a text attribute, that identifies the location of the device.This could include things like: \"in Room 123A, second floor of building XYZ\".The string value gives the IPP name value.The locale gives the IPP natural language.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class PrinterMakeAndModel is a printing attribute class, a text attribute, that the make and model of the printer.IPP Compatibility: The string value gives the IPP name value.The locale gives the IPP natural language.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class PrinterIsAcceptingJobs is a printing attribute class, an enumeration, that indicates whether the printer is currently able to accept jobs.This value is independent of the PrinterState and PrinterStateReasons attributes because its value does not affect the current job; rather it affects future jobs.If the value is NOT_ACCEPTING_JOBS, the printer will reject jobs even when the PrinterState is IDLE.If value is ACCEPTING_JOBS, the Printer will accept jobs even when the PrinterState is STOPPED.IPP Compatibility: The IPP boolean value is \"true\" for ACCEPTING_JOBS and \"false\" for NOT_ACCEPTING_JOBS.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "The PrinterJob class is the principal class that controls printing.An application calls methods in this class to set up a job, optionally to invoke a print dialog with the user, and then to print the pages of the job."},
{"description": "The PrinterIOException class is a subclass of PrinterException and is used to indicate that an IO error of some sort has occurred while printing.As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.The \"IOException that terminated the print job\" that is provided at construction time and accessed via the getIOException() method is now known as the cause, and may be accessed via the Throwable.getCause() method, as well as the aforementioned \"legacy method.\""},
{"description": "The PrinterAbortException class is a subclass of PrinterException and is used to indicate that a user or application has terminated the print job while it was in the process of printing."},
{"description": "JAXB providers are allowed to use whatever class that implements the ValidationEvent interface.This class is just provided for a convenience."},
{"description": "The PrinterException class and its subclasses are used to indicate that an exceptional condition has occurred in the print system."},
{"description": "Class PrinterInfo is a printing attribute class, a text attribute, that provides descriptive information about a printer.This could include things like: \"This printer can be used for printing color transparencies for HR presentations\", or \"Out of courtesy for others, please print only small (1-5 page) jobs at this printer\", or even \\ \"This printer is going away on July 1, 1997, please find a new printer\".The string value gives the IPP name value.The locale gives the IPP natural language.The category name returned by getName() gives the IPP attribute name."},
{"description": "The PrinterGraphics interface is implemented by Graphics objects that are passed to Printable objects to render a page.It allows an application to find the PrinterJob object that is controlling the printing."},
{"description": "This event indicates that a problem was encountered while converting data from the Java content tree into its lexical representation."},
{"description": "The Printable interface is implemented by the print methods of the current page painter, which is called by the printing system to render a page.When building a Pageable, pairs of PageFormat instances and instances that implement this interface are used to describe each page.The instance implementing Printable is called to print the page's graphics.A Printable(..) may be set on a PrinterJob.When the client subsequently initiates printing by calling PrinterJob.print(..) control is handed to the printing system until all pages have been printed.It does this by calling Printable.print(..) until all pages in the document have been printed.The parameters to Printable.print(..) include a PageFormat which describes the printable area of the page, needed for calculating the contents that will fit the page, and the page index, which specifies the zero-based print stream index of the requested page.For correct printing behaviour, the following points should be observed: The printing system may request a page index more than once.On each occasion equal PageFormat parameters will be supplied.The printing system will call Printable.print(..) with page indexes which increase monotonically, although as noted above, the Printable should expect multiple calls for a page index and that page indexes may be skipped, when page ranges are specified by the client, or by a user through a print dialog.If multiple collated copies of a document are requested, and the printer cannot natively support this, then the document may be imaged multiple times.Printing will start each copy from the lowest print stream page index page.With the exception of re-imaging an entire document for multiple collated copies, the increasing page index order means that when page N is requested if a client needs to calculate page break position, it may safely discard any state related to pages < N, and make current that for page N. \"State\" usually is just the calculated position in the document that corresponds to the start of the page.When called by the printing system the Printable must inspect and honour the supplied PageFormat parameter as well as the page index.The format of the page to be drawn is specified by the supplied PageFormat.The size, orientation and imageable area of the page is therefore already determined and rendering must be within this imageable area.This is key to correct printing behaviour, and it has the implication that the client has the responsibility of tracking what content belongs on the specified page.When the Printable is obtained from a client-supplied Pageable then the client may provide different PageFormats for each page index.Calculations of page breaks must account for this."},
{"description": "These include boolean, byte, short, int, long, char, float, and double."},
{"description": "An Iterator specialized for int values."},
{"description": "An Iterator specialized for long values."},
{"description": "This interface represents the abstract notion of a principal, which can be used to represent any entity, such as an individual, a corporation, and a login id."},
{"description": "An Iterator specialized for double values."},
{"description": "Specialized subtypes are provided for int, long, and double values.Such boxing may offset any advantages gained when using the primitive specializations.To avoid boxing, the corresponding primitive-based methods should be used.IntConsumer) should be used in preference to PrimitiveIterator.Iteration of primitive values using boxing-based methods next() and forEachRemaining(), does not affect the order in which the values, transformed to boxed values, are encountered."},
{"description": "Class PresentationDirection is a printing attribute class, an enumeration, that is used in conjunction with the NumberUp attribute to indicate the layout of multiple print-stream pages to impose upon a single side of an instance of a selected medium.This is useful to mirror the text layout conventions of different scripts.For example, English is \"toright-tobottom\", Hebrew is \"toleft-tobottom\" and Japanese is usually \"tobottom-toleft\".IPP Compatibility: This attribute is not an IPP 1.1 attribute; it is an attribute in the Production Printing Extension (PDF) of IPP 1.1.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "An object that represents a precompiled SQL statement.A SQL statement is precompiled and stored in a PreparedStatement object.This object can then be used to efficiently execute this statement multiple times.Note: The setter methods (setShort, setString, and so on) for setting IN parameter values must specify types that are compatible with the defined SQL type of the input parameter.For instance, if the IN parameter has SQL type INTEGER, then the method setInt should be used.If arbitrary parameter type conversions are required, the method setObject should be used with a target SQL type.In the following example of setting a parameter, con represents an active connection: PreparedStatement pstmt = con.prepareStatement(\"UPDATE EMPLOYEES SET SALARY = ?"},
{"description": "A factory object that generates Preferences objects.Providers of new Preferences implementations should provide corresponding PreferencesFactory implementations so that the new Preferences implementation can be installed in place of the platform-specific default implementation.This class is for Preferences implementers only.Normal users of the Preferences facility should have no need to consult this documentation."},
{"description": "An event emitted by a Preferences node to indicate that a preference has been added, removed or has had its value changed.Note, that although PreferenceChangeEvent inherits Serializable interface from EventObject, it is not intended to be Serializable.Appropriate serialization methods are implemented to throw NotSerializableException."},
{"description": "This class allows applications to store and retrieve user and system preference and configuration data.This data is stored persistently in an implementation-dependent backing store.Typical implementations include flat files, OS-specific registries, directory servers and SQL databases.The user of this class needn't be concerned with details of the backing store.There are two separate trees of preference nodes, one for user preferences and one for system preferences.Each user has a separate user preference tree, and all users in a given system share the same system preference tree.The precise description of \"user\" and \"system\" will vary from implementation to implementation.Typical information stored in the user preference tree might include font choice, color choice, or preferred window location and size for a particular application.Typical information stored in the system preference tree might include installation configuration data for an application.Nodes in a preference tree are named in a similar fashion to directories in a hierarchical file system.Every node in a preference tree has a node name (which is not necessarily unique), a unique absolute path name, and a path name relative to each ancestor including itself.The root node has a node name of the empty string (\"\").Every other node has an arbitrary node name, specified at the time it is created.The only restrictions on this name are that it cannot be the empty string, and it cannot contain the slash character ('/').The root node has an absolute path name of \"/\".Children of the root node have absolute path names of \"/\" + <node name>.All other nodes have absolute path names of <parent's absolute path name> + \"/Note that all absolute path names begin with the slash character.A node n's path name relative to its ancestora is simply the string that must be appended to a's absolute path name in order to form n's absolute path name, with the initial slash character (if present) removed.Note that: No relative path names begin with the slash character.Every node's path name relative to itself is the empty string.Every node's path name relative to its parent is its node name (except for the root node, which does not have a parent).Every node's path name relative to the root is its absolute path name with the initial slash character removed.Note finally that: No path name contains multiple consecutive slash characters.No path name with the exception of the root's absolute path name ends in the slash character.Any string that conforms to these two rules is a valid path name.All of the methods that modify preferences data are permitted to operate asynchronously; they may return immediately, and changes will eventually propagate to the persistent backing store with an implementation-dependent delay.The flush method may be used to synchronously force updates to the backing store.Normal termination of the Java Virtual Machine will not result in the loss of pending updates -- an explicit flush invocation is not required upon termination to ensure that pending updates are made persistent.All of the methods that read preferences from a Preferences object require the invoker to provide a default value.The intent is to allow applications to operate, albeit with slightly degraded functionality, even if the backing store becomes unavailable.Several methods, like flush, have semantics that prevent them from operating if the backing store is unavailable.Ordinary applications should have no need to invoke any of these methods, which can be identified by the fact that they are declared to throw BackingStoreException.The methods in this class may be invoked concurrently by multiple threads in a single JVM without the need for external synchronization, and the results will be equivalent to some serial execution.If this class is used concurrently by multiple JVMs that store their preference data in the same backing store, the data store will not be corrupted, but no other guarantees are made concerning the consistency of the preference data.This class contains an export/import facility, allowing preferences to be \"exported\" to an XML document, and XML documents representing preferences to be \"imported\" back into the system.This facility may be used to back up all or part of a preference tree, and subsequently restore from the backup.The XML document has the following DOCTYPE declaration: <!DOCTYPE preferences SYSTEM\"http://java.sun.com/dtd/preferences.dtd\"> Note that the system URI (http://java.sun.com/dtd/preferences.dtd) is not accessed when exporting or importing preferences; it merely serves as a string to uniquely identify the DTD, which is: <?-- The preferences element is at the root of an XML document representing a Preferences tree.The preferences element contains an optional version attribute, which specifies version of DTD.The root element has a map representing the root's preferences (if any), and one node for each child of the root (if any).-- Additionally, the root contains a type attribute, which specifies whether it's the system or user root.-- Each node has a map representing its preferences (if any), and one node for each child (if any).-- Additionally, each node has a name attribute --> <!-- A map represents the preferences stored at a node (if any).An entry represents a single preference, which is simply a key-value pair.Every Preferences implementation must have an associated PreferencesFactory implementation.SE implementation must provide some means of specifying which PreferencesFactory implementation is used to generate the root preferences nodes.This allows the administrator to replace the default preferences implementation with an alternative implementation.Implementation note: In Sun's JRE, the PreferencesFactory implementation is located as follows: If the system property java.util.prefs.PreferencesFactory is defined, then it is taken to be the fully-qualified name of a class implementing the PreferencesFactory interface.If a PreferencesFactory implementation class file has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named java.util.prefs.PreferencesFactory in the resource directory META-INF/services, then the first class name specified in that file is taken.Finally, if neither the above-mentioned system property nor an extension jar file is provided, then the system-wide default PreferencesFactory implementation for the underlying platform is loaded and instantiated."},
{"description": "This is a functional interface whose functional method is test(Object)."},
{"description": "The PostConstruct annotation is used on a method that needs to be executed after dependency injection is done to perform any initialization.This method MUST be invoked before the class is put into service.This annotation MUST be supported on all classes that support dependency injection.The method annotated with PostConstruct MUST be invoked even if the class does not request any resources to be injected.Only one method can be annotated with this annotation.The method on which the PostConstruct annotation is applied MUST fulfill all of the following criteria: The method MUST NOT have any parameters except in the case of interceptors in which case it takes an InvocationContext object as defined by the Interceptors specification.The method defined on an interceptor class MUST HAVE one of the following signatures: void <METHOD>(InvocationContext)Object <METHOD>(InvocationContext) throws Exception Note: A PostConstruct interceptor method must not throw application exceptions, but it may be declared to throw checked exceptions including the java.lang.Exception if the same interceptor method interposes on business or timeout methods in addition to lifecycle events.If a PostConstruct interceptor method returns a value, it is ignored by the container.The method defined on a non-interceptor class MUST HAVE the following signature:The method on which PostConstruct is applied MAY be public, protected, package private or private.The method MUST NOT be static except for the application client.If the method throws an unchecked exception the class MUST NOT be put into service except in the case of EJBs where the EJB can handle exceptions and even recover from them."},
{"description": "File attributes associated with files on file systems used by operating systems that implement the Portable Operating System Interface (POSIX) family of standards.The POSIX attributes of a file are retrieved using a PosixFileAttributeView by invoking its readAttributes method."},
{"description": "A file attribute view that provides a view of the file attributes commonly associated with files on file systems used by operating systems that implement the Portable Operating System Interface (POSIX) family of standards.Operating systems that implement the POSIX family of standards commonly use file systems that have a file owner, group-owner, and related access permissions.This file attribute view provides read and write access to these attributes.The readAttributes method is used to read the file's attributes.The file owner is represented by a UserPrincipal that is the identity of the file owner for the purposes of access control.The group-owner, represented by a GroupPrincipal, is the identity of the group owner, where a group is an identity created for administrative purposes so as to determine the access rights for the members of the group.The permissions attribute is a set of access permissions.This file attribute view provides access to the nine permission defined by the PosixFilePermission class.These nine permission bits determine the read, write, and execute access for the file owner, group, and others (others meaning identities other than the owner and members of the group).Some operating systems and file systems may provide additional permission bits but access to these other bits is not defined by this class in this release.Usage Example: Suppose we need to print out the owner and access permissions of a file: Path file = ...(); System.out.format(\"%s %s%n\", attrs.owner().getName(), PosixFilePermissions.toString(attrs.permissions())); Dynamic Access Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by BasicFileAttributeView and FileOwnerAttributeView, and in addition, the following attributes are supported: Name Type \"permissions\" Set<PosixFilePermission> \"group\" GroupPrincipal The getAttribute method may be used to read any of these attributes, or any of the attributes defined by BasicFileAttributeView as if by invoking the readAttributes() method.The setAttribute method may be used to update the file's last modified time, last access time or create time attributes as defined by BasicFileAttributeView.It may also be used to update the permissions, owner, or group-owner as if by invoking the setPermissions, setOwner, and setGroup methods respectively.Setting Initial Permissions Implementations supporting this attribute view may also support setting the initial permissions when creating a file or directory.The initial permissions are provided to the createFile or createDirectory methods as a FileAttribute with name \"posix:permissions\" and a value that is the set of permissions.The following example uses the asFileAttribute method to construct a FileAttribute when creating a file:; When the access permissions are set at file creation time then the actual value of the permissions may differ that the value of the attribute object.The reasons for this are implementation specific.On UNIX systems, for example, a process has a umask that impacts the permission bits of newly created files.Where an implementation supports the setting of the access permissions, and the underlying file system supports access permissions, then it is required that the value of the actual access permissions will be equal or less than the value of the attribute provided to the createFile or createDirectory methods.In other words, the file may be more secure than requested."},
{"description": "The PreDestroy annotation is used on methods as a callback notification to signal that the instance is in the process of being removed by the container.The method annotated with PreDestroy is typically used to release resources that it has been holding.This annotation MUST be supported by all container managed objects that support PostConstruct except the application client container in Java EE 5.The method on which the PreDestroy annotation is applied MUST fulfill all of the following criteria: The method MUST NOT have any parameters except in the case of interceptors in which case it takes an InvocationContext object as defined by the Interceptors specification.The method defined on an interceptor class MUST HAVE one of the following signatures: void <METHOD>(InvocationContext)Object <METHOD>(InvocationContext) throws Exception Note: A PreDestroy interceptor method must not throw application exceptions, but it may be declared to throw checked exceptions including the java.lang.Exception if the same interceptor method interposes on business or timeout methods in addition to lifecycle events.If a PreDestroy interceptor method returns a value, it is ignored by the container.The method defined on a non-interceptor class MUST HAVE the following signature:The method on which PreDestroy is applied MAY be public, protected, package private or private.If the method throws an unchecked exception it is ignored except in the case of EJBs where the EJB can handle exceptions."},
{"description": "The standard interface that provides the framework for all FilteredRowSet objects to describe their filters.1.0 Background The Predicate interface is a standard interface that applications can implement to define the filter they wish to apply to a a FilteredRowSet object.A FilteredRowSet object consumes implementations of this interface and enforces the constraints defined in the implementation of the method evaluate.: It outputs only rows that are within the constraints of the filter; and conversely, it inserts, modifies, or updates only rows that are within the constraints of the filter.At this time, the JDBC RowSet Implementations (JSR-114) does not specify any standard filters definitions.By specifying a standard means and mechanism for a range of filters to be defined and deployed with both the reference and vendor implementations of the FilteredRowSet interface, this allows for a flexible and application motivated implementations of Predicate to emerge.A sample implementation would look something like this: public class Range implementsCheck the present row determine if it lies //SEVERE, null, ex); return false; } if (value < lo[i] && value > hi[i]) { // outside of filter constraints return false; } } //Within filter constraints return true; } } The example above implements a simple range predicate.Note, that implementations should but are not required to provide String and integer index based constructors to provide for JDBC RowSet Implementation applications that use both column identification conventions."},
{"description": "This class consists exclusively of static methods that operate on sets of PosixFilePermission objects."},
{"description": "A position indicates a location between two characters.The bias can be used to indicate an interest toward one of the two sides of the position in boundary conditions where a simple offset is ambiguous."},
{"description": "It is intended to abstract away implementation details of the document and enable specification of positions within the document that are capable of tracking of change as the document is edited.A Position object points at a location between two characters.As the surrounding content is altered, the Position object adjusts its offset automatically to reflect the changes.If content is inserted or removed before the Position object's location, then the Position increments or decrements its offset, respectively, so as to point to the same location.If a portion of the document is removed that contains a Position's offset, then the Position's offset becomes that of the beginning of the removed region.For example, if a Position has an offset of 5 and the region 2-10 is removed, then the Position's offset becomes 2.Position with an offset of 0 is a special case.It never changes its offset while document content is altered."},
{"description": "The PortInfo interface is used by a HandlerResolver to query information about the port it is being asked to create a handler chain for.This interface is never implemented by an application, only by a JAX-WS implementation."},
{"description": "The delegate is a singleton instance of a class that implements this interface and provides a replacement implementation for all the methods of javax.rmi.PortableRemoteObject.Delegates are enabled by providing the delegate's class name as the value of the javax.rmi.CORBA.PortableRemoteObjectClass system property."},
{"description": "Signals that an ICMP Port Unreachable message has been received on a connected datagram."},
{"description": "Server implementation objects may either inherit from javax.rmi.PortableRemoteObject or they may implement a remote interface and then use the exportObject method to register themselves as a server object.The toStub method takes a server implementation and returns a stub that can be used to access that server object.The connect method makes a Remote object ready for remote communication.The unexportObject method is used to deregister a server object, allowing it to become available for garbage collection.The narrow method takes an object reference or abstract interface type and attempts to narrow it to conform to the given interface.If the operation is successful the result will be an object of the specified type, otherwise an exception will be thrown."},
{"description": "Info class extends Line.Info with additional information specific to ports, including the port's name and whether it is a source or a target for its mixer.By definition, a port acts as either a source or a target to its mixer, but not both.(Audio input ports are sources; audio output ports are targets.)To learn what ports are available, you can retrieve port info objects through the getSourceLineInfo and getTargetLineInfo methods of the Mixer interface.Info class may also be constructed and used to obtain lines matching the parameters specified in the Port."},
{"description": "Ports are simple lines for input or output of audio to or from audio devices.Common examples of ports that act as source lines (mixer inputs) include the microphone, line input, and CD-ROM drive.Ports that act as target lines (mixer outputs) include the speaker, headphone, and line output.You can access port using a Port."},
{"description": "PopupMenuEvent only contains the source of the event which is the JPoupMenu sending the event Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "An object that provides hooks for connection pool management.A PooledConnection object represents a physical connection to a data source.The connection can be recycled rather than being closed when an application is finished with it, thus reducing the number of connections that need to be made.An application programmer does not use the PooledConnection interface directly; rather, it is used by a middle tier infrastructure that manages the pooling of connections.When an application calls the method DataSource.getConnection, it gets back a Connection object.If connection pooling is being done, that Connection object is actually a handle to a PooledConnection object, which is a physical connection.The connection pool manager, typically the application server, maintains a pool of PooledConnection objects.If there is a PooledConnection object available in the pool, the connection pool manager returns a Connection object that is a handle to that physical connection.If no PooledConnection object is available, the connection pool manager calls the ConnectionPoolDataSource method getPoolConnection to create a new physical connection.The JDBC driver implementing ConnectionPoolDataSource creates a new PooledConnection object and returns a handle to it.When an application closes a connection, it calls the Connection method close.When connection pooling is being done, the connection pool manager is notified because it has registered itself as a ConnectionEventListener object using the ConnectionPool method addConnectionEventListener.The connection pool manager deactivates the handle to the PooledConnection object and returns the PooledConnection object to the pool of connections so that it can be used again.Thus, when an application closes its connection, the underlying physical connection is recycled rather than being closed.The physical connection is not closed until the connection pool manager calls the PooledConnection method close.This method is generally called to have an orderly shutdown of the server or if a fatal error has made the connection unusable.A connection pool manager is often also a statement pool manager, maintaining a pool of PreparedStatement objects.When an application closes a prepared statement, it calls the PreparedStatement method close.When Statement pooling is being done, the pool manager is notified because it has registered itself as a StatementEventListener object using the ConnectionPool method addStatementEventListener.Thus, when an application closes its PreparedStatement, the underlying prepared statement is recycled rather than being closed."},
{"description": "The Polygon class encapsulates a description of a closed, two-dimensional region within a coordinate space.This region is bounded by an arbitrary number of line segments, each of which is one side of the polygon.Internally, a polygon comprises of a list of (x,y) coordinate pairs, where each pair defines a vertex of the polygon, and two successive pairs are the endpoints of a line that is a side of the polygon.The first and final pairs of (x,y) points are joined by a line segment that closes the polygon.This Polygon is defined with an even-odd winding rule.This class's hit-testing methods, which include the contains, intersects and inside methods, use the insideness definition described in the Shape class comments."},
{"description": "Popups are used to display a Component to the user, typically on top of all the other Components in a particular containment hierarchy.Popups have a very small life cycle.Once you have obtained a Popup, and hidden it (invoked the hide method), you should no longer invoke any methods on it.This allows the PopupFactory to cache Popups for later use.The general contract is that if you need to change the size of the Component, or location of the Popup, you should obtain a new Popup.Popup does not descend from Component, rather implementations of Popup are responsible for creating and maintaining their own Components to render the requested Component to the user.You typically do not explicitly create an instance of Popup, instead obtain one from a PopupFactory."},
{"description": "PopupFactory, as the name implies, is used to obtain instances of Popups.Popups are used to display a Component above all other Components in a particular containment hierarchy.The general contract is that once you have obtained a Popup from a PopupFactory, you must invoke hide on the Popup.The typical usage is: PopupFactory factory = PopupFactory.getSharedInstance(); Popup popup = factory.getPopup(owner, contents, x, y);"},
{"description": "A class that implements a menu which can be dynamically popped up at a specified position within a component.However, if you use a PopupMenu like a Menu (e.g., you add it to a MenuBar), then you cannot call show on that PopupMenu."},
{"description": "SEQUENCE { policyQualifierId PolicyQualifierId, qualifier ANY DEFINED BY policyQualifierId } A certificate policies extension, if present in an X.509 version 3 certificate, contains a sequence of one or more policy information terms, each of which consists of an object identifier (OID) and optional qualifiers.In an end-entity certificate, these policy information terms indicate the policy under which the certificate has been issued and the purposes for which the certificate may be used.In a CA certificate, these policy information terms limit the set of policies for certification paths which include this certificate.A Set of PolicyQualifierInfo objects are returned by the PolicyNode.getPolicyQualifiers method.This allows applications with specific policy requirements to process and validate each policy qualifier.Applications that need to process policy qualifiers should explicitly set the policyQualifiersRejected flag to false (by calling the PKIXParameters.setPolicyQualifiersRejected method) before validating a certification path.Note that the PKIX certification path validation algorithm specifies that any policy qualifier in a certificate policies extension that is marked critical must be processed and validated.If the policyQualifiersRejected flag is set to false, it is up to the application to validate all policy qualifiers in this manner in order to be PKIX compliant.That is, multiple threads may concurrently invoke the methods defined in this class on a single PolicyQualifierInfo object (or more than one) with no ill effects.Requiring PolicyQualifierInfo objects to be immutable and thread-safe allows them to be passed around to various pieces of code without worrying about coordinating access."},
{"description": "One of the outputs of the PKIX certification path validation algorithm is a valid policy tree, which includes the policies that were determined to be valid, how this determination was reached, and any policy qualifiers encountered.This tree is of depth n, where n is the length of the certification path that has been validated.Most applications will not need to examine the valid policy tree.They can achieve their policy processing goals by setting the policy-related parameters in PKIXParameters.However, the valid policy tree is available for more sophisticated applications, especially those that process policy qualifiers.PKIXCertPathValidatorResult.getPolicyTree returns the root node of the valid policy tree.The tree can be traversed using the getChildren and getParent methods.Data about a particular node can be retrieved using other methods of PolicyNode.Multiple threads may concurrently invoke the methods defined in this class on a single PolicyNode object (or more than one) with no ill effects.This stipulation applies to all public fields and methods of this class and any added or overridden by subclasses."},
{"description": "This class defines the Service Provider Interface (SPI) for the Policy class.All the abstract methods in this class must be implemented by each service provider who wishes to supply a Policy implementation.Subclass implementations of this abstract class must provide a public constructor that takes a Policy.Parameters object as an input parameter.This constructor also must throw an IllegalArgumentException if it does not understand the Policy."},
{"description": "A portable ORB service implementation registers an instance of the PolicyFactory interface during ORB initialization in order to enable its policy types to be constructed using CORBA.ORB.create_policy.The POA is required to preserve any policy which is registered with ORBInitInfo in this manner."},
{"description": "Encapsulates a reason a Policy may be invalid."},
{"description": "A PolicyError exception may include one of the following policy error reason codes defined in the org.omg.CORBA package:"},
{"description": "This represents a marker interface for Policy parameters."},
{"description": "A portable ORB service implementation registers an instance of the PolicyFactory interface during ORB initialization in order to enable its policy types to be constructed using CORBA.ORB.create_policy.The POA is required to preserve any policy which is registered with ORBInitInfo in this manner."},
{"description": "java.security.Policy has a method: public PermissionCollection getPermissions (java.security.ProtectionDomain pd) and ProtectionDomain has a constructor: public ProtectionDomain (CodeSource cs, PermissionCollection permissions, ClassLoader loader, Principal[] principals)These two APIs provide callers the means to query the Policy for Principal-based Permission entries."},
{"description": "Interfaces derived from the Policy interface allow an ORB or CORBA service access to certain choices that affect its operation.This information is accessed in a structured manner using interfaces derived from the Policy interface defined in the CORBA module.A CORBA service does not have to use this method of accessing operating options, but may choose to do so.The Security Service in particular uses this technique for associating Security Policy with objects in the system."},
{"description": "A Policy object is responsible for determining whether code executing in the Java runtime environment has permission to perform a security-sensitive operation.There is only one Policy object installed in the runtime at any given time.A Policy object can be installed by calling the setPolicy method.The installed Policy object can be obtained by calling the getPolicy method.If no Policy object has been installed in the runtime, a call to getPolicy installs an instance of the default Policy implementation (a default subclass implementation of this abstract class).The default Policy implementation can be changed by setting the value of the policy.provider security property to the fully qualified name of the desired Policy subclass implementation.Application code can directly subclass Policy to provide a custom implementation.In addition, an instance of a Policy object can be constructed by invoking one of the getInstance factory methods with a standard type.The default policy type is \"JavaPolicy\".Once a Policy instance has been installed (either by default, or by calling setPolicy), the Java runtime invokes its implies method when it needs to determine whether executing code (encapsulated in a ProtectionDomain) can perform SecurityManager-protected operations.How a Policy object retrieves its policy data is up to the Policy implementation itself.The policy data may be stored, for example, in a flat ASCII file, in a serialized binary file of the Policy class, or in a database.The refresh method causes the policy object to refresh/reload its data.For example, if the policy object stores its data in configuration files, calling refresh will cause it to re-read the configuration policy files.If a refresh operation is not supported, this method does nothing.Note that refreshed policy may not have an effect on classes in a particular ProtectionDomain.This is dependent on the Policy provider's implementation of the implies method and its PermissionCollection caching strategy."},
{"description": "A class that describes the pointer position.It provides the GraphicsDevice where the pointer is and the Point that represents the coordinates of the pointer.Instances of this class should be obtained via MouseInfo.getPointerInfo().To get the updated location, you must call MouseInfo.getPointerInfo() again."},
{"description": "The Float class defines a point specified in float precision."},
{"description": "The Point2D class defines a point representing a location in (x,y) coordinate space.This class is only the abstract superclass for all objects that store a 2D coordinate.The actual storage representation of the coordinates is left to the subclass."},
{"description": "The Double class defines a point specified in double precision."},
{"description": "A POA object manages the implementation of a collection of objects.The POA supports a name space for the objects, which are identified by Object Ids.A POA also provides a name space for POAs.A POA is created as a child of an existing POA, which forms a hierarchy starting with the root POA.A POA object must not be exported to other processes, or externalized with ORB::object_to_string."},
{"description": "Each POA object has an associated POAManager object.A POA manager may be associated with one or more POA objects.A POA manager encapsulates the processing state of the POAs it is associated with."},
{"description": "Each POA object has an associated POAManager object.A POA manager may be associated with one or more POA objects.A POA manager encapsulates the processing state of the POAs it is associated with."},
{"description": "A POA object manages the implementation of a collection of objects.The POA supports a name space for the objects, which are identified by Object Ids.A POA also provides a name space for POAs.A POA is created as a child of an existing POA, which forms a hierarchy starting with the root POA.A POA object must not be exported to other processes, or externalized with ORB::object_to_string."},
{"description": "A platform managed object is a JMX MXBean for monitoring and managing a component in the Java platform.Each platform managed object has a unique object name for the platform MBeanServer access.All platform MXBeans will implement this interface.Note: The platform MXBean interfaces (i.e. all subinterfaces of PlatformManagedObject) are implemented by the Java platform only.New methods may be added in these interfaces in future Java SE releases.In addition, this PlatformManagedObject interface is only intended for the management interfaces for the platform to extend but not for applications."},
{"description": "A POA object manages the implementation of a collection of objects.The POA supports a name space for the objects, which are identified by Object Ids.A POA also provides a name space for POAs.A POA is created as a child of an existing POA, which forms a hierarchy starting with the root POA.A POA object must not be exported to other processes, or externalized with ORB::object_to_string."},
{"description": "There is a single global instance of the PlatformLoggingMXBean.The ManagementFactory.getPlatformMXBean method can be used to obtain the PlatformLoggingMXBean object as follows: PlatformLoggingMXBean logging = ManagementFactory.getPlatformMXBean(PlatformLoggingMXBean.class); The PlatformLoggingMXBean object is also registered with the platform MBeanServer.The ObjectName for uniquely identifying the PlatformLoggingMXBean within an MBeanServer is: java.util.logging:type=Logging The instance registered in the platform MBeanServer with this ObjectName implements all attributes defined by LoggingMXBean."},
{"description": "Various revocation options that can be specified for the revocation checking mechanism."},
{"description": "The PKIXReason enumerates the potential PKIX-specific reasons that an X.509 certification path may be invalid according to the PKIX (RFC 3280) standard.These reasons are in addition to those of the CertPathValidatorException."},
{"description": "This class represents the successful result of the PKIX certification path validation algorithm.Instances of PKIXCertPathValidatorResult are returned by the validate method of CertPathValidator objects implementing the PKIX algorithm.All PKIXCertPathValidatorResult objects contain the valid policy tree and subject public key resulting from the validation algorithm, as well as a TrustAnchor describing the certification authority (CA) that served as a trust anchor for the certification path.Unless otherwise specified, the methods defined in this class are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "A PKIXRevocationChecker checks the revocation status of certificates with the Online Certificate Status Protocol (OCSP) or Certificate Revocation Lists (CRLs).OCSP is described in RFC 2560 and is a network protocol for determining the status of a certificate.A CRL is a time-stamped list identifying revoked certificates, and RFC 5280 describes an algorithm for determining the revocation status of certificates using CRLs.Each PKIXRevocationChecker must be able to check the revocation status of certificates with OCSP and CRLs.By default, OCSP is the preferred mechanism for checking revocation status, with CRLs as the fallback mechanism.However, this preference can be switched to CRLs with the PREFER_CRLS option.In addition, the fallback mechanism can be disabled with the NO_FALLBACK option.A PKIXRevocationChecker is obtained by calling the getRevocationChecker method of a PKIX CertPathValidator.Additional parameters and options specific to revocation can be set (by calling the setOcspResponder method for instance).The PKIXRevocationChecker is added to a PKIXParameters object using the addCertPathChecker or setCertPathCheckers method, and then the PKIXParameters is passed along with the CertPath to be validated to the validate method of a PKIX CertPathValidator.When supplying a revocation checker in this manner, it will be used to check revocation irrespective of the setting of the RevocationEnabled flag.Similarly, a PKIXRevocationChecker may be added to a PKIXBuilderParameters object for use with a PKIX CertPathBuilder.Note that when a PKIXRevocationChecker is added to PKIXParameters, it clones the PKIXRevocationChecker; thus any subsequent modifications to the PKIXRevocationChecker have no effect.Any parameter that is not set (or is set to null) will be set to the default value for that parameter.Unless otherwise specified, the methods defined in this class are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "An abstract class that performs one or more checks on an X509Certificate.A concrete implementation of the PKIXCertPathChecker class can be created to extend the PKIX certification path validation algorithm.For example, an implementation may check for and process a critical private extension of each certificate in a certification path.Instances of PKIXCertPathChecker are passed as parameters using the setCertPathCheckers or addCertPathChecker methods of the PKIXParameters and PKIXBuilderParameters class.Each of the PKIXCertPathCheckers check methods will be called, in turn, for each certificate processed by a PKIX CertPathValidator or CertPathBuilder implementation.A PKIXCertPathChecker may be called multiple times on successive certificates in a certification path.Concrete subclasses are expected to maintain any internal state that may be necessary to check successive certificates.The init method is used to initialize the internal state of the checker so that the certificates of a new certification path may be checked.A stateful implementation must override the clone method if necessary in order to allow a PKIX CertPathBuilder to efficiently backtrack and try other paths.In these situations, the CertPathBuilder is able to restore prior path validation states by restoring the cloned PKIXCertPathCheckers.The order in which the certificates are presented to the PKIXCertPathChecker may be either in the forward direction (from target to most-trusted CA) or in the reverse direction (from most-trusted CA to target).A PKIXCertPathChecker implementation must support reverse checking (the ability to perform its checks when it is presented with certificates in the reverse direction) and may support forward checking (the ability to perform its checks when it is presented with certificates in the forward direction).Additional input parameters required for executing the check may be specified through constructors of concrete implementations of this class.Unless otherwise specified, the methods defined in this class are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "Parameters used as input for the PKIX CertPathValidator algorithm.A PKIX CertPathValidator uses these parameters to validate a CertPath according to the PKIX certification path validation algorithm.To instantiate a PKIXParameters object, an application must specify one or more most-trusted CAs as defined by the PKIX certification path validation algorithm.The most-trusted CAs can be specified using one of two constructors.An application can call PKIXParameters(Set), specifying a Set of TrustAnchor objects, each of which identify a most-trusted CA.Alternatively, an application can call PKIXParameters(KeyStore), specifying a KeyStore instance containing trusted certificate entries, each of which will be considered as a most-trusted CA.Once a PKIXParameters object has been created, other parameters can be specified (by calling setInitialPolicies or setDate, for instance) and then the PKIXParameters is passed along with the CertPath to be validated to CertPathValidator.validate.Any parameter that is not set (or is set to null) will be set to the default value for that parameter.The default value for the date parameter is null, which indicates the current time when the path is validated.The default for the remaining parameters is the least constrained.Unless otherwise specified, the methods defined in this class are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "A plain document that maintains no character attributes.The default element structure for this document is a map of the lines in the text.The Element returned by getDefaultRootElement is a map of the lines, and each child element represents a line.This model does not maintain any character level attributes, but each line can be tagged with an arbitrary set of attributes.Line to offset, and offset to line translations can be quickly performed using the default root element.The structure information of the DocumentEvent's fired by edits will indicate the line structure changes.The default content storage management is performed by a gapped buffer implementation (GapContent).It supports editing reasonably large documents with good efficiency when the edits are contiguous or clustered, as is typical.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The PixelGrabber class implements an ImageConsumer which can be attached to an Image or ImageProducer object to retrieve a subset of the pixels in that image.(pixel >> 24) & 0xff; int red = (pixel >> 16) & 0xff; int green =x, y, w, h, pixels, 0, w); try { pg.grabPixels();} catch (InterruptedException e) { System.err.println(\"interrupted waiting for pixels!\")= 0) { System.err.println(\"image fetch aborted or errored\"); return; } for (int j = 0; j < h; j++) { for (int i = 0;"},
{"description": "This class represents the successful result of the PKIX certification path builder algorithm.All certification paths that are built and returned using this algorithm are also validated according to the PKIX certification path validation algorithm.Instances of PKIXCertPathBuilderResult are returned by the build method of CertPathBuilder objects implementing the PKIX algorithm.All PKIXCertPathBuilderResult objects contain the certification path constructed by the build algorithm, the valid policy tree and subject public key resulting from the build algorithm, and a TrustAnchor describing the certification authority (CA) that served as a trust anchor for the certification path.Unless otherwise specified, the methods defined in this class are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "Parameters used as input for the PKIX CertPathBuilder algorithm.A PKIX CertPathBuilder uses these parameters to build a CertPath which has been validated according to the PKIX certification path validation algorithm.To instantiate a PKIXBuilderParameters object, an application must specify one or more most-trusted CAs as defined by the PKIX certification path validation algorithm.The most-trusted CA can be specified using one of two constructors.An application can call PKIXBuilderParameters(Set, CertSelector), specifying a Set of TrustAnchor objects, each of which identifies a most-trusted CA.Alternatively, an application can call PKIXBuilderParameters(KeyStore, CertSelector), specifying a KeyStore instance containing trusted certificate entries, each of which will be considered as a most-trusted CA.In addition, an application must specify constraints on the target certificate that the CertPathBuilder will attempt to build a path to.The constraints are specified as a CertSelector object.These constraints should provide the CertPathBuilder with enough search criteria to find the target certificate.Minimal criteria for an X509Certificate usually include the subject name and/or one or more subject alternative names.If enough criteria is not specified, the CertPathBuilder may throw a CertPathBuilderException.Unless otherwise specified, the methods defined in this class are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "This class represents the ASN.1 encoding of a private key, encoded according to the ASN.1 type PrivateKeyInfo.The PrivateKeyInfo syntax is defined in the PKCS#8 standard as follows:"},
{"description": "This class represents image data which is stored in a pixel interleaved fashion and for which each sample of a pixel occupies one data element of the DataBuffer.It subclasses ComponentSampleModel but provides a more efficient implementation for accessing pixel interleaved image data than is provided by ComponentSampleModel.Pixel stride is the number of data array elements between two samples for the same band on the same scanline.Scanline stride is the number of data array elements between a given sample and the corresponding sample in the same column of the next scanline.The bands are numbered from 0 toN-1. Bank indices denote the correspondence between a bank of the data buffer and a band of image data.This class supports TYPE_BYTE, TYPE_USHORT, TYPE_SHORT, TYPE_INT, TYPE_FLOAT and TYPE_DOUBLE datatypes."},
{"description": "The attribute name is an ASN.1 Object Identifier and the attribute value is a set of ASN.1 types."},
{"description": "Implements View interface for a simple multi-line text view that has text in one font and color.The view represents each child element as a line of text."},
{"description": "A piped output stream can be connected to a piped input stream to create a communications pipe.The piped output stream is the sending end of the pipe.Typically, data is written to a PipedOutputStream object by one thread and data is read from the connected PipedInputStream by some other thread.Attempting to use both objects from a single thread is not recommended as it may deadlock the thread.The pipe is said to be broken if a thread that was reading data bytes from the connected piped input stream is no longer alive."},
{"description": "All permissions have a name (whose interpretation depends on the subclass), as well as abstract functions for defining the semantics of the particular Permission subclass.Most Permission objects also include an \"actions\" list that tells the actions that are permitted for the object.For example, for a java.io.FilePermission object, the permission name is the pathname of a file (or directory), and the actions list (such as \"read, write\") specifies which actions are granted for the specified file (or for files in the specified directory).The actions list is optional for Permission objects, such as java.lang.RuntimePermission, that don't need such a list; you either have the named permission (such as \"system.exit\") or you don't.An important method that must be implemented by each subclass is the implies method to compare Permissions.Basically, \"permission p1 implies permission p2\" means that if one is granted permission p1, one is naturally granted permission p2.Thus, this is not an equality test, but rather more of a subset test.Permission objects are similar to String objects in that they are immutable once they have been created.Subclasses should not provide methods that can change the state of a permission once it has been created."},
{"description": "A piped input stream should be connected to a piped output stream; the piped input stream then provides whatever data bytes are written to the piped output stream.Typically, data is read from a PipedInputStream object by one thread and data is written to the corresponding PipedOutputStream by some other thread.Attempting to use both objects from a single thread is not recommended, as it may deadlock the thread.The piped input stream contains a buffer, decoupling read operations from write operations, within limits.A pipe is said to be broken if a thread that was providing data bytes to the connected piped output stream is no longer alive."},
{"description": "This class represents a heterogeneous collection of Permissions.That is, it contains different types of Permission objects, organized into PermissionCollections.For example, if any java.io.FilePermission objects are added to an instance of this class, they are all stored in a single PermissionCollection.It is the PermissionCollection returned by a call to the newPermissionCollection method in the FilePermission class.Similarly, any java.lang.RuntimePermission objects are stored in the PermissionCollection returned by a call to the newPermissionCollection method in the RuntimePermission class.Thus, this class represents a collection of PermissionCollections.When the add method is called to add a Permission, the Permission is stored in the appropriate PermissionCollection.If no such collection exists yet, the Permission object's class is determined and the newPermissionCollection method is called on that class to create the PermissionCollection and add it to the Permissions object.If newPermissionCollection returns null, then a default PermissionCollection that uses a hashtable will be created and used.Each hashtable entry stores a Permission object as both the key and the value.Enumerations returned via the elements method are not fail-fast.Modifications to a collection should not be performed while enumerating over that collection."},
{"description": "This interface represents a permission, such as that used to grant a particular type of access to a resource."},
{"description": "Class PDLOverrideSupported is a printing attribute class, an enumeration, that expresses the printer's ability to attempt to override processing instructions embedded in documents' print data with processing instructions specified as attributes outside the print data.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "This class models a quantity or amount of time in terms of years, months and days.Durations and periods differ in their treatment of daylight savings time when added to ZonedDateTime.A Duration will add an exact number of seconds, thus a duration of one day is always exactly 24 hours.By contrast, a Period will add a conceptual day, trying to maintain the local time.The Period will add the conceptual day and result in a ZonedDateTime at 18:00 the following day.By contrast, the Duration will add exactly 24 hours, resulting in a ZonedDateTime at 19:00 the following day (assuming a one hour DST gap).The supported units of a period are YEARS, MONTHS and DAYS.All three fields are always present, but may be set to zero.The ISO-8601 calendar system is the modern civil calendar system used today in most of the world.It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time.The period is modeled as a directed amount of time, meaning that individual parts of the period may be negative.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of Period may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "A user-chosen password that can be used with password-based encryption (PBE).The password can be viewed as some kind of raw key material, from which the encryption mechanism that uses it derives a cryptographic key.Different PBE mechanisms may consume different bits of each password character.For example, the PBE mechanism defined in PKCS #5 looks at only the low order 8 bits of each character, whereas PKCS #12 looks at all 16 bits of each character.You convert the password characters to a PBE key by creating an instance of the appropriate secret-key factory.For example, a secret-key factory for PKCS #5 will construct a PBE key from only the low order 8 bits of each password character, whereas a secret-key factory for PKCS #12 will take all 16 bits of each character.Also note that this class stores passwords as char arrays instead of String objects (which would seem more logical), because the String class is immutable and there is no way to overwrite its internal value when the password stored in it is no longer needed.Hence, this class requests the password as a char array, so it can be overwritten when done."},
{"description": "This class specifies the set of parameters used with password-based encryption (PBE), as defined in the PKCS #5 standard."},
{"description": "With a PermissionCollection, you can: add a permission to the collection using the add method.check to see if a particular permission is implied in the collection, using the implies method.When it is desirable to group together a number of Permission objects of the same type, the newPermissionCollection method on that particular type of Permission object should first be called.The default behavior (from the Permission class) is to simply return null.Subclasses of class Permission override the method if they need to store their permissions in a particular PermissionCollection object in order to provide the correct semantics when the PermissionCollection.implies method is called.If null is returned, then the caller of newPermissionCollection is free to store permissions of the given type in any PermissionCollection they choose (one that uses a Hashtable, one that uses a Vector, etc).The PermissionCollection returned by the Permission.newPermissionCollection method is a homogeneous collection, which stores only Permission objects for a given Permission type.For example, Permissions is a PermissionCollection subclass that represents a collection of PermissionCollections.That is, its members are each a homogeneous PermissionCollection.For example, a Permissions object might have a FilePermissionCollection for all the FilePermission objects, a SocketPermissionCollection for all the SocketPermission objects, and so on.Its add method adds a permission to the appropriate collection.Whenever a permission is added to a heterogeneous PermissionCollection such as Permissions, and the PermissionCollection doesn't yet contain a PermissionCollection of the specified permission's type, the PermissionCollection should call the newPermissionCollection method on the permission's class to see if it requires a special PermissionCollection.If newPermissionCollection returns null, the PermissionCollection is free to store the permission in any type of PermissionCollection it desires (one using a Hashtable, one using a Vector, etc.).For example, the Permissions object uses a default PermissionCollection implementation that stores the permission objects in a Hashtable.Subclass implementations of PermissionCollection should assume that they may be called simultaneously from multiple threads, and therefore should be synchronized properly.Furthermore, Enumerations returned via the elements method are not fail-fast.Modifications to a collection should not be performed while enumerating over that collection."},
{"description": "A regular expression, specified as a string, must first be compiled into an instance of this class.The resulting pattern can then be used to create a Matcher object that can match arbitrary character sequences against the regular expression.All of the state involved in performing a match resides in the matcher, so many matchers can share the same pattern.A typical invocation sequence is thus Pattern p = Pattern.compile(\"a*b\");Matcher m = p.matcher(\"aaaaab\"); boolean b = m.matches(); A matches method is defined by this class as a convenience for when a regular expression is used just once.This method compiles an expression and matches an input sequence against it in a single invocation.The statement boolean b = Pattern.matches(\"a*b\", \"aaaaab\"); is equivalent to the three statements above, though for repeated matches it is less efficient since it does not allow the compiled pattern to be reused.Instances of this class are immutable and are safe for use by multiple concurrent threads.Instances of the Matcher class are not safe for such use.Summary of regular-expression constructs Construct Matches \u00a0 CharactersThe control character corresponding to x \u00a0 Character classes [abc] a, b, or c (simple class)Any Unicode linebreak sequence, is equivalent to \\u000D\\u000A|[\\u000A\\u000B\\u000C\\u000D\\u0085\\u2028\\u2029] \u00a0 Greedy quantifiersm}+ X, at least n but not more than m times \u00a0 Logical operators XY X followed by Y X|YWhatever the nth capturing group matched \\k<name>i d m sX, as an independent, non-capturing group Backslashes, escapes, and quoting The backslash character ('\\') serves to introduce escaped constructs, as defined in the table above, as well as to quote characters that otherwise would be interpreted as unescaped constructs.Thus the expression \\\\ matches a single backslash and \\{ matches a left brace.It is an error to use a backslash prior to any alphabetic character that does not denote an escaped construct; these are reserved for future extensions to the regular-expression language.A backslash may be used prior to a non-alphabetic character regardless of whether that character is part of an unescaped construct.Backslashes within string literals in Java source code are interpreted as required by The Java\u2122 Language Specification as either Unicode escapes (section 3.3) or other character escapes (section 3.10.6)It is therefore necessary to double backslashes in string literals that represent regular expressions to protect them from interpretation by the Java bytecode compiler.The string literal \"\\b\", for example, matches a single backspace character when interpreted as a regular expression, while \"\\\\b\" matches a word boundary.The string literal \"\\(hello\\)\" is illegal and leads to a compile-time error; in order to match the string (hello) the string literal \"\\\\(hello\\\\)\" must be used.Character Classes Character classes may appear within other character classes, and may be composed by the union operator (implicit) and the intersection operator (&&).The union operator denotes a class that contains every character that is in at least one of its operand classes.The intersection operator denotes a class that contains every character that is in both of its operand classes.The precedence of character-class operators is as follows, from highest to lowest: 1\u00a0\u00a0\u00a0\u00a0 Note that a different set of metacharacters are in effect inside a character class than outside a character class.loses its special meaning inside a character class, while the expression - becomes a range forming metacharacter.A line terminator is a one- or two-character sequence that marks the end of a line of the input character sequence.The following are recognized as line terminators:A carriage-return character followed immediately by a newline character\u00a0(\"\\r\\n\"), A standalone carriage-return character\u00a0('\\r'), A next-line character\u00a0('\\u0085'), A line-separator character\u00a0('\\u2028'), or A paragraph-separator character\u00a0('\\u2029).If UNIX_LINES mode is activated, then the only line terminators recognized are newline characters.matches any character except a line terminator unless the DOTALL flag is specified.If MULTILINE mode is activated then ^ matches at the beginning of input and after any line terminator except at the end of input.Groups and capturing Group number Capturing groups are numbered by counting their opening parentheses from left to right.In the expression ((A)(B(C))), for example, there are four such groups: 1\u00a0\u00a0\u00a0\u00a0 (C) Group zero always stands for the entire expression.Capturing groups are so named because, during a match, each subsequence of the input sequence that matches such a group is saved.The captured subsequence may be used later in the expression, via a back reference, and may also be retrieved from the matcher once the match operation is complete.Group name A capturing group can also be assigned a \"name\", a named-capturing group, and then be back-referenced later by the \"name\".Group names are composed of the following characters.The first character must be a letter.The uppercase letters 'A' through 'Z' ('\\u0041'\u00a0through\u00a0'\\u005a'),The lowercase letters 'a' through 'z' ('\\u0061'\u00a0through\u00a0'\\u007a'), The digits '0' through '9' ('\\u0030'\u00a0through\u00a0'\\u0039'), A named-capturing group is still numbered as described in Group number.The captured input associated with a group is always the subsequence that the group most recently matched.If a group is evaluated a second time because of quantification then its previously-captured value, if any, will be retained if the second evaluation fails.Matching the string \"aba\" against the expression (a(b)?)+, for example, leaves group two set to \"b\".All captured input is discarded at the beginning of each match.Groups beginning with (? are either pure, non-capturing groups that do not capture text and do not count towards the group total, or named-capturing group.Unicode support This class is in conformance with Level 1 of Unicode Technical Standard #18: Unicode Regular Expression, plus RL2.1 Canonical Equivalents.Unicode escape sequences such as \\u2014 in Java source code are processed as described in section 3.3 of The Java\u2122 Language Specification.Such escape sequences are also implemented directly by the regular-expression parser so that Unicode escapes can be used in expressions that are read from files or from the keyboard.Thus the strings \"\\u2014\" and \"\\\\u2014\", while not equal, compile into the same pattern, which matches the character with hexadecimal value 0x2014.A Unicode character can also be represented in a regular-expression by using its Hex notation(hexadecimal code point value) directly as described in construct \\x{...}, for example a supplementary character U+2011F can be specified as \\x{2011F}, instead of two consecutive Unicode escape sequences of the surrogate pair \\uD840\\uDD1F.Unicode scripts, blocks, categories and binary properties are written with the \\p and \\P constructs as in Perl.\\p{prop} matches if the input has the property prop, while \\P{prop} does not match if the input has that property.Scripts, blocks, categories and binary properties can be used both inside and outside of a character class.Scripts are specified either with the prefix Is, as in IsHiragana, or by using the script keyword (or its short form sc)as in script=Hiragana or sc=Hiragana.The script names supported by Pattern are the valid script names accepted and defined by UnicodeScript.forName. Blocks are specified with the prefix In, as in InMongolian, or by using the keyword block (or its short form blk) as in block=Mongolian or blk=Mongolian.The block names supported by Pattern are the valid block names accepted and defined by UnicodeBlock.forName.Categories may be specified with the optional prefixBoth \\p{L} and \\p{IsL} denote the category of Unicode letters.Same as scripts and blocks, categories can also be specified by using the keyword general_category (or its short form gc) as in general_category=Lu or gc=Lu.The supported categories are those of The Unicode Standard in the version specified by the Character class.The category names are those defined in the Standard, both normative and informative.Binary properties are specified with the prefix Is, as in IsAlphabetic.The supported binary properties by Pattern are Alphabetic Ideographic Letter Lowercase UppercaseAssigned The following Predefined Character classes and POSIX character classes are in conformance with the recommendation of Annex C: Compatibility Properties of Unicode Regular Expression , when UNICODE_CHARACTER_CLASS flag is specified.: [^\\w] Categories that behave like the java.lang.Character boolean ismethodname methods (except for the deprecated ones) are available through the same \\p{prop} syntax where the specified property has the name javamethodname.The Pattern engine performs traditional NFA-based matching with ordered alternation as occurs in Perl 5.Notable differences from Perl: In Perl, \\1 through \\9 are always interpreted as back references; a backslash-escaped number greater than 9 is treated as a back reference if at least that many subexpressions exist, otherwise it is interpreted, if possible, as an octal escape.In this class octal escapes must always begin with a zero.In this class, \\1 through \\9 are always interpreted as back references, and a larger number is accepted as a back reference if at least that many subexpressions exist at that point in the regular expression, otherwise the parser will drop digits until the number is smaller or equal to the existing number of groups or it is one digit.Perl uses the g flag to request a match that resumes where the last match left off.This functionality is provided implicitly by the Matcher class: Repeated invocations of the find method will resume where the last match left off, unless the matcher is reset.In this class, embedded flags always take effect at the point at which they appear, whether they are at the top level or within a group; in the latter case, flags are restored at the end of the group just as in Perl."},
{"description": "Unchecked exception thrown to indicate a syntax error in a regular-expression pattern."},
{"description": "This class consists exclusively of static methods that return a Path by converting a path string or URI."},
{"description": "An interface that is implemented by objects that perform match operations on paths."},
{"description": "The PathIterator interface provides the mechanism for objects that implement the Shape interface to return the geometry of their boundary by allowing a caller to retrieve the path of that boundary a segment at a time.This interface allows these objects to retrieve the path of their boundary a segment at a time by using 1st through 3rd order B\u00e9zier curves, which are lines and quadratic or cubic B\u00e9zier splines.Multiple subpaths can be expressed by using a \"MOVETO\" segment to create a discontinuity in the geometry to move from the end of one subpath to the beginning of the next.Each subpath can be closed manually by ending the last segment in the subpath on the same coordinate as the beginning \"MOVETO\" segment for that subpath or by using a \"CLOSE\" segment to append a line segment from the last point back to the first.Be aware that manually closing an outline as opposed to using a \"CLOSE\" segment to close the path might result in different line style decorations being used at the end points of the subpath.For example, the BasicStroke object uses a line \"JOIN\" decoration to connect the first and last points if a \"CLOSE\" segment is encountered, whereas simply ending the path on the same coordinate as the beginning coordinate results in line \"CAP\" decorations being used at the ends."},
{"description": "The Float class defines a geometric path with coordinates stored in single precision floating point."},
{"description": "An object that may be used to locate a file in a file system.It will typically represent a system dependent file path.A Path represents a path that is hierarchical and composed of a sequence of directory and file name elements separated by a special separator or delimiter.A root component, that identifies a file system hierarchy, may also be present.The name element that is farthest from the root of the directory hierarchy is the name of a file or directory.The other name elements are directory names.A Path can represent a root, a root and a sequence of names, or simply one or more name elements.A Path is considered to be an empty path if it consists solely of one name element that is empty.Accessing a file using an empty path is equivalent to accessing the default directory of the file system.Path defines the getFileName, getParent, getRoot, and subpath methods to access the path components or a subsequence of its name elements.In addition to accessing the components of a path, a Path also defines the resolve and resolveSibling methods to combine paths.The relativize method that can be used to construct a relative path between two paths.Paths can be compared, and tested against each other using the startsWith and endsWith methods.This interface extends Watchable interface so that a directory located by a path can be registered with a WatchService and entries in the directory watched.This interface is only intended to be implemented by those developing custom file system implementations.Methods may be added to this interface in future releases.Files Paths may be used with the Files class to operate on files, directories, and other types of files.For example, suppose we want a BufferedReader to read text from a file \"access.log\".The file is located in a directory \"logs\" relative to the current working directory and is UTF-8 encoded.UTF_8); Interoperability Paths associated with the default provider are generally interoperable with the java.io.File class.Paths created by other providers are unlikely to be interoperable with the abstract path names represented by java.io.File.The toPath method may be used to obtain a Path from the abstract path name represented by a java.io.File object.The resulting Path can be used to operate on the same file as the java.io.File object.In addition, the toFile method is useful to construct a File from the String representation of a Path.Concurrency Implementations of this interface are immutable and safe for use by multiple concurrent threads."},
{"description": "A Patch object represents a location, on a MIDI synthesizer, into which a single instrument is stored (loaded).Every Instrument object has its own Patch object that specifies the memory location into which that instrument should be loaded.The location is specified abstractly by a bank index and a program number (not by any scheme that directly refers to a specific address or offset in RAM).This is a hierarchical indexing scheme:MIDI provides for up to 16384 banks, each of which contains up to 128 program locations.For example, a minimal sort of synthesizer might have only one bank of instruments, and only 32 instruments (programs) in that bank.To select what instrument should play the notes on a particular MIDI channel, two kinds of MIDI message are used that specify a patch location: a bank-select command, and a program-change channel command.The Java Sound equivalent is the programChange(int, int) method of MidiChannel."},
{"description": "The Double class defines a geometric path with coordinates stored in double precision floating point."},
{"description": "The Path2D class provides a simple, yet flexible shape which represents an arbitrary geometric path.It can fully represent any path which can be iterated by the PathIterator interface including all of its segment types and winding rules and it implements all of the basic hit testing methods of the Shape interface.Use Path2D.Float when dealing with data that can be represented and used with floating point precision.Use Path2D.Double for data that requires the accuracy or range of double precision.Path2D provides exactly those facilities required for basic construction and management of a geometric path and implementation of the above interfaces with little added interpretation.If it is useful to manipulate the interiors of closed geometric shapes beyond simple hit testing then the Area class provides additional capabilities specifically targeted at closed figures.While both classes nominally implement the Shape interface, they differ in purpose and together they provide two useful views of a geometric shape where Path2D deals primarily with a trajectory formed by path segments and Area deals more with interpretation and manipulation of enclosed regions of 2D geometric space.The PathIterator interface has more detailed descriptions of the types of segments that make up a path and the winding rules that control how to determine which regions are inside or outside the path."},
{"description": "This is basically a field ui that renders its contents as the echo character specified in the associated component (if it can narrow the component to a JPasswordField)."},
{"description": "The class PasswordAuthentication is a data holder that is used by Authenticator.It is simply a repository for a user name and a password."},
{"description": "For example, when listing a context, this exception indicates that returned results only represents some of the bindings in the context.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "This class works with the deprecated Parser interface."},
{"description": "Responsible for starting up a new DocumentParser each time its parse method is invoked."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This class wraps a SAX1 Parser and makes it act as a SAX2 XMLReader, with feature, property, and Namespace support.Note that it is not possible to report skippedEntity events, since SAX1 does not make that information available.This adapter does not test for duplicate Namespace-qualified attribute names."},
{"description": "Underlying security services instantiate and pass a PasswordCallback to the handle method of a CallbackHandler to retrieve password information."},
{"description": "The parser reads an HTML file from an InputStream and calls various methods (which should be overridden in a subclass) when tags and data are encountered.Unfortunately there are many badly implemented HTML parsers out there, and as a result there are many badly formatted HTML files.This parser attempts to parse most HTML files.This means that the implementation sometimes deviates from the SGML specification in favor of HTML.Newlines after starttags and before end tags are ignored just as specified in the SGML/HTML specification.Specifically, the following scenarios are not discussed (note that a space should be used here, but I am using &nbsp to force the space to be displayed): '<b><i>\u00a0<strike>\u00a0foo' which can be treated as: '<b>Using</em></a></p>' which appears to be treated as: '<p><a href=\"xx\"><em>' If strict is false, when a tag that breaks flow, (TagElement.breaksFlows) or trailing whitespace is encountered, all whitespace will be ignored until a non whitespace character is encountered.This appears to give behavior closer to the popular browsers."},
{"description": "JAXB providers are allowed to use whatever class that implements the ValidationEvent interface.This class is just provided for a convenience."},
{"description": "This interface has been replaced by the SAX2 XMLReader interface, which includes Namespace support."},
{"description": "ParsePosition is a simple class used by Format and its subclasses to keep track of the current position during parsing.The parseObject method in the various Format classes requires a ParsePosition object as an argument.By design, as you parse through a string with different formats, you can use the same ParsePosition, since the index parameter records the current position."},
{"description": "This event indicates that a problem was encountered while converting a string from the XML data into a value of the target Java data type."},
{"description": "The ParameterDescriptor class allows bean implementors to provide additional information on each of their parameters, beyond the low level type information provided by the java.lang.reflect.Method class.Currently all our state comes from the FeatureDescriptor base class."},
{"description": "A ParameterBlock encapsulates all the information about sources and parameters (Objects) required by a RenderableImageOp, or other classes that process images.Although it is possible to place arbitrary objects in the source Vector, users of this class may impose semantic constraints such as requiring all sources to be RenderedImages or RenderableImage.ParameterBlock itself is merely a container and performs no checking on source or parameter types.All parameters in a ParameterBlock are objects; convenience add and set methods are available that take arguments of base type and construct the appropriate subclass of Number (such as Integer or Float).Corresponding get methods perform a downward cast and have return values of base type; an exception will be thrown if the stored values do not have the correct type.There is no way to distinguish between the results of \"short s; add(s)\" and \"add(new Short(s))\".Note that the get and set methods operate on references.Therefore, one must be careful not to share references between ParameterBlocks when this is inappropriate.For example, to create a new ParameterBlock that is equal to an old one except for an added source, one might be tempted to write:new ParameterBlock(pb.getSources()); pb1.addSource(im); return pb1; } This code will have the side effect of altering the original ParameterBlock, since the getSources operation returned a reference to its source Vector.Both pb and pb1 share their source Vector, and a change in either is visible to both.A correct way to write the addSource function is to clone the source Vector:new ParameterBlock(pb.getSources().clone()); pb1.addSource(im); return pb1; } The clone method of ParameterBlock has been defined to perform a clone of both the source and parameter Vectors for this reason.A standard, shallow clone is available as shallowClone.The addSource, setSource, add, and set methods are defined to return 'this' after adding their argument.This allows use of syntax like: ParameterBlock pb ="},
{"description": "An object that can be used to get information about the types and properties for each parameter marker in a PreparedStatement object.For some queries and driver implementations, the data that would be returned by a ParameterMetaData object may not be available until the PreparedStatement has been executed.Some driver implementations may not be able to provide information about thetypes and properties for each parameter marker in a CallableStatementobject."},
{"description": "A mixin interface for an element that has type parameters."},
{"description": "ParameterizedType represents a parameterized type such as Collection<String>.A parameterized type is created the first time it is needed by a reflective method, as specified in this package.When a parameterized type p is created, the generic type declaration that p instantiates is resolved, and all type arguments of p are created recursively.Repeated creation of a parameterized type has no effect.Instances of classes that implement this interface must implement an equals() method that equates any two instances that share the same generic type declaration and have equal type parameters."},
{"description": "A Parameter provides information about method parameters, including its name and modifiers.It also provides an alternate means of obtaining attributes for the parameter."},
{"description": "View of a simple line-wrapping paragraph that supports multiple fonts, colors, components, icons, etc.It is basically a vertical box with a margin around it.The contents of the box are a bunch of rows which are special horizontal boxes.This view creates a collection of views that represent the child elements of the paragraph element.Each of these views are placed into a row directly if they will fit, otherwise the breakView method is called to try and carve the view into pieces that fit."},
{"description": "Panel is the simplest container class.A panel provides space in which an application can attach any other component, including other panels.The default layout manager for a panel is the FlowLayout layout manager."},
{"description": "The Painter interface defines exactly one method, paint.It is used in situations where the developer can change the painting routine of a component without having to resort to subclassing the component.It is also generically useful when doing any form of painting delegation.Painters are simply encapsulations of Java2D code and make it fairly trivial to reuse existing Painters or to combine them together.Implementations of this interface are also trivial to write, such that if you can't find a Painter that does what you need, you can write one with minimal effort.Writing a Painter requires knowledge of Java2D. A Painter may be created with a type parameter.This type will be expected in the paint method.For example, you may wish to write a Painter that only works with subclasses of Component.In that case, when the Painter is declared, you may declare that it requires a Component, allowing the paint method to be type safe.//and so forth } } This interface makes no guarantees of threadsafety."},
{"description": "The Paper class describes the physical characteristics of a piece of paper.When creating a Paper object, it is the application's responsibility to ensure that the paper size and the imageable area are compatible.For example, if the paper size is changed from 11 x 17 to 8.5 x 11, the application might need to reduce the imageable area so that whatever is printed fits on the page."},
{"description": "This event is a special type which is used to ensure that paint/update method calls are serialized along with the other events delivered from the event queue.This event is not designed to be used with the Event Listener model; programs should continue to override paint/update methods in order render themselves properly.An unspecified behavior will be caused if the id parameter of any particular PaintEvent instance is not in the range from PAINT_FIRST to PAINT_LAST."},
{"description": "The PaintContext interface defines the encapsulated and optimized environment to generate color patterns in device space for fill or stroke operations on a Graphics2D.The PaintContext provides the necessary colors for Graphics2D operations in the form of a Raster associated with a ColorModel.The PaintContext maintains state for a particular paint operation.In a multi-threaded environment, several contexts can exist simultaneously for a single Paint object."},
{"description": "Class PagesPerMinuteColor is an integer valued printing attribute that indicates the nominal number of pages per minute to the nearest whole number which may be generated by this printer when printing color (e.g., simplex, color).For purposes of this attribute, \"color\" means the same as for the ColorSupported attribute, namely, the device is capable of any type of color printing at all, including highlight color as well as full process color.Generally, it is the value used in the marketing literature to describe the color capabilities of this device.A value of 0 indicates a device that takes more than two minutes to process a page.If a color device has several color modes, it may use the pages-per- minute value for this attribute that corresponds to the mode that produces the highest number.A black and white only printer must not include the PagesPerMinuteColor attribute in its attribute set or service registration.If this attribute is present, then the ColorSupported printer description attribute must also be present and have a value of SUPPORTED.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class PagesPerMinute is an integer valued printing attribute that indicates the nominal number of pages per minute to the nearest whole number which may be generated by this printer (e.g., simplex, black-and-white).Generally, it is the value used in the marketing literature to describe the device.A value of 0 indicates a device that takes more than two minutes to process a page.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "The cookie must be supplied to the next search operation in order to get the next batch of results.The code sample in PagedResultsControl shows how this class may be used.This class implements the LDAPv3 Response Control for paged-results as defined in RFC 2696.The control's value has the following ASN.1 definition: realSearchControlValue ::= SEQUENCE { size INTEGER (0..maxInt), -- requested page size from client -- result"},
{"description": "The PageFormat class describes the size and orientation of a page to be printed."},
{"description": "This Paint interface defines how color patterns can be generated for Graphics2D operations.A class implementing the Paint interface is added to the Graphics2D context in order to define the color pattern used by the draw and fill methods.Instances of classes implementing Paint must be read-only because the Graphics2D does not clone these objects when they are set as an attribute with the setPaint method or when the Graphics2D object is itself cloned."},
{"description": "Class PageRanges is a printing attribute class, a set of integers, that identifies the range(s) of print-stream pages that the Printer object uses for each copy of each document which are to be printed.Nothing is printed for any pages identified that do not exist in the document(s).The attribute is associated with print-stream pages, not application-numbered pages (for example, the page numbers found in the headers and or footers for certain word processing applications).In most cases, the exact pages to be printed will be generated by a device driver and this attribute would not be required.However, when printing an archived document which has already been formatted, the end user may elect to print just a subset of the pages contained in the document.In this case, if a page range of \"n-m\" is specified, the first page to be printed will be page n.All subsequent pages of the document will be printed through and including page m.If a PageRanges attribute is not specified for a print job, all pages of the document will be printed.In other words, the default value for the PageRanges attribute is always {{1, Integer.The effect of a PageRanges attribute on a multidoc print job (a job with multiple documents) depends on whether all the docs have the same page ranges specified or whether different docs have different page ranges specified, and on the (perhaps defaulted) value of the MultipleDocumentHandling attribute.If all the docs have the same page ranges specified, then any value of MultipleDocumentHandling makes sense, and the printer's processing depends on the MultipleDocumentHandling value:SINGLE_DOCUMENT -- All the input docs will be combined together into one output document.The specified page ranges of that output document will be printed.SINGLE_DOCUMENT_NEW_SHEET -- All the input docs will be combined together into one output document, and the first impression of each input doc will always start on a new media sheet.The specified page ranges of that output document will be printed.For each separate input doc, the specified page ranges will be printed.For each separate input doc, the specified page ranges will be printed.For each separate input doc, its own specified page ranges will be printed..For each separate input doc, its own specified page ranges will be printed.. IPP Compatibility: The PageRanges attribute's canonical array form gives the lower and upper bound for each range of pages to be included in and IPP \"page-ranges\" attribute.The category name returned by getName() gives the IPP attribute name."},
{"description": "Requests that the results of a search operation be returned by the LDAP server in batches of a specified size.The requestor controls the rate at which batches are returned by the rate at which it invokes search operations.(); // Activate paged results int pageSize = 20; // 20 entries per page byte[] cookie = null; int total; ctx.setRequestControls(new Control[]{ new PagedResultsControl(pageSize, Control.Handle the entry's response controls (if any) if (entry instanceof HasControls) {This class implements the LDAPv3 Control for paged-results as defined in RFC 2696.The control's value has the following ASN.1 definition: realSearchControlValue ::= SEQUENCE { size INTEGER (0..maxInt), -- requested page size from client -- result"},
{"description": "These sizes are in compliance with IPP 1.1."},
{"description": "A set of attributes which control the output of a printed page.Instances of this class control the color state, paper size (media type), orientation, logical origin, print quality, and resolution of every page which uses the instance.Attribute names are compliant with the Internet Printing Protocol (IPP) 1.1 where possible.To use a method which takes an inner class type, pass a reference to one of the constant fields of the inner class.Client code cannot create new instances of the inner class types because none of those classes has a public constructor.For example, to set the color state to monochrome, use the following code: import java.awt.PageAttributes; public class MonochromeExample { public void setMonochrome(PageAttributes pageAttributes) { pageAttributes.setColor(PageAttributes.MONOCHROME); } } Every IPP attribute which supports an attributeName-default value has a corresponding setattributeNameToDefault method."},
{"description": "These print qualities are in compliance with IPP 1.1."},
{"description": "The PackedColorModel class is an abstract ColorModel class that works with pixel values which represent color and alpha information as separate samples and which pack all samples for a single pixel into a single int, short, or byte quantity.This class can be used with an arbitrary ColorSpace.The number of color samples in the pixel values must be the same as the number of color components in the ColorSpace.There can be a single alpha sample.The array length is always 1 for those methods that use a primitive array pixel representation of type transferType.The transfer types supported are DataBuffer.Color and alpha samples are stored in the single element of the array in bits indicated by bit masks.The same masks apply to the single int pixel representation used by other methods.The correspondence of masks and color/alpha samples is as follows: Masks are identified by indices running from 0 through getNumComponents\u00a0-\u00a01.The first getNumColorComponents indices refer to color samples.If an alpha sample is present, it corresponds the last index.The order of the color indices is specified by the ColorSpace.Typically, this reflects the name of the color space type (for example, TYPE_RGB), index 0 corresponds to red, index 1 to green, and index 2 to blue.The translation from pixel values to color/alpha components for display or processing purposes is a one-to-one correspondence of samples to components.A PackedColorModel is typically used with image data that uses masks to define packed samples.For example, a PackedColorModel can be used in conjunction with a SinglePixelPackedSampleModel to construct a BufferedImage.Normally the masks used by the SampleModel and the ColorModel would be the same.However, if they are different, the color interpretation of pixel data is done according to the masks of the ColorModel.A single int pixel representation is valid for all objects of this class since it is always possible to represent pixel values used with this class in a single int.Therefore, methods that use this representation do not throw an IllegalArgumentException due to an invalid pixel value.A subclass of PackedColorModel is DirectColorModel, which is similar to an X11 TrueColor visual."},
{"description": "Package objects contain version information about the implementation and specification of a Java package.This versioning information is retrieved and made available by the ClassLoader instance that loaded the class(es).Typically, it is stored in the manifest that is distributed with the classes.The set of classes that make up the package may implement a particular specification and if so the specification title, version number, and vendor strings identify that specification.An application can ask if the package is compatible with a particular version, see the isCompatibleWith method for details.Specification version numbers use a syntax that consists of nonnegative decimal integers separated by periods \".This allows an extensible number to be used to represent major, minor, micro, etc.The version specification is described by the following formal grammar: SpecificationVersion: Digits RefinedVersionopt RefinedVersion: .The implementation title, version, and vendor strings identify an implementation and are made available conveniently to enable accurate reporting of the packages involved when a problem occurs.The implementation version strings have no specified syntax and should only be compared for equality with desired version identifiers.Within each ClassLoader instance all classes from the same java package have the same Package object.The static methods allow a package to be found by name or the set of all packages known to the current class loader to be found."},
{"description": "The unpacker engine converts the packed stream to a JAR file.An instance of the engine can be obtained using Pack200.newUnpacker().Every JAR file produced by this engine will include the string \"PACK200\" as a zip file comment.Note: Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown.This version of the unpacker is compatible with all previous versions."},
{"description": "Typically the packer engine is used by application developers to deploy or host JAR files on a website.The unpacker engine is used by deployment applications to transform the byte-stream back to JAR format.Here is an example using packer and unpacker: import java.util.jar.Pack200; import java.util.jar.Pack200.*; ... // Create the Packer object Packer packer = Pack200.newPacker// default is \"5\" //debug attributes p.put(Packer.CODE_ATTRIBUTE_PFX+\"LineNumberTable\", Packer.STRIP); // throw an error if an attribute is unrecognized p.put(Packer.UNKNOWN_ATTRIBUTE, Packer.(); } catch (IOException ioe) { ioe.printStackTrace(); } A Pack200 file compressed with gzip can be hosted on HTTP/1.1 web servers.The deployment applications can use \"Accept-EncodingThis indicates to the server that the client application desires a version of the file encoded with Pack200 and further compressed with gzip.Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown."},
{"description": "The packer engine applies various transformations to the input JAR file, making the pack stream highly compressible by a compressor such as gzip or zip.An instance of the engine can be obtained using Pack200.newPacker().The high degree of compression is achieved by using a number of techniques described in the JSR 200 specification.Some of the techniques are sorting, re-ordering and co-location of the constant pool.The pack engine is initialized to an initial state as described by their properties below.The initial state can be manipulated by getting the engine properties (using properties()) and storing the modified properties on the map.The resource files will be passed through with no changes at all.The class files will not contain identical bytes, since the unpacker is free to change minor class file features such as constant pool order.However, the class files will be semantically identical, as specified in The Java\u2122 Virtual Machine Specification.By default, the packer does not change the order of JAR elements.Also, the modification time and deflation hint of each JAR element is passed unchanged.(Any other ZIP-archive information, such as extra attributes giving Unix file permissions, are lost.)This means that packing and unpacking will in general invalidate any digital signatures which rely on bytewise images of JAR elements.In order both to sign and to pack a JAR, you must first pack and unpack the JAR to \"normalize\" it, then compute signatures on the unpacked JAR elements, and finally repack the signed JAR.Both packing steps should use precisely the same options, and the segment limit may also need to be set to \"-1\", to prevent accidental variation of segment boundaries as class file sizes change slightly.(Here's why this works: Any reordering the packer does of any classfile structures is idempotent, so the second packing does not change the orderings produced by the first packing.Also, the unpacker is guaranteed by the JSR 200 specification to produce a specific bytewise image for any given transmission ordering of archive elements.)In order to maintain backward compatibility, the pack file's version is set to accommodate the class files present in the input JAR file.In other words, the pack file version will be the latest, if the class files are the latest and conversely the pack file version will be the oldest if the class file versions are also the oldest.For intermediate class file versions the corresponding pack file version will be used.For example: If the input JAR-files are solely comprised of 1.5 (or lesser) class files, a 1.5 compatible pack file is produced.This will also be the case for archives that have no class files.If the input JAR-files contains a 1.6 class file, then the pack file version will be set to 1.6.Note: Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown."},
{"description": "(Note that the Acl interface in the java.security.acl package extends this Owner interface.)The initial owner Principal should be specified as an argument to the constructor of the class implementing this interface."},
{"description": "Indicates that a method declaration is intended to override a method declaration in a supertype.If a method is annotated with this annotation type compilers are required to generate an error message unless at least one of the following conditions hold: The method does override or implement a method declared in a supertype.The method has a signature that is override-equivalent to that of any public method declared in Object."},
{"description": "The requested size of the container will be the largest requested size of the children, taking alignment needs into consideration.The alignment is based upon what is needed to properly fit the children in the allocation area.The children will be placed such that their alignment points are all on top of each other.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Unchecked exception thrown when an attempt is made to acquire a lock on a region of a file that overlaps a region already locked by the same Java virtual machine, or when another thread is already waiting to lock an overlapping region of the same file."},
{"description": "The Pageable implementation represents a set of pages to be printed.The Pageable object returns the total number of pages in the set as well as the PageFormat and Printable for a specified page."},
{"description": "An OutputStreamWriter is a bridge from character streams to byte streams: Characters written to it are encoded into bytes using a specified charset.The charset that it uses may be specified by name or may be given explicitly, or the platform's default charset may be accepted.Each invocation of a write() method causes the encoding converter to be invoked on the given character(s).The resulting bytes are accumulated in a buffer before being written to the underlying output stream.The size of this buffer may be specified, but by default it is large enough for most purposes.Note that the characters passed to the write() methods are not buffered.For example: Writer out = new BufferedWriter(new OutputStreamWriter(System.out)); A surrogate pair is a character represented by a sequence of two char values:A malformed surrogate element is a high surrogate that is not followed by a low surrogate or a low surrogate that is not preceded by a high surrogate.This class always replaces malformed surrogate elements and unmappable character sequences with the charset's default substitution sequence.The CharsetEncoder class should be used when more control over the encoding process is required."},
{"description": "OutputStream provides interface for writing of all of the mapped IDL type to the stream.It extends org.omg.CORBA.portable.OutputStream, and defines new methods defined by CORBA 2.3."},
{"description": "OuputStream is the Java API for writing IDL types to CDR marshal streams.These methods are used by the ORB to marshal IDL types as well as to insert IDL types into Anys.The _array versions of the methods can be directly used to write sequences and arrays of IDL types."},
{"description": "These orientations are in partial compliance with IPP 1.1."},
{"description": "This abstract class is the superclass of all classes representing an output stream of bytes.An output stream accepts output bytes and sends them to some sink.Applications that need to define a subclass of OutputStream must always provide at least a method that writes one byte of output."},
{"description": "Provides string constants that can be used to set output properties for a Transformer, or to retrieve output properties from a Transformer or Templates object.All the fields in this class are read-only."},
{"description": "Class OutputDeviceAssigned is a printing attribute class, a text attribute, that identifies the output device to which the service has assigned this job.If an output device implements an embedded Print Service instance, the printer need not set this attribute.If a print server implements a Print Service instance, the value may be empty (zero- length string) or not returned until the service assigns an output device to the job.This attribute is particularly useful when a single service supports multiple devices (so called \"fan-out\").The string value gives the IPP name value.The locale gives the IPP natural language.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class OrientationRequested is a printing attribute class, an enumeration, that indicates the desired orientation for printed print-stream pages; it does not describe the orientation of the client-supplied print-stream pages.For some document formats (such as \"application/postscript\"), the desired orientation of the print-stream pages is specified within the document data.This information is generated by a device driver prior to the submission of the print job.Other document formats (such as \"text/plain\") do not include the notion of desired orientation within the document data.In the latter case it is possible for the printer to bind the desired orientation to the document data after it has been submitted.It is expected that a printer would only support the OrientationRequested attribute for some document formats (e.g., \"text/plain\" or \"text/html\") but not others (e.g. \"application/postscript\").This is no different from any other job template attribute, since a print job can always impose constraints among the values of different job template attributes.However, a special mention is made here since it is very likely that a printer will support the OrientationRequested attribute for only a subset of the supported document formats.IPP Compatibility: The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "Thrown when the Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made available by the garbage collector.OutOfMemoryError objects may be constructed by the virtual machine as if suppression were disabled and/or the stack trace was not writable."},
{"description": "A container object which may or may not contain a long value.If a value is present, isPresent() will return true and getAsLong() will return the value.Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() (return a default value if value not present) and ifPresent() (execute a block of code if the value is present).This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of OptionalLong may have unpredictable results and should be avoided."},
{"description": "A container object which may or may not contain a int value.If a value is present, isPresent() will return true and getAsInt() will return the value.Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() (return a default value if value not present) and ifPresent() (execute a block of code if the value is present).This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of OptionalInt may have unpredictable results and should be avoided."},
{"description": "A container object which may or may not contain a double value.If a value is present, isPresent() will return true and getAsDouble() will return the value.Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() (return a default value if value not present) and ifPresent() (execute a block of code if the value is present).This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of OptionalDouble may have unpredictable results and should be avoided."},
{"description": "Passed to each ORBInitializer, allowing it to to register interceptors and perform other duties while the ORB is initializing.The ORBInitInfo object is only valid during ORB.init.If a service keeps a reference to its ORBInitInfo object and tries to use it after ORB.init returns, the object no longer exists and an OBJECT_NOT_EXIST exception shall be thrown."},
{"description": "Passed to each ORBInitializer, allowing it to to register interceptors and perform other duties while the ORB is initializing.The ORBInitInfo object is only valid during ORB.init.If a service keeps a reference to its ORBInitInfo object and tries to use it after ORB.init returns, the object no longer exists and an OBJECT_NOT_EXIST exception shall be thrown."},
{"description": "Interceptors are intended to be a means by which ORB services gain access to ORB processing, effectively becoming part of the ORB.Since Interceptors are part of the ORB, when ORB.init returns an ORB, the Interceptors shall have been registered.Interceptors cannot be registered on an ORB after it has been returned by a call to ORB.init.An Interceptor is registered by registering an associated ORBInitializer object which implements the ORBInitializer interface.When an ORB is initializing, it shall call each registered ORBInitializer, passing it an ORBInitInfo object which is used to register its Interceptor.Registering ORB Initializers in Java ORBInitializers are registered via Java ORB properties.The property names are of the form: org.omg.PortableInterceptor.ORBInitializerClass.<Service> where <Service> is the string name of a class which implements org.omg.PortableInterceptor.ORBInitializer To avoid name collisions, the reverse DNS name convention should be used.For example, if company X has three initializers, it could define the following properties: org.omg.PortableInterceptor.ORBInitializerClass.com.x.Init1 org.omg.PortableInterceptor.ORBInitializerClass.com.x.Init2 org.omg.PortableInterceptor.ORBInitializerClass.com.x.Init3During ORB.init, these ORB properties which begin with org.omg.PortableInterceptor.ORBInitializerClass shall be collected, the <Service> portion of each property shall be extracted, an object shall be instantiated with the <Service> string as its class name, and the pre_init and post_init methods shall be called on that object.If there are any exceptions, the ORB shall ignore them and proceed.Example A client-side logging service written by company X, for example, may have the following ORBInitializer implementation: package com.x.logging; import org.omg.PortableInterceptor.Interceptor; import org.omg.PortableInterceptor.ORBInitializer; import org.omg.PortableInterceptor.ORBInitInfo; public class LoggingService implements ORBInitializer { void pre_init( ORBInitInfo info ) { //This service does not need two init points. }} To run a program called MyApp using this logging service, the user could type:LoggingService MyApp Notes about Registering Interceptors Request Interceptors are registered on a per-ORB basis.To achieve virtual per-object Interceptors, query the policies on the target from within the interception points to determine whether they should do any work.While Interceptors may be ordered administratively, there is no concept of order with respect to the registration of Interceptors.Request Interceptors are concerned with service contexts.Service contexts have no order, so there is no purpose for request Interceptors to have an order.IOR Interceptors are concerned with tagged components.Tagged components also have no order, so there is no purpose for IOR Interceptors to have an order.Registration code should avoid using the ORB (i.e., calling ORB.init with the provided orb_id).Since registration occurs during ORB initialization, results of invocations on this ORB while it is in this state are undefined."},
{"description": "This is the object installed as items of the DefaultComboBoxModel used to represent the <select> element.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A container object which may or may not contain a non-null value.If a value is present, isPresent() will return true and get() will return the value.Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() (return a default value if value not present) and ifPresent() (execute a block of code if the value is present).This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of Optional may have unpredictable results and should be avoided."},
{"description": "This exception may be thrown in two cases: An attempt was made to read an object when the next element in the stream is primitive data.In this case, the OptionalDataException's length field is set to the number of bytes of primitive data immediately readable from the stream, and the eof field is set to false.An attempt was made to read past the end of data consumable by a class-defined readObject or readExternal method.In this case, the OptionalDataException's eof field is set to true, and the length field is set to 0."},
{"description": "Interceptors are intended to be a means by which ORB services gain access to ORB processing, effectively becoming part of the ORB.Since Interceptors are part of the ORB, when ORB.init returns an ORB, the Interceptors shall have been registered.Interceptors cannot be registered on an ORB after it has been returned by a call to ORB.init.An Interceptor is registered by registering an associated ORBInitializer object which implements the ORBInitializer interface.When an ORB is initializing, it shall call each registered ORBInitializer, passing it an ORBInitInfo object which is used to register its Interceptor.Registering ORB Initializers in Java ORBInitializers are registered via Java ORB properties.The property names are of the form: org.omg.PortableInterceptor.ORBInitializerClass.<Service> where <Service> is the string name of a class which implements org.omg.PortableInterceptor.ORBInitializer To avoid name collisions, the reverse DNS name convention should be used.For example, if company X has three initializers, it could define the following properties: org.omg.PortableInterceptor.ORBInitializerClass.com.x.Init1 org.omg.PortableInterceptor.ORBInitializerClass.com.x.Init2 org.omg.PortableInterceptor.ORBInitializerClass.com.x.Init3During ORB.init, these ORB properties which begin with org.omg.PortableInterceptor.ORBInitializerClass shall be collected, the <Service> portion of each property shall be extracted, an object shall be instantiated with the <Service> string as its class name, and the pre_init and post_init methods shall be called on that object.If there are any exceptions, the ORB shall ignore them and proceed.Example A client-side logging service written by company X, for example, may have the following ORBInitializer implementation: package com.x.logging; import org.omg.PortableInterceptor.Interceptor; import org.omg.PortableInterceptor.ORBInitializer; import org.omg.PortableInterceptor.ORBInitInfo; public class LoggingService implements ORBInitializer { void pre_init( ORBInitInfo info ) { //This service does not need two init points. }} To run a program called MyApp using this logging service, the user could type:LoggingService MyApp Notes about Registering Interceptors Request Interceptors are registered on a per-ORB basis.To achieve virtual per-object Interceptors, query the policies on the target from within the interception points to determine whether they should do any work.While Interceptors may be ordered administratively, there is no concept of order with respect to the registration of Interceptors.Request Interceptors are concerned with service contexts.Service contexts have no order, so there is no purpose for request Interceptors to have an order.IOR Interceptors are concerned with tagged components.Tagged components also have no order, so there is no purpose for IOR Interceptors to have an order.Registration code should avoid using the ORB (i.e., calling ORB.init with the provided orb_id).Since registration occurs during ORB initialization, results of invocations on this ORB while it is in this state are undefined."},
{"description": "For example, if a server does not support the Context.bind() method it would throw OperationNotSupportedException when the bind() method is invoked on it.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "The management interface for the operating system on which the Java virtual machine is running.A Java virtual machine has a single instance of the implementation class of this interface.This instance implementing this interface is an MXBean that can be obtained by calling the ManagementFactory.getOperatingSystemMXBean() method or from the platform MBeanServer method.The ObjectName for uniquely identifying the MXBean for the operating system within an MBeanServer is: java.lang:type=OperatingSystem It can be obtained by calling the PlatformManagedObject.getObjectName() method.This interface defines several convenient methods for accessing system properties about the operating system on which the Java virtual machine is running."},
{"description": "A class extending org.omg.CORBA.ORB to make the ORB portable under the OMG CORBA version 2.3 specification."},
{"description": "The OpenType class is the parent abstract class of all classes which describe the actual open type of open data values.An open type is defined by: the fully qualified Java class name of the open data values this type describes; note that only a limited set of Java classes is allowed for open data values (see ALLOWED_CLASSNAMES_LIST), its name, its description."},
{"description": "An object that configures how to open or create a file.Objects of this type are used by methods such as newOutputStream, newByteChannel, FileChannel.open, and AsynchronousFileChannel.open when opening or creating a file.The StandardOpenOption enumeration type defines the standard options."},
{"description": "The OpenType interface represents OpenType and TrueType fonts.This interface makes it possible to obtain sfnt tables from the font.A particular Font object can implement this interface."},
{"description": "A class providing APIs for the CORBA Object Request Broker features.The ORB class also provides \"pluggable ORB implementation\" APIs that allow another vendor's ORB implementation to be used.An ORB makes it possible for CORBA objects to communicate with each other by connecting objects making requests (clients) with objects servicing requests (servers).The ORB class, which encapsulates generic CORBA functionality, does the following: (Note that items 5 and 6, which include most of the methods in the class ORB, are typically used with the Dynamic Invocation Interface (DII) and the Dynamic Skeleton Interface (DSI).These interfaces may be used by a developer directly, but most commonly they are used by the ORB internally and are not seen by the general programmer.)resolve_initial_references converts object references to strings and back connects the ORB to a servant (an instance of a CORBA object implementation) and disconnects the ORB from a servant creates objects such as TypeCode Any NamedValue Context Environment lists (such as NVList) containing these objectssends multiple messages in the DII The ORB class can be used to obtain references to objects implemented anywhere on the network.Two of the three methods use the properties (associations of a name with a value) shown in the table below.These properties allow a different vendor's ORB implementation to be \"plugged in.\" When an ORB instance is being created, the class name of the ORB implementation is located using the following standard search order: check in Applet parameter or application string array, if any check in properties parameter, if any check in the System properties check in the orb.properties file located in the user.home directory (if any) check in the orb.properties file located in the java.home/lib directory (if any) fall back on a hardcoded default behavior (use the Java\u00a0IDL implementation)Note that Java\u00a0IDL provides a default implementation for the fully-functional ORB and for the Singleton ORB.When the method init is given no parameters, the default Singleton ORB is returned.When the method init is given parameters but no ORB class is specified, the Java\u00a0IDL ORB implementation is returned.The following code fragment creates an ORB object initialized with the default ORB Singleton.This ORB has a restricted implementation to prevent malicious applets from doing anything beyond creating typecodes.It is called a singleton because there is only one instance for an entire virtual machine.ORB.init(); The following code fragment creates an ORB object for an application.The parameter args represents the arguments supplied to the application's main method.Since the property specifies the ORB class to be \"SomeORBImplementation\", the new ORB will be initialized with that ORB implementation.If p had been null, and the arguments had not specified an ORB class, the new ORB would have been initialized with the default Java\u00a0IDL implementation.Properties p = new Properties(); p.put(\"org.omg.CORBA.ORBClass\", \"SomeORBImplementation\"); ORB orb = ORB.init(args, p); The following code fragment creates an ORB object for the applet supplied as the first parameter.If the given applet does not specify an ORB class, the new ORB will be initialized with the default Java\u00a0IDL implementation.ORB orb = ORB.init(myApplet, null); An application or applet can be initialized in one or more ORBs.ORB initialization is a bootstrap call into the CORBA world."},
{"description": "This interface declares the same methods as the class MBeanParameterInfo.A class implementing this interface (typically OpenMBeanParameterInfoSupport) should extend MBeanParameterInfo."},
{"description": "This interface declares the same methods as the class MBeanOperationInfo.A class implementing this interface (typically OpenMBeanOperationInfoSupport) should extend MBeanOperationInfo.The getSignature() method should return at runtime an array of instances of a subclass of MBeanParameterInfo which implements the OpenMBeanParameterInfo interface (typically OpenMBeanParameterInfoSupport)."},
{"description": "The OpenMBeanInfoSupport class describes the management information of an open MBean: it is a subclass of MBeanInfo, and it implements the OpenMBeanInfo interface.Note that an open MBean is recognized as such if its getMBeanInfo() method returns an instance of a class which implements the OpenMBeanInfo interface, typically OpenMBeanInfoSupport."},
{"description": "Describes an Open MBean: an Open MBean is recognized as such if its getMBeanInfo() method returns an instance of a class which implements the OpenMBeanInfo interface, typically OpenMBeanInfoSupport.This interface declares the same methods as the class MBeanInfo.A class implementing this interface (typically OpenMBeanInfoSupport) should extend MBeanInfo.The getAttributes(), getOperations() and getConstructors() methods of the implementing class should return at runtime an array of instances of a subclass of MBeanAttributeInfo, MBeanOperationInfo or MBeanConstructorInfo respectively which implement the OpenMBeanAttributeInfo, OpenMBeanOperationInfo or OpenMBeanConstructorInfo interface respectively."},
{"description": "This interface declares the same methods as the class MBeanConstructorInfo.A class implementing this interface (typically OpenMBeanConstructorInfoSupport) should extend MBeanConstructorInfo.The getSignature() method should return at runtime an array of instances of a subclass of MBeanParameterInfo which implements the OpenMBeanParameterInfo interface (typically OpenMBeanParameterInfoSupport)."},
{"description": "The vendor minor code ID reserved for OMG.Minor codes for the standard exceptions are prefaced by the VMCID assigned to OMG, defined as the constant OMGVMCID, which, like all VMCIDs, occupies the high order 20 bits."},
{"description": "This class represents Universal Object Identifiers (Oids) and their associated operations.Oids are hierarchically globally-interpretable identifiers used within the GSS-API framework to identify mechanisms and name formats.The structure and encoding of Oids is defined in ISOIEC-8824For example the Oid representation of Kerberos V5 mechanism is \"1.2.840.113554.1.2.2\" The GSSName name class contains public static Oid objects representing the standard name types defined in GSS-API."},
{"description": "OffsetTime is an immutable date-time object that represents a time, often viewed as hour-minute-second-offset.This class stores all time fields, to a precision of nanoseconds, as well as a zone offset.For example, the value \"13:45.30.123456789+02:00\" can be stored in an OffsetTime.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of OffsetTime may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "OffsetDateTime is an immutable representation of a date-time with an offset.This class stores all date and time fields, to a precision of nanoseconds, as well as the offset from UTC/Greenwich.For example, the value \"2nd October 2007 at 13:45.30.123456789 +02:00\" can be stored in an OffsetDateTime.and Instant all store an instant on the time-line to nanosecond precision.Instant is the simplest, simply representing the instant.OffsetDateTime adds to the instant the offset from UTC/Greenwich, which allows the local date-time to be obtained.ZonedDateTime adds full time-zone rules.It is intended that ZonedDateTime or Instant is used to model data in simpler applications.This class may be used when modeling date-time concepts in more detail, or when communicating to a database or in a network protocol.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of OffsetDateTime may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "Component decorator that implements the view interface for <object> elements.This view will try to load the class specified by the classid attribute.If possible, the Classloader used to load the associated Document is used.This would typically be the same as the ClassLoader used to load the EditorKit.If the class can successfully be loaded, an attempt will be made to create an instance of it by calling Class.newInstance.An attempt will be made to narrow the instance to type java.awt.Component to display the object.This view can also manage a set of parameters with limitations.The parameters to the <object> element are expected to be present on the associated elements attribute set as simple strings.Each bean property will be queried as a key on the AttributeSet, with the expectation that a non-null value (of type String) will be present if there was a parameter specification for the property.Reflection is used to set the parameter.Currently, this is limited to a very simple single parameter of type String.HTML invocation is: <object classid=\"javax.swing."},
{"description": "A class can implement the Observer interface when it wants to be informed of changes in observable objects."},
{"description": "An ObjID is used to identify a remote object exported to an RMI runtime.When a remote object is exported, it is assigned an object identifier either implicitly or explicitly, depending on the API used to export.The ObjID() constructor can be used to generate a unique object identifier.Such an ObjID is unique over time with respect to the host it is generated on.The ObjID(int) constructor can be used to create a \"well-known\" object identifier.The scope of a well-known ObjID depends on the RMI runtime it is exported to.An ObjID instance contains an object number (of type long) and an address space identifier (of type UID).In a unique ObjID, the address space identifier is unique with respect to a given host over time.In a well-known ObjID, the address space identifier is equivalent to one returned by invoking the UID.UID(short) constructor with the value zero.If the system property java.rmi.server.randomIDs is defined to equal the string \"true\" (case insensitive), then the ObjID() constructor will use a cryptographically strong random number generator to choose the object number of the returned ObjID."},
{"description": "This class represents an observable object, or \"data\" in the model-view paradigm.It can be subclassed to represent an object that the application wants to have observed.An observable object can have one or more observers.An observer may be any object that implements interface Observer.After an observable instance changes, an application calling the Observable's notifyObservers method causes all of its observers to be notified of the change by a call to their update method.The order in which notifications will be delivered is unspecified.The default implementation provided in the Observable class will notify Observers in the order in which they registered interest, but subclasses may change this order, use no guaranteed order, deliver notifications on separate threads, or may guarantee that their subclass follows this order, as they choose.Note that this notification mechanism has nothing to do with threads and is completely separate from the wait and notify mechanism of class Object.When an observable object is newly created, its set of observers is empty.Two observers are considered the same if and only if the equals method returns true for them."},
{"description": "Represents an operation that accepts an object-valued and a int-valued argument, and returns no result.This is the (reference, int) specialization of BiConsumer.Unlike most other functional interfaces, ObjIntConsumer is expected to operate via side-effects.This is a functional interface whose functional method is accept(Object, int)."},
{"description": "This interface declares the same methods as the class MBeanAttributeInfo.A class implementing this interface (typically OpenMBeanAttributeInfoSupport) should extend MBeanAttributeInfo."},
{"description": "Represents an operation that accepts an object-valued and a long-valued argument, and returns no result.This is the (reference, long) specialization of BiConsumer.Unlike most other functional interfaces, ObjLongConsumer is expected to operate via side-effects.This is a functional interface whose functional method is accept(Object, long)."},
{"description": "Constants written into the Object Serialization Stream."},
{"description": "The designers of the Metal Look and Feel strive to keep the default look up to date, possibly through the use of new themes in the future.Therefore, developers should only use this class directly when they wish to customize the \"Ocean\" look, or force it to be the current theme, regardless of future updates.All colors returned by OceanTheme are completely opaque."},
{"description": "It contains the name and serialVersionUID of the class.The ObjectStreamClass for a specific class loaded in this Java VM can be found/created using the lookup method.The algorithm to compute the SerialVersionUID is described in Object Serialization Specification, Section 4.6, Stream Unique Identifiers."},
{"description": "Sequence of object reference templates is used for reporting state changes that do not occur on the adapter manager."},
{"description": "This class consists of static utility methods for operating on objects.These utilities include null-safe or null-tolerant methods for computing the hash code of an object, returning a string for an object, and comparing two objects."},
{"description": "Sequence of object reference templates is used for reporting state changes that do not occur on the adapter manager."},
{"description": "An instance of this must exist for each object adapter created in an ORB.The server_id, orb_id, and adapter_name attributes uniquely identify this template within the scope of an IMR.Note that adapter_id is similarly unique within the same scope, but it is opaque, and less useful in many cases."},
{"description": "An instance of this must exist for each object adapter created in an ORB.The server_id, orb_id, and adapter_name attributes uniquely identify this template within the scope of an IMR.Note that adapter_id is similarly unique within the same scope, but it is opaque, and less useful in many cases."},
{"description": "An instance of this must exist for each object adapter created in an ORB.The server_id, orb_id, and adapter_name attributes uniquely identify this template within the scope of an IMR.Note that adapter_id is similarly unique within the same scope, but it is opaque, and less useful in many cases."},
{"description": "This provides the capability of creating an object reference."},
{"description": "This provides the capability of creating an object reference."},
{"description": "An ObjectOutputStream writes primitive data types and graphs of Java objects to an OutputStream.The objects can be read (reconstituted) using an ObjectInputStream.Persistent storage of objects can be accomplished by using a file for the stream.If the stream is a network socket stream, the objects can be reconstituted on another host or in another process.Only objects that support the java.io.Serializable interface can be written to streams.The class of each serializable object is encoded including the class name and signature of the class, the values of the object's fields and arrays, and the closure of any other objects referenced from the initial objects.The method writeObject is used to write an object to the stream.Any object, including Strings and arrays, is written with writeObject.Multiple objects or primitives can be written to the stream.The objects must be read back from the corresponding ObjectInputstream with the same types and in the same order as they were written.Primitive data types can also be written to the stream using the appropriate methods from DataOutput.Strings can also be written using the writeUTF method.The default serialization mechanism for an object writes the class of the object, the class signature, and the values of all non-transient and non-static fields.References to other objects (except in transient or static fields) cause those objects to be written also.Multiple references to a single object are encoded using a reference sharing mechanism so that graphs of objects can be restored to the same shape as when the original was written.For example to write an object that can be read by the example in ObjectInputStream: FileOutputStream fos = new FileOutputStream(\"t.tmp\"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeInt(12345); oos.writeObject(\"Today\"); oos.writeObject(new Date()); oos.close(); Classes that require special handling during the serialization and deserialization process must implement special methods with these exact signatures: private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException; private void writeObject(java.io.The writeObject method is responsible for writing the state of the object for its particular class so that the corresponding readObject method can restore it.The method does not need to concern itself with the state belonging to the object's superclasses or subclasses.State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput.Serialization does not write out the fields of any object that does not implement the java.io.Serializable interface.Subclasses of Objects that are not serializable can be serializable.In this case the non-serializable class must have a no-arg constructor to allow its fields to be initialized.In this case it is the responsibility of the subclass to save and restore the state of the non-serializable class.It is frequently the case that the fields of that class are accessible (public, package, or protected) or that there are get and set methods that can be used to restore the state.Serialization of an object can be prevented by implementing writeObject and readObject methods that throw the NotSerializableException.The exception will be caught by the ObjectOutputStream and abort the serialization process.Implementing the Externalizable interface allows the object to assume complete control over the contents and format of the object's serialized form.The methods of the Externalizable interface, writeExternal and readExternal, are called to save and restore the objects state.When implemented by a class they can write and read their own state using all of the methods of ObjectOutput and ObjectInput.It is the responsibility of the objects to handle any versioning that occurs.Enum constants are serialized differently than ordinary serializable or externalizable objects.The serialized form of an enum constant consists solely of its name; field values of the constant are not transmitted.Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream.The process by which enum constants are serialized cannot be customized; any class-specific writeObject and writeReplace methods defined by enum types are ignored during serialization.Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored--all enum types have a fixed serialVersionUID of 0L. Primitive data, excluding serializable fields and externalizable data, is written to the ObjectOutputStream in block-data records.A block data record is composed of a header and data.The block data header consists of a marker and the number of bytes to follow the header.Consecutive primitive data writes are merged into one block-data record.The blocking factor used for a block-data record will be 1024 bytes.Each block-data record will be filled up to 1024 bytes, or be written whenever there is a termination of block-data mode.Calls to the ObjectOutputStream methods writeObject, defaultWriteObject and writeFields initially terminate any existing block-data record."},
{"description": "Represents the object name of an MBean, or a pattern that can match the names of several MBeans.Instances of this class are immutable.An instance of this class can be used to represent: An object name An object name pattern, within the context of a queryAn object name consists of two parts, the domain and the key properties.The domain is a string of characters not including the character colonIt is recommended that the domain should not contain the string \"//\", which is reserved for future use.If the domain includes at least one occurrence of the wildcard characters asterisk(*) or question mark (?), then the object name is a pattern.The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.If the domain is empty, it will be replaced in certain contexts by the default domain of the MBean server in which the ObjectName is used.The key properties are an unordered set of keys and associated values.Each key is a nonempty string of characters which may not contain any of the characters comma (,), equals (=), colon, asterisk, or question mark.The same key may not occur twice in a given ObjectName.Each value associated with a key is a string of characters that is either unquoted or quoted.An unquoted value is a possibly empty string of characters which may not contain any of the characters comma, equals, colon, or quote.If the unquoted value contains at least one occurrence of the wildcard characters asterisk or question mark, then the object name is a property value pattern.The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.A quoted value consists of a quote (\"), followed by a possibly empty string of characters, followed by another quote.Within the string of characters, the backslash (\\) has a special meaning.It must be followed by one of the following characters: Another backslash.The second backslash has no special meaning and the two characters represent a single backslash.The two characters represent a newline ('\\n' in Java).The two characters represent a quote, and that quote is not considered to terminate the quoted value.The two characters represent a question mark or asterisk respectively.A quote may not appear inside a quoted value except immediately after an odd number of consecutive backslashes.The quotes surrounding a quoted value, and any backslashes within that value, are considered to be part of the value.If the quoted value contains at least one occurrence of the characters asterisk or question markand they are not preceded by a backslash, then they are considered as wildcard characters and the object name is a property value pattern.The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.An ObjectName may be a property list pattern.In this case it may have zero or more keys and associated values.It matches a nonpattern ObjectName whose domain matches and that contains the same keys and associated values, as well as possibly other keys and values.An ObjectName is a property value pattern when at least one of its quoted or unquoted key property values contains the wildcard characters asterisk or question mark as described above.In this case it has one or more keys and associated values, with at least one of the values containing wildcard characters.It matches a nonpattern ObjectName whose domain matches and that contains the same keys whose values match; if the property value pattern is also a property list pattern then the nonpattern ObjectName can contain other keys and values.An ObjectName is a property pattern if it is either a property list pattern or a property value pattern or both.An ObjectName is a pattern if its domain contains a wildcard or if the ObjectName is a property pattern.If an ObjectName is not a pattern, it must contain at least one key with its associated value.Examples of ObjectName patterns are: *:type=Foo,name=Bar to match names in any domain whose exact set of keys is type=type=Foo,name=Bar,* to match names in the domain d that have the keys type=*:type=Foo,name=Bar,* to match names in any domain that has the keys type=,name=Bar will match e.g. d:type=Foo,name=Bar and d:=Bar will match e.g. d:type=Fo,name=Bar and d:type=type=Foo,name=\"B*\" will match e.g. d:type=Foo,name=\"Bling\".Wildcards are recognized even inside quotes, and like other special characters can be escaped with \\.An ObjectName can be written as a String with the following elements in order: The domain.A key property list written as a String is a comma-separated list of elements.Each element is either an asterisk or a key property.A key property consists of a key, an equals (=), and the associated value.If the key property list contains an asterisk element, the ObjectName is a property list pattern.Spaces have no special significance in a String representing an ObjectName.For example, the String: domain: key1 = value1 , key2 = value2 represents an ObjectName with two keys.The name of each key contains six characters, of which the first and last are spaces.The value associated with the key \"\u00a0key1\u00a0\" also begins and ends with a space.In addition to the restrictions on characters spelt out above, no part of an ObjectName may contain a newline character ('\\n'), whether the domain, a key, or a value, whether quoted or unquoted.The newline character can be represented in a quoted value with the sequence \\n.The rules on special characters and quoting apply regardless of which constructor is used to make an ObjectName.To avoid collisions between MBeans supplied by different vendors, a useful convention is to begin the domain name with the reverse DNS name of the organization that specifies the MBeans, followed by a period and a string whose interpretation is determined by that organization.For example, MBeans specified by example.com would have domains such as com.example.MyDomain.This is essentially the same convention as for Java-language package names.The serialVersionUID of this class is 1081892073854801359L."},
{"description": "An array of ObjectStreamFields is used to declare the Serializable fields of a class."},
{"description": "An ObjectInputStream deserializes primitive data and objects previously written using an ObjectOutputStream. ObjectOutputStreamObjectInputStream is used to recover those objects previously serialized.Other uses include passing objects between hosts using a socket stream or for marshaling and unmarshaling arguments and parameters in a remote communication system.ObjectInputStream ensures that the types of all objects in the graph created from the stream match the classes present in the Java Virtual Machine.Classes are loaded as required using the standard mechanisms.Only objects that support the java.io.Serializable or java.io.Externalizable interface can be read from streams.The method readObject is used to read an object from the stream.Java's safe casting should be used to get the desired type.In Java, strings and arrays are objects and are treated as objects during serialization.When read they need to be cast to the expected type.Primitive data types can be read from the stream using the appropriate method on DataInput.The default deserialization mechanism for objects restores the contents of each field to the value and type it had when it was written.Fields declared as transient or static are ignored by the deserialization process.References to other objects cause those objects to be read from the stream as necessary.Graphs of objects are restored correctly using a reference sharing mechanism.New objects are always allocated when deserializing, which prevents existing objects from being overwritten.Reading an object is analogous to running the constructors of a new object.Memory is allocated for the object and initialized to zero (NULL).No-arg constructors are invoked for the non-serializable classes and then the fields of the serializable classes are restored from the stream starting with the serializable class closest to java.lang.object and finishing with the object's most specific class.ois.close(); Classes control how they are serialized by implementing either the java.io.Serializable or java.io.Externalizable interfaces.Implementing the Serializable interface allows object serialization to save and restore the entire state of the object and it allows classes to evolve between the time the stream is written and the time it is read.It automatically traverses references between objects, saving and restoring entire graphs.Serializable classes that require special handling during the serialization and deserialization process should implement the following methods: private void writeObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException; private void readObjectNoData() throws ObjectStreamException; The readObject method is responsible for reading and restoring the state of the object for its particular class using data written to the stream by the correspondingThe method does not need to concern itself with the state belonging to its superclasses or subclasses.State is restored by reading data from the ObjectInputStream for the individual fields and making assignments to the appropriate fields of the object.Reading primitive data types is supported by DataInput.Any attempt to read object data which exceeds the boundaries of the custom data written by the corresponding writeObject method will cause an OptionalDataException to be thrown with an eof field value of true.Non-object reads which exceed the end of the allotted data will reflect the end of data in the same way that they would indicate the end of the stream: bytewise reads will return -1 as the byte read or number of bytes read, and primitive reads will throw EOFExceptions.If there is no corresponding writeObject method, then the end of default serialized data marks the end of the allotted data.Primitive and object read calls issued from within a readExternal method behave in the same manner--if the stream is already positioned at the end of data written by the corresponding writeExternal method, object reads will throw OptionalDataExceptions with eof set to true, bytewise reads will return -1, and primitive reads will throw EOFExceptions.Note that this behavior does not hold for streams written with the old ObjectStreamConstants.PROTOCOL_VERSION_1 protocol, in which the end of data written by writeExternal methods is not demarcated, and hence cannot be detected.The readObjectNoData method is responsible for initializing the state of the object for its particular class in the event that the serialization stream does not list the given class as a superclass of the object being deserialized.This may occur in cases where the receiving party uses a different version of the deserialized instance's class than the sending party, and the receiver's version extends classes that are not extended by the sender's version.This may also occur if the serialization stream has been tampered; hence, readObjectNoData is useful for initializing deserialized objects properly despite a \"hostile\" or incomplete source stream.Serialization does not read or assign values to the fields of any object that does not implement the java.io.Serializable interface.Subclasses of Objects that are not serializable can be serializable.In this case the non-serializable class must have a no-arg constructor to allow its fields to be initialized.In this case it is the responsibility of the subclass to save and restore the state of the non-serializable class.It is frequently the case that the fields of that class are accessible (public, package, or protected) or that there are get and set methods that can be used to restore the state.Any exception that occurs while deserializing an object will be caught by the ObjectInputStream and abort the reading process.Implementing the Externalizable interface allows the object to assume complete control over the contents and format of the object's serialized form.The methods of the Externalizable interface, writeExternal and readExternal, are called to save and restore the objects state.When implemented by a class they can write and read their own state using all of the methods of ObjectOutput and ObjectInput.It is the responsibility of the objects to handle any versioning that occurs.Enum constants are deserialized differently than ordinary serializable or externalizable objects.The serialized form of an enum constant consists solely of its name; field values of the constant are not transmitted.To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the static method Enum.valueOf(Class, String) with the enum constant's base type and the received constant name as arguments.Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream.The process by which enum constants are deserialized cannot be customized: any class-specific readObject, readObjectNoData, and readResolve methods defined by enum types are ignored during deserialization.Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored--all enum types have a fixed serialVersionUID of 0L."},
{"description": "If the MBean is a Dynamic MBean the class name should be retrieved from the MBeanInfo it provides."},
{"description": "Allows an object to be called when a complete graph of objects has been deserialized."},
{"description": "This provides the capability of creating an object reference."},
{"description": "ObjectImpl class is the base class for all stubs.It provides the basic delegation mechanism.It extends org.omg.CORBA.portable.ObjectImpl and provides new methods defined by CORBA 2.3."},
{"description": "ObjectInput extends the DataInput interface to include the reading of objects.DataInput includes methods for the input of primitive types, ObjectInput extends that interface to include objects, arrays, and Strings."},
{"description": "The common base class for all stub classes; provides default implementations of the org.omg.CORBA.Object methods.All method implementations are forwarded to a Delegate object stored in the ObjectImpl instance.ObjectImpl allows for portable stubs because the Delegate can be implemented by a different vendor-specific ORB."},
{"description": "It is usually used to store \"out\" and \"inout\" parameters in IDL methods.If an IDL method signature has a CORBA Object reference as an \"out\" or \"inout\" parameter, the programmer must pass an instance of ObjectHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myObjectHolder is an instance of ObjectHolder, the value stored in its value field can be accessed with myObjectHolder.value."},
{"description": "This provides the identity of a particular object that was created by an object adapter."},
{"description": "ObjectOutput extends the DataOutput interface to include writing of objects.DataOutput includes methods for output of primitive types, ObjectOutput extends that interface to include objects, arrays, and Strings."},
{"description": "This interface represents a factory for creating an object.The JNDI framework allows for object implementations to be loaded in dynamically via object factories.For example, when looking up a printer bound in the name space, if the print service binds printer names to References, the printer Reference could be used to create a printer object, so that the caller of lookup can directly operate on the printer object after the lookup.An ObjectFactory is responsible for creating objects of a specific type.In the above example, you may have a PrinterObjectFactory for creating Printer objects.An object factory must implement the ObjectFactory interface.In addition, the factory class must be public and must have a public constructor that accepts no parameters.The getObjectInstance() method of an object factory may be invoked multiple times, possibly using different parameters.The mention of URL in the documentation for this class refers to a URL string as defined by RFC 1738 and its related RFCs.It is any string that conforms to the syntax described therein, and may not always have corresponding support in the java.net.URL class or Web browsers."},
{"description": "A CORBA object reference is a handle for a particular CORBA object implemented by a server.A CORBA object reference identifies the same CORBA object each time the reference is used to invoke a method on the object.A CORBA object may have multiple, distinct object references.The org.omg.CORBA.Object interface is the root of the inheritance hierarchy for all CORBA object references in the Java programming language, analogous to java.rmi.Remote for RMI remote objects.If it is a local object (that is, running in the same VM as the client), invocations may be directly serviced by the object instance, and the object reference could point to the actual instance of the object implementation class.If a CORBA object is a remote object (that is, running in a different VM from the client), the object reference points to a stub (proxy) which uses the ORB machinery to make a remote invocation on the server where the object implementation resides.Default implementations of the methods in the interface org.omg.CORBA.Object are provided in the class org.omg.CORBA.portable.ObjectImpl, which is the base class for stubs and object implementations."},
{"description": "Exception raised whenever an invocation on a deleted object was performed.It is an authoritative \"hard\" fault report.Anyone receiving it is allowed (even expected) to delete all copies of this object reference and to perform other appropriate \"final recovery\" style procedures.Bridges forward this exception to clients, also destroying any records they may hold (for example, proxy objects used in reference translation).The clients could in turn purge any of their own data structures.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "This interface represents a builder that creates object factories.The JNDI framework allows for object implementations to be loaded in dynamically via object factories.For example, when looking up a printer bound in the name space, if the print service binds printer names to References, the printer Reference could be used to create a printer object, so that the caller of lookup can directly operate on the printer object after the lookup.An ObjectFactory is responsible for creating objects of a specific type.JNDI uses a default policy for using and loading object factories.You can override this default policy by calling NamingManager.setObjectFactoryBuilder() with an ObjectFactoryBuilder, which contains the program-defined way of creating/loading object factories.Any ObjectFactoryBuilder implementation must implement this interface that for creating object factories."},
{"description": "Class Object is the root of the class hierarchy.Every class has Object as a superclass.All objects, including arrays, implement the methods of this class."},
{"description": "This class specifies the set of parameters used with OAEP Padding, as defined in the PKCS #1 standard.Its ASN.1 definition in PKCS#1 standard is described below: RSAES-OAEP-params ::= SEQUENCE { hashAlgorithm [0] OAEP-PSSDigestAlgorithms DEFAULT sha1, maskGenAlgorithm [1] PKCS1MGFAlgorithms DEFAULT mgf1SHA1,{ OID id-sha384 PARAMETERS NULL }| { OID id-sha512 PARAMETERS NULL }, ... -- Allows for future expansion -- }DEFAULT uses the following: message digest -- \"SHA-1\" mask generation function (mgf) -- \"MGF1\" parameters for mgf --"},
{"description": "The class NVList is used as follows: to describe arguments for a Request object in the Dynamic Invocation Interface and the Dynamic Skeleton Interface to describe context values in a Context object Each NamedValue object consists of the following: a name, which is a String object a value, as an Any object an argument mode flagAn NVList object may be created using one of the following ORB methods: org.omg.CORBA.ORB.create_listorg.omg.CORBA.NVList nv = orb.create_list(3); The variable nv represents a newly-created NVList object.The argument is a memory-management hint to the orb and does not imply the actual length of the list.If, for example, you want to use an NVList object in a request, and the method being invoked takes three parameters, you might optimize by supplying 3 to the method create_list.Note that the new NVList will not necessarily have a length of 3; it could have a length of 2 or 4, for instance.Note also that you can add any number of NamedValue objects to this list regardless of its original length.org.omg.CORBA.NVList nv = orb.create_operation_list(myOperationDef); The variable nv represents a newly-created NVList object that contains descriptions of the arguments to the method described in the given OperationDef object.The methods in the class NVList all deal with the NamedValue objects in the list.There are three methods for adding a NamedValue object, a method for getting the count of NamedValue objects in the list, a method for retrieving a NamedValue object at a given index, and a method for removing a NamedValue object at a given index."},
{"description": "Range represents a Unicode range of a script having its own decimal digits.For example, the THAI range has the Thai digits, THAI DIGIT ZERO (U+0E50) to THAI DIGIT NINE (U+0E59).The Range enum replaces the traditional bit mask-based values (e.g., NumericShaper.EUROPEAN); can be written using this enum as: NumericShaper.getContextualShaper(EnumSet.of( NumericShaper.Range."},
{"description": "This exception typically indicates an administrative mismatch, for example, a server may have made an attempt to register itself with an implementation repository under a name that is already in use, or is unknown to the repository.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "Represents an operation that accepts an object-valued and a double-valued argument, and returns no result.This is the (reference, double) specialization of BiConsumer.Unlike most other functional interfaces, ObjDoubleConsumer is expected to operate via side-effects.This is a functional interface whose functional method is accept(Object, double)."},
{"description": "The NumericShaper class is used to convert Latin-1Users of this class will primarily be people who wish to present data using national digit shapes, but find it more convenient to represent the data internally using Latin-1 (European) digits.This does not interpret the deprecated numeric shape selector character (U+206E).Instances of NumericShaper are typically applied as attributes to text with the NUMERIC_SHAPING attribute of the TextAttribute class.For example, this code snippet causes a TextLayout to shape European digits to Arabic in an Arabic context:; layout.draw(g2d, x, y); It is also possible to perform numeric shaping explicitly using instances of NumericShaper, as this code snippet demonstrates:// shape all EUROPEAN digits (except zero) to ARABIC digits NumericShaper shaper =ARABIC); shaper.shape(text, start, count); // shape European digits to ARABIC digits if preceding text is Arabic, or // shapeEuropean digits to TAMIL digits if preceding text is Tamil, or // leave European digits alone if there is no preceding text, or //preceding text is neither Arabic nor Tamil NumericShaper shaper = NumericShaper.getContextualShaper(NumericShaper.; shaper.shape(text, start, count); Bit mask- and enum-based Unicode ranges This class supports two different programming interfaces to represent Unicode ranges for script-specific digits: bit mask-based ones, such as NumericShaper.Multiple ranges can be specified by ORing bit mask-based constants, such as: NumericShaper.The enum-based ranges are a super set of the bit mask-based ones.If the two interfaces are mixed (including serialization), Unicode range values are mapped to their counterparts where such mapping is possible, such as NumericShaper.If any unmappable range values are specified, such as NumericShaper.A Unicode range may have more than one set of decimal digits.If multiple decimal digits sets are specified for the same Unicode range, one of the sets will take precedence as follows."},
{"description": "NumberFormat is the abstract base class for all number formats.This class provides the interface for formatting and parsing numbers.NumberFormat also provides methods for determining which locales have number formats, and what their names are.NumberFormat helps you to format and parse numbers for any locale.Your code can be completely independent of the locale conventions for decimal points, thousands-separators, or even the particular decimal digits used, or whether the number format is even decimal.To format a number for the current Locale, use one of the factory class methods: myString = NumberFormat.getInstance().format(myNumber); If you are formatting multiple numbers, it is more efficient to get the format and use it multiple times so that the system doesn't have to fetch the information about the local language and country conventions multiple times.FRENCH); You can also use a NumberFormat to parse numbers: myNumber = nf.parse(myString); Use getInstance or getNumberInstance to get the normal number format.With this format, a fraction like 0.53 is displayed as 53%.You can also control the display of numbers with such methods as setMinimumFractionDigits.If you want even more control over the format or parsing, or want to give your users more control, you can try casting the NumberFormat you get from the factory methods to a DecimalFormat.This will work for the vast majority of locales; just remember to put it in a try block in case you encounter an unusual one.NumberFormat and DecimalFormat are designed such that some controls work for formatting and others work for parsing.The following is the detailed description for each these control methods, setParseIntegerOnly : only affects parsing, e.g. if true, \"3456.78\" \u2192 3456 (and leaves the parse position just after index 6) if false, \"3456.78\" \u2192 3456.78 (and leaves the parse position just after index 8)This is independent of formatting.If you want to not show a decimal point where there might be no digits after the decimal point, use setDecimalSeparatorAlwaysShown.only affects formatting, and only where there might be no digits after the decimal point, such as with a pattern like \"#,##0.\" if false, 3456.00 \u2192 \"3456\" This is independent of parsing.If you want parsing to stop at the decimal point, use setParseIntegerOnly.You can also use forms of the parse and format methods with ParsePosition and FieldPosition to allow you to: progressively parse through pieces of a string align the decimal point and other areasFor example, you can align numbers in two ways: If you are using a monospaced font with spacing for alignment, you can pass the FieldPosition in your format call, with field = INTEGER_FIELD.On output, getEndIndex will be set to the offset between the last character of the integer and the decimal.Add (desiredSpaceCount - getEndIndex) spaces at the front of the string.If you are using proportional fonts, instead of padding with spaces, measure the width of the string in pixels from the start to getEndIndex.It also works where there is no decimal, but possibly additional characters at the end, e.g., with parentheses in negative numbers: \"(12)\" for -12.It is recommended to create separate format instances for each thread.If multiple threads access a format concurrently, it must be synchronized externally."},
{"description": "Specifies the method that a listener of a NamingEvent with event type of OBJECT_CHANGED must implement.An OBJECT_CHANGED event type is fired when (the contents of) an object has changed.How the object has changed can be determined by examining the NamingEvent's old and new bindings.A listener interested in OBJECT_CHANGED event types must:Implement this interface and its method(objectChanged())Implement NamingListener.namingExceptionThrown() so that it will be notified of exceptions thrown while attempting to collect information about the events.A listener that wants to be notified of namespace change events should also implement the NamespaceChangeListener interface."},
{"description": "The abstract class Number is the superclass of platform classes representing numeric values that are convertible to the primitive types byte, double, float, int, long, and short.The specific semantics of the conversion from the numeric value of a particular Number implementation to a given primitive type is defined by the Number implementation in question.For platform classes, the conversion is often analogous to a narrowing primitive conversion or a widening primitive conversion as defining in The Java\u2122 Language Specification for converting between primitive types.Therefore, conversions may lose information about the overall magnitude of a numeric value, may lose precision, and may even return a result of a different sign than the input."},
{"description": "This is the type of the expression null,"},
{"description": "Thrown when an instance is required to have a Serializable interface.The serialization runtime or the class of the instance can throw this exception.The argument should be the name of the class."},
{"description": "Thrown when an application attempts to use null in a case where an object is required.These include: Calling the instance method of a null object.Taking the length of null as if it were an array.Accessing or modifying the slots of null as if it were an array.Throwing null as if it were a Throwable value.Applications should throw instances of this class to indicate other illegal uses of the null object.NullPointerException objects may be constructed by the virtual machine as if suppression were disabled and/or the stack trace was not writable."},
{"description": "The kinds of NoType are: VOID - corresponds to the keyword void.NONE - used in other cases where no actual type is appropriate; for example, the superclass of java.lang.Object."},
{"description": "Unchecked exception thrown when an attempt is made to invoke an I/O operation upon a socket channel that is not yet connected."},
{"description": "The NullCipher class is a class that provides an \"identity cipher\" -- one that does not transform the plain text.As a consequence, the ciphertext is identical to the plaintext.All initialization methods do nothing, while the blocksize is set to 1 byte."},
{"description": "Unchecked exception thrown when an attempt is made to invoke an I/O operation upon a server socket channel that is not yet bound."},
{"description": "This is an exception that is thrown whenever the modification of an object (such as an Access Control List) is only allowed to be done by an owner of the object, but the Principal attempting the modification is not an owner."},
{"description": "Checked exception thrown when a file system operation fails because a file is not a symbolic link."},
{"description": "Notifications in a notification buffer have positive, monotonically increasing sequence numbers.The result of a notification query contains the following elements: The sequence number of the earliest notification still in the buffer.This will be the starting sequence number for the next notification query.An array of (Notification,listenerID) pairs corresponding to the returned notifications and the listeners they correspond to.It is possible for the nextSequenceNumber to be less than the earliestSequenceNumber.This signifies that notifications between the two might have been lost."},
{"description": "Should be implemented by an object that wants to receive notifications."},
{"description": "This can be used as the super class of an MBean that sends notifications.By default, the notification dispatch model is synchronous.That is, when a thread calls sendNotification, the NotificationListener.handleNotification method of each listener is called within that thread.You can override this default by overriding handleNotification in a subclass, or by passing an Executor to the constructor.If the method call of a filter or listener throws an Exception, then that exception does not prevent other listeners from being invoked.However, if the method call of a filter or of Executor.execute or of handleNotification (when no Excecutor is specified) throws an Error, then that Error is propagated to the caller of sendNotification.Remote listeners added using the JMX Remote API (see JMXConnector) are not usually called synchronously.That is, when sendNotification returns, it is not guaranteed that any remote listeners have yet received the notification."},
{"description": "The filtering is performed on the notification type attribute.Then, before sending a notification to a listener registered with a filter, the notification broadcaster compares this notification type with all notification types enabled by the filter.The notification will be sent to the listener only if its filter enables this notification type.(); myFilter.enableType(\"my_example.my_type\"); myBroadcaster.addListener(myListener, myFilter, null); The listener myListener will only receive notifications the type of which equals/starts with \"my_example.my_type\"."},
{"description": "It allows a registered notification listener to filter the notifications of interest."},
{"description": "Interface implemented by an MBean that emits Notifications.It allows a listener to be registered with the MBean as a notification listener.Notification dispatchWhen an MBean emits a notification, it considers each listener that has been added with addNotificationListener and not subsequently removed with removeNotificationListener.If a filter was provided with that listener, and if the filter's isNotificationEnabled method returns false, the listener is ignored.Otherwise, the listener's handleNotification method is called with the notification, as well as the handback object that was provided to addNotificationListener.If the same listener is added more than once, it is considered as many times as it was added.It is often useful to add the same listener with different filters or handback objects.Implementations of this interface can differ regarding the thread in which the methods of filters and listeners are called.If the method call of a filter or listener throws an Exception, then that exception should not prevent other listeners from being invoked.However, if the method call throws an Error, then it is recommended that processing of the notification stop at that point, and if it is possible to propagate the Error to the sender of the notification, this should be done.This interface should be used by new code in preference to the NotificationBroadcaster interface.Implementations of this interface and of NotificationBroadcaster should be careful about synchronization.In particular, it is not a good idea for an implementation to hold any locks while it is calling a listener.To deal with the possibility that the list of listeners might change while a notification is being dispatched, a good strategy is to use a CopyOnWriteArrayList for this list."},
{"description": "The Notification class represents a notification emitted by an MBean.It contains a reference to the source MBean: if the notification has been forwarded through the MBean server, and the original source of the notification was a reference to the emitting MBean object, then the MBean server replaces it by the MBean's ObjectName.If the listener has registered directly with the MBean, this is either the object name or a direct reference to the MBean.It is strongly recommended that notification senders use the object name rather than a reference to the MBean object as the source.The serialVersionUID of this class is -7516092053498031989L."},
{"description": "This event indicates that a problem was encountered resolving an ID/IDREF."},
{"description": "JAXB providers are allowed to use whatever class that implements the ValidationEvent interface.This class is just provided for a convenience."},
{"description": "Interface implemented by an MBean that emits Notifications.It allows a listener to be registered with the MBean as a notification listener.Notification dispatch When an MBean emits a notification, it considers each listener that has been added with addNotificationListener and not subsequently removed with removeNotificationListener.If a filter was provided with that listener, and if the filter's isNotificationEnabled method returns false, the listener is ignored.Otherwise, the listener's handleNotification method is called with the notification, as well as the handback object that was provided to addNotificationListener.If the same listener is added more than once, it is considered as many times as it was added.It is often useful to add the same listener with different filters or handback objects.Implementations of this interface can differ regarding the thread in which the methods of filters and listeners are called.If the method call of a filter or listener throws an Exception, then that exception should not prevent other listeners from being invoked.However, if the method call throws an Error, then it is recommended that processing of the notification stop at that point, and if it is possible to propagate the Error to the sender of the notification, this should be done.New code should use the NotificationEmitter interface instead.Implementations of this interface and of NotificationEmitter should be careful about synchronization.In particular, it is not a good idea for an implementation to hold any locks while it is calling a listener.To deal with the possibility that the list of listeners might change while a notification is being dispatched, a good strategy is to use a CopyOnWriteArrayList for this list."},
{"description": "This exception is thrown when a naming operation proceeds to a point where a context is required to continue the operation, but the resolved object is not a context.For example, Context.destroy() requires that the named object be a context.Another example is a non-context being encountered during the resolution phase of the Context methods.It is also thrown when a particular subtype of context is required, such as a DirContext, and the resolved object is a context but not of the required subtype.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "Exception which occurs when trying to register an object in the MBean server that is not a JMX compliant MBean."},
{"description": "Checked exception thrown when a file system operation, intended for a directory, fails because the file is not a directory."},
{"description": "A NotBoundException is thrown if an attempt is made to lookup or unbind in the registry a name that has no associated binding."},
{"description": "An interface for handling Notation Declarations Receive notification of a notation declaration event.It is up to the application to record the notation for later reference, At least one of publicId and systemId must be non-null.There is no guarantee that the notation declaration will be reported before any unparsed entities that use it."},
{"description": "This exception is thrown when a particular padding mechanism is requested but is not available in the environment."},
{"description": "A NoSuchObjectException is thrown if an attempt is made to invoke a method on an object that no longer exists in the remote virtual machine.If a NoSuchObjectException occurs attempting to invoke a method on a remote object, the call may be retransmitted and still preserve RMI's \"at most once\" call semantics.A NoSuchObjectException is also thrown by the method java.rmi.server.RemoteObject.toStub and by the unexportObject methods of java.rmi.server.UnicastRemoteObject and java.rmi.activation.Activatable and"},
{"description": "This interface represents a notation declared in the DTD.The nodeName attribute inherited from Node is set to the declared name of the notation.The DOM Core does not support editing Notation nodes; they are therefore readonly.A Notation node does not have any parent."},
{"description": "This exception is thrown when a particular security provider is requested but is not available in the environment."},
{"description": "Signals that the class doesn't have a field of a specified name."},
{"description": "This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment."},
{"description": "This exception is thrown when attempting to access an attribute that does not exist.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "Thrown if an application tries to call a specified method of a class (either static or instance), and that class no longer has a definition of that method.Normally, this error is caught by the compiler; this error can only occur at run time if the definition of a class has incompatibly changed."},
{"description": "Checked exception thrown when an attempt is made to access a file that does not exist."},
{"description": "Thrown if an application tries to access or modify a specified field of an object, and that object no longer has that field.Normally, this error is caught by the compiler; this error can only occur at run time if the definition of a class has incompatibly changed."},
{"description": "Thrown by various accessor methods to indicate that the element being requested does not exist."},
{"description": "This enum provides constants of the four Unicode normalization forms that are described in Unicode Standard Annex #15 \u2014 Unicode Normalization Forms and two methods to access them."},
{"description": "Signals that an error occurred while attempting to connect a socket to a remote address and port.Typically, the remote host cannot be reached because of an intervening firewall, or if an intermediate router is down."},
{"description": "This exception is thrown when attempting to perform an operation for which the client has no permission.The access control/permission model is dictated by the directory/naming server.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "This class provides the method normalize which transforms Unicode text into an equivalent composed or decomposed form, allowing for easier sorting and searching of text.The normalize method supports the standard normalization forms described in Unicode Standard Annex #15 \u2014 Unicode Normalization Forms.Characters with accents or other adornments can be encoded in several different ways in Unicode.In Unicode, this can be encoded as a single character (the \"composed\" form):U+0301 COMBINING ACUTE ACCENT To a user of your program, however, both of these sequences should be treated as the same \"user-level\" character \"A with acute accent\".When you are searching or comparing text, you must ensure that these two sequences are treated as equivalent.In addition, you must handle characters with more than one accent.Sometimes the order of a character's combining accents is significant, while in other cases accent sequences in different orders are really equivalent.Similarly, the string \"ffi\" can be encoded as three separate letters: U+0066 LATIN SMALL LETTER F U+0066 LATIN SMALL LETTER F U+0069 LATIN SMALL LETTER I or as the single character U+FB03The ffi ligature is not a distinct semantic character, and strictly speakingit shouldn't be in Unicode at all, but it was included for compatibility with existing character sets that already provided it.The Unicode standard identifies such characters by giving them \"compatibility\" decompositions into the corresponding semantic characters.When sorting and searching, you will often want to use these mappings.The normalize method helps solve these problems by transforming text into the canonical composed and decomposed forms as shown in the first example above.In addition, you can have it perform compatibility decompositions so that you can treat compatibility characters the same as their equivalents.Finally, the normalize method rearranges accents into the proper canonical order, so that you do not have to worry about accent rearrangement on your own.The W3C generally recommends to exchange texts in NFC.Note also that most legacy character encodings use only precomposed forms and often do not encode any combining marks by themselves.For conversion to such character encodings the Unicode text needs to be normalized to NFC."},
{"description": "Unchecked exception thrown when an attempt is made to write to a channel that was not originally opened for writing."},
{"description": "The NoninvertibleTransformException class represents an exception that is thrown if an operation is performed requiring the inverse of an AffineTransform object but the AffineTransform is in a non-invertible state."},
{"description": "Unchecked exception thrown when an attempt is made to read from a channel that was not originally opened for reading."},
{"description": "The policy of how an initial context implementation is selected is described in the documentation of the InitialContext class.This exception can be thrown during any interaction with the InitialContext, not only when the InitialContext is constructed.For example, the implementation of the initial context might lazily retrieve the context only when actual methods are invoked on it.The application should not have any dependency on when the existence of an initial context is determined.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "The type (class) and ordering of the nodes contained in the set are not defined by this class; instead that behavior should be defined by NodeSetData subclasses."},
{"description": "The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented.NodeList objects in the DOM are live.The items in the NodeList are accessible via an integral index, starting from 0."},
{"description": "This exception is thrown when a particular XML mechanism is requested but is not available in the environment.A NoSuchMechanismException can contain a cause: another throwable that caused this NoSuchMechanismException to get thrown."},
{"description": "An event emitted by a Preferences node to indicate that a child of that node has been added or removed.Note, that although NodeChangeEvent inherits Serializable interface from java.util.EventObject, it is not intended to be Serializable.Appropriate serialization methods are implemented to throw NotSerializableException."},
{"description": "Unchecked exception thrown when the finishConnect method of a SocketChannel is invoked without first successfully invoking its connect method."},
{"description": "This interface extnends the standard DOM Node interface with methods for getting and setting the value of a node, for getting and setting the parent of a node, and for removing a node."},
{"description": "The Node interface is the primary datatype for the entire Document Object Model.It represents a single node in the document tree.While all objects implementing the Node interface expose methods for dealing with children, not all objects implementing the Node interface may have children.For example, Text nodes may not have children, and adding children to such nodes results in a DOMException being raised.The attributes nodeName, nodeValue and attributes are included as a mechanism to get at node information without casting down to the specific derived interface.In cases where there is no obvious mapping of these attributes for a specific nodeType (e.g., nodeValue for an Element or attributes for a Comment ), this returns null.Note that the specialized interfaces may contain additional and more convenient mechanisms to get and set the relevant information.The values of nodeName, nodeValue, and attributes vary according to the node type as follows:the content of the text node null See also the Document Object Model (DOM) Level 3 Core Specification."},
{"description": "Thrown if the Java Virtual Machine or a ClassLoader instance tries to load in the definition of a class (as part of a normal method call or as part of creating a new instance using the new expression) and no definition of the class could be found."},
{"description": "This exception is raised if a client attempts to retrieve the result of a deferred synchronous call, but the response for the request is not yet available.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "Exception thrown when an invocation failed because the caller has insufficient privileges.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "This exception indicates that even though the operation that was invoked exists (it has an IDL definition), no implementation for that operation exists.NO_IMPLEMENT can, for example, be raised by an ORB if a client asks for an object's type definition from the interface repository, but no interface repository is provided by the ORB.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "Exception thrown when the ORB run time has run out of memory.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "Exception thrown when the ORB has encountered some general resource limitation.For example, the run time may have reached the maximum permissible number of open connections.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "Each Region that has been registered with the NimbusLookAndFeel will have an associated NimbusStyle.Third party components that are registered with the NimbusLookAndFeel will therefore be handed a NimbusStyle from the look and feel from the #getStyle(JComponent, Region) method.This class properly reads and retrieves values placed in the UIDefaults according to the standard Nimbus naming conventions.NimbusStyle also supports the ability to override settings on a per component basis.NimbusStyle checks the component's client property map for \"Nimbus.If the value associated with this key is an instance of UIDefaults, then the values in that defaults table will override the standard Nimbus defaults in UIManager, but for that component instance only.Optionally, you may specify the client property \"Nimbus.If true, this client property indicates that the defaults located in UIManager should first be read, and then replaced with defaults located in the component client properties.If false, then only the defaults located in the component client property map will be used.You must specify \"Nimbus.InheritDefaults\" to have any effect.Overrides\" indicates whether there are any overrides, while \"Nimbus.InheritDefaults\" indicates whether those overrides should first be initialized with the defaults from UIManager.The NimbusStyle is reloaded whenever a property change event is fired for a component for \"Nimbus.So for example, setting a new UIDefaults on a component would cause the style to be reloaded.The values are only read out of UIManager once, and then cached.If you need to read the values again (for example, if the UI is being reloaded), then discard this NimbusStyle and read a new one from NimbusLookAndFeel using NimbusLookAndFeel.getStyle.The primary API of interest in this class for 3rd party component authors are the three methods which retrieve painters: #getBackgroundPainter, #getForegroundPainter, and #getBorderPainter.NimbusStyle allows you to specify custom states, or modify the order of states.Synth (and thus Nimbus) has the concept of a \"state\".For example, a JButton might be in the \"MOUSE_OVER\" state, or the \"ENABLED\" state, or the \"DISABLED\" state.These are all \"standard\" states which are defined in synth, and which apply to all synth Regions.Sometimes, however, you need to have a custom state.For example, you want JButton to render differently if it's parent is a JToolbar.In Nimbus, you specify these custom states by including a special key in UIDefaults.The following UIDefaults entries define three states for this button: JButton.States entry lists the states that the JButton style will support.You then specify the settings for each state.If you do not specify the JButton.If you specify the entry but the list of states is empty or null, then the standard synth states will be assumed."},
{"description": "This class represents a Network Interface made up of a name, and a list of IP addresses assigned to this interface.It is used to identify the local interface on which a multicast group is joined.Interfaces are normally known by names such as \"le0\"."},
{"description": "This class is for various network permissions.A NetPermission contains a name (also referred to as a \"target name\") but no actions list; you either have the named permission or you don't.The target name is the name of the network permission (see below).The naming convention follows the hierarchical property naming convention.Also, an asterisk may appear at the end of the name, following a \".*\" and \"*\" signify a wildcard match, while \"*foo\" and \"a*b\" do not.The following table lists all the possible NetPermission target names, and for each provides a description of what the permission allows and a discussion of the risks of granting code the permission.What the Permission Allows Risks of Allowing this PermissionMalicious code using HTTP TRACE could get access to security sensitive information in the HTTP headers (such as cookies) that it might not otherwise have access to.The ability to get the cookie handler that processes highly security sensitive cookie information for an Http session.Malicious code can get a cookie handler to obtain access to highly security sensitive cookie information.Some web servers use cookies to save user private information such as access control information, or to track user browsing habit.Malicious code can read information about network hardware such as MAC addresses, which could be used to construct local IPv6 addresses.The ability to get the proxy selector used to make decisions on which proxies to use when making network connections.Malicious code can get a ProxySelector to discover proxy hosts and ports on internal networks, which could then become targets for attack.The ability to get the response cache that provides access to a local response cache.Malicious code getting access to the local response cache could access security sensitive information.The ability to ask the authenticator registered with the system for a password Malicious code may steal this password.The ability to set the cookie handler that processes highly security sensitive cookie information for an Http session.Malicious code can set a cookie handler to obtain access to highly security sensitive cookie information.Some web servers use cookies to save user private information such as access control information, or to track user browsing habit.The ability to set the way authentication information is retrieved when a proxy or HTTP server asks for authentication Malicious codecan set an authenticator that monitors and steals user authentication input as it retrieves the input from the user.The ability to set the proxy selector used to make decisions on which proxies to use when making network connections.Malicious code can set a ProxySelector that directs network traffic to an arbitrary network host.The ability to set the response cache that provides access to a local response cache.Malicious code getting access to the local response cache could access security sensitive information, or create false entries in the response cache.The ability to specify a stream handler when constructing a URL Malicious code may create a URL with resources that it wouldnormally not have access to (like file:/foo/fum/), specifying astream handler that gets the actual bytes from someplace it doeshave access to.Thus it might be able to trick the system intocreating a ProtectionDomain/CodeSource for a class even thoughthat class really didn't come from that location."},
{"description": "A channel that implements this interface is a channel to a network socket.The bind method is used to bind the socket to a local address, the getLocalAddress method returns the address that the socket is bound to, and the setOption and getOption methods are used to set and query socket options.An implementation of this interface should specify the socket options that it supports.The bind and setOption methods that do not otherwise have a value to return are specified to return the network channel upon which they are invoked.Implementations of this interface should specialize the return type so that method invocations on the implementation class can be chained."},
{"description": "An SQL NCLOB is a built-in type that stores a Character Large Object using the National Character Set as a column value in a row of a database table.The NClob interface extends the Clob interface which provides provides methods for getting the length of an SQL NCLOB value, for materializing a NCLOB value on the client, and for searching for a substring or NCLOB object within a NCLOB value.A NClob object, just like a Clob object, is valid for the duration of the transaction in which it was created.Methods in the interfaces ResultSet, CallableStatement, and PreparedStatement, such as getNClob and setNClob allow a programmer to access an SQL NCLOB value.In addition, this interface has methods for updating a NCLOB value.All methods on the NClob interface must be fully implemented if the JDBC driver supports the data type."},
{"description": "Thrown if an application tries to create an array with negative size."},
{"description": "Caret implementations that wish to support a NavigationFilter must provide an implementation that will not callback into the NavigationFilter."},
{"description": "When the default cursor positioning actions attempt to reposition the cursor they will call into the NavigationFilter, assuming the JTextComponent has a non-null NavigationFilter set.In this manner the NavigationFilter can effectively restrict where the cursor can be positioned.Similarly DefaultCaret will call into the NavigationFilter when the user is changing the selection to further restrict where the cursor can be positioned.Subclasses can conditionally call into supers implementation to restrict where the cursor can be placed, or call directly into the FilterBypass."},
{"description": "Type elements come in four varieties: top-level, member, local, and anonymous.Nesting kind is a non-standard term used here to denote this classification.Note that it is possible additional nesting kinds will be added in future versions of the platform.Example: The classes below are annotated with their nesting kind.System.out.format(\"%s is %s%n\", clazz.getName"},
{"description": "A SortedMap extended with navigation methods returning the closest matches for given search targets.Entry objects associated with keys respectively less than, less than or equal, greater than or equal, and greater than a given key, returning null if there is no such key.Similarly, methods lowerKey, floorKey, ceilingKey, and higherKey return only the associated keys.All of these methods are designed for locating, not traversing entries.A NavigableMap may be accessed and traversed in either ascending or descending key order.The descendingMap method returns a view of the map with the senses of all relational and directional methods inverted.The performance of ascending operations and views is likely to be faster than that of descending ones.Methods subMap, headMap, and tailMap differ from the like-named SortedMap methods in accepting additional arguments describing whether lower and upper bounds are inclusive versus exclusive.Submaps of any NavigableMap must implement the NavigableMap interface.This interface additionally defines methods firstEntry, pollFirstEntry, lastEntry, and pollLastEntry that return and/or remove the least and greatest mappings, if any exist, else returning null.Implementations of entry-returning methods are expected to return Map.Entry pairs representing snapshots of mappings at the time they were produced, and thus generally do not support the optional Entry.setValue method.Note however that it is possible to change mappings in the associated map using method put.Methods subMap(K, K), headMap(K), and tailMap(K) are specified to return SortedMap to allow existing implementations of SortedMap to be compatibly retrofitted to implement NavigableMap, but extensions and implementations of this interface are encouraged to override these methods to return NavigableMap.Similarly, SortedMap.keySet() can be overriden to return NavigableSet.This interface is a member of the Java Collections Framework."},
{"description": "Indicates that a field defining a constant value may be referenced from native code.The annotation may be used as a hint by tools that generate native header files to determine whether a header file is required, and if so, what declarations it should contain."},
{"description": "This class contains methods for creating context objects and objects referred to by location information in the naming or directory service.It has only static methods.The mention of URL in the documentation for this class refers to a URL string as defined by RFC 1738 and its related RFCs.It is any string that conforms to the syntax described therein, and may not always have corresponding support in the java.net.URL class or Web browsers.NamingManager is safe for concurrent access by multiple threads.Except as otherwise noted, a Name or environment parameter passed to any method is owned by the caller.The implementation will not modify the object or keep a reference to it, although it may keep a reference to a clone or copy."},
{"description": "This interface is the root of listener interfaces that handle NamingEvents.It does not make sense for a listener to implement just this interface.A listener typically implements a subinterface of NamingListener, such as ObjectChangeListener or NamespaceChangeListener.This interface contains a single method, namingExceptionThrown(), that must be implemented so that the listener can be notified of exceptions that are thrown (by the service provider) while gathering information about the events that they're interested in.When this method is invoked, the listener has been automatically deregistered from the EventContext with which it has registered.Then, if the connection to the server is subsequently broken, the listener will receive a NamingExceptionEvent and may take some corrective action, such as notifying the user of the application."},
{"description": "A SortedSet extended with navigation methods reporting closest matches for given search targets.Methods lower, floor, ceiling, and higher return elements respectively less than, less than or equal, greater than or equal, and greater than a given element, returning null if there is no such element.A NavigableSet may be accessed and traversed in either ascending or descending order.The descendingSet method returns a view of the set with the senses of all relational and directional methods inverted.The performance of ascending operations and views is likely to be faster than that of descending ones.This interface additionally defines methods pollFirst and pollLast that return and remove the lowest and highest element, if one exists, else returning null.Methods subSet, headSet, and tailSet differ from the like-named SortedSet methods in accepting additional arguments describing whether lower and upper bounds are inclusive versus exclusive.Subsets of any NavigableSet must implement the NavigableSet interface.The return values of navigation methods may be ambiguous in implementations that permit null elements.However, even in this case the result can be disambiguated by checking contains(null).To avoid such issues, implementations of this interface are encouraged to not permit insertion of null elements.(Note that sorted sets of Comparable elements intrinsically do not permit null.)Methods subSet(E, E), headSet(E), and tailSet(E) are specified to return SortedSet to allow existing implementations of SortedSet to be compatibly retrofitted to implement NavigableSet, but extensions and implementations of this interface are encouraged to override these methods to return NavigableSet.This interface is a member of the Java Collections Framework."},
{"description": "This is the superclass of security-related exceptions thrown by operations in the Context and DirContext interfaces.The nature of the failure is described by the name of the subclass.If the program wants to handle this exception in particular, it should catch NamingSecurityException explicitly before attempting to catch NamingException.A program might want to do this, for example, if it wants to treat security-related exceptions specially from other sorts of naming exception.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "This class represents an event fired when the procedures/processes used to collect information for notifying listeners of NamingEvents threw a NamingException.This can happen, for example, if the server which the listener is using aborts subsequent to the addNamingListener() call."},
{"description": "This class represents an event fired by a naming/directory service.The NamingEvent's state consists of The event source: the EventContext which fired this event.information about the change that triggered this event; usually service provider-specific or server-specific information.Note that the event source is always the same EventContext instance that the listener has registered with.Furthermore, the names of the bindings in the NamingEvent are always relative to that instance.For example, suppose a listener makes the following registration: NamespaceChangeListener listener = ...; src.addNamingListener(\"x\", SUBTREE_SCOPE, listener); When an object named \"x/y\" is subsequently deleted, the corresponding NamingEvent (evt) must contain: evt.getEventContext() ==Care must be taken when multiple threads are accessing the same EventContext concurrently."},
{"description": "This interface is for enumerating lists returned by methods in the javax.naming and javax.naming.directory packages.It extends Enumeration to allow as exceptions to be thrown during the enumeration.When a method such as list(), listBindings(), or search() returns a NamingEnumeration, any exceptions encountered are reserved until all results have been returned.At the end of the enumeration, the exception is thrown (by hasMore()); For example, if the list() is returning only a partial answer, the corresponding exception would be PartialResultException. list() would first return a NamingEnumeration.When the last of the results has been returned by the NamingEnumeration's next(), invoking hasMore() would result in PartialResultException being thrown.In another example, if a search() method was invoked with a specified size limit of 'n'.If the answer consists of more than 'n' results, search() would first return a NamingEnumeration.When the n'th result has been returned by invoking next() on the NamingEnumeration, a SizeLimitExceedException would then thrown when hasMore() is invoked.Note that if the program uses hasMoreElements() and nextElement() instead to iterate through the NamingEnumeration, because these methods cannot throw exceptions, no exception will be thrown.Instead, in the previous example, after the n'th result has been returned by nextElement(), invoking hasMoreElements() would return false.Note also that NoSuchElementException is thrown if the program invokes next() or nextElement() when there are no elements left in the enumeration.The program can always avoid this exception by using hasMore() and hasMoreElements() to check whether the end of the enumeration has been reached.If an exception is thrown during an enumeration, the enumeration becomes invalid.Subsequent invocation of any method on that enumeration will yield undefined results."},
{"description": "A naming context is an object that contains a set of name bindings in which each name is unique.Different names can be bound to an object in the same or different contexts at the same time."},
{"description": "A naming context is an object that contains a set of name bindings in which each name is unique.Different names can be bound to an object in the same or different contexts at the same time."},
{"description": "A naming context is an object that contains a set of name bindings in which each name is unique.Different names can be bound to an object in the same or different contexts at the same time."},
{"description": "A naming context is an object that contains a set of name bindings in which each name is unique.Different names can be bound to an object in the same or different contexts at the same time."},
{"description": "This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces.The nature of the failure is described by the name of the subclass.This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to.Portion of name that has been resolved.Object to which resolution of name proceeded.Portion of name that has not been resolved.null is an acceptable value for any of these fields.When null, it means that no such information has been recorded for that field.A NamingException instance is not synchronized against concurrent multithreaded access.Multiple threads trying to access and modify a single NamingException instance should lock the object.This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.The root exception (or root cause) is the same object as the cause returned by the Throwable.getCause() method."},
{"description": "NamingContextExt is the extension of NamingContext which contains a set of name bindings in which each name is unique and is part of Interoperable Naming Service.Different names can be bound to an object in the same or different contexts at the same time.Using NamingContextExt, you can use URL-based names to bind and resolve."},
{"description": "NamingContextExt is the extension of NamingContext which contains a set of name bindings in which each name is unique and is part of Interoperable Naming Service.Different names can be bound to an object in the same or different contexts at the same time.Using NamingContextExt, you can use URL-based names to bind and resolve."},
{"description": "NamingContextExt is the extension of NamingContext which contains a set of name bindings in which each name is unique and is part of Interoperable Naming Service.Different names can be bound to an object in the same or different contexts at the same time.Using NamingContextExt, you can use URL-based names to bind and resolve."},
{"description": "NamingContextExt is the extension of NamingContext which contains a set of name bindings in which each name is unique and is part of Interoperable Naming Service.Different names can be bound to an object in the same or different contexts at the same time.Using NamingContextExt, you can use URL-based names to bind and resolve."},
{"description": "A naming context is an object that contains a set of name bindings in which each name is unique.Different names can be bound to an object in the same or different contexts at the same time."},
{"description": "The Naming class provides methods for storing and obtaining references to remote objects in a remote object registry.Each method of the Naming class takes as one of its arguments a name that is a java.lang.String in URL format (without the scheme component) of the form: //host:port/name where host is the host (remote or local) where the registry is located, port is the port number on which the registry accepts calls, and where name is a simple string uninterpreted by the registry.If host is omitted, the host defaults to the local host.If port is omitted, then the port defaults to 1099, the \"well-known\" port that RMI's registry, rmiregistry, uses.Binding a name for a remote object is associating or registering a name for a remote object that can be used at a later time to look up that remote object.A remote object can be associated with a name using the Naming class's bind or rebind methods.Once a remote object is registered (bound) with the RMI registry on the local host, callers on a remote (or local) host can lookup the remote object by name, obtain its reference, and then invoke remote methods on the object.A registry may be shared by all servers running on a host or an individual server process may create and use its own registry if desired (see java.rmi.registry.LocateRegistry.createRegistry method for details)."},
{"description": "NamingContextExt is the extension of NamingContext which contains a set of name bindings in which each name is unique and is part of Interoperable Naming Service.Different names can be bound to an object in the same or different contexts at the same time.Using NamingContextExt, you can use URL-based names to bind and resolve."},
{"description": "Associates a name with a value that is an attribute of an IDL struct, and is used in the DynStruct APIs."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This class encapsulates the logic of Namespace processing: it tracks the declarations currently in force for each context and automatically processes qualified XML names into their Namespace parts; it can also be used in reverse for generating XML qnames from Namespaces.Namespace support objects are reusable, but the reset method must be invoked between each session.parts[2]); parts = support.processName(\"dc:title\", parts, false); System.out.println(\"Namespace URI: \" +; Note that this class is optimized for the use case where most elements do not contain Namespace declarations: if the same prefix/URI mapping is repeated for each context (for example), this class will be somewhat less efficient.Although SAX drivers (parsers) may choose to use this class to implement namespace handling, they are not required to do so.Applications must track namespace information themselves if they want to use namespace information."},
{"description": "An XML Namespace has the properties:Namespace name expressed as a URI to which the prefix is bound prefix: syntactically, this is the part of the attribute name following the XMLConstants.All get*(*) methods operate in the current scope for Namespace URI and prefix resolution.Note that a Namespace URI can be bound to multiple prefixes in the current scope.Namespace declarations occur in the same Start-Tag and refer to the same Namespace URI.This can also occur when the same Namespace URI is used in multiple XMLConstants.A prefix can only be bound to a single Namespace URI in the current scope."},
{"description": "This interface is used for parsing names from a hierarchical namespace.The NameParser contains knowledge of the syntactic information (like left-to-right orientation, name separator, etc.) needed to parse names.The equals() method, when used to compare two NameParsers, returns true if and only if they serve the same namespace."},
{"description": "An interface that contains information about a namespace.Namespaces are accessed from a StartElement."},
{"description": "Specifies the methods that a listener interested in namespace changes must implement.Specifically, the listener is interested in NamingEvents with event types of OBJECT_ADDED, OBJECT_RENAMED, or OBJECT_REMOVED.Implement NamingListener.namingExceptionThrown() so that it will be notified of exceptions thrown while attempting to collect information about the events.A listener that wants to be notified of OBJECT_CHANGED event types should also implement the ObjectChangeListener interface."},
{"description": "This exception is thrown when a component of the name cannot be resolved because it is not bound.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "The NameList interface provides the abstraction of an ordered collection of parallel pairs of name and namespace values (which could be null values), without defining or constraining how this collection is implemented.The items in the NameList are accessible via an integral index, starting from 0."},
{"description": "A name is a sequence of name components."},
{"description": "A name is a sequence of name components."},
{"description": "NamedValue objects are also used in the Context object routines to pass lists of property names and values.If the NamedValue object is used to describe arguments to a request, the name will be an argument identifier specified in the OMG IDL interface definition for the operation being described.a value -- an Any object an argument mode flag -- one of the following: ARG_IN.value ARG_OUT.value ARG_INOUT.value zero -- if this NamedValue object represents a property in a Context object rather than a parameter or return valueThe class NamedValue has three methods, which access its fields.The following code fragment demonstrates creating a NamedValue object and then accessing its fields: ORB orb = ORB.init(args, null); String s} catch (org.omg.CORBA.BAD_OPERATION b) { System.out.println(\"extract failed\"); } If this code fragment were put into a main method, the output would be something like the following:This nv name is argument_1 This nv value is 12345This nv flag is 1 Note that the method value returns an Any object.In order to access the long contained in the Any object, we used the method extract_long."},
{"description": "Underlying security services instantiate and pass a NameCallback to the handle method of a CallbackHandler to retrieve name information."},
{"description": "A MutableCallSite is a CallSite whose target variable behaves like an ordinary field.An invokedynamic instruction linked to a MutableCallSite delegates all calls to the site's current target.The dynamic invoker of a mutable call site also delegates each call to the site's current target.Here is an example of a mutable call site which introduces a state variable into a method handle chain.The same call site may be used in several places at once.\", (String) worker2.invokeExact()); Non-synchronization of target values: A write to a mutable call site's target does not force other threads to become aware of the updated value.Threads which do not perform suitable synchronization actions relative to the updated call site may cache the old target value and delay their use of the new target value indefinitely.(This is a normal consequence of the Java Memory Model as applied to object fields.)The syncAll operation provides a way to force threads to accept a new target value, even if there is no other synchronization.For target values which will be frequently updated, consider using a volatile call site instead."},
{"description": "Implementations will probably want to provide a constructor of the form: public XXXAttributeSet(ConstAttributeSet source);"},
{"description": "Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name.Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order.Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.NamedNodeMap objects in the DOM are live."},
{"description": "This class represents the object name and class name pair of a binding found in a context.A context consists of name-to-object bindings.The NameClassPair class represents the name and the class of the bound object.It consists of a name and a string representing the package-qualified class name.Use subclassing for naming systems that generate contents of a name/class pair dynamically.A NameClassPair instance is not synchronized against concurrent access by multiple threads.Threads that need to access a NameClassPair concurrently should synchronize amongst themselves and provide the necessary locking."},
{"description": "A multiplexing UI used to combine ViewportUIs.This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine TreeUIs.This file was automatically generated by AutoMulti."},
{"description": "This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine TextUIs.This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine ToolTipUIs.This file was automatically generated by AutoMulti."},
{"description": "This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine TableUIs.This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine TabbedPaneUIs.This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine SliderUIs.This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine ScrollBarUIs.This file was automatically generated by AutoMulti."},
{"description": "This file was automatically generated by AutoMulti."},
{"description": "This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine SeparatorUIs.This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine ProgressBarUIs.This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine SpinnerUIs.This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine RootPaneUIs.This file was automatically generated by AutoMulti."},
{"description": "This is the superclass for Paints which use a multiple color gradient to fill in their raster.It provides storage for variables and enumerated values common to LinearGradientPaint and RadialGradientPaint."},
{"description": "The MultipleMaster interface represents Type 1 Multiple Master fonts.A particular Font object can implement this interface."},
{"description": "Class MultipleDocumentHandling is a printing attribute class, an enumeration, that controls finishing operations and the placement of one or more print-stream pages into impressions and onto media sheets.When the value of the Copies attribute exceeds 1, MultipleDocumentHandling also controls the order in which the copies that result from processing the documents are produced.This attribute is relevant only for a multidoc print job consisting of two or more individual docs.Briefly, MultipleDocumentHandling determines the relationship between the multiple input (electronic) documents fed into a multidoc print job and the output (physical) document or documents produced by the multidoc print job.There are two possibilities: The multiple input documents are combined into a single output document.Finishing operations (Finishings), are performed on this single output document.The Copies attribute tells how many copies of this single output document to produce.The MultipleDocumentHandling values SINGLE_DOCUMENT and SINGLE_DOCUMENT_NEW_SHEET specify two variations of this possibility.The multiple input documents remain separate output documents.Finishing operations (Finishings), are performed on each output document separately.The Copies attribute tells how many copies of each separate output document to produce.The MultipleDocumentHandling values SEPARATE_DOCUMENTS_UNCOLLATED_COPIES and SEPARATE_DOCUMENTS_COLLATED_COPIES specify two variations of this possibility.In the detailed explanations below, if \"a\" represents an instance of document data, then the result of processing the data in document \"a\" is a sequence of media sheets represented by \"a(*)\".The standard MultipleDocumentHandling values are: SINGLE_DOCUMENT.If a print job has multiple documents -- say, the document data is called a and b -- then the result of processing all the document data (a and then b) must be treated as a single sequence of media sheets for finishing operations; that is, finishing would be performed on the concatenation of the sequences a(*),b(*).The printer must not force the data in each document instance to be formatted onto a new print-stream page, nor to start a new impression on a new media sheet.If more than one copy is made, the ordering of the sets of media sheets resulting from processing the document data must be a(*),b(*),a(*),b..., and the printer object must force each copy (a(*),b(*)) to start on a new media sheet.If a print job has multiple documents -- say, the document data is called a and b -- then the result of processing the data in each document instance must be treated as a single sequence of media sheets for finishing operations; that is, the sets a(*) andThe printer must force each copy of the result of processing the data in a single document to start on a new media sheet.If more than one copy is made, the ordering of the sets of media sheets resulting from processing the document data must be a(*),a(*),...If a print job has multiple documents -- say, the document data is called a and b -- then the result of processing the data in each document instance must be treated as a single sequence of media sheets for finishing operations; that is, the sets a(*) andThe printer must force each copy of the result of processing the data in a single document to start on a new media sheet.If more than one copy is made, the ordering of the sets of media sheets resulting from processing the document data must be a(*),b(*),a(*),bSame as SINGLE_DOCUMENT, except that the printer must ensure that the first impression of each document instance in the job is placed on a new media sheet.This value allows multiple documents to be stapled together with a single staple where each document starts on a new sheet.SINGLE_DOCUMENT is the same as SEPARATE_DOCUMENTS_COLLATED_COPIES with respect to ordering of print-stream pages, but not media sheet generation, since SINGLE_DOCUMENT will put the first page of the next document on the back side of a sheet if an odd number of pages have been produced so far for the job, while SEPARATE_DOCUMENTS_COLLATED_COPIES always forces the next document or document copy on to a new sheet.In addition, if a Finishings attribute of STAPLE is specified, then: With SINGLE_DOCUMENT, documents a and b are stapled together as a single document with no regard to new sheets.With SINGLE_DOCUMENT_NEW_SHEET, documents a and b are stapled together as a single document, but document b starts on a new sheet.With SEPARATE_DOCUMENTS_UNCOLLATED_COPIES and SEPARATE_DOCUMENTS_COLLATED_COPIES, documents a and b are stapled separately.Note: None of these values provide means to produce uncollated sheets within a document, i.e., where multiple copies of sheet n are produced before sheet n+1 of the same document.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "A multiplexing UI used to combine PopupMenuUIs.This file was automatically generated by AutoMulti."},
{"description": "The MultiPixelPackedSampleModel class represents one-banded images and can pack multiple one-sample pixels into one data element.Pixels are not allowed to span data elements.The data type can be DataBuffer.Each pixel must be a power of 2 number of bits and a power of 2 number of pixels must fit exactly in one data element.Pixel bit stride is equal to the number of bits per pixel.Scanline stride is in data elements and the last several data elements might be padded with unused pixels.Data bit offset is the offset in bits from the beginning of the DataBuffer to the first pixel and must be a multiple of pixel bit stride.The following code illustrates extracting the bits for pixel x,\u00a0y from DataBuffer data and storing the pixel data in data elements of type dataType: int dataElementSize = DataBuffer.getDataTypeSize(dataType); int bitnum = dataBitOffset + x*pixelBitStride; int element = data.getElem(y*scanlineStride"},
{"description": "A multiplexing UI used to combine PanelUIs.This file was automatically generated by AutoMulti."},
{"description": "This file was automatically generated by AutoMulti."},
{"description": "A multiplexing look and feel that allows more than one UI to be associated with a component at the same time.Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A multiplexing UI used to combine OptionPaneUIs.This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine MenuItemUIs.This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine ListUIs.This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine LabelUIs.This file was automatically generated by AutoMulti."},
{"description": "Interface MultiPrintService is the factory for a MultiDocPrintJob.A MultiPrintService describes the capabilities of a Printer and can be queried regarding a printer's supported attributes."},
{"description": "Obtained from a MultiDocPrintService, a MultiDocPrintJob can print a specified collection of documents as a single print job with a set of job attributes."},
{"description": "A multiplexing UI used to combine DesktopPaneUIs.This file was automatically generated by AutoMulti."},
{"description": "This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine DesktopIconUIs.This file was automatically generated by AutoMulti."},
{"description": "Interface MultiDoc specifies the interface for an object that supplies more than one piece of print data for a Print Job.\"Doc\" is a short, easy-to-pronounce term that means \"a piece of print data,\" and a \"multidoc\" is a group of several docs.The client passes to the Print Job an object that implements interface MultiDoc, and the Print Job calls methods on that object to obtain the print data.Interface MultiDoc provides an abstraction similar to a \"linked list\" of docs.A multidoc object is like a node in the linked list, containing the current doc in the list and a pointer to the next node (multidoc) in the list.The Print Job can call the multidoc's getDoc() method to get the current doc.When it's ready to go on to the next doc, the Print Job can call the multidoc's next() method to get the next multidoc, which contains the next doc.So Print Job code for accessing a multidoc might look like this:{ MultiDoc current = theMultiDoc; while (current != null) { processDoc (current.getDoc()); current = current.next(); } } Of course, interface MultiDoc can be implemented in any way that fulfills the contract; it doesn't have to use a linked list in the implementation.To get all the print data for a multidoc print job, a Print Service proxy could use either of two patterns:Get the next multidoc from the current multidoc, and repeat until there are no more.(The code example above uses the interleaved pattern.)Get the next multidoc from the current multidoc, and repeat until there are no more.Go to the next doc in the list, and repeat until there are no more.Now, consider a printing client that is generating print data on the fly and does not have the resources to store more than one piece of print data at a time.If the print service proxy used the all-at-once pattern to get the print data, it would pose a problem for such a client; the client would have to keep all the docs' print data around until the print service proxy comes back and asks for them, which the client is not able to do.To work with such a client, the print service proxy must use the interleaved pattern.To address this problem, and to simplify the design of clients providing multiple docs to a Print Job, every Print Service proxy that supports multidoc print jobs is required to access a MultiDoc object using the interleaved pattern.That is, given a MultiDoc object, the print service proxy will call getDoc() one or more times until it successfully obtains the current Doc object.The print service proxy will then obtain the current doc's print data, not proceeding until all the print data is obtained or an unrecoverable error occurs.If it is able to continue, the print service proxy will then call next() one or more times until it successfully obtains either the next MultiDoc object or an indication that there are no more.An implementation of interface MultiDoc can assume the print service proxy will follow this interleaved pattern; for any other pattern of usage, the MultiDoc implementation's behavior is unspecified.There is no restriction on the number of client threads that may be simultaneously accessing the same multidoc.Therefore, all implementations of interface MultiDoc must be designed to be multiple thread safe.In fact, a client thread could be adding docs to the end of the (conceptual) list while a Print Job thread is simultaneously obtaining docs from the beginning of the list; provided the multidoc object synchronizes the threads properly, the two threads will not interfere with each other"},
{"description": "This file was automatically generated by AutoMulti."},
{"description": "A multiplexing UI used to combine ComboBoxUIs.This file was automatically generated by AutoMulti."},
{"description": "A network channel that supports Internet Protocol (IP) multicasting.IP multicasting is the transmission of IP datagrams to members of a group that is zero or more hosts identified by a single destination address.In the case of a channel to an IPv4 socket, the underlying operating system supports RFC\u00a02236: Internet Group Management Protocol, Version 2 (IGMPv2).It may optionally support source filtering as specified by RFC\u00a03376: Internet Group Management Protocol, Version 3 (IGMPv3).For channels to an IPv6 socket, the equivalent standards are RFC\u00a02710:The join(InetAddress,NetworkInterface) method is used to join a group and receive all multicast datagrams sent to the group.A channel may join several multicast groups and may join the same group on several interfaces.Membership is dropped by invoking the drop method on the returned MembershipKey.If the underlying platform supports source filtering then the block and unblock methods can be used to block or unblock multicast datagrams from particular source addresses.The join(InetAddress,NetworkInterface,InetAddress) method is used to begin receiving datagrams sent to a group whose source address matches a given source address.This method throws UnsupportedOperationException if the underlying platform does not support source filtering.Membership is cumulative and this method may be invoked again with the same group and interface to allow receiving datagrams from other source addresses.The method returns a MembershipKey that represents membership to receive datagrams from the given source address.Invoking the key's drop method drops membership so that datagrams from the source address can no longer be received.The multicast implementation is intended to map directly to the native multicasting facility.Consequently, the following items should be considered when developing an application that receives IP multicast datagrams: The creation of the channel should specify the ProtocolFamily that corresponds to the address type of the multicast groups that the channel will join.There is no guarantee that a channel to a socket in one protocol family can join and receive multicast datagrams when the address of the multicast group corresponds to another protocol family.For example, it is implementation specific if a channel to an IPv6 socket can join an IPv4 multicast group and receive multicast datagrams sent to the group.The channel's socket should be bound to the wildcard address.If the socket is bound to a specific address, rather than the wildcard address then it is implementation specific if multicast datagrams are received by the socket.The SO_REUSEADDR option should be enabled prior to binding the socket.This is required to allow multiple members of the group to bind to the same address."},
{"description": "A multiplexing UI used to combine ButtonUIs.This file was automatically generated by AutoMulti."},
{"description": "The class that is interested in processing a mouse wheel event implements this interface (and all the methods it contains).The listener object created from that class is then registered with a component using the component's addMouseWheelListener method.For information on how mouse wheel events are dispatched, see the class description for MouseWheelEvent."},
{"description": "This file was automatically generated by AutoMulti."},
{"description": "This feature represents the use of MTOM with a web service.This annotation MUST only be used in conjunction the javax.jws.WebService, WebServiceProvider, WebServiceRef annotations.When used with the javax.jws.WebService annotation this annotation MUST only be used on the service endpoint implementation class.When used with a WebServiceRef annotation, this annotation MUST only be used when a proxy instance is created.The injected SEI proxy, and endpoint MUST honor the values of the MTOM annotation.This annotation's behaviour is defined by the corresponding feature MTOMFeature."},
{"description": "The multicast datagram socket class is useful for sending and receiving IP multicast packets.A MulticastSocket is a (UDP) DatagramSocket, with additional capabilities for joining \"groups\" of other multicast hosts on the internet.A multicast group is specified by a class D IP address and by a standard UDP port number.Class D IP addresses are in the range 224.0.0.0 to 239.255.255.255, inclusive.One would join a multicast group by first creating a MulticastSocket with the desired port, then invoking the joinGroup(InetAddress groupAddr) method: // join a Multicast group and send the group salutations ...\"Hello\"; InetAddress group = InetAddress.getByName(\"228.5.6.7\"); MulticastSocket s = new MulticastSocket(6789); s.joinGroup(group); DatagramPacket hi = new DatagramPacket(msg.getBytes(), msg.length(), group, 6789); s.send(hi); // get their responses!OK, I'm done talking - leave the group... s.leaveGroup(group); When one sends a message to a multicast group, all subscribing recipients to that host and port receive the message (within the time-to-live range of the packet, see below).The socket needn't be a member of the multicast group to send messages to it.When a socket subscribes to a multicast group/port, it receives datagrams sent by other hosts to the group/port, as do all other members of the group and port.A socket relinquishes membership in a group by the leaveGroup(InetAddress addr) method.Multiple MulticastSocket's may subscribe to a multicast group and port concurrently, and they will all receive group datagrams.Currently applets are not allowed to use multicast sockets."},
{"description": "The methods in this class are empty.This class exists as convenience for creating listener objects.(Many such events will be generated in a normal program.(If you implement the MouseMotionListener interface, you have to define all of the methods in it.This abstract class defines null methods for them all, so you can only have to define methods for events you care about.)When the mouse is moved or dragged, the relevant method in the listener object is invoked and the MouseEvent is passed to it."},
{"description": "This class also provides an empty implementation of the MouseWheelListener interface, through its extension from AWT's MouseAdapter."},
{"description": "The class that is interested in processing a mouse motion event either implements this interface (and all the methods it contains) or extends the abstract MouseMotionAdapter class (overriding only the methods of interest).The listener object created from that class is then registered with a component using the component's addMouseMotionListener method.When a mouse motion event occurs, the relevant method in the listener object is invoked, and the MouseEvent is passed to it."},
{"description": "An event which indicates that the mouse wheel was rotated in a component.A wheel mouse is a mouse which has a wheel in place of the middle button.This wheel can be rotated towards or away from the user.Mouse wheels are most often used for scrolling, though other uses are possible.A MouseWheelEvent object is passed to every MouseWheelListener object which registered to receive the \"interesting\" mouse events using the component's addMouseWheelListener method.Each such listener object gets a MouseEvent containing the mouse event.Due to the mouse wheel's special relationship to scrolling Components, MouseWheelEvents are delivered somewhat differently than other MouseEvents.This is because while other MouseEvents usually affect a change on the Component directly under the mouse cursor (for instance, when clicking a button), MouseWheelEvents often have an effect away from the mouse cursor (moving the wheel while over a Component inside a ScrollPane should scroll one of the Scrollbars on the ScrollPane).MouseWheelEvents start delivery from the Component underneath the mouse cursor.If MouseWheelEvents are not enabled on the Component, the event is delivered to the first ancestor Container with MouseWheelEvents enabled.This will usually be a ScrollPane with wheel scrolling enabled.The source Component and x,y coordinates will be relative to the event's final destination (the ScrollPane).This allows a complex GUI to be installed without modification into a ScrollPane, and for all MouseWheelEvents to be delivered to the ScrollPane for scrolling.Some AWT Components are implemented using native widgets which display their own scrollbars and handle their own scrolling.The particular Components for which this is true will vary from platform to platform.When the mouse wheel is moved over one of these Components, the event is delivered straight to the native widget, and not propagated to ancestors.Platforms offer customization of the amount of scrolling that should take place when the mouse wheel is moved.The two most common settings are to scroll a certain number of \"units\" (commonly lines of text in a text-based component) or an entire \"block\" (similar to page-up/page-down).The MouseWheelEvent offers methods for conforming to the underlying platform settings.These platform settings can be changed at any time by the user.MouseWheelEvents reflect the most recent settings.The MouseWheelEvent class includes methods for getting the number of \"clicks\" by which the mouse wheel is rotated.The getWheelRotation() method returns the integer number of \"clicks\" corresponding to the number of notches by which the wheel was rotated.In addition to this method, the MouseWheelEvent class provides the getPreciseWheelRotation() method which returns a double number of \"clicks\" in case a partial rotation occurred.The getPreciseWheelRotation() method is useful if a mouse supports a high-resolution wheel, such as a freely rotating wheel with no notches.Applications can benefit by using this method to process mouse wheel events more precisely, and thus, making visual perception smoother."},
{"description": "MouseInfo provides methods for getting information about the mouse, such as mouse pointer location and the number of mouse buttons."},
{"description": "(To track mouse moves and mouse drags, use the MouseMotionListener.)The class that is interested in processing a mouse event either implements this interface (and all the methods it contains) or extends the abstract MouseAdapter class (overriding only the methods of interest).The listener object created from that class is then registered with a component using the component's addMouseListener method.A mouse event is also generated when the mouse cursor enters or leaves a component.When a mouse event occurs, the relevant method in the listener object is invoked, and the MouseEvent is passed to it."},
{"description": "The MouseEvent interface provides specific contextual information associated with Mouse events.The detail attribute inherited from UIEvent indicates the number of times a mouse button has been pressed and released over the same screen location during a user action.The attribute value is 1 when the user begins this action and increments by 1 for each full sequence of pressing and releasing.If the user moves the mouse between the mousedown and mouseup the value will be set to 0, indicating that no click is occurring.Ancestors of the targeted element may use bubbling to obtain notification of mouse events which occur within its descendent elements."},
{"description": "An event which indicates that a mouse action occurred in a component.A mouse action is considered to occur in a particular component if and only if the mouse cursor is over the unobscured part of the component's bounds when the action happens.For lightweight components, such as Swing's components, mouse events are only dispatched to the component if the mouse event type has been enabled on the component.A mouse event type is enabled by adding the appropriate mouse-based EventListener to the component (MouseListener or MouseMotionListener), or by invoking Component.enableEvents(long) with the appropriate mask parameter (AWTEvent.If the mouse event type has not been enabled on the component, the corresponding mouse events are dispatched to the first ancestor that has enabled the mouse event type.For example, if a MouseListener has been added to a component, or enableEvents(AWTEvent.MOUSE_EVENT_MASK) has been invoked, then all the events defined by MouseListener are dispatched to the component.On the other hand, if a MouseMotionListener has not been added and enableEvents has not been invoked with AWTEvent.MOUSE_MOTION_EVENT_MASK, then mouse motion events are not dispatched to the component.Instead the mouse motion events are dispatched to the first ancestors that has enabled mouse motion events.This low-level event is generated by a component object for: Mouse Events a mouse button is pressed a mouse button is releasedthe mouse cursor enters the unobscured part of component's geometry the mouse cursor exits the unobscured part of component's geometry Mouse Motion Events the mouse is moved the mouse is dragged A MouseEvent object is passed to every MouseListener or MouseAdapter object which is registered to receive the \"interesting\" mouse events using the component's addMouseListener method.(MouseAdapter objects implement the MouseListener interface.)Each such listener object gets a MouseEvent containing the mouse event.A MouseEvent object is also passed to every MouseMotionListener or MouseMotionAdapter object which is registered to receive mouse motion events using the component's addMouseMotionListener method.(MouseMotionAdapter objects implement the MouseMotionListener interface.)Each such listener object gets a MouseEvent containing the mouse motion event.When a mouse button is clicked, events are generated and sent to the registered MouseListeners.The state of modal keys can be retrieved using InputEvent.getModifiers() and InputEvent.getModifiersEx().The button mask returned by InputEvent.getModifiers() reflects only the button that changed state, not the current state of all buttons.META_MASK/BUTTON3_MASK, this is not always true for mouse events involving modifier keys).The button which has changed state is returned by getButton()For example, if the first mouse button is pressed, events are sent in the following order:id modifiers buttonBUTTON1_MASK BUTTON1 When multiple mouse buttons are pressed, each press, release, and click results in a separate event.For example, if the user presses button 1 followed by button 2, and then releases them in the same order, the following sequence of events is generated:id modifiers buttonIf button 2 is released first, the MOUSE_RELEASED/MOUSE_CLICKED pair for BUTTON2_MASK arrives first, followed by the pair for BUTTON1_MASK.Some extra mouse buttons are added to extend the standard set of buttons represented by the following constants:BUTTON1, BUTTON2, and BUTTON3.Extra buttons have no assigned BUTTONx constants as well as their button masks have no assigned BUTTONx_DOWN_MASK constants.Nevertheless, ordinal numbers starting from 4 may be used as button numbers (button ids).Values obtained by the getMaskForButton(button) method may be used as button masks.MOUSE_DRAGGED events are delivered to the Component in which the mouse button was pressed until the mouse button is released (regardless of whether the mouse position is within the bounds of the Component).Due to platform-dependent Drag&Drop implementations, MOUSE_DRAGGED events may not be delivered during a native Drag&Drop operation.In a multi-screen environment mouse drag events are delivered to the Component even if the mouse position is outside the bounds of the GraphicsConfiguration associated with that Component.However, the reported position for mouse drag events in this case may differ from the actual mouse position: In a multi-screen environment without a virtual device: The reported coordinates for mouse drag events are clipped to fit within the bounds of the GraphicsConfiguration associated with the Component.In a multi-screen environment with a virtual device: The reported coordinates for mouse drag events are clipped to fit within the bounds of the virtual device associated with the Component.An unspecified behavior will be caused if the id parameter of any particular MouseEvent instance is not in the range from MOUSE_FIRST to MOUSE_LAST-1 (MOUSE_WHEEL is not acceptable)."},
{"description": "The methods in this class are empty.This class exists as convenience for creating listener objects.Mouse events let you track when a mouse is pressed, released, clicked, moved, dragged, when it enters a component, when it exits and when a mouse wheel is moved.(If you implement the MouseListener, MouseMotionListener interface, you have to define all of the methods in it.This abstract class defines null methods for them all, so you can only have to define methods for events you care about.)The relevant method in the listener object is invoked and the MouseEvent or MouseWheelEvent is passed to it in following cases: when a mouse button is pressed, released, or clicked (pressed and released) when the mouse cursor enters or exits the component when the mouse wheel rotated, or mouse moved or dragged"},
{"description": "This abstract subclass of DragGestureRecognizer defines a DragGestureRecognizer for mouse-based gestures.Each platform implements its own concrete subclass of this class, available via the Toolkit.createDragGestureRecognizer() method, to encapsulate the recognition of the platform dependent mouse gesture(s) that initiate a Drag and Drop operation.Mouse drag gesture recognizers should honor the drag gesture motion threshold, available through DragSource.getDragThreshold().A drag gesture should be recognized only when the distance in either the horizontal or vertical direction between the location of the latest mouse dragged event and the location of the corresponding mouse button pressed event is greater than the drag gesture motion threshold.Drag gesture recognizers created with DragSource.createDefaultDragGestureRecognizer(java.awt.Component, int, java.awt.dnd.DragGestureListener) follow this convention."},
{"description": "This feature represents the use of MTOM with a web service.This feature can be used during the creation of SEI proxy, and Dispatch instances on the client side and Endpoint instances on the server side.This feature cannot be used for Service instance creation on the client side.The following describes the affects of this feature with respect to being enabled or disabled: ENABLED:In this Mode, MTOM will be enabled.A receiver MUST accept both a non-optimized and an optimized message, and a sender MAY send an optimized message, or a non-optimized message.In this Mode, MTOM will be disabled The threshold property can be used to set the threshold value used to determine when binary data should be XOP encoded."},
{"description": "Month is an enum representing the 12 months of the year - January, February, March, April, May, June, July, August, September, October, November and December.In addition to the textual enum name, each month-of-year has an int value.The int value follows normal usage and the ISO-8601 standard, from 1 (January) to 12 (December).It is recommended that applications use the enum rather than the int value to ensure code clarity.This enum represents a common concept that is found in many calendar systems.As such, this enum may be used by any calendar system that has the month-of-year concept defined exactly equivalent to the ISO-8601 calendar system."},
{"description": "The notification source and a set of parameters concerning the monitor MBean's state need to be specified when creating a new object of this class.The list of notifications fired by the monitor MBeans is the following:Common to all kind of monitors: The observed object is not registered in the MBean server.The observed attribute is not contained in the observed object.The type of the observed attribute is not correct.Any exception (except the cases described above) occurs when trying to get the value of the observed attribute.The threshold high or threshold low are not of the same type as the gauge (gauge monitors).The threshold or the offset or the modulus are not of the same type as the counter (counter monitors).Counter monitors only: The observed attribute has reached the threshold value.Gauge monitors only: The observed attribute has exceeded the threshold high value.The observed attribute has exceeded the threshold low value.String monitors only: The observed attribute has matched the \"string to compare\" value.The observed attribute has differed from the \"string to compare\" value."},
{"description": "Exception thrown by the monitor when a monitor setting becomes invalid while the monitor is running.As the monitor attributes may change at runtime, a check is performed before each observation."},
{"description": "MonthDay is an immutable date-time object that represents the combination of a month and day-of-month.Any field that can be derived from a month and day, such as quarter-of-year, can be obtained.For example, the value \"December 3rd\" can be stored in a MonthDay.Since a MonthDay does not possess a year, the leap day of February 29th is considered valid.This class implements TemporalAccessor rather than Temporal.This is because it is not possible to define whether February 29th is valid or not without external information, preventing the implementation of plus/minus.Related to this, MonthDay only provides access to query and set the fields MONTH_OF_YEAR and DAY_OF_MONTH.The ISO-8601 calendar system is the modern civil calendar system used today in most of the world.It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time.For most applications written today, the ISO-8601 rules are entirely suitable.However, any application that makes use of historical dates, and requires them to be accurate will find the ISO-8601 approach unsuitable.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of MonthDay may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "An object monitor is locked when entering a synchronization block or method on that object.MXBean Mapping MonitorInfo is mapped to a CompositeData with attributes as specified in the from method."},
{"description": "This class represents a modification item.It consists of a modification code and an attribute on which to operate.A ModificationItem instance is not synchronized against concurrent multithreaded access.Multiple threads trying to access and modify a single ModificationItem instance should lock the object."},
{"description": "Not all modifiers are applicable to all kinds of elements.When two or more modifiers appear in the source code of an element then it is customary, though not required, that they appear in the same order as the constants listed in the detail section below.Note that it is possible additional modifiers will be added in future versions of the platform."},
{"description": "The Modifier class provides static methods and constants to decode class and member access modifiers.The sets of modifiers are represented as integers with distinct bit positions representing different modifiers.The values for the constants representing the modifiers are taken from the tables in sections 4.1, 4.4, 4.5, and 4.7 of The Java\u2122 Virtual Machine Specification."},
{"description": "Defines the part common to all monitor MBeans.The observed attribute is monitored at intervals specified by the granularity period.A gauge value (derived gauge) is derived from the values of the observed attribute."},
{"description": "This interface must be implemented by the ModelMBeans.An implementation of this interface must be shipped with every JMX Agent.the ModelMBean using the MBeanServer's createMBean method.The resource then sets the ModelMBeanInfo (with Descriptors) for the ModelMBean instance.The attributes and operations exposed via the ModelMBeanInfo for the ModelMBean are accessible from MBeans, connectors/adaptors like other MBeans.Through the ModelMBeanInfo Descriptors, values and methods in the managed application can be defined and mapped to attributes and operations of the ModelMBean.This mapping can be defined during development in an XML formatted file or dynamically and programmatically at runtime.Every ModelMBean which is instantiated in the MBeanServer becomes manageable: its attributes and operations become remotely accessible through the connectors/adaptors connected to that MBeanServer.A Java object cannot be registered in the MBeanServer unless it is a JMX compliant MBean.By instantiating a ModelMBean, resources are guaranteed that the MBean is valid.MBeanException and RuntimeOperationsException must be thrown on every public method.This allows for wrapping exceptions from distributed communications (RMI, EJB, etc.).These exceptions do not have to be thrown by the implementation except in the scenarios described in the specification and javadoc."},
{"description": "The ModelMBeanNotificationInfo object describes a notification emitted by a ModelMBean.It is a subclass of MBeanNotificationInfo with the addition of an associated Descriptor and an implementation of the Descriptor interface.The fields in the descriptor are defined, but not limited to, the following.Note that when the Type in this table is Number, a String that is the decimal representation of a Long can also be used.descriptorTypeString Must be \"notification\".The default descriptor contains the name, descriptorType, displayName and severity(=6) fields.The default value of the name and displayName fields is the name of the Notification class (as specified by the name parameter of the ModelMBeanNotificationInfo constructor).The serialVersionUID of this class is -7445681389570207141L."},
{"description": "This class represents the meta data for ModelMBeans.Descriptors have been added on the meta data objects.the ModelMBean using the MBeanServer's createMBean method.The resource then sets the ModelMBeanInfo and Descriptors for the ModelMBean instance.The attributes and operations exposed via the ModelMBeanInfo for the ModelMBean are accessible from MBeans, connectors/adaptors like other MBeans.This mapping can be defined during development in a file or dynamically and programmatically at runtime.Every ModelMBean which is instantiated in the MBeanServer becomes manageable: its attributes and operations become remotely accessible through the connectors/adaptors connected to that MBeanServer.A Java object cannot be registered in the MBeanServer unless it is a JMX compliant MBean.By instantiating a ModelMBean, resources are guaranteed that the MBean is valid.MBeanException and RuntimeOperationsException must be thrown on every public method.This allows for wrapping exceptions from distributed communications (RMI, EJB, etc.)The serialVersionUID of this class is -1935722590756516193L."},
{"description": "The ModelMBeanOperationInfo object describes a management operation of the ModelMBean.It is a subclass of MBeanOperationInfo with the addition of an associated Descriptor and an implementation of the DescriptorAccess interface.The fields in the descriptor are defined, but not limited to, the following.Note that when the Type in this table is Number, a String that is the decimal representation of a Long can also be used.descriptorTypeString Must be \"operation\".roleString Must be \"operation\", \"getter\", or \"setter\".Can be: ObjectReference | Handle | EJBHandle | IORThe default descriptor will have name, descriptorType, displayName and role fields set.The default value of the name and displayName fields is the operation name.Note: because of inconsistencies in previous versions of this specification, it is recommended not to use negative or zero values for currencyTimeLimit.To indicate that a cached value is never valid, omit the currencyTimeLimit field.To indicate that it is always valid, use a very large number for this field.The serialVersionUID of this class is 6532732096650090465L."},
{"description": "The ModelMBeanConstructorInfo object describes a constructor of the ModelMBean.It is a subclass of MBeanConstructorInfo with the addition of an associated Descriptor and an implementation of the DescriptorAccess interface.The fields in the descriptor are defined, but not limited to, the following.Note that when the Type in this table is Number, a String that is the decimal representation of a Long can also be used.descriptorTypeString Must be \"operation\".roleString Must be \"constructor\".presentationStringString XML formatted string to describe how to present operation The persistPolicy and currencyTimeLimit fields are meaningless for constructors, but are not considered invalid.The default descriptor will have the name, descriptorType, displayName and role fields.The serialVersionUID of this class is 3862947819818064362L."},
{"description": "The ModelMBeanAttributeInfo object describes an attribute of the ModelMBean.It is a subclass of MBeanAttributeInfo with the addition of an associated Descriptor and an implementation of the DescriptorAccess interface.The fields in the descriptor are defined, but not limited to, the following.Note that when the Type in this table is Number, a String that is the decimal representation of a Long can also be used.displayNameString Name of attribute to be used in displays.protocolMapDescriptor See the section \"Protocol Map Support\" in the JMX specification document.Mappings must be appropriate for the attribute and entries can be updated or augmented at runtime.Used when persistPolicy is \"OnTimer\" or \"NoMoreOftenThan\".The default descriptor contains the name, descriptorType and displayName fields.The default value of the name and displayName fields is the name of the attribute.Note: because of inconsistencies in previous versions of this specification, it is recommended not to use negative or zero values for currencyTimeLimit.To indicate that a cached value is never valid, omit the currencyTimeLimit field.To indicate that it is always valid, use a very large number for this field.The serialVersionUID of this class is 6181543027787327345L."},
{"description": "This interface must be implemented by the ModelMBeans.An implementation of this interface must be shipped with every JMX Agent.the ModelMBean using the MBeanServer's createMBean method.The resource then sets the ModelMBeanInfo (with Descriptors) for the ModelMBean instance.The attributes and operations exposed via the ModelMBeanInfo for the ModelMBean are accessible from MBeans, connectors/adaptors like other MBeans.Through the ModelMBeanInfo Descriptors, values and methods in the managed application can be defined and mapped to attributes and operations of the ModelMBean.This mapping can be defined during development in an XML formatted file or dynamically and programmatically at runtime.Every ModelMBean which is instantiated in the MBeanServer becomes manageable: its attributes and operations become remotely accessible through the connectors/adaptors connected to that MBeanServer.A Java object cannot be registered in the MBeanServer unless it is a JMX compliant MBean.By instantiating a ModelMBean, resources are guaranteed that the MBean is valid.MBeanException and RuntimeOperationsException must be thrown on every public method.This allows for wrapping exceptions from distributed communications (RMI, EJB, etc.).These exceptions do not have to be thrown by the implementation except in the scenarios described in the specification and javadoc."},
{"description": "This class represents the contents of the MLET tag.It can be consulted by a subclass of MLet that overrides the MLet.check method."},
{"description": "Allows you to instantiate and register one or several MBeans in the MBean server coming from a remote URL.The m-let service does this by loading an m-let text file, which specifies information on the MBeans to be obtained.The information on each MBean is specified in a single instance of a tag, called the MLET tag.The location of the m-let text file is specified by a URL.The MLET tag has the following syntax: <MLET CODE =where: CODE = class This attribute specifies the full Java class name, including package name, of the MBean to be obtained.The compiled .class file of the MBean must be contained in one of the .jar files specified by the ARCHIVE attribute.OBJECT = serfile This attribute specifies the .ser file that contains a serialized representation of the MBean to be obtained.This file must be contained in one of the .jar files specified by the ARCHIVE attribute.If the .jar file contains a directory hierarchy, specify the path of the file within this hierarchy.One of the .jar files must contain the file specified by the CODE or OBJECT attribute.If archivelist contains more than one file: Each file must be separated from the one that follows it by a comma (,).archivelist must be enclosed in double quote marks.All .jar files in archivelist must be stored in the directory specified by the code base URL.It identifies the directory that contains the .jar files specified by the ARCHIVE attribute.Specify this attribute only if the .jar files are not in the same directory as the m-let text file.If this attribute is not specified, the base URL of the m-let text file is used.NAME = mbeanname This optional attribute specifies the object name to be assigned to the MBean instance when the m-let service registers it.If mbeanname starts with the colon character (:), the domain part of the object name is the default domain of the MBean server, as returned by MBeanServer.getDefaultDomain().VERSION = version This optional attribute specifies the version number of the MBean and associated .jarThis version number can be used to specify that the .jar files are loaded from the server to update those stored locally in the cache the next time the m-let text file is loaded.version must be a series of non-negative decimal integers each separated by a period from the one that precedes it.arglist This optional attribute specifies a list of one or more parameters for the MBean to be instantiated.This list describes the parameters to be passed the MBean's constructor.where: argumentType is the type of the argument that will be passed as parameter to the MBean's constructor.The arguments' type in the argument list should be a Java primitive type or a Java basic type (java.lang.Boolean, java.lang.Byte, java.lang.Short, java.lang.Long, java.lang.Integer, java.lang.Float, java.lang.Double, java.lang.String).When an m-let text file is loaded, an instance of each MBean specified in the file is created and registered.The m-let service extends the java.net.URLClassLoader and can be used to load remote classes and jar files in the VM of the agent.Note - The MLet class loader uses the MBeanServerFactory.getClassLoaderRepository(javax.management.MBeanServer) to load classes that could not be found in the loaded jar files."},
{"description": "This mechanism allows the implementation to determine how resources are managed in creation / management of a mixer."},
{"description": "Info class represents information about an audio mixer, including the product's name, version, and vendor, along with a textual description.This information may be retrieved through the getMixerInfo method of the Mixer interface."},
{"description": "This interface is implemented by the ModelMBeanInfo for every ModelMBean.An implementation of this interface must be shipped with every JMX Agent.the ModelMBean using the MBeanServer's createMBean method.The resource then sets the ModelMBeanInfo and Descriptors for the ModelMBean instance.The attributes, operations, and notifications exposed via the ModelMBeanInfo for the ModelMBean comprise the management interface and are accessible from MBeans, connectors/adaptors like other MBeans.This mapping can be defined during development in a file or dynamically and programmatically at runtime.Every ModelMBean which is instantiated in the MBeanServer becomes manageable: its attributes, operations, and notifications become remotely accessible through the connectors/adaptors connected to that MBeanServer.A Java object cannot be registered in the MBeanServer unless it is a JMX compliant MBean.By instantiating a ModelMBean, resources are guaranteed that the MBean is valid.MBeanException and RuntimeOperationsException must be thrown on every public method.This allows for wrapping exceptions from distributed communications (RMI, EJB, etc.)"},
{"description": "Unchecked exception thrown when there is a format specifier which does not have a corresponding argument or if an argument index refers to an argument that does not exist.Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown."},
{"description": "Thrown when an application attempts to access the Class object corresponding to a TypeMirror."},
{"description": "Thrown when an application attempts to access a sequence of Class objects each corresponding to a TypeMirror."},
{"description": "A mixer is an audio device with one or more lines.It need not be designed for mixing audio signals.A mixer that actually mixes audio has multiple input (source) lines and at least one output (target) line.The former are often instances of classes that implement SourceDataLine, and the latter, TargetDataLine.Port objects, too, are either source lines or target lines.A mixer can accept prerecorded, loopable sound as input, by having some of its source lines be instances of objects that implement the Clip interface.Through methods of the Line interface, which Mixer extends, a mixer might provide a set of controls that are global to the mixer.For example, the mixer can have a master gain control.These global controls are distinct from the controls belonging to each of the mixer's individual lines.Some mixers, especially those with internal digital mixing capabilities, may provide additional capabilities by implementing the DataLine interface.A mixer can support synchronization of its lines.When one line in a synchronized group is started or stopped, the other lines in the group automatically start or stop simultaneously with the explicitly affected one."},
{"description": "Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown."},
{"description": "MinimalHTMLWriter is a fallback writer used by the HTMLEditorKit to write out HTML for a document that is a not produced by the EditorKit.The format for the document is: <html> <head> <style> <!-- list of named styles p.normal { font-family: SansSerif; margin-height: 0; font-size: 14 } --> </style>Bold, italic, and underline attributes of the run are emitted as HTML tags.The remaining attributes are emitted as part of the style attribute of a <span> tag.The syntax is similar to inline styles."},
{"description": "The Minguo calendar system has two eras.The current era, for years from 1 onwards, is known as the 'Republic of China' era."},
{"description": "This date operates using the Minguo calendar.This calendar system is primarily used in the Republic of China, often known as Taiwan.Dates are aligned such that 0001-01-01 (Minguo) is 1912-01-01 (ISO).This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of MinguoDate may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "This chronology defines the rules of the Minguo calendar system.This calendar system is primarily used in the Republic of China, often known as Taiwan.Dates are aligned such that 0001-01-01 (Minguo) is 1912-01-01 (ISO).era - There are two eras, the current 'Republic' (ERA_ROC) and the previous era (ERA_BEFORE_ROC).year-of-era - The year-of-era for the current era increases uniformly from the epoch at year one.For the previous era the year increases from one as time goes backwards.The value for the current era is equal to the ISO proleptic-year minus 1911.The proleptic year is the same as the year-of-era for the current era.For the previous era, years have zero, then negative values.The value is equal to the ISO proleptic-year minus 1911.day-of-month - The Minguo day-of-month exactly matches ISO.day-of-year - The Minguo day-of-year exactly matches ISO.- The Minguo leap-year pattern exactly matches ISO, such that the two calendars are never out of step."},
{"description": "This class extends FileTypeMap and provides data typing of files via their file extension.It uses the .mime.types format.The MimetypesFileTypeMap looks in various places in the user's system for MIME types file entries.When requests are made to search for MIME types in the MimetypesFileTypeMap, it searches MIME types files in the following order: Programmatically added entries to the MimetypesFileTypeMap instance.The file or resource named META-INF/mimetypes.default (usually found only in the activation.jar file).# comments begin with a '#' # the format is <mime type> <space separated file extensionstext/plain txt text TXT # this would map file.txt, file.text, and file."},
{"description": "A class to encapsulate MimeType parsing related exceptions."},
{"description": "A class to encapsulate MimeType parsing related exceptions"},
{"description": "The Primary type of the object must already be stripped off."},
{"description": "An object that stores a MIME header name and its value.One or more MimeHeader objects may be contained in a MimeHeaders object."},
{"description": "A container for MimeHeader objects, which represent the MIME headers present in a MIME part of a message.This class is used primarily when an application wants to retrieve specific attachments based on certain MIME headers and values.This class will most likely be used by implementations of AttachmentPart and other MIME dependent parts of the SAAJ API."},
{"description": "The MidiSystem class provides access to the installed MIDI system resources, including devices such as synthesizers, sequencers, and MIDI input and output ports.A typical simple MIDI application might begin by invoking one or more MidiSystem methods to learn what devices are installed and to obtain the ones needed in that application.The class also has methods for reading files, streams, and URLs that contain standard MIDI file data or soundbanks.You can query the MidiSystem for the format of a specified MIDI file.You cannot instantiate a MidiSystem; all the methods are static.Properties can be used to specify default MIDI devices.The sound.properties properties file is read from an implementation-specific location (typically it is the lib directory in the Java installation directory).If a property exists both as a system property and in the properties file, the system property takes precedence.If none is specified, a suitable default is chosen among the available devices.The syntax of the properties file is specified in Properties.load.The following table lists the available property keys and which methods consider them: MIDI System Property Keys Property Key Interface Affected Method javax.sound.midi.Receiver Receiver getReceiver() javax.sound.midi.Sequencer Sequencer getSequencer() The property value consists of the provider class name and the device name, separated by the hash mark (\"#\").The provider class name is the fully-qualified name of a concrete MIDI device provider class.The device name is matched against the String returned by the getName method of MidiDevice.If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of MidiDevice.Info objects is retrieved from the provider.Otherwise, or when these devices do not provide a subsequent match, the list is retrieved from getMidiDeviceInfo() to contain all available MidiDevice.If a device name is specified, the resulting list of MidiDevice.Info objects is searched: the first one with a matching name, and whose MidiDevice implements the respective interface, will be returned.Info object is found, or the device name is not specified, the first suitable device from the resulting list will be returned.For Sequencer and Synthesizer, a device is suitable if it implements the respective interface; whereas for Receiver and Transmitter, a device is suitable if it implements neither Sequencer nor Synthesizer and provides at least one Receiver or Transmitter, respectively.For example, the property javax.sound.midi.Receiver with a value \"com.sun.media.sound.MidiProvider#SunMIDI1\" will have the following consequences when getReceiver is called: if the class com.sun.media.sound.MidiProvider exists in the list of installed MIDI device providers, the first Receiver device with name \"SunMIDI1\" will be returned.If it cannot be found, the first Receiver from that provider will be returned, regardless of name.If there is none, the first Receiver with name \"SunMIDI1\" in the list of all devices (as returned by getMidiDeviceInfo) will be returned, or, if not found, the first Receiver that can be found in the list of all devices is returned."},
{"description": "This often occurs when a device is in use by another application.More generally, it can occur when there is a finite number of a certain kind of resource that can be used for some purpose, and all of them are already in use (perhaps all by this application)."},
{"description": "MidiMessage is the base class for MIDI messages.They include not only the standard MIDI messages that a synthesizer can respond to, but also \"meta-events\" that can be used by sequencer programs.There are meta-events for such information as lyrics, copyrights, tempo indications, time and key signatures, markers, etc.For more information, see the Standard MIDI Files 1.0 specification, which is part of the Complete MIDI 1.0 Detailed Specification published by the MIDI Manufacturer's Association (http://www.midi.org).The base MidiMessage class provides access to three types of information about a MIDI message: The messages's status byteA byte array containing the complete message MidiMessage includes methods to get, but not set, these values.Setting them is a subclass responsibility.However, because JavaTM uses signed bytes, the Java Sound API uses integers instead of bytes when expressing MIDI data.If you are processing MIDI data that originated outside Java Sound and now is encoded as signed bytes, the bytes can can be converted to integers using this conversion:If you simply need to pass a known MIDI byte value as a method parameter, it can be expressed directly as an integer, using (for example) decimal or hexadecimal notation.For instance, to pass the \"active sensing\" status byte as the first argument to ShortMessage's setMessage(int) method, you can express it as 254 or 0xFE."},
{"description": "A MidiFileWriter supplies MIDI file-writing services.Classes that implement this interface can write one or more types of MIDI file from a Sequence object."},
{"description": "A MidiFileReader supplies MIDI file-reading services.Classes implementing this interface can parse the format information from one or more types of MIDI file, and can produce a Sequence object from files of these types."},
{"description": "A MidiFileFormat object encapsulates a MIDI file's type, as well as its length and timing information.A MidiFileFormat object can include a set of properties.A property is a pair of key and value: the key is of type String, the associated property value is an arbitrary object.Properties specify additional informational meta data (like a author, or copyright).Properties are optional information, and file reader and file writer implementations are not required to provide or recognize properties.The following table lists some common properties that should be used in implementations: MIDI File Format Properties Property key Value type Description \"author\" String name of the author of this file \"title\" String title of this file \"copyright\" String copyright message \"date\" Date date of the recording or release \"comment\" String an arbitrary text"},
{"description": "MIDI events contain a MIDI message and a corresponding time-stamp expressed in ticks, and can represent the MIDI event information stored in a MIDI file or a Sequence object.The duration of a tick is specified by the timing information contained in the MIDI file or Sequence object.In Java Sound, MidiEvent objects are typically contained in a Track, and Tracks are likewise contained in a Sequence."},
{"description": "MidiDeviceReceiver is a Receiver which represents a MIDI input connector of a MidiDevice (see MidiDevice.getReceiver())."},
{"description": "A MidiDeviceProvider is a factory or provider for a particular type of MIDI device.This mechanism allows the implementation to determine how resources are managed in the creation and management of a device."},
{"description": "MidiDevice is the base interface for all MIDI devices.Common devices include synthesizers, sequencers, MIDI input ports, and MIDI output ports.A MidiDevice can be a transmitter or a receiver of MIDI events, or both.Therefore, it can provide Transmitter or Receiver instances (or both).Typically, MIDI IN ports provide transmitters, MIDI OUT ports and synthesizers provide receivers.A Sequencer typically provides transmitters for playback and receivers for recording.Explicit opening is accomplished by calling open(), explicit closing is done by calling close() on the MidiDevice instance.If an application opens a MidiDevice explicitly, it has to close it explicitly to free system resources and enable the application to exit cleanly.The MidiDevice used by MidiSystem.getReceiver and MidiSystem.getTransmitter is implementation-dependant unless the properties javax.sound.midi.Receiver and javax.sound.midi.Transmitter are used (see the description of properties to select default providers in MidiSystem).A MidiDevice that was opened implicitly, is closed implicitly by closing the Receiver or Transmitter that resulted in opening it.If more than one implicitly opening Receiver or Transmitter were obtained by the application, the device is closed after the last Receiver or Transmitter has been closed.On the other hand, calling getReceiver or getTransmitter on the device instance directly does not open the device implicitly.Closing these Transmitters and Receivers does not close the device implicitly.To use a device with Receivers or Transmitters obtained this way, the device has to be opened and closed explicitly.If implicit and explicit opening and closing are mixed on the same MidiDevice instance, the following rules apply: After an explicit open (either before or after implicit opens), the device will not be closed by implicit closing.The only way to close an explicitly opened device is an explicit close.An explicit close always closes the device, even if it also has been opened implicitly.A subsequent implicit close has no further effect.To detect if a MidiDevice represents a hardware MIDI port, the following programming technique can be used: MidiDevice device = ...; if ( !(device instanceof Sequencer) && !(device instanceof Synthesizer)){ // we're now sure that device represents a MIDI port // ... }A MidiDevice includes a MidiDevice.Info object to provide manufacturer information and so on."},
{"description": "A MidiChannel object represents a single MIDI channel.Generally, each MidiChannel method processes a like-named MIDI \"channel voice\" or \"channel mode\" message as defined by the MIDI specification.However, MidiChannel adds some \"get\" methods that retrieve the value most recently set by one of the standard MIDI channel messages.Similarly, methods for per-channel solo and mute have been added.A Synthesizer object has a collection of MidiChannels, usually one for each of the 16 channels prescribed by the MIDI 1.0 specification.The Synthesizer generates sound when its MidiChannels receive noteOn messages.See the MIDI 1.0 Specification for more information about the prescribed behavior of the MIDI channel messages, which are not exhaustively documented here.The specification is titled MIDI Reference: The Complete MIDI 1.0 Detailed Specification, and is published by the MIDI Manufacturer's Association ( http://www.midi.org).MIDI was originally a protocol for reporting the gestures of a keyboard musician.This genesis is visible in the MidiChannel API, which preserves such MIDI concepts as key number, key velocity, and key pressure.It should be understood that the MIDI data does not necessarily originate with a keyboard player (the source could be a different kind of musician, or software).Some devices might generate constant values for velocity and pressure, regardless of how the note was performed.Also, the MIDI specification often leaves it up to the synthesizer to use the data in the way the implementor sees fit.For example, velocity data need not always be mapped to volume and/or brightness."},
{"description": "MidiDeviceTransmitter is a Transmitter which represents a MIDI input connector of a MidiDevice (see MidiDevice.getTransmitter())."},
{"description": "Info object contains assorted data about a MidiDevice, including its name, the company who created it, and descriptive text."},
{"description": "This class specifies the set of parameters used with mask generation function MGF1 in OAEP Padding and RSA-PSS signature scheme, as defined in the PKCS #1 v2.1 standard.Its ASN.1 definition in PKCS#1 standard is described below: MGF1Parameters ::= OAEP-PSSDigestAlgorthms where OAEP-PSSDigestAlgorithms ALGORITHM-IDENTIFIER ::| { OID id-sha384 PARAMETERS NULL }| { OID id-sha512 PARAMETERS NULL }, ... -- Allows for future expansion -- }"},
{"description": "This class consists exclusively of static methods that operate on or return method handles.They fall into several categories: Lookup methods which help create method handles for methods and fields.Combinator methods, which combine or transform pre-existing method handles into new ones.Other factory methods to create method handles that emulate other common JVM operations or control flow patterns."},
{"description": "A method type represents the arguments and return type accepted and returned by a method handle, or the arguments and return type passed and expected by a method handle caller.Method types must be properly matched between a method handle and all its callers, and the JVM's operations enforce this matching at, specifically during calls to MethodHandle.invokeExact and MethodHandle.invoke, and during execution of invokedynamic instructions.The structure is a return type accompanied by any number of parameter types.The types (primitive, void, and reference) are represented by Class objects.(For ease of exposition, we treat void as if it were a type.In fact, it denotes the absence of a return type.)All instances of MethodType are immutable.Equality depends on pairwise correspondence of the return and parameter types and on nothing else.This type can be created only by factory methods.Some factory methods are static, while others are virtual methods which modify precursor method types, e.g., by changing a selected parameter.Factory methods which operate on groups of parameter types are systematically presented in two versions, so that both Java arrays and Java lists can be used to work with groups of parameter types.The query methods parameterArray and parameterList also provide a choice between arrays and lists.MethodType objects are sometimes derived from bytecode instructions such as invokedynamic, specifically from the type descriptor strings associated with the instructions in a class file's constant pool.Like classes and strings, method types can also be represented directly in a class file's constant pool as constants.A method type may be loaded by an ldc instruction which refers to a suitable CONSTANT_MethodType constant pool entry.The entry refers to a CONSTANT_Utf8 spelling for the descriptor string.When the JVM materializes a MethodType from a descriptor string, all classes named in the descriptor must be accessible, and will be loaded.(But the classes need not be initialized, as is the case with a CONSTANT_Class.)This loading may occur at any time before the MethodType object is first derived."},
{"description": "A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values.These transformations are quite general, and include such patterns as conversion, insertion, deletion, and substitution.Method handle contents Method handles are dynamically and strongly typed according to their parameter and return types.They are not distinguished by the name or the defining class of their underlying methods.A method handle must be invoked using a symbolic type descriptor which matches the method handle's own type descriptor.Every method handle reports its type descriptor via the type accessor.This type descriptor is a MethodType object, whose structure is a series of classes, one of which is the return type of the method (or void.class if none).A method handle's type controls the types of invocations it accepts, and the kinds of transformations that apply to it.A method handle contains a pair of special invoker methods called invokeExact and invoke.Both invoker methods provide direct access to the method handle's underlying method, constructor, field, or other operation, as modified by transformations of arguments and return values.Both invokers accept calls which exactly match the method handle's own type.The plain, inexact invoker also accepts a range of other call types.Method handles are immutable and have no visible state.Of course, they can be bound to underlying methods or data which exhibit state.With respect to the Java Memory Model, any method handle will behave as if all of its (internal) fields are final variables.This means that any method handle made visible to the application will always be fully formed.This is true even if the method handle is published through a shared variable in a data race.Method handles cannot be subclassed by the user.Implementations may (or may not) create internal subclasses of MethodHandle which may be visible via the Object.getClass operation.The programmer should not draw conclusions about a method handle from its specific class, as the method handleclass hierarchy (if any) may change from time to time or across implementations from different vendors.Method handle compilation A Java method call expression naming invokeExact or invoke can invoke a method handle from Java source code.From the viewpoint of source code, these methods can take any arguments and their result can be cast to any return type.Formally this is accomplished by giving the invoker methods Object return types and variable arity Object arguments, but they have an additional quality called signature polymorphism which connects this freedom of invocation directly to the JVM execution stack.More unusually, the compiler must record the actual argument types, and may not perform method invocation conversions on the arguments.Instead, it must push them on the stack according to their own unconverted types.The method handle object itself is pushed on the stack before the arguments.The compiler then calls the method handle with a symbolic type descriptor which describes the argument and return types.To issue a complete symbolic type descriptor, the compiler must also determine the return type.This is based on a cast on the method invocation expression, if there is one, or else Object if the invocation is an expression or else void if the invocation is a statement.The cast may be to a primitive type (but not void).As a corner case, an uncasted null argument is given a symbolic type descriptor of java.lang.Void.The ambiguity with the type Void is harmless, since there are no references of type Void except the null reference.Method handle invocation The first time a invokevirtual instruction is executed it is linked, by symbolically resolving the names in the instruction and verifying that the method call is statically legal.This is true of calls to invokeExact and invoke.In this case, the symbolic type descriptor emitted by the compiler is checked for correct syntax and names it contains are resolved.Thus, an invokevirtual instruction which invokes a method handle will always link, as long as the symbolic type descriptor is syntactically well-formed and the types exist.When the invokevirtual is executed after linking, the receiving method handle's type is first checked by the JVM to ensure that it matches the symbolic type descriptor.If the type match fails, it means that the method which the caller is invoking is not present on the individual method handle being invoked.In the case of invokeExact, the type descriptor of the invocation (after resolving symbolic type names) must exactly match the method type of the receiving method handle.In the case of plain, inexact invoke, the resolved type descriptor must be a valid argument to the receiver's asType method.Thus, plain invoke is more permissive than invokeExact.After type matching, a call to invokeExact directly and immediately invoke the method handle's underlying method (or other behavior, as the case may be).A call to plain invoke works the same as a call to invokeExact, if the symbolic type descriptor specified by the caller exactly matches the method handle's own type.If there is a type mismatch, invoke attempts to adjust the type of the receiving method handle, as if by a call to asType, to obtain an exactly invokable method handle M2.This allows a more powerful negotiation of method type between caller and callee.(Note: The adjusted method handle M2 is not directly observable, and implementations are therefore not required to materialize it.)But if a match fails, the JVM will throw a WrongMethodTypeException, either directly (in the case of invokeExact) or indirectly as if by a failed call to asType (in the case of invoke).Thus, a method type mismatch which might show up as a linkage error in a statically typed program can show up as a dynamic WrongMethodTypeException in a program which uses method handles.Because method types contain \"live\" Class objects, method type matching takes into account both types names and class loaders.Thus, even if a method handle M is created in one class loader L1 and used in another L2, method handle calls are type-safe, because the caller's symbolic type descriptor, as resolved in L2, is matched against the original callee method's symbolic type descriptor, as resolved in L1.The resolution in L1 happens when M is created and its type is assigned, while the resolution in L2 happens when the invokevirtual instruction is linked.Apart from the checking of type descriptors, a method handle's capability to call its underlying method is unrestricted.If a method handle is formed on a non-public method by a class that has access to that method, the resulting handle can be used in any place by any caller who receives a reference to it.Unlike with the Core Reflection API, where access is checked every time a reflective method is invoked, method handle access checking is performed when the method handle is created.In the case of ldc (see below), access checking is performed as part of linking the constant pool entry underlying the constant method handle.Thus, handles to non-public methods, or to methods in non-public classes, should generally be kept secret.They should not be passed to untrusted code unless their use from the untrusted code would be harmless.Method handle creation Java code can create a method handle that directly accesses any method, constructor, or field that is accessible to that code.This is done via a reflective, capability-based API called MethodHandles.For example, a static method handle can be obtained from Lookup.findStatic.There are also conversion methods from Core Reflection API objects, such as Lookup.unreflect.Like classes and strings, method handles that correspond to accessible fields, methods, and constructors can also be represented directly in a class file's constant pool as constants to be loaded by ldc bytecodes.A new type of constant pool entry, CONSTANT_MethodHandle, refers directly to an associated CONSTANT_Methodref, CONSTANT_InterfaceMethodref, or CONSTANT_Fieldref constant pool entry.(For full details on method handle constants, see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)Method handles produced by lookups or constant loads from methods or constructors with the variable arity modifier bit (0x0080) have a corresponding variable arity, as if they were defined with the help of asVarargsCollector.A method reference may refer either to a static or non-static method.In the non-static case, the method handle type includes an explicit receiver argument, prepended before any other arguments.In the method handle's type, the initial receiver argument is typed according to the class under which the method was initially requested.(E.g., if a non-static method handle is obtained via ldc, the type of the receiver is the class named in the constant pool entry.)Method handle constants are subject to the same link-time access checks their corresponding bytecode instructions, and the ldc instruction will throw corresponding linkage errors if the bytecode behaviors would throw such errors.As a corollary of this, access to protected members is restricted to receivers only of the accessing class, or one of its subclasses, and the accessing class must in turn be a subclass (or package sibling) of the protected member's defining class.If a method reference refers to a protected non-static method or field of a class outside the current package, the receiver argument will be narrowed to the type of the accessing class.When a method handle to a virtual method is invoked, the method is always looked up in the receiver (that is, the first argument).A non-virtual method handle to a specific virtual method implementation can also be created.These do not perform virtual lookup based on receiver type.Such a method handle simulates the effect of an invokespecial instruction to the same method.Usage examples Here are some examples of usage:MethodHandles.lookup();// mt is (char,char)Stringmt = MethodType.methodType(String.class, char.class, char.class);mh = lookup.findVirtual(String.class, \"replace\", mt);s = (String)mh.invokeWithArguments(\"sappy\", 'p', 'v');assertEquals(s, \"savvy\");// mt is (Object[])Listmt = MethodType.methodType(java.util.String;)Ljava/lang/Object;assertEquals(x, java.util.Arrays.asList(\"one\",\"two\"));// mt is (Object,Object,Object)Objectmt = MethodType.genericMethodType(3);mh = mh.asType(mt);x =lang/Object;assertEquals(x, java.util.Arrays.asList(1,2,3));// mt is ()intmt = MethodType.methodType(int.class);mh = lookup.findVirtual(java.util.List.class, \"size\", mt);i = (int)Each of the above calls to invokeExact or plain invoke generates a single invokevirtual instruction with the symbolic type descriptor indicated in the following comment.In these examples, the helper method assertEquals is assumed to be a method which calls Objects.equals on its arguments, and asserts that the result is true.Exceptions The methods invokeExact and invoke are declared to throw Throwable, which is to say that there is no static restriction on what a method handle can throw.Since the JVM does not distinguish between checked and unchecked exceptions (other than by their class, of course), there is no particular effect on bytecode shape from ascribing checked exceptions to method handle invocations.But in Java source code, methods which perform method handle calls must either explicitly throw Throwable, or else must catch all throwables locally, rethrowing only those which are legal in the context, and wrapping ones which are illegal.The unusual compilation and linkage behavior of invokeExact and plain invoke is referenced by the term signature polymorphism.As defined in the Java Language Specification, a signature polymorphic method is one which can operate with any of a wide range of call signatures and return types.In source code, a call to a signature polymorphic method will compile, regardless of the requested symbolic type descriptor.As usual, the Java compiler emits an invokevirtual instruction with the given symbolic type descriptor against the named method.The unusual part is that the symbolic type descriptor is derived from the actual argument and return types, not from the method declaration.When the JVM processes bytecode containing signature polymorphic calls, it will successfully link any such call, regardless of its symbolic type descriptor.(In order to retain type safety, the JVM will guard such calls with suitable dynamic type checks, as described elsewhere.)Bytecode generators, including the compiler back end, are required to emit untransformed symbolic type descriptors for these methods.Tools which determine symbolic linkage are required to accept such untransformed descriptors, without reporting linkage errors.Interoperation between method handles and the Core Reflection API Using factory methods in the Lookup API, any class member represented by a Core Reflection API object can be converted to a behaviorally equivalent method handle.For example, a reflective Method can be converted to a method handle using Lookup.unreflect.The resulting method handles generally provide more direct and efficient access to the underlying class members.As a special case, when the Core Reflection API is used to view the signature polymorphic methods invokeExact or plain invoke in this class, they appear as ordinary non-polymorphic methods.Their reflective appearance, as viewed by Class.getDeclaredMethod, is unaffected by their special status in this API.For example, Method.getModifiers will report exactly those modifier bits required for any similarly declared method, including in this case native and varargs bits.As with any reflected method, these methods (when reflected) may be invoked via java.lang.reflect.Method.invoke.However, such reflective calls do not result in method handle invocations.Such a call, if passed the required argument (a single one, of type Object[]), will ignore the argument and will throw an UnsupportedOperationException.Since invokevirtual instructions can natively invoke method handles under any symbolic type descriptor, this reflective view conflicts with the normal presentation of these methods via bytecodes.Thus, these two native methods, when reflectively viewed by Class.getDeclaredMethod, may be regarded as placeholders only.The Lookup.findVirtual API is also able to return a method handle to call invokeExact or plain invoke, for any specified type descriptor .A method handle can be obtained on a method, constructor, or field which is declared with Java generic types.As with the Core Reflection API, the type of the method handle will constructed from the erasure of the source-level type.When a method handle is invoked, the types of its arguments or the return value cast type may be generic types or type instances.If this occurs, the compiler will replace those types by their erasures when it constructs the symbolic type descriptor for the invokevirtual instruction.Method handles do not represent their function-like types in terms of Java parameterized (generic) types, because there are three mismatches between function-like types and parameterized Java types.Method types range over all possible arities, from no arguments to up to the maximum number of allowed arguments.Generics are not variadic, and so cannot represent this.Method types can specify arguments of primitive types, which Java generic types cannot range over.Higher order functions over method handles (combinators) are often generic across a wide range of function types, including those of multiple arities.It is impossible to represent such genericity with a Java type parameter.Arity limits The JVM imposes on all methods and constructors of any kind an absolute limit of 255 stacked arguments.This limit can appear more restrictive in certain cases:A non-static method consumes an extra argument for the object on which the method is called.A constructor consumes an extra argument for the object which is being constructed.Since a method handle\u2019s invoke method (or other signature-polymorphic method) is non-virtual, it consumes an extra argument for the methodThese limits imply that certain method handles cannot be created, solely because of the JVM limit on stacked arguments.For example, if a static JVM method accepts exactly 255 arguments, a method handle cannot be created for it.Attempts to create method handles with impossible method types lead to an IllegalArgumentException.In particular, a method handle\u2019s type must not have an arity of the exact maximum 255."},
{"description": "This class consists exclusively of static methods that help adapt method handles to other JVM types, such as interfaces."},
{"description": "A Method provides information about, and access to, a single method on a class or interface.The reflected method may be a class method or an instance method (including an abstract method).A Method permits widening conversions to occur when matching the actual parameters to invoke with the underlying method's formal parameters, but it throws an IllegalArgumentException if a narrowing conversion would occur."},
{"description": "A lookup object is a factory for creating method handles, when the creation requires access checking.Method handles do not perform access checks when they are called, but rather when they are created.The caller class against which those restrictions are enforced is known as the lookup class.A lookup class which needs to create method handles will call MethodHandles.lookup to create a factory for itself.When the Lookup factory object is created, the identity of the lookup class is determined, and securely stored in the Lookup object.The lookup class (or its delegates) may then use factory methods on the Lookup object to create method handles for access-checked members.This includes all methods, constructors, and fields which are allowed to the lookup class, even private ones.The factory methods on a Lookup object correspond to all major use cases for methods, constructors, and fields.Each method handle created by a factory method is the functional equivalent of a particular bytecode behavior.(Bytecode behaviors are described in section 5.4.3.5 of the Java Virtual Machine Specification.)Here is a summary of the correspondence between these factory methods and the behavior the resulting method handles: lookup expression member bytecode behavior; Here, the type C is the class or interface being searched for a member, documented as a parameter named refc in the lookup methods.The method type MT is composed from the return type T and the sequence of argument typesThe constructor also has a sequence of argument types A* and is deemed to return the newly-created object of type C.Both MT and the field type FT are documented as a parameter named type.The formal parameter this stands for the self-reference of type C; if it is present, it is always the leading argument to the method handle invocation.(In the case of some protected members, this may be restricted in type to the lookup class; see below.)The name arg stands for all the other method handle arguments.In the code examples for the Core Reflection API, the name thisOrNull stands for a null reference if the accessed method or field is static, and this otherwise.The names aMethod, aField, and aConstructor stand for reflective objects corresponding to the given members.In cases where the given member is of variable arity (i.e., a method or constructor) the returned method handle will also be of variable arity.In all other cases, the returned method handle will be of fixed arity.The equivalence between looked-up method handles and underlying class members and bytecode behaviors can break down in a few ways: If C is not symbolically accessible from the lookup class's loader, the lookup can still succeed, even when there is no equivalent Java expression or bytecoded constant.Likewise, if T or MT is not symbolically accessible from the lookup class's loader, the lookup can still succeed.For example, lookups for MethodHandle.invokeExact and MethodHandle.invoke will always succeed, regardless of requested type.If there is a security manager installed, it can forbid the lookup on various grounds (see below).By contrast, the ldc instruction on a CONSTANT_MethodHandle constant is not subject to security manager checks.If the looked-up method has a very large arity, the method handle creation may fail, due to the method handle type having too many parameters.Access checking Access checks are applied in the factory methods of Lookup, when a method handle is created.This is a key difference from the Core Reflection API, since java.lang.reflect.Method.invoke performs access checking against every caller, on every call.All access checks start from a Lookup object, which compares its recorded lookup class against all requests to create method handles.A single Lookup object can be used to create any number of access-checked method handles, all checked against a single lookup class.A Lookup object can be shared with other trusted code, such as a metaobject protocol.Even if privileged code uses the Lookup object, the access checking is confined to the privileges of the original lookup class.A lookup can fail, because the containing class is not accessible to the lookup class, or because the desired class member is missing, or because the desired class member is not accessible to the lookup class, or because the lookup object is not trusted enough to access the member.In any of these cases, a ReflectiveOperationException will be thrown from the attempted lookup.The exact class will be one of the following: NoSuchMethodException \u2014 if a method is requested but does not exist NoSuchFieldException \u2014 if a field is requested but does not exist IllegalAccessException \u2014 if the member exists but an access check fails In general, the conditions under which a method handle may be looked up for a method M are no more restrictive than the conditions under which the lookup class could have compiled, verified, and resolved a call to M. Where the JVM would raise exceptions like NoSuchMethodError, a method handlelookup will generally raise a corresponding checked exception, such as NoSuchMethodException.And the effect of invoking the method handle resulting from the lookup is exactly equivalent to executing the compiled, verified, and resolved call to M. The same pointAccess checks only apply to named and reflected methods, constructors, and fields.Other method handle creation methods, such as MethodHandle.asType, do not require any access checks, and are used independently of any Lookup object.If the desired member is protected, the usual JVM rules apply, including the requirement that the lookup class must be either be in the same package as the desired member, or must inherit that member.In addition, if the desired member is a non-static field or method in a different package, the resulting method handle may only be applied to objects of the lookup class or one of its subclasses.This requirement is enforced by narrowing the type of the leading this parameter from C (which will necessarily be a superclass of the lookup class) to the lookup class itself.The JVM imposes a similar requirement on invokespecial instruction, that the receiver argument must match both the resolved method and the current class.Again, this requirement is enforced by narrowing the type of the leading parameter to the resulting method handle.The JVM represents constructors and static initializer blocks as internal methods with special names (\"<init>\" and \"<clinit>\").The internal syntax of invocation instructions allows them to refer to such internal methods as if they were normal methods, but the JVM bytecode verifier rejects them.A lookup of such an internal method will produce a NoSuchMethodException.In some cases, access between nested classes is obtained by the Java compiler by creating an wrapper method to access a private method of another class in the same top-level declaration.For example, a nested class C.D can access private members within other related classes such as C, C.D.E, or C.B, but the Java compiler may need to generate wrapper methods in those related classes.In such cases, a Lookup object on C.E would be unable to those private members.A workaround for this limitation is the Lookup.in method, which can transform a lookup on C.E into one on any of those other classes, without special elevation of privilege.The accesses permitted to a given lookup object may be limited, according to its set of lookupModes, to a subset of members normally accessible to the lookup class.For example, the publicLookup method produces a lookup object which is only allowed to access public members in public classes.The caller sensitive method lookup produces a lookup object with full capabilities relative to its caller class, to emulate all supported bytecode behaviors.Also, the Lookup.in method may produce a lookup object with fewer access modes than the original lookup object.Discussion of private access: We say that a lookup has private access if its lookup modes include the possibility of accessing private members.As documented in the relevant methods elsewhere, only lookups with private access possess the following capabilities: access private fields, methods, and constructors of the lookup class create method handles which invoke caller sensitive methods, such as Class.forName create method handles which emulate invokespecial instructions avoid package access checks for classes accessible to the lookup class create delegated lookup objects which have private access to other classes within the same package memberEach of these permissions is a consequence of the fact that a lookup object with private access can be securely traced back to an originating class, whose bytecode behaviors and Java language access permissions can be reliably determined and emulated by method handles.Although bytecode instructions can only refer to classes in a related class loader, this API can search for methods in any class, as long as a reference to its Class object is available.Such cross-loader references are also possible with the Core Reflection API, and are impossible to bytecode instructions such as invokestatic or getfield.There is a security manager API to allow applications to check such cross-loader references.These checks apply to both the MethodHandles.Lookup API and the Core Reflection API (as found on Class).If a security manager is present, member lookups are subject to additional checks.Any of these calls can refuse access by throwing a SecurityException.Define smgr as the security manager, lookc as the lookup class of the current lookup object, refc as the containing class in which the member is being sought, and defc as the class in which the member is actually defined.The value lookc is defined as not present if the current lookup object does not have private access.The calls are made according to the following rules:Step 1: If lookc is not present, or if its class loader is not the same as or an ancestor of the class loader of refc, then smgr.checkPackageAccess(refcPkg) is called, where refcPkg is the package of refc.Step 2: If the retrieved member is not public and lookc is not present, then smgr.checkPermission with RuntimePermission(\"accessDeclaredMembers\") is called.If the retrieved member is not public, and if lookc is not present, and if defc and refc are different, then smgr.checkPackageAccess(defcPkg) is called, where defcPkg is the package of defc.Therefore, the above rules presuppose a member that is public, or else that is being accessed from a lookup class that has rights to access the member.A small number of Java methods have a special property called caller sensitivity.A caller-sensitive method can behave differently depending on the identity of its immediate caller.If a method handle for a caller-sensitive method is requested, the general rules for bytecode behaviors apply, but they take account of the lookup class in a special way.The resulting method handle behaves as if it were called from an instruction contained in the lookup class, so that the caller-sensitive method detects the lookup class.(By contrast, the invoker of the method handle is disregarded.)Thus, in the case of caller-sensitive methods, different lookup classes may give rise to differently behaving method handles.In cases where the lookup object is publicLookup(), or some other lookup object without private access, the lookup class is disregarded.In such cases, no caller-sensitive method handle can be created, access is forbidden, and the lookup fails with an IllegalAccessException.For example, the caller-sensitive method Class.forName(x) can return varying classes or throw varying exceptions, depending on the class loader of the class that calls it.A public lookup of Class.forName will fail, because there is no reasonable way to determine its bytecode behavior.If an application caches method handles for broad sharing, it should use publicLookup() to create them.If there is a lookup of Class.forName, it will fail, and the application must take appropriate action in that case.It may be that a later lookup, perhaps during the invocation of a bootstrap method, can incorporate the specific identity of the caller, making the method accessible.The function MethodHandles.lookup is caller sensitive so that there can be a secure foundation for lookups.Nearly all other methods in the JSR 292 API rely on lookup objects to check access requests."},
{"description": "A direct method handle represents a method, constructor, or field without any intervening argument bindings or other transformations.The method, constructor, or field referred to by a direct method handle is called its underlying member.Direct method handles may be obtained in any of these ways: By executing an ldc instruction on a CONSTANT_MethodHandle constant.(See the Java Virtual Machine Specification, sections 4.4.8 and 5.4.3.)A symbolic reference consists of a class, name string, and type.Restrictions on Cracking Given a suitable Lookup object, it is possible to crack any direct method handle to recover a symbolic reference for the underlying method, constructor, or field.Cracking must be done via a Lookup object equivalent to that which created the target method handle, or which has enough access permissions to recreate an equivalent method handle.If the underlying method is caller sensitive, the direct method handle will have been \"bound\" to a particular caller class, the lookup class of the lookup object used to create it.Cracking this method handle with a different lookup class will fail even if the underlying method is public (like Class.forName).The requirement of lookup object matching provides a \"fast fail\" behavior for programs which may otherwise trust erroneous revelation of a method handle with symbolic information (or caller binding) from an unexpected scope.The Lookup Factory Methods correspond to all major use cases for methods, constructors, and fields.These use cases may be distinguished using small integers as follows:"},
{"description": "A MetaMessage is a MidiMessage that is not meaningful to synthesizers, but that can be stored in a MIDI file and interpreted by a sequencer program.There are also meta-events for such information as lyrics, copyrights, tempo indications, time and key signatures, markers, etc.For more information, see the Standard MIDI Files 1.0 specification, which is part of the Complete MIDI 1.0 Detailed Specification published by the MIDI Manufacturer's Association (http://www.midi.org).When data is being transported using MIDI wire protocol, a ShortMessage with the status value 0xFF represents a system reset message.In MIDI files, this same status value denotes a MetaMessage.The types of meta-message are distinguished from each other by the first byte that follows the status byteThe subsequent bytes are data bytes.As with system exclusive messages, there are an arbitrary number of data bytes, depending on the type of MetaMessage."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This implementation is a \"combined\" view/controller."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The metal look and feel implementation of TreeUI.MetalTreeUI allows for configuring how to visually render the spacing and delineation between nodes.The following hints are supported: Angled A line is drawn connecting the child to the parent.Horizontal A horizontal line is drawn dividing the children of the root node.None Do not draw any visual indication between nodes.As it is typically impractical to obtain the TreeUI from the JTree and cast to an instance of MetalTreeUI you enable this property via the client property JTree.lineStyle.For example, to switch to Horizontal style you would do: tree.putClientProperty(\"JTree.lineStyle\", \"Horizontal\"); The default is Angled."},
{"description": "Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "MetalTheme provides the color palette and fonts used by the Java Look and Feel.MetalTheme is abstract, see DefaultMetalTheme and OceanTheme for concrete implementations.MetalLookAndFeel maintains the current theme that the the ComponentUI implementations for metal use.MetalTheme provides a number of public methods for getting colors.These methods are implemented in terms of a handful of protected abstract methods.A subclass need only override the protected abstract methods (getPrimary1, getPrimary2, getPrimary3, getSecondary1, getSecondary2, and getSecondary3); although a subclass may override the other public methods for more control over the set of colors that are used.Concrete implementations of MetalTheme must return non-null values from all methods.While the behavior of returning null is not specified, returning null will result in incorrect behavior.It is strongly recommended that subclasses return completely opaque colors."},
{"description": "Metal split pane.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "MetalRootPaneUI provides support for the windowDecorationStyle property of JRootPane.MetalRootPaneUI does this by way of installing a custom LayoutManager, a private Component to render the appropriate widgets, and a private Border.The LayoutManager is always installed, regardless of the value of the windowDecorationStyle property, but the Border and Component are only installed/added if the windowDecorationStyle is other than JRootPane.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "JButton object for Metal scrollbar arrows.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This implementation is a \"combined\" view/controller.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This implementation is a \"combined\" view/controller."},
{"description": "This class is responsible for providing the metal look and feel for JMenuBars."},
{"description": "Each of the ComponentUIs provided by MetalLookAndFeel derives its behavior from the defaults table.Unless otherwise noted each of the ComponentUI implementations in this package document the set of defaults they use.Unless otherwise noted the defaults are installed at the time installUI is invoked, and follow the recommendations outlined in LookAndFeel for installing defaults.MetalLookAndFeel derives it's color palette and fonts from MetalTheme.The default theme is OceanTheme.The theme can be changed using the setCurrentTheme method, refer to it for details on changing the theme.Prior to 1.5 the default theme was DefaultMetalTheme.The system property \"swing.metalTheme\" can be set to \"steel\" to indicate the default should be DefaultMetalTheme.Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Class that manages a JLF title bar"},
{"description": "Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This implementation is completely static, i.e. there's only one UIView implementation that's shared by all JLabel objects."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Factory object that vends Icons for the Java\u2122 look and feel (Metal).These icons are used extensively in Metal via the defaults mechanism.Each method in this class returns either an Icon or null, where null implies that there is no default icon.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Metal UI for JComboBox Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The default editor for Metal editable combo boxes Warning:Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This utility class draws the horizontal bars which indicate a MetalComboBox"},
{"description": "A subclass of BasicComboBoxEditor that implements UIResource.BasicComboBoxEditor doesn't implement UIResource directly so that applications can safely override the cellRenderer property with BasicListCellRenderer subclasses.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "CheckboxUI implementation for MetalCheckboxUI Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Factory object that can vend Borders appropriate for the metal L & F."},
{"description": "The MetaEventListener interface should be implemented by classes whose instances need to be notified when a Sequencer has processed a MetaMessage."},
{"description": "This class defines the Service Provider Interface (SPI) for the MessageDigest class, which provides the functionality of a message digest algorithm, such as MD5 or SHA.Message digests are secure one-way hash functions that take arbitrary-sized data and output a fixed-length hash value.All the abstract methods in this class must be implemented by a cryptographic service provider who wishes to supply the implementation of a particular message digest algorithm.Implementations are free to implement the Cloneable interface."},
{"description": "This MessageDigest class provides applications the functionality of a message digest algorithm, such as SHA-1 or SHA-256.Message digests are secure one-way hash functions that take arbitrary-sized data and output a fixed-length hash value.The data is processed through it using the update methods.At any point reset can be called to reset the digest.Once all the data to be updated has been updated, one of the digest methods should be called to complete the hash computation.The digest method can be called once for a given number of updates.After digest has been called, the MessageDigest object is reset to its initialized state.Implementations are free to implement the Cloneable interface.Client applications can test cloneability by attempting cloning and catching the CloneNotSupportedException:catch (CloneNotSupportedException cnse) { throw new DigestException(\"couldn't make digest of partial content\"); } Note that if a given implementation is not cloneable, it is still possible to compute intermediate digests by instantiating several instances, if the number of digests is known in advance.Note that this class is abstract and extends from MessageDigestSpi for historical reasons.Application developers should only take notice of the methods defined in this MessageDigest class; all the methods in the superclass are intended for cryptographic service providers who wish to supply their own implementations of message digest algorithms.Every implementation of the Java platform is required to support the following standard MessageDigest algorithms:SHA-1 SHA-256 These algorithms are described in the MessageDigest section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other algorithms are supported."},
{"description": "Defines constants that are used as attribute keys in the AttributedCharacterIterator returned from MessageFormat.formatToCharacterIterator."},
{"description": "A SAAJ client can create a MessageFactory object using the method newInstance, as shown in the following lines of code.SOAP_1_2_PROTOCOL); All MessageFactory objects, regardless of how they are created, will produce SOAPMessage objects that have the following elements by default: A SOAPPart object A SOAPEnvelope object A SOAPBody object A SOAPHeader object In some cases, specialized MessageFactory objects may be obtained that produce messages prepopulated with additional entries in the SOAPHeader object and the SOAPBody object.The content of a new SOAPMessage object depends on which of the two MessageFactory methods is used to create it.() This is the method clients would normally use to create a request message.createMessage(MimeHeaders, java.io.InputStream) -- message has content from the InputStream object and headers from the MimeHeaders object This method can be used internally by a service implementation to create a message that is a response to a request."},
{"description": "A Messager provides the way for an annotation processor to report error messages, warnings, and other notices.Elements, annotations, and annotation values can be passed to provide a location hint for the message.Printing a message with an error kind will raise an error.Note that the messages \"printed\" by methods in this interface may or may not appear as textual output to a location like System.out or System.err.Implementations may choose to present this information in a different fashion, such as messages in a window."},
{"description": "This is a utility class used within the per-message GSSContext methods to convey per-message properties.When used with the GSSContext interface's wrap and getMIC methods, an instance of this class is used to indicate the desired Quality-of-Protection (QOP) and to request if confidentiality services are to be applied to caller supplied data (wrap only).To request default QOP, the value of 0 should be used for QOP.When used with the unwrap and verifyMIC methods of the GSSContext interface, an instance of this class will be used to indicate the applied QOP and confidentiality services over the supplied message.In the case of verifyMIC, the confidentiality state will always be false.Upon return from these methods, this object will also contain any supplementary status values applicable to the processed token.The supplementary status values can indicate old tokens, out of sequence tokens, gap tokens or duplicate tokens."},
{"description": "Properties scoped as APPLICATION are visible to handlers, client applications and service endpoints; properties scoped as HANDLER are only normally visible to handlers."},
{"description": "MessageFormat provides a means to produce concatenated messages in a language-neutral way.MessageFormat takes a set of objects, formats them, then inserts the formatted strings into the pattern at the appropriate places.MessageFormat differs from the other Format classes in that you create a MessageFormat object with one of its constructors (not with a getInstance style factory method).The factory methods aren't necessary because MessageFormat itself doesn't implement locale specific behavior.Any locale specific behavior is defined by the pattern that you provide as well as the subformats used for inserted arguments.Patterns and Their Interpretation MessageFormat uses patterns of the following form: MessageFormatPattern: String MessageFormatPattern FormatElement String FormatElement: { ArgumentIndex } { ArgumentIndex , FormatType } { ArgumentIndex , FormatType , FormatStyle } FormatType:one of number date time choice FormatStyle: short medium long full integer currency percent SubformatPattern Within a String, a pair of single quotes can be used to quote any arbitrary characters except single quotes.For example, pattern string \"'{0}'\" represents string \"{0}\", not a FormatElement.A single quote itself must be represented by doubled single quotes '' throughout a String.For example, pattern string \"'{''}'\" is interpreted as a sequence of '{ (start of quoting and a left curly brace), '' (a single quote), and }' (a right curly brace and end of quoting), not '{' and '}' (quoted left and right curly braces): representing string \"{'}\", not \"{}\".A SubformatPattern is interpreted by its corresponding subformat, and subformat-dependent pattern rules apply.For example, pattern string \"{1,number,$'#',##}\" (SubformatPattern with underline) will produce a number format with the pound-sign quoted, with a result such as: \"$#31,45\".Any unmatched quote is treated as closed at the end of the given pattern.For example, pattern string \"'{0}\" is treated as pattern \"'{0}'\".Any curly braces within an unquoted pattern must be balanced.For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.The rules for using quotes within message format patterns unfortunately have shown to be somewhat confusing.which strings will be processed by MessageFormat.Note that localizers may need to use single quotes in translated strings where the original version doesn't have them.The ArgumentIndex value is a non-negative integer written using the digits '0' through '9', and represents an index into the arguments array passed to the format methods or the result array returned by the parse methods.The FormatType and FormatStyle values are used to create a Format instance for the format element.The following table shows how the values map to Format instances.Combinations not shown in the table are illegal.A SubformatPattern must be a valid pattern string for the Format subclass used.FormatType FormatStyle Subformat Created (none) (none)Usage Information Here are some examples of usage.In real internationalized programs, the message format pattern and other static strings will, of course, be obtained from resource bundles.Other parameters will be dynamically determined at runtime.The first example uses the static method MessageFormat.format, which internally creates a MessageFormat for one-time use: int planet = 7; String event =\"a disturbance in the Force\"; String result =( \"At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.\", planet, new Date(), event); The output is: At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.The following example creates a MessageFormat instance that can be used repeatedly: int fileCount = 1273; String diskName = \"MyDisk\"; Object[] testArgs = {new Long(fileCount), diskName}; MessageFormat form = new MessageFormat( \"The disk \\\"{1}\\\" contains {0} file(s).\"); System.out.println(form.format(testArgs)); The output with different values for fileCount: The disk \"MyDisk\" contains 0 file(s).The disk \"MyDisk\" contains 1 file(s).The disk \"MyDisk\" contains 1,273 file(s).For more sophisticated patterns, you can use a ChoiceFormat to produce correct forms for singular and plural:\"MyDisk\"; Object[] testArgs = {new Long(fileCount), diskName}; System.out.println(form.format(testArgs)); The output with different values for fileCount: The disk \"MyDisk\" contains no files.The disk \"MyDisk\" contains one file.The disk \"MyDisk\" contains 1,273 files.You can create the ChoiceFormat programmatically, as in the above example, or by using a pattern.form.applyPattern( \"There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files}.\"); Note: As we see above, the string produced by a ChoiceFormat in MessageFormat is treated as special; occurrences of '{' are used to indicate subformats, and cause recursion.If you create both a MessageFormat and ChoiceFormat programmatically (instead of using the string patterns), then be careful not to produce a format that recurses on itself, which will cause an infinite loop.When a single argument is parsed more than once in the string, the last match will be the final result of the parsing.; // result now equals \"3.14, 3.1\" objs = null; objs = mf.parse(result, new ParsePosition(0)); // objs now equals {new Double(3.1)}Likewise, parsing with a MessageFormat object using patterns containing multiple occurrences of the same argument would return the last match.x, y, z\"; Object[] objs = mf.parse(forParsing, new ParsePosition(0)); // result now equals {new String(\"z\")} Synchronization Message formats are not synchronized.It is recommended to create separate format instances for each thread.If multiple threads access a format concurrently, it must be synchronized externally."},
{"description": "The MenuShortcutclass represents a keyboard accelerator for a MenuItem.Menu shortcuts are created using virtual keycodes, not characters.For example, a menu shortcut for Ctrl-a (assuming that Control is the accelerator key) would be created with code like the following:VK_A, false); or alternatively MenuShortcut ms = new MenuShortcut(KeyEvent.getExtendedKeyCodeForChar('A'), false); Menu shortcuts may also be constructed for a wider set of keycodes using the java.awt.event.KeyEvent.getExtendedKeyCodeForChar call.For example, a menu shortcut for \"Ctrl+cyrillic ef\" is created by MenuShortcut ms = new MenuShortcut(KeyEvent.getExtendedKeyCodeForChar('?'), false);However, a shortcut made of an extended keycode not listed in KeyEvent only work if the current keyboard layout produces a corresponding letter.The accelerator key is platform-dependent and may be obtained via Toolkit.getMenuShortcutKeyMask()."},
{"description": "The interface MessageContext abstracts the message context that is processed by a handler in the handle method.The MessageContext interface provides methods to manage a property set.MessageContext properties enable handlers in a handler chain to share processing related state."},
{"description": "MenuKeyEvent is used to notify interested parties that the menu element has received a KeyEvent forwarded to it in a menu tree.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "All items in a menu must belong to the class MenuItem, or one of its subclasses.The default MenuItem object embodies a simple labeled menu item.This picture of a menu bar shows five menu items: The first two items are simple menu items, labeled \"Basic\" and \"Simple\".Following these two items is a separator, which is itself a menu item, created with the label \"-\".The final menu item is a submenu labeled \"More\u00a0Examples\", and this submenu is an instance of Menu.When a menu item is selected, AWT sends an action event to the menu item.Since the event is an instance of ActionEvent, the processEvent method examines the event and passes it along to processActionEvent.The latter method redirects the event to any ActionListener objects that have registered an interest in action events generated by this menu item.Note that the subclass Menu overrides this behavior and does not send any event to the frame until one of its subitems is selected."},
{"description": "A MenuSelectionManager owns the selection in menu hierarchy."},
{"description": "MenuEvent is used to notify interested parties that the menu which is the event source has been posted, selected, or canceled.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Any component that can be placed into a menu should implement this interface.This interface is used by MenuSelectionManager to handle selection and navigation in menu hierarchies."},
{"description": "MenuDragMouseEvent is used to notify interested parties that the menu element has received a MouseEvent forwarded to it under drag conditions.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A memory pool represents the memory resource managed by the Java virtual machine and is managed by one or more memory managers.A Java virtual machine has one or more instances of the implementation class of this interface.An instance implementing this interface is an MXBean that can be obtained by calling the ManagementFactory.getMemoryPoolMXBeans() method or from the platform MBeanServer method.The ObjectName for uniquely identifying the MXBean for a memory pool within an MBeanServer is: java.lang:type=MemoryPool,name=pool's name It can be obtained by calling the PlatformManagedObject.getObjectName() method.The Java virtual machine has a heap for object allocation and also maintains non-heap memory for the method area and the Java virtual machine execution.The Java virtual machine can have one or more memory pools.Each memory pool represents a memory area of one of the following types: heap non-heap Memory Usage Monitoring A memory pool has the following attributes: Memory usage Peak memory usage Usage Threshold Collection Usage Threshold (only supported by some garbage-collected memory pools) 1.The getUsage() method provides an estimate of the current usage of a memory pool.For a garbage-collected memory pool, the amount of used memory includes the memory occupied by all objects in the pool including both reachable and unreachable objects.In general, this method is a lightweight operation for getting an approximate memory usage.For some memory pools, for example, when objects are not packed contiguously, this method may be an expensive operation that requires some computation to determine the current memory usage.An implementation should document when this is the case.The Java virtual machine maintains the peak memory usage of a memory pool since the virtual machine was started orThe peak memory usage is returned by the getPeakUsage() method and reset by calling the resetPeakUsage() method.Each memory pool has a manageable attribute called the usage threshold which has a default value supplied by the Java virtual machine.The usage threshold can be set via the setUsageThreshold method.If the threshold is set to a positive value, the usage threshold crossing checking is enabled in this memory pool.If the usage threshold is set to zero, usage threshold crossing checking on this memory pool is disabled.A Java virtual machine performs usage threshold crossing checking on a memory pool basis at its best appropriate time, typically, at garbage collection time.Each memory pool maintains a usage threshold count that will get incremented every time when the Java virtual machine detects that the memory pool usage is crossing the threshold.This manageable usage threshold attribute is designed for monitoring the increasing trend of memory usage with low overhead.Usage threshold may not be appropriate for some memory pools.For example, a generational garbage collector, a common garbage collection algorithm used in many Java virtual machine implementations, manages two or more generations segregating objects by age.Most of the objects are allocated in the youngest generation (say a nursery memory pool).The nursery memory pool is designed to be filled up and collecting the nursery memory pool will free most of its memory space since it is expected to contain mostly short-lived objects and mostly are unreachable at garbage collection time.In this case, it is more appropriate for the nursery memory pool not to support a usage threshold.In addition, if the cost of an object allocation in one memory pool is very low (for example, just atomic pointer exchange), the Java virtual machine would probably not support the usage threshold for that memory pool since the overhead in comparing the usage with the threshold is higher than the cost of object allocation.The memory usage of the system can be monitored using polling or threshold notification mechanisms.Polling An application can continuously monitor its memory usage by calling either the getUsage() method for all memory pools or the isUsageThresholdExceeded() method for those memory pools that support a usage threshold.Below is example code that has a thread dedicated for task distribution and processing.At every interval, it will determine if it should receive and process new tasks based on its memory usage.If the memory usage exceeds its usage threshold, it will redistribute all outstanding tasks to other VMs and stop receiving new tasks until the memory usage returns below its usage threshold.Assume the usage threshold is supported for this pool.Set the threshold to myThreshold above which no new tasks // should be taken.// sleep for sometime try { Thread.sleep(sometime);} catch (InterruptedException e) { ... } } The above example does not differentiate the case where the memory usage has temporarily dropped below the usage threshold from the case where the memory usage remains above the threshold between two iterations.The usage threshold count returned by the getUsageThresholdCount() method can be used to determine if the memory usage has returned below the threshold between two polls.Below shows another example that takes some action if a memory pool is under low memory and ignores the memory usage changes during the action processing time.Assume the usage threshold is supported for this pool.Set the threshold to myThreshold which determines if // the application will take some action under low memory condition.A busy loop to detect when the memory usage // has exceeded the threshold.|| pool.getUsageThresholdCount() == prevCrossingCount) { try { Thread.sleep(sometime) } catch (InterruptException e) { .... } } //The busy loop will then // ignore any crossing of threshold happens during the processing.pool.getUsageThresholdCount(); } Usage Threshold Notifications Usage threshold notification will be emitted by MemoryMXBean.When the Java virtual machine detects that the memory usage of a memory pool has reached or exceeded the usage threshold the virtual machine will trigger the MemoryMXBean to emit an usage threshold exceeded notification.Another usage threshold exceeded notification will not be generated until the usage has fallen below the threshold and then exceeded it again.Below is an example code implementing the same logic as the first example above but using the usage threshold notification mechanism to detect low memory conditions instead of polling.The handleNotification method should be designed to do a very minimal amount of work and return without delay to avoid causing delay in delivering subsequent notifications.Time-consuming actions should be performed by a separate thread.The notification listener may be invoked by multiple threads concurrently; so the tasks performed by the listener should be properly synchronized.; // Assume this pool supports a usage threshold.Set the threshold to myThreshold above which no new tasks // should be taken.Usage threshold detection is enabled and notification will be // handled by MyListener.There is no guarantee about when the MemoryMXBean will emit a threshold notification and when the notification will be delivered.When a notification listener is invoked, the memory usage of the memory pool may have crossed the usage threshold more than once.The MemoryNotificationInfo.getCount() method returns the number of times that the memory usage has crossed the usage threshold at the point in time when the notification was constructed.It can be compared with the current usage threshold count returned by the getUsageThresholdCount() method to determine if such situation has occurred.Collection Usage Threshold Collection usage threshold is a manageable attribute only applicable to some garbage-collected memory pools.After a Java virtual machine has expended effort in reclaiming memory space by recycling unused objects in a memory pool at garbage collection time, some number of bytes in the memory pools that are garbaged collected will still be in use.The collection usage threshold allows a value to be set for this number of bytes such that if the threshold is exceeded, a collection usage threshold exceeded notification will be emitted by the MemoryMXBean.In addition, the collection usage threshold count will then be incremented.A Java virtual machine performs collection usage threshold checking on a memory pool basis.This checking is enabled if the collection usage threshold is set to a positive value.If the collection usage threshold is set to zero, this checking is disabled on this memory pool.Default value is zero.The Java virtual machine performs the collection usage threshold checking at garbage collection time.Some garbage-collected memory pools may choose not to support the collection usage threshold.For example, a memory pool is only managed by a continuous concurrent garbage collector.Objects can be allocated in this memory pool by some thread while the unused objects are reclaimed by the concurrent garbage collector simultaneously.Unless there is a well-defined garbage collection time which is the best appropriate time to check the memory usage, the collection usage threshold should not be supported.The collection usage threshold is designed for monitoring the memory usage after the Java virtual machine has expended effort in reclaiming memory space.The collection usage could also be monitored by the polling and threshold notification mechanism described above for the usage threshold in a similar fashion."},
{"description": "A memory notification is emitted by MemoryMXBean when the Java virtual machine detects that the memory usage of a memory pool is exceeding a threshold value.The notification emitted will contain the memory notification information about the detected condition: The name of the memory pool.The memory usage of the memory pool when the notification was constructed.The number of times that the memory usage has crossed a threshold when the notification was constructed.For usage threshold notifications, this count will be the usage threshold count.For collection threshold notifications, this count will be the collection usage threshold count.A CompositeData representing the MemoryNotificationInfo object is stored in the user data of a notification.The from method is provided to convert from a CompositeData to a MemoryNotificationInfo object.(); MemoryNotificationInfo info = MemoryNotificationInfo.from(cd); .... } The types of notifications emitted by MemoryMXBean are: A usage threshold exceeded notification.This notification will be emitted when the memory usage of a memory pool is increased and has reached or exceeded its usage threshold value.Subsequent crossing of the usage threshold value does not cause further notification until the memory usage has returned to become less than the usage threshold value.A collection usage threshold exceeded notification.This notification will be emitted when the memory usage of a memory pool is greater than or equal to its collection usage threshold after the Java virtual machine has expended effort in recycling unused objects in that memory pool."},
{"description": "A memory manager manages one or more memory pools of the Java virtual machine.A Java virtual machine has one or more memory managers.An instance implementing this interface is an MXBean that can be obtained by calling the ManagementFactory.getMemoryManagerMXBeans() method or from the platform MBeanServer method.The ObjectName for uniquely identifying the MXBean for a memory manager within an MBeanServer is: java.lang:type=MemoryManager,name=manager's name It can be obtained by calling the PlatformManagedObject.getObjectName() method."},
{"description": "This class is an implementation of the ImageProducer interface which uses an array to produce pixel values for an Image.Here is an example which calculates a 100x100 image representing a fade from black to blue along the X axis and a fade from black to red along the Y axis: int w = 100; int h = 100; int pix| blue; } } Image img = createImage(new MemoryImageSource(w, h, pix, 0, w)); The MemoryImageSource is also capable of managing a memory image which varies over time to allow animation or custom rendering.Here is an example showing how to set up the animation source and signal changes in the data (adapted from the MemoryAnimationSourceDemo by Garth Dickie): int pixels[]; MemoryImageSource source; public void init() { int width = 50; int height = 50; int size ="},
{"description": "Handler that buffers requests in a circular buffer in memory.Normally this Handler simply stores incoming LogRecords into its memory buffer and discards earlier records.This buffering is very cheap and avoids formatting costs.On certain trigger conditions, the MemoryHandler will push out its current buffer contents to a target Handler, which will typically publish them to the outside world.There are three main models for triggering a push of the buffer: An incoming LogRecord has a type that is greater than a pre-defined level, the pushLevel.An external class calls the push method explicitly.A subclass overrides the log method and scans each incoming LogRecord and calls push if a record matches some desired criteria.By default each MemoryHandler is initialized using the following LogManager configuration properties where <handler-name> refers to the fully-qualified class name of the handler.If properties are not defined (or have invalid values) then the specified default values are used.<handler-name>.filter specifies the name of a Filter class to use (defaults to no Filter).<handler-name>.size defines the buffer size (defaults to 1000).<handler-name>.push defines the pushLevel (defaults to level.<handler-name>.target specifies the name of the target Handler class.For example, the properties for MemoryHandler would be: java.util.logging.MemoryHandler.level=INFO java.util.logging.MemoryHandler.formatter=java.util.logging.SimpleFormatterFor a custom handler, e.g. com.foo.MyHandler, the properties would be: com.foo.MyHandler.level=INFO com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter"},
{"description": "Member is an interface that reflects identifying information about a single member (a field or a method) or a constructor."},
{"description": "A Java virtual machine has a single instance of the implementation class of this interface.This instance implementing this interface is an MXBean that can be obtained by calling the ManagementFactory.getMemoryMXBean() method or from the platform MBeanServer method.The ObjectName for uniquely identifying the MXBean for the memory system within an MBeanServer is: java.lang:type=MemoryIt can be obtained by calling the PlatformManagedObject.getObjectName() method.Memory The memory system of the Java virtual machine manages the following kinds of memory: 1.The Java virtual machine has a heap that is the runtime data area from which memory for all class instances and arrays are allocated.It is created at the Java virtual machine start-up.Heap memory for objects is reclaimed by an automatic memory management system which is known as a garbage collector.The heap may be of a fixed size or may be expanded and shrunk.The memory for the heap does not need to be contiguous.The Java virtual machine manages memory other than the heap (referred as non-heap memory).The Java virtual machine has a method area that is shared among all threads.The method area belongs to non-heap memory.It stores per-class structures such as a runtime constant pool, field and method data, and the code for methods and constructors.It is created at the Java virtual machine start-up.The method area is logically part of the heap but a Java virtual machine implementation may choose not to either garbage collect or compact it.Similar to the heap, the method area may be of a fixed size or may be expanded and shrunk.The memory for the method area does not need to be contiguous.In addition to the method area, a Java virtual machine implementation may require memory for internal processing or optimization which also belongs to non-heap memory.For example, the JIT compiler requires memory for storing the native machine code translated from the Java virtual machine code for high performance.Memory Pools and Memory Managers Memory pools and memory managers are the abstract entities that monitor and manage the memory system of the Java virtual machine.A memory pool represents a memory area that the Java virtual machine manages.The Java virtual machine has at least one memory pool and it may create or remove memory pools during execution.A memory pool can belong to either the heap or the non-heap memory.A memory manager is responsible for managing one or more memory pools.The garbage collector is one type of memory manager responsible for reclaiming memory occupied by unreachable objects.A Java virtual machine may have one or more memory managers.It may add or remove memory managers during execution.A memory pool can be managed by more than one memory manager.Memory Usage Monitoring Memory usage is a very important monitoring attribute for the memory system.The memory usage, for example, could indicate: the memory usage of an application, the workload being imposed on the automatic memory management system, potential memory leakage.The memory usage can be monitored in three ways:Collection Usage Threshold Notification Details are specified in the MemoryPoolMXBean interface.The memory usage monitoring mechanism is intended for load-balancing or workload distribution use.For example, an application would stop receiving any new workload when its memory usage exceeds a certain threshold.It is not intended for an application to detect and recover from a low memory condition.Notifications This MemoryMXBean is a NotificationEmitter that emits two types of memory notifications if any one of the memory pools supports a usage threshold or a collection usage threshold which can be determined by calling the MemoryPoolMXBean.isUsageThresholdSupported() and MemoryPoolMXBean.isCollectionUsageThresholdSupported() methods.usage threshold exceeded notification - for notifying that the memory usage of a memory pool is increased and has reached or exceeded its usage threshold value.collection usage threshold exceeded notification - for notifying that the memory usage of a memory pool is greater than or equal to its collection usage threshold after the Java virtual machine has expended effort in recycling unused objects in that memory pool.The notification emitted is a Notification instance whose user data is set to a CompositeData that represents a MemoryNotificationInfo object containing information about the memory pool when the notification was constructed.The CompositeData contains the attributes as described in MemoryNotificationInfo.The MemoryMXBean object returned by ManagementFactory.getMemoryMXBean() implements the NotificationEmitter interface that allows a listener to be registered within the MemoryMXBean as a notification listener.Below is an example code that registers a MyListener to handle notification emitted by the MemoryMXBean. class MyListener implements javax.management.NotificationListener { public void handleNotification(Notification notif, Object handback)"},
{"description": "ImageOutputStream that writes its output to a regular OutputStream.A memory buffer is used to cache at least the data between the discard position and the current write position.The only constructor takes an OutputStream, so this class may not be used for read/modify/write operations.Reading can occur only on parts of the stream that have already been written to the cache and not yet flushed."},
{"description": "An implementation of ImageInputStream that gets its input from a regular InputStream.A memory buffer is used to cache at least the data between the discard position and the current read position.In general, it is preferable to use a FileCacheImageInputStream when reading from a regular InputStream.This class is provided for cases where it is not possible to create a writable temporary file."},
{"description": "A membership key may represent a membership to receive all datagrams sent to the group, or it may be source-specific, meaning that it represents a membership that receives only datagrams from a specific source address.Whether or not a membership key is source-specific may be determined by invoking its sourceAddress method.A membership key is valid upon creation and remains valid until the membership is dropped by invoking the drop method, or the channel is closed.The validity of the membership key may be tested by invoking its isValid method.Where a membership key is not source-specific and the underlying operation system supports source filtering, then the block and unblock methods can be used to block or unblock multicast datagrams from particular source addresses."},
{"description": "Class MediaTray is a subclass of Media.Class MediaTray is a printing attribute class, an enumeration, that specifies the media tray or bin for the job.This attribute can be used instead of specifying MediaSize or MediaName.Class MediaTray declares keywords for standard media kind values.kind attribute may also be created by defining a subclass of class MediaTray.IPP Compatibility: MediaTray is a representation class for values of the IPP \"media\" attribute which name paper trays."},
{"description": "NA includes MediaSize values for North American media."},
{"description": "JIS includes MediaSize values for JIS (Japanese) media."},
{"description": "Class MediaSize is a two-dimensional size valued printing attribute class that indicates the dimensions of the medium in a portrait orientation, with the X dimension running along the bottom edge and the Y dimension running along the left edge.Thus, the Y dimension must be greater than or equal to the X dimension.Class MediaSize declares many standard media size values, organized into nested classes for ISO, JIS, North American, engineering, and other media.MediaSize is not yet used to specify media.Its current role is as a mapping for named media (see MediaSizeName).Clients can use the mapping method MediaSize.getMediaSizeForName(MediaSizeName) to find the physical dimensions of the MediaSizeName instances enumerated in this API.This is useful for clients which need this information to format & paginate printing."},
{"description": "ISO includes MediaSize values for ISO media."},
{"description": "The MediaTracker class is a utility class to track the status of a number of media objects.Media objects could include audio clips as well as images, though currently only images are supported.To use a media tracker, create an instance of MediaTracker and call its addImage method for each image to be tracked.In addition, each image can be assigned a unique identifier.This identifier controls the priority order in which the images are fetched.It can also be used to identify unique subsets of the images that can be waited on independently.Images with a lower ID are loaded in preference to those with a higher ID number.Tracking an animated image might not always be useful due to the multi-part nature of animated image loading and painting, but it is supported.MediaTracker treats an animated image as completely loaded when the first frame is completely loaded.At that point, the MediaTracker signals any waiters that the image is completely loaded.If no ImageObservers are observing the image when the first frame has finished loading, the image might flush itself to conserve resources (see Image.flush()).Here is an example of using MediaTracker: import java.applet.Applet; import java.awt.Color; import java.awt.Image; import java.awt.Graphics; import java.awt.MediaTracker; public class ImageBlaster extends Applet implementsGet the images for the background (id =; tracker.addImage(anim[i], 1); } } // Start the animation thread.First wait for the background image to fully load // and paint.Finally, loop and // increment the animation frame index.public void run() { try { tracker.waitForID(0); tracker.waitForID(1);} catch (InterruptedException e) { return; } Thread me =Thread.currentThread(); while (animator == me) { try { Thread.sleep(100);The background image fills the frameso we // don't need to clear the applet on repaints.public void update(Graphics g) { paint(g); } // Paint a large red rectangle if there are any errors // loading the images.Otherwise always paint the // background so that it appears incrementally as it // is loading.Finally, only paint the current animation // frame if all of the frames (id == 1) are done loading, // so that we don't get partial animations."},
{"description": "Other includes MediaSize values for miscellaneous media."},
{"description": "Class MediaSizeName is a subclass of Media.This attribute can be used instead of specifying MediaName or MediaTray.Class MediaSizeName currently declares a few standard media name values.MediaSizeName is a representation class for values of the IPP \"media\" attribute which names media sizes.The names of the media sizes correspond to those in the IPP 1.1 RFC RFC 2911"},
{"description": "Engineering includes MediaSize values for engineering media."},
{"description": "Class MediaPrintableArea is a printing attribute used to distinguish the printable and non-printable areas of media.The printable area is specified to be a rectangle, within the overall dimensions of a media.Most printers cannot print on the entire surface of the media, due to printer hardware limitations.This class can be used to query the acceptable values for a supposed print job, and to request an area within the constraints of the printable area to be used in a print job.To query for the printable area, a client must supply a suitable context.Without specifying at the very least the size of the media being used no meaningful value for printable area can be obtained.The attribute is not described in terms of the distance from the edge of the paper, in part to emphasise that this attribute is not independent of a particular media, but must be described within the context of a choice of other attributes.Additionally it is usually more convenient for a client to use the printable area.The hardware's minimum margins is not just a property of the printer, but may be a function of the media size, orientation, media type, and any specified finishings.PrintService provides the method to query the supported values of an attribute in a suitable context :The rectangular printable area is defined thus: The (x,y) origin is positioned at the top-left of the paper in portrait mode regardless of the orientation specified in the requesting context.For example a printable area for A4 paper in portrait or landscape orientation will have height > width.A printable area attribute's values are stored internally as integers in units of micrometers (\u00b5m), where 1 micrometer = 10-6 meter =This permits dimensions to be represented exactly to a precision of 1/1000 mm (= 1 \u00b5m) or 1/100 inch (= 254 \u00b5m).If fractional inches are expressed in negative powers of two, this permits dimensions to be represented exactly to a precision of 1/8 inch (= 3175 \u00b5m) but not 1/16 inch (because 1/16 inch does not equal an integral number of \u00b5m).MediaPrintableArea is not an IPP attribute."},
{"description": "Class Media is a printing attribute class that specifies the medium on which to print.Media may be specified in different ways.it may be specified by paper source - eg paper trayit may be specified by a standard size - eg \"A4\"it may be specified by a name - eg \"letterhead\" Each of these corresponds to the IPP \"media\" attribute.The current API does not support describing media by characteristics (eg colour, opacity).This may be supported in a later revision of the specification.A Media object is constructed with a value which represents one of the ways in which the Media attribute can be specified.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "This permission represents \"trust\" in a signer or codebase.MBeanTrustPermission contains a target name but no actions list.A single target name, \"register\", is defined for this permission.The target \"*\" is also allowed, permitting \"register\" and any future targets that may be defined.Only the null value or the empty string are allowed for the action to allow the policy object to create the permissions specified in the policy file.If a signer, or codesource is granted this permission, then it is considered a trusted source for MBeans.Only MBeans from trusted sources may be registered in the MBeanServer."},
{"description": "Given an MBeanServerConnection, the ObjectName of an MBean within that MBean server, and a Java interface Intf that describes the management interface of the MBean using the patterns for a Standard MBean or an MXBean, this class can be used to construct a proxy for the MBean.The proxy implements the interface Intf such that all of its methods are forwarded through the MBean server to the MBean.If the InvocationHandler is for an MXBean, then the parameters of a method are converted from the type declared in the MXBean interface into the corresponding mapped type, and the return value is converted from the mapped type into the declared type.For example, with the method public List<String> reverse(List<String> list); and given that the mapped type for List<String> is String[], a call to proxy.reverse(someList) will convert someList from a List<String> to a String[], call the MBean operation reverse, then convert the returned String[] into a List<String>.(), or Object.equals(Object), when invoked on a proxy using this invocation handler, is forwarded to the MBean server as a method on the proxied MBean only if it appears in one of the proxy's interfaces.For a proxy created with JMX.newMBeanProxy or JMX.newMXBeanProxy, this means that the method must appear in the Standard MBean or MXBean interface.Otherwise these methods have the following behavior:toString() returns a string representation of the proxy hashCode() returns a hash code for the proxy such that two equal proxies have the same hash code equals(Object) returns true if andonly if the Object argument is of the same proxy class as this proxy, with an MBeanServerInvocationHandler that has the same MBeanServerConnection and ObjectName; if one of the MBeanServerInvocationHandlers was constructed with a Class argument then the other must have been constructed with the same Class for equals to return true."},
{"description": "The name of the permission specifies the operation requested or granted by the permission.For a granted permission, it can be * to allow all of the MBeanServer operations specified below.Otherwise, for a granted or requested permission, it must be one of the following:createMBeanServer Create a new MBeanServer object using the method MBeanServerFactory.createMBeanServer() or MBeanServerFactory.createMBeanServer(java.lang.findMBeanServer Find an MBeanServer with a given name, or all MBeanServers in this JVM, using the method MBeanServerFactory.findMBeanServer(java.lang.The name of the permission can also denote a list of one or more comma-separated operations.Spaces are allowed at the beginning and end of the name and before and after commas."},
{"description": "This filter filters MBeanServerNotification notifications by selecting the ObjectNames of interest and the operations (registration, unregistration, both) of interest (corresponding to notification types).The serialVersionUID of this class is 2605900539589789736L."},
{"description": "The MBean Server emits the following types of notifications: MBean registration, MBean unregistration.To receive MBeanServerNotifications, you need to register a listener with the MBeanServerDelegate MBean that represents the MBeanServer.The ObjectName of the MBeanServerDelegate is MBeanServerDelegate.DELEGATE_NAME, which is JMImplementation:type=MBeanServerDelegate.The following code prints a message every time an MBean is registered or unregistered in the MBean Serverprivate static final NotificationListener printListener = new NotificationListener() { public void handleNotification(Notification n, Object handback) { if (!(n instanceof MBeanServerNotification))\"MBean registered\"; else if (n.getType().equals(MBeanServerNotification.UNREGISTRATION_NOTIFICATION))DELEGATE_NAME, printListener, null, null); An MBean which is not an MBeanServerDelegate may also emit MBeanServerNotifications.In particular, there is a convention for MBeans to emit an MBeanServerNotification for a group of MBeans.An MBeanServerNotification emitted to denote the registration or unregistration of a group of MBeans has the following characteristics: Its notification type is \"JMX.mbean.registered.group\" or \"JMX.mbean.unregistered.group\", which can also be written REGISTRATION_NOTIFICATION+ \".group\" or UNREGISTRATION_NOTIFICATION+ \".group\".Its MBean name is an ObjectName pattern that selects the set (or a superset) of the MBeans being registered or unregistered Its user data can optionally be set to an array of ObjectNames containing the names of all MBeans being registered or unregistered.MBeans which emit these group registration/unregistration notifications will declare them in their MBeanNotificationInfo."},
{"description": "An object of this class implements the MBeanServer interface and wraps another object that also implements that interface.Typically, an implementation of this interface performs some action in some or all methods of the MBeanServer interface before and/or after forwarding the method to the wrapped object.Examples include security checking and logging."},
{"description": "Class MediaName is a subclass of Media, a printing attribute class (an enumeration) that specifies the media for a print job as a name.This attribute can be used instead of specifying MediaSize or MediaTray.Class MediaName currently declares a few standard media names.Implementation- or site-defined names for a media name attribute may also be created by defining a subclass of class MediaName.IPP Compatibility: MediaName is a representation class for values of the IPP \"media\" attribute which names media."},
{"description": "This class represents a builder that creates a default MBeanServer implementation.The JMX MBeanServerFactory allows applications to provide their custom MBeanServer implementation by providing a subclass of this class."},
{"description": "This interface represents a way to talk to an MBean server, whether local or remote.The MBeanServer interface, representing a local MBean server, extends this interface."},
{"description": "There are no instances of this class.Since JMX 1.2 this class makes it possible to replace the default MBeanServer implementation.This is done using the MBeanServerBuilder class.The class of the initial MBeanServerBuilder to be instantiated can be specified through the javax.management.builder.initial system property.The specified class must be a public subclass of MBeanServerBuilder, and must have a public empty constructor.By default, if no value for that property is specified, an instance of javax.management.MBeanServerBuilder is created.Otherwise, the MBeanServerFactory attempts to load the specified class using Thread.currentThread().getContextClassLoader(), or if that is null, Class.forName().Then it creates an initial instance of that Class using Class.newInstance().If any checked exception is raised during this process (e.g. ClassNotFoundException, InstantiationException) the MBeanServerFactory will propagate this exception from within a RuntimeException.The javax.management.builder.initial system property is consulted every time a new MBeanServer needs to be created, and the class pointed to by that property is loaded.If that class is different from that of the current MBeanServerBuilder, then a new MBeanServerBuilder is created.Otherwise, the MBeanServerFactory may create a new MBeanServerBuilder or reuse the current one.If the class pointed to by the property cannot be loaded, or does not correspond to a valid subclass of MBeanServerBuilder then an exception is propagated, and no MBeanServer can be created until the javax.management.builder.initial system property is reset to valid value.The MBeanServerBuilder makes it possible to wrap the MBeanServers returned by the default MBeanServerBuilder implementation, for the purpose of e.g. adding an additional security layer."},
{"description": "The MBeanServerDelegate MBean emits the MBeanServerNotifications when an MBean is registered/unregistered in the MBean server."},
{"description": "This is the interface for MBean manipulation on the agent side.It contains the methods necessary for the creation, registration, and deletion of MBeans as well as the access methods for registered MBeans.This is the core component of the JMX infrastructure.User code does not usually implement this interface.Instead, an object that implements this interface is obtained with one of the methods in the MBeanServerFactory class.Every MBean which is added to the MBean server becomes manageable: its attributes and operations become remotely accessible through the connectors/adaptors connected to that MBean server.A Java object cannot be registered in the MBean server unless it is a JMX compliant MBean.When an MBean is registered or unregistered in the MBean server a MBeanServerNotification Notification is emitted.To register an object as listener to MBeanServerNotifications you should call the MBean server method addNotificationListener with ObjectName the ObjectName of the MBeanServerDelegate.An object obtained from the createMBeanServer or newMBeanServer methods of the MBeanServerFactory class applies security checks to its methods, as follows.First, if there is no security manager (System.getSecurityManager() is null), then an implementation of this interface is free not to make any checks.Assuming that there is a security manager, or that the implementation chooses to make checks anyway, the checks are made as detailed below.In what follows, and unless otherwise specified, className is the string returned by MBeanInfo.getClassName() for the target MBean.If a security check fails, the method throws SecurityException.For methods that can throw InstanceNotFoundException, this exception is thrown for a non-existent MBean, regardless of permissions.This is because a non-existent MBean has no className.For the invoke method, the caller's permissions must imply MBeanPermission(className, operationName, name, \"invoke\").For the getAttribute method, the caller's permissions must imply MBeanPermission(className, attribute, name, \"getAttribute\").For the getAttributes method, the caller's permissions must imply MBeanPermission(className, null, name, \"getAttribute\").Additionally, for each attribute a in the AttributeList, if the caller's permissions do not imply MBeanPermission(className, a, name, \"getAttribute\"), the MBean server will behave as if that attribute had not been in the supplied list.For the setAttribute method, the caller's permissions must imply MBeanPermission(className, attrName, name, \"setAttribute\"), where attrName is attribute.getName().For the setAttributes method, the caller's permissions must imply MBeanPermission(className, null, name, \"setAttribute\").Additionally, for each attribute a in the AttributeList, if the caller's permissions do not imply MBeanPermission(className, a, name, \"setAttribute\"), the MBean server will behave as if that attribute had not been in the supplied list.For the addNotificationListener methods, the caller's permissions must imply MBeanPermission(className, null, name, \"addNotificationListener\").For the removeNotificationListener methods, the caller's permissions must imply MBeanPermission(className, null, name, \"removeNotificationListener\").For the getMBeanInfo method, the caller's permissions must imply MBeanPermission(className, null, name, \"getMBeanInfo\").For the getObjectInstance method, the caller's permissions must imply MBeanPermission(className, null, name, \"getObjectInstance\").For the isInstanceOf method, the caller's permissions must imply MBeanPermission(className, null, name, \"isInstanceOf\").For the queryMBeans method, the caller's permissions must imply MBeanPermission(null, null, null, \"queryMBeans\").Additionally, for each MBean n that matches name, if the caller's permissions do not imply MBeanPermission(className, null, n, \"queryMBeans\"), the MBean server will behave as if that MBean did not exist.Certain query elements perform operations on the MBean server.If the caller does not have the required permissions for a given MBean, that MBean will not be included in the result of the query.The standard query elements that are affected are Query.attr(String), Query.attr(String,String), and Query.classattr().For the queryNames method, the checks are the same as for queryMBeans except that \"queryNames\" is used instead of \"queryMBeans\" in the MBeanPermission objects.Note that a \"queryMBeans\" permission implies the corresponding \"queryNames\" permission.For the getDomains method, the caller's permissions must imply MBeanPermission(null, null, null, \"getDomains\").Additionally, for each domain d in the returned array, if the caller's permissions do not imply MBeanPermission(null, null, new ObjectName(\"d:x\"), \"getDomains\"), the domain is eliminated from the array.Here, x=x is any key=value pair, needed to satisfy ObjectName's constructor but not otherwise relevant.For the getClassLoader method, the caller's permissions must imply MBeanPermission(className, null, loaderName, \"getClassLoader\").For the getClassLoaderFor method, the caller's permissions must imply MBeanPermission(className, null, mbeanName, \"getClassLoaderFor\").For the getClassLoaderRepository method, the caller's permissions must imply MBeanPermission(null, null, null, \"getClassLoaderRepository\").For the deprecated deserialize methods, the required permissions are the same as for the methods that replace them.For the instantiate methods, the caller's permissions must imply MBeanPermission(className, null, null, \"instantiate\"), where className is the name of the class which is to be instantiated.For the registerMBean method, the caller's permissions must imply MBeanPermission(className, null, name, \"registerMBean\").If the MBeanPermission check succeeds, the MBean's class is validated by checking that its ProtectionDomain implies MBeanTrustPermission(\"register\").Finally, if the name argument is null, another MBeanPermission check is made using the ObjectName returned by MBeanRegistration.preRegister.For the createMBean methods, the caller's permissions must imply the permissions needed by the equivalent instantiate followed by registerMBean.For the unregisterMBean method, the caller's permissions must imply MBeanPermission(className, null, name, \"unregisterMBean\")."},
{"description": "Instances of this class are immutable."},
{"description": "Instances of this class are immutable."},
{"description": "Describes the management interface exposed by an MBean; that is, the set of attributes and operations which are available for management operations.Instances of this class are immutable.Usually the MBeanInfo for any given MBean does not change over the lifetime of that MBean.Dynamic MBeans can change their MBeanInfo and in that case it is recommended that they emit a Notification with a type of \"jmx.mbean.info.changed\" and a userData that is the new MBeanInfo.This is not required, but provides a conventional way for clients of the MBean to discover the change.The contents of the MBeanInfo for a Dynamic MBean are determined by its getMBeanInfo() method.This includes Open MBeans and Model MBeans, which are kinds of Dynamic MBeans.The contents of the MBeanInfo for a Standard MBean are determined by the MBean server as follows: getClassName() returns the Java class name of the MBean object; getConstructors() returns the list of all public constructors in that object; getAttributes() returns the list of all attributes whose existence is deduced from the presence in the MBean interface of a getName, isName, or setName method that conforms to the conventions for Standard MBeans; getOperations() returns the list of all methods in the MBean interface that do not represent attributes; getNotifications() returns an empty array if the MBean does not implement the NotificationBroadcaster interface, otherwise the result of calling NotificationBroadcaster.getNotificationInfo() on it; getDescriptor() returns a descriptor containing the contents of any descriptor annotations in the MBean interface (see @DescriptorKey).The description returned by getDescription() and the descriptions of the contained attributes and operations are not specified.The remaining details of the MBeanInfo for a Standard MBean are not specified.This includes the description of any contained constructors, and notifications; the names of parameters to constructors and operations; and the descriptions of constructor parameters."},
{"description": "The feature described can be an attribute, an operation, a parameter, or a notification.Instances of this class are immutable."},
{"description": "Permission controlling access to MBeanServer operations.If a security manager has been set using System.setSecurityManager(java.lang.SecurityManager), most operations on the MBean Server require that the caller's permissions imply an MBeanPermission appropriate for the operation.This is described in detail in the documentation for the MBeanServer interface.As with other Permission objects, an MBeanPermission can represent either a permission that you have or a permission that you need.When a sensitive operation is being checked for permission, an MBeanPermission is constructed representing the permission you need.The operation is only allowed if the permissions you have imply the permission you need.An MBeanPermission contains four items of information: The action.For a permission you need, this is one of the actions in the list below.For a permission you have, this is a comma-separated list of those actions, or *, representing all actions.The action is returned by getActions().For a permission you need, this is the class name of an MBean you are accessing, as returned by MBeanServer.getMBeanInfo(name).getClassName().Certain operations do not reference a class name, in which case the class name is null.For a permission you have, this is either empty or a class name pattern.A class name pattern is a string following the Java conventions for dot-separated class names.*\" meaning that the permission grants access to any class that begins with the string preceding \".A class name pattern can also be empty or the single character \"*\", both of which grant access to any class.For a permission you need, this is the name of the attribute or operation you are accessing.For operations that do not reference an attribute or operation, the member is null.For a permission you have, this is either the name of an attribute or operation you can access, or it is empty or the single character \"*\", both of which grant access to any member.For a permission you need, this is the ObjectName of the MBean you are accessing.For operations that do not reference a single MBean, it is null.It is never an object name pattern.For a permission you have, this is the ObjectName of the MBean or MBeans you can access.It may be an object name pattern to grant access to all MBeans whose names match the pattern.It may also be empty, which grants access to all MBeans whatever their name.If you have an MBeanPermission, it allows operations only if all four of the items match.The class name, member, and object name can be written together as a single string, which is the name of this permission.The name of the permission is the string returned by getName().The format of the string is: className#member[objectName]The object name is written using the usual syntax for ObjectName.It may contain any legal characters, including ].It is terminated by a ] character that is the last character in the string.One or more of the className, member, or objectName may be omitted.It is not legal to omit all three items, that is to have a name that is the empty string.One or more of the className, member, or objectName may be the character \"-\", which is equivalent to a null value.A null value is implied by any value (including another null value) but does not imply any other value.The possible actions are these: addNotificationListener getAttribute getClassLoaderisInstanceOf queryMBeans queryNames registerMBean removeNotificationListener setAttribute unregisterMBean In a comma-separated list of actions, spaces are allowed before and after each action."},
{"description": "An MBean can also implement this interface in order to get a reference to the MBean Server and/or its name within that MBean Server."},
{"description": "The MBeanNotificationInfo class is used to describe the characteristics of the different notification instances emitted by an MBean, for a given Java class of notification.If an MBean emits notifications that can be instances of different Java classes, then the metadata for that MBean should provide an MBeanNotificationInfo object for each of these notification Java classes.Instances of this class are immutable.This class extends javax.management.MBeanFeatureInfo and thus provides name and description fields.The name field should be the fully qualified Java class name of the notification objects described by this class.The getNotifTypes method returns an array of strings containing the notification types that the MBean may emit.The notification type is a dot-notation string which describes what the emitted notification is about, not the Java class of the notification.A single generic notification class can be used to send notifications of several types.All of these types are returned in the string array result of the getNotifTypes method."},
{"description": "Represents \"user defined\" exceptions thrown by MBean methods in the agent.It \"wraps\" the actual \"user defined\" exception thrown.This exception will be built by the MBeanServer when a call to an MBean method results in an unknown exception."},
{"description": "This interface contains query methods used to determine the results of a match against a regular expression.The match boundaries, groups and group boundaries can be seen but not modified through a MatchResult."},
{"description": "An engine that performs match operations on a character sequence by interpreting a Pattern.A matcher is created from a pattern by invoking the pattern's matcher method.Once created, a matcher can be used to perform three different kinds of match operations:The matches method attempts to match the entire input sequence against the pattern.The lookingAt method attempts to match the input sequence, starting at the beginning, against the pattern.The find method scans the input sequence looking for the next subsequence that matches the pattern.Each of these methods returns a boolean indicating success or failure.More information about a successful match can be obtained by querying the state of the matcher.A matcher finds matches in a subset of its input called the region.By default, the region contains all of the matcher's input.The region can be modified via theregion method and queried via the regionStart and regionEnd methods.The way that the region boundaries interact with some pattern constructs can be changed.This class also defines methods for replacing matched subsequences with new strings whose contents can, if desired, be computed from the match result.The appendReplacement and appendTail methods can be used in tandem in order to collect the result into an existing string buffer, or the more convenient replaceAll method can be used to create a string in which every matching subsequence in the input sequence is replaced.The explicit state of a matcher includes the start and end indices of the most recent successful match.It also includes the start and end indices of the input subsequence captured by each capturing group in the pattern as well as a total count of such subsequences.As a convenience, methods are also provided for returning these captured subsequences in string form.The explicit state of a matcher is initially undefined; attempting to query any part of it before a successful match will cause an IllegalStateException to be thrown.The explicit state of a matcher is recomputed by every match operation.The implicit state of a matcher includes the input character sequence as well as the append position, which is initially zero and is updated by the appendReplacement method.A matcher may be reset explicitly by invoking its reset() method or, if a new input sequence is desired, its reset(CharSequence) method.Resetting a matcher discards its explicit state information and sets the append position to zero.Instances of this class are not safe for use by multiple concurrent threads."},
{"description": "Instances of this class are immutable."},
{"description": "Instances of this class are immutable."},
{"description": "A class which provides a matte-like border of either a solid color or a tiled icon.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The class Math contains methods for performing basic numeric operations such as the elementary exponential, logarithm, square root, and trigonometric functions.Unlike some of the numeric methods of class StrictMath, all implementations of the equivalent functions of class Math are not defined to return the bit-for-bit same results.This relaxation permits better-performing implementations where strict reproducibility is not required.By default many of the Math methods simply call the equivalent method in StrictMath for their implementation.Code generators are encouraged to use platform-specific native libraries or microprocessor instructions, where available, to provide higher-performance implementations of Math methods.Such higher-performance implementations still must conform to the specification for Math.The quality of implementation specifications concern two properties, accuracy of the returned result and monotonicity of the method.Accuracy of the floating-point Math methods is measured in terms of ulps, units in the last place.When discussing the accuracy of a method as a whole rather than at a specific argument, the number of ulps cited is for the worst-case error at any argument.If a method always has an error less than 0.5 ulps, the method always returns the floating-point number nearest the exact result; such a method is correctly rounded.Instead, for the Math class, a larger error bound of 1 or 2 ulps is allowed for certain methods.Informally, with a 1 ulp error bound, when the exact result is a representable number, the exact result should be returned as the computed result; otherwise, either of the two floating-point values which bracket the exact result may be returned.For exact results large in magnitude, one of the endpoints of the bracket may be infinite.Besides accuracy at individual arguments, maintaining proper relations between the method at different arguments is also important.Therefore, most methods with more than 0.5 ulp errors are required to be semi-monotonic: whenever the mathematical function is non-decreasing, so is the floating-point approximation, likewise, whenever the mathematical function is non-increasing, so is the floating-point approximation.Not all approximations that have 1 ulp accuracy will automatically meet the monotonicity requirements.The platform uses signed two's complement integer arithmetic with int and long primitive types.The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation.The best practice is to choose the primitive type and algorithm to avoid overflow.In cases where the size is int or long and overflow errors need to be detected, the methods addExact, subtractExact, multiplyExact, and toIntExact throw an ArithmeticException when the results overflow.For other arithmetic operations such as divide, absolute value, increment, decrement, and negation overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate."},
{"description": "Immutable objects which encapsulate the context settings which describe certain rules for numerical operators, such as those implemented by the BigDecimal class.The base-independent settings are: precision: the number of digits to be used for an operation; results are rounded to this precisionroundingMode: a RoundingMode object which specifies the algorithm to be used for rounding."},
{"description": "MaskFormatter is used to format and edit strings.The behavior of a MaskFormatter is controlled by way of a String mask that specifies the valid characters that can be contained at a particular location in the Document model.All lowercase letters are mapped to upper case.All upper case letters are mapped to lower case.Typically characters correspond to one char, but in certain languages this is not the case.The mask is on a per character basis, and will thus adjust to fit as many chars as are needed.You can further restrict the characters that can be input by the setInvalidCharacters and setValidCharacters methods.For example, the following code block is equivalent to a mask of '0xHHH'***\"); formatter.setValidCharacters(\"0123456789abcdefABCDEF\"); When initially formatting a value if the length of the string is less than the length of the mask, two things can happen.Precedence is given to the placeholder string.For example: MaskFormatter formatter = new MaskFormatter(\"###-####\"); formatter.setPlaceholderCharacter('_'); formatter.getDisplayValue(tf, \"123\"); Would result in the string '123-____'.If setPlaceholder(\"555-1212\") was invoked '123-1212' would result.The placeholder String is only used on the initial format, on subsequent formats only the placeholder character will be used.If a MaskFormatter is configured to only allow valid characters (setAllowsInvalid(false))Using the right arrow key to navigate through the field will result in (| indicates the position of the caret): |555-1212 5|55-1212 55|5-1212 555-|1212 555-1|212Both inserts will result in the same String, '123-45__'.When MaskFormatter is processing the insert at character position 3 (the '-'), two things can happen: If the inserted character is '-', it is accepted.If the inserted character matches the mask for the next non-literal character, it is accepted at the new location.Anything else results in an invalid edit By default MaskFormatter will not allow invalid edits, you can change this with the setAllowsInvalid method, and will commit edits on valid edits (use the setCommitsOnValidEdit to change this).By default, MaskFormatter is in overwrite mode.That is as characters are typed a new character is not inserted, rather the character at the current location is replaced with the newly typed character.You can change this behavior by way of the method setOverwriteMode.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class enables pre and post processing of each marshalled object.The event callbacks are called when marshalling from an instance that maps to an xml element or complex type definition.The event callbacks are not called when marshalling from an instance of a Java datatype that represents a simple type definition.External listener is one of two different mechanisms for defining marshal event callbacks."},
{"description": "The Marshaller class is responsible for governing the process of serializing Java content trees back into XML data.It provides the basic marshalling methods: Assume the following setup code for all following code fragments: JAXBContext jc = JAXBContext.newInstancejc.createMarshaller(); Marshalling to a File: OutputStream os = new FileOutputStream( \"nosferatu.xml\" ); m.marshal( element, os ); Marshalling to a SAX ContentHandler: // assume MyContentHandler instanceof ContentHandler m.marshal( element, new MyContentHandler() ); Marshalling to a DOM Node: DocumentBuilderFactory dbf(); m.marshal( element, doc ); Marshalling to a java.io.OutputStream: m.marshal( element, System.out ); Marshalling to a java.io.Writer: m.marshal( element, new PrintWriter( System.out ) ); Marshalling to a javax.xml.transform.SAXResult: // assume MyContentHandler instanceof ContentHandler SAXResult result = new SAXResult( new MyContentHandler() ); m.marshal( element, result ); Marshalling to a javax.xml.transform.DOMResult: DOMResult result = new DOMResult(); m.marshal( element, result ); Marshalling to a javax.xml.transform.StreamResult:Object, ...) methods must be a JAXB element as computed by JAXBIntrospector.isElement(java.lang.Object); otherwise, a Marshaller.marshal method must throw a MarshalException.There exist two mechanisms to enable marshalling an instance that is not a JAXB element.One method is to wrap the instance as a value of a JAXBElement, and pass the wrapper element as the first parameter to a Marshaller.marshal method.For java to schema binding, it is also possible to simply annotate the instance's class with @XmlRootElement.Encoding By default, the Marshaller will use UTF-8 encoding when generating XML data to a java.io.OutputStream, or a java.io.Writer.Client applications are expected to supply a valid character encoding name as defined in the W3C XML 1.0 Recommendation and supported by your Java Platform.Validation and Well-Formedness Client applications are not required to validate the Java content tree prior to calling any of the marshal API's.Furthermore, there is no requirement that the Java content tree be valid with respect to its original schema in order to marshal it back into XML data.Different JAXB Providers will support marshalling invalid Java content trees at varying levels, however all JAXB Providers must be able to marshal a valid content tree back to XML data.A JAXB Provider must throw a MarshalException when it is unable to complete the marshal operation due to invalid content.Some JAXB Providers will fully allow marshalling invalid content, others will fail on the first validation error.Even when schema validation is not explictly enabled for the marshal operation, it is possible that certain types of validation events will be detected during the operation.Validation events will be reported to the registered event handler.If the client application has not registered an event handler prior to invoking one of the marshal API's, then events will be delivered to a default event handler which will terminate the marshal operation after encountering the first error or fatal error.Note that for JAXB 2.0 and later versions, DefaultValidationEventHandler is no longer used.All JAXB Providers are required to support the following set of properties.Some providers may support additional properties.jaxb.encoding - value must be a java.lang.StringThe output encoding to use when marshalling the XML data.The Marshaller will use \"UTF-8\" by default if this property is not specified.jaxb.formatted.output - value must be a java.lang.Boolean This property controls whether or not the Marshaller will format the resulting XML data with line breaks and indentation.A true value for this property indicates human readable indented xml data, while a false value indicates unformatted xml data.The Marshaller will default to false (unformatted) if this property is not specified.jaxb.schemaLocation - value must be a java.lang.StringThis property allows the client application to specify an xsi:The format of the schemaLocation attribute value is discussed in an easy to understand, non-normative form in Section 5.6 of the W3C XML Schema Part 0:jaxb.noNamespaceSchemaLocation - value must be a java.lang.StringThis property allows the client application to specify an xsi:The format of the schemaLocation attribute value is discussed in an easy to understand, non-normative form in Section 5.6 of the W3C XML Schema Part 0:jaxb.fragment - value must be a java.lang.Boolean This property determines whether or not document level events will be generated by the Marshaller.This property has different implications depending on which marshal api you are using - when this property is set to true: marshal(Object,ContentHandler) - the Marshaller won't invoke ContentHandler.startDocument() andthe property has no effect on this API.the Marshaller won't generate an xml declaration.the Marshaller won't generate an xml declaration.marshal(Object,Result) - depends on the kind of Result object, see semantics for Node, ContentHandler, and Stream APIs marshal(Object,XMLEventWriter) - the Marshaller will not generate XMLStreamConstants.marshal(Object,XMLStreamWriter) - the Marshaller will not generate XMLStreamConstants.The Marshaller provides two styles of callback mechanisms that allow application specific processing during key points in the unmarshalling process.In 'class defined' event callbacks, application specific code placed in JAXB mapped classes is triggered during marshalling. 'Class defined event callback methods allow any JAXB mapped class to specify its own specific callback methods by defining methods with the following method signatures: //Invoked by Marshaller after it has created an instance of this object.boolean beforeMarshal(Marshaller); // Invoked by Marshaller after it has marshalled all properties of this object.void afterMarshal(Marshaller); The class defined event callback methods should be used when the callback method requires access to non-public methods and/or fields of the class.The external listener callback mechanism enables the registration of a Marshaller.The external listener receives all callback events, allowing for more centralized processing than per class defined callback methods.The 'class defined' and external listener event callback methods are independent of each other, both can be called for one event.The invocation ordering when both listener callback methods exist is defined in Marshaller.An event callback method throwing an exception terminates the current marshal process."},
{"description": "A MarshalledObject contains a byte stream with the serialized representation of an object given to its constructor.The get method returns a new copy of the original object, as deserialized from the contained byte stream.The contained object is serialized and deserialized with the same serialization semantics used for marshaling and unmarshaling parameters and return values of RMI calls: When the serialized form is created: classes are annotated with a codebase URL from where the class can be loaded (if available), and any remote object in the MarshalledObject is represented by a serialized instance of its stub.When copy of the object is retrieved (via the get method), if the class is not available locally, it will be loaded from the appropriate location (specified the URL annotated with the class descriptor when the class was serialized.MarshalledObject facilitates passing objects in RMI calls that are not automatically deserialized immediately by the remote peer."},
{"description": "This exception indicates that an error has occurred while performing a marshal operation that the provider is unable to recover from.The ValidationEventHandler can cause this exception to be thrown during the marshal operations."},
{"description": "Indicates an exceptional condition that occurred during the XML marshalling or unmarshalling process.A MarshalException can contain a cause: another throwable that caused this MarshalException to get thrown."},
{"description": "A MarshalException is thrown if a java.io.IOException occurs while marshalling the remote call header, arguments or return value for a remote method call.A MarshalException is also thrown if the receiver does not support the protocol version of the sender.If a MarshalException occurs during a remote method call, the call may or may not have reached the server.If the call did reach the server, parameters may have been deserialized.A call may not be retransmitted after a MarshalException and reliably preserve \"at most once\" call semantics."},
{"description": "A request or reply from the network is structurally invalid.This error typically indicates a bug in either the client-side or server-side run time.For example, if a reply from the server indicates that the message contains 1000 bytes, but the actual message is shorter or longer than 1000 bytes, the ORB raises this exception.MARSHAL can also be caused by using the DII or DSI incorrectly, for example, if the type of the actual parameters sent does not agree with IDL signature of an operation.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "A direct byte buffer whose content is a memory-mapped region of a file.Mapped byte buffers are created via the FileChannel.map method.This class extends the ByteBuffer class with operations that are specific to memory-mapped file regions.The content of a mapped byte buffer can change at any time, for example if the content of the corresponding region of the mapped file is changed by this program or another.All or part of a mapped byte buffer may become inaccessible at any time, for example if the mapped file is truncated.An attempt to access an inaccessible region of a mapped byte buffer will not change the buffer's content and will cause an unspecified exception to be thrown either at the time of the access or at some later time.It is therefore strongly recommended that appropriate precautions be taken to avoid the manipulation of a mapped file by this program, or by a concurrently running program, except to read or write the file's content.Mapped byte buffers otherwise behave no differently than ordinary direct byte buffers."},
{"description": "The Map.entrySet method returns a collection-view of the map, whose elements are of this class.The only way to obtain a reference to a map entry is from the iterator of this collection-view.Entry objects are valid only for the duration of the iteration; more formally, the behavior of a map entry is undefined if the backing map has been modified after the entry was returned by the iterator, except through the setValue operation on the map entry."},
{"description": "Requests that referral and other special LDAP objects be manipulated as normal LDAP objects.It enables the requestor to interrogate or update such objects.This class implements the LDAPv3 Request Control for ManageDsaIT as defined in RFC 3296.The control has no control value."},
{"description": "The XML Schema Definition is defined as: <element name=\"Manifest\" type=\"ds:ManifestType\"/> <complexType name=\"ManifestType\"> <sequence> <element ref=\"ds:A Manifest instance may be created by invoking one of the newManifest methods of the XMLSignatureFactory class; for example: XMLSignatureFactory factory ="},
{"description": "The Manifest class is used to maintain Manifest entry names and their associated Attributes.There are main Manifest Attributes as well as per-entry Attributes."},
{"description": "An object that maps keys to values.A map cannot contain duplicate keys; each key can map to at most one value.This interface takes the place of the Dictionary class, which was a totally abstract class rather than an interface.The Map interface provides three collection views, which allow a map's contents to be viewed as a set of keys, collection of values, or set of key-value mappings.The order of a map is defined as the order in which the iterators on the map's collection views return their elements.Some map implementations, like the TreeMap class, make specific guarantees as to their order; others, like the HashMap class, do not.Note: great care must be exercised if mutable objects are used as map keys.The behavior of a map is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is a key in the map.A special case of this prohibition is that it is not permissible for a map to contain itself as a key.While it is permissible for a map to contain itself as a value, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a map.All general-purpose map implementation classes should provide two \"standard\" constructors: a void (no arguments) constructor which creates an empty map, and a constructor with a single argument of type Map, which creates a new map with the same key-value mappings as its argument.In effect, the latter constructor allows the user to copy any map, producing an equivalent map of the desired class.There is no way to enforce this recommendation (as interfaces cannot contain constructors) but all of the general-purpose map implementations in the JDK comply.The \"destructive\" methods contained in this interface, that is, the methods that modify the map on which they operate, are specified to throw UnsupportedOperationException if this map does not support the operation.If this is the case, these methods may, but are not required to, throw an UnsupportedOperationException if the invocation would have no effect on the map.For example, invoking the putAll(Map) method on an unmodifiable map may, but is not required to, throw the exception if the map whose mappings are to be \"superimposed\" is empty.Some map implementations have restrictions on the keys and values they may contain.For example, some implementations prohibit null keys and values, and some have restrictions on the types of their keys.Attempting to insert an ineligible key or value throws an unchecked exception, typically NullPointerException or ClassCastException.Attempting to query the presence of an ineligible key or value may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter.More generally, attempting an operation on an ineligible key or value whose completion would not result in the insertion of an ineligible element into the map may throw an exception or it may succeed, at the option of the implementation.Such exceptions are marked as \"optional\" in the specification for this interface.Many methods in Collections Framework interfaces are defined in terms of the equals method.For example, the specification for the containsKey(Object key) method says: \"returns true if and only if this map contains a mapping for a key k such that (key==null ?\" This specification should not be construed to imply that invoking Map.containsKey with a non-null argument key will cause key.equals(k) to be invoked for any key k. Implementations are free to implement optimizations whereby the equals invocation is avoided, for example, by first comparing the hash codes of the two keys.(The Object.hashCode() specification guarantees that two objects with unequal hash codes cannot be equal.)More generally, implementations of the various Collections Framework interfaces are free to take advantage of the specified behavior of underlying Object methods wherever the implementor deems it appropriate.Some map operations which perform recursive traversal of the map may fail with an exception for self-referential instances where the map directly or indirectly contains itself.This includes the clone(), equals(), hashCode() and toString() methods.Implementations may optionally handle the self-referential scenario, however most current implementations do not do so.This interface is a member of the Java Collections Framework."},
{"description": "This class is the base interface for providing algorithm-specific information to a KeyManagerFactory or TrustManagerFactory.In some cases, initialization parameters other than keystores may be needed by a provider.Users of that particular provider are expected to pass an implementation of the appropriate sub-interface of this class as defined by the provider.The provider can then call the specified methods in the ManagerFactoryParameters implementation to obtain the needed information."},
{"description": "The permission which the SecurityManager will check when code that is running with a SecurityManager calls methods defined in the management interface for the Java platform.The following table provides a summary description of what the permission allows, and discusses the risks of granting code the permission.What the Permission Allows Risks of Allowing this Permission control Ability to control the runtime characteristics of the Java virtual machine, for example, enabling and disabling the verbose output for the class loading or memory system, setting the threshold of a memory pool, and enabling and disabling the thread contention monitoring support.Some actions controlled by this permission can disclose information about the running application, like the -verbose:class flag.This allows an attacker to control the runtime characteristics of the Java virtual machine and cause the system to misbehave.An attacker can also access some information related to the running application.This allows malicious code to monitor runtime information and uncover vulnerabilities.Programmers do not normally create ManagementPermission objects directly.Instead they are created by the security policy code based on reading the security policy file."},
{"description": "Either no legal protocol could be found in a specification string or the string could not be parsed."},
{"description": "Thrown when a semantically malformed parameterized type is encountered by a reflective method that needs to instantiate it.For example, if the number of type arguments to a parameterized type is wrong."},
{"description": "This exception is thrown when a malformed link was encountered while resolving or constructing a link.Synchronization and serialization issues that apply to LinkException apply directly here."},
{"description": "Checked exception thrown when an input byte sequence is not legal for given charset, or an input character sequence is not a legal sixteen-bit Unicode sequence."},
{"description": "Thrown when the java.lang.reflect package attempts to read method parameters from a class file and determines that one or more parameters are malformed.The following is a list of conditions under which this exception can be thrown: The number of parameters (parameter_count) is wrong for the method A constant pool index is out of bounds.A constant pool index does not refer to a UTF-8 entry A parameter's name is \"\", or contains an illegal character The flags field contains an illegal flag (something other than FINAL, SYNTHETIC, or MANDATED)"},
{"description": "The ManagementFactory class is a factory class for getting managed beans for the Java platform.This class consists of static methods each of which returns one or more platform MXBeans representing the management interface of a component of the Java virtual machine.A platform MXBean is a managed bean that conforms to the JMX Instrumentation Specification and only uses a set of basic data types.A JMX management application and the platform MBeanServer can interoperate without requiring classes for MXBean specific data types.The data types being transmitted between the JMX connector server and the connector client are open types and this allows interoperation across versions.Each platform MXBean is a PlatformManagedObject and it has a unique ObjectName for registration in the platformAn application can access a platform MXBean in the following ways: 1.Direct access to an MXBean interface Get an MXBean instance by calling the getPlatformMXBean or getPlatformMXBeans method and access the MXBean locally in the running virtual machine.Construct an MXBean proxy instance that forwards the method calls to a given MBeanServer by calling the getPlatformMXBean(MBeanServerConnection, Class) or getPlatformMXBeans(MBeanServerConnection, Class) method.The newPlatformMXBeanProxy method can also be used to construct an MXBean proxy instance of a given ObjectName.A proxy is typically constructed to remotely access an MXBean of another running virtual machine.Indirect access to an MXBean interface via MBeanServer Go through the platform MBeanServer to access MXBeans locally or a specific MBeanServerConnection to access MXBeans remotely.The attributes and operations of an MXBean use only JMX open types which include basic data types, CompositeData, and TabularData defined in OpenType.The mapping is specified in the MXBean specification for details.The getPlatformManagementInterfaces method returns all management interfaces supported in the Java virtual machine including the standard management interfaces listed in the tables below as well as the management interfaces extended by the JDK implementation.A Java virtual machine has a single instance of the following management interfaces: Management Interface ObjectName ClassLoadingMXBean java.lang:type=ClassLoading MemoryMXBeanjava.util.logging:type=Logging A Java virtual machine has zero or a single instance of the following management interfaces.A Java virtual machine may have one or more instances of the following management interfaces."},
{"description": "The format of the string does not correspond to a valid ObjectName."},
{"description": "MailcapCommandMap extends the CommandMap abstract class.It implements a CommandMap whose configuration is based on mailcap files (RFC 1524).The MailcapCommandMap can be configured both programmatically and via configuration files.Mailcap file search order: The MailcapCommandMap looks in various places in the user's system for mailcap file entries.When requests are made to search for commands in the MailcapCommandMap, it searches mailcap files in the following order: Programatically added entries to the MailcapCommandMap instance.The file or resource named META-INF/mailcap.default (usually found only in the activation.jar file).Mailcap files must conform to the mailcap file specification (RFC 1524, A User Agent Configuration Mechanism For Multimedia Mail Format Information).The file format consists of entries corresponding to particular MIME types.In general, the specification specifies applications for clients to use when they themselves cannot operate on the specified MIME type.The MailcapCommandMap extends this specification by using a parameter mechanism in mailcap files that allows JavaBeans(tm) components to be specified as corresponding to particular commands for a MIME type.When a mailcap file is parsed, the MailcapCommandMap recognizes certain parameter signatures, specifically those parameter names that begin with x-java-.The MailcapCommandMap uses this signature to find command entries for inclusion into its registries.Parameter names with the form x-java-<name> are read by the MailcapCommandMap as identifying a command with the name name.When the name is content-handlerthe MailcapCommandMap recognizes the class signified by this parameter as a DataContentHandler.All other commands are handled generically regardless of command name.The command implementation is specified by a fully qualified class name of a JavaBean(tm) component.For example; a command for viewing some data can be specified as: x-java-view=com.foo.When the command name is fallback-entry, the value of the command may be true or false.An entry for a MIME type that includes a parameter of x-java-fallback-entry=true defines fallback commands for that MIME type that will only be used if no non-fallback entry can be found.TextViewer specifies a view command to be used for any text MIME type.This view command would only be used if a non-fallback view command for the MIME type could not be found.MailcapCommandMap aware mailcap files have the following general form:# Comments begin with a '#' and continue to the end of the line.Where a parameter list consists of one or more parameters, # where parameters look like: x-java-view=com.sun.TextEdit # Note that mailcap entries that do not contain 'x-java' parameters # and comply to RFC 1524 are simply ignored:"},
{"description": "This class defines the Service Provider Interface (SPI) for the Mac class.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular MAC algorithm.Implementations are free to implement the Cloneable interface."},
{"description": "A LSSerializer provides an API for serializing (writing) a DOM document out into XML.The XML data is written to a string or an output stream.Any changes or fixups made during the serialization affect only the serialized data.The Document object and its children are never altered by the serialization operation.During serialization of XML data, namespace fixup is done as defined in [DOM Level 3 Core] ,Appendix B. [DOM Level 2 Core] allows empty strings as a real namespace URI.If the namespaceURI of a Node is empty string, the serialization will treat them as null, ignoring the prefix if any.LSSerializer accepts any node type for serialization.For nodes of type Document or Entity, well-formed XML will be created when possible (well-formedness is guaranteed if the document or entity comes from a parse operation and is unchanged since it was created).The serialized output for these node types is either as a XML document or an External XML Entity, respectively, and is acceptable input for an XML parser.For all other types of nodes the serialized form is implementation dependent.Within a Document, DocumentFragment, or Entity being serialized, Nodes are processed as follows Document nodes are written, including the XML declaration (unless the parameter \"xml-declaration\" is set to false) and a DTD subset, if one exists in the DOM.Writing a Document node serializes the entire document.Entity nodes, when written directly by LSSerializer.write, outputs the entity expansion but no namespace fixup is done.The resulting output will be valid as an external entity.If the parameter \" entities\" is set to true, EntityReference nodes are serialized as an entity reference of the form \" &entityName;\" in the output.Child nodes (the expansion) of the entity reference are ignored.If the parameter \" entities\" is set to false, only the children of the entity reference are serialized.EntityReference nodes with no children (no corresponding Entity node or the corresponding Entity nodes have no children) are always serialized.CDATAsections containing content characters that cannot be represented in the specified output encoding are handled according to the \" split-cdata-sections\" parameter.If the parameter is set to true, CDATAsections are split, and the unrepresentable characters are serialized as numeric character references in ordinary content.The exact position and number of splits is not specified.If the parameter is set to false, unrepresentable characters in a CDATAsection are reported as \"wf-invalid-character\" errors if the parameter \" well-formed\" is set to true.The error is not recoverable - there is no mechanism for supplying alternative characters and continuing with the serialization.DocumentFragment nodes are serialized by serializing the children of the document fragment in the order they appear in the document fragment.All other node types (Element, Text, etc.) are serialized to their corresponding XML source form.Note: The serialization of a Node does not always generate a well-formed XML document, i.e. a LSParser might throw fatal errors when parsing the resulting serialization.Within the character data of a document (outside of markup), any characters that cannot be represented directly are replaced with character references.The other predefined entities (&gt;, &apos;, and &quot;) might not be used, except where needed (e.g. using &gt; in cases such as ']]>').Any characters that cannot be represented directly in the output character encoding are serialized as numeric character references (and since character encoding standards commonly use hexadecimal representations of characters, using the hexadecimal representation when serializing character references is encouraged).To allow attribute values to contain both single and double quotes, the apostrophe or single-quote character (') may be represented as \"&apos;\", and the double-quote character (\") as \"&quot;\".New line characters and other characters that cannot be represented directly in attribute values in the output character encoding are serialized as a numeric character reference.Within markup, but outside of attributes, any occurrence of a character that cannot be represented in the output character encoding is reported as a DOMError fatal error.An example would be serializing the element <LaCa\u00f1ada/> with encoding=\"us-ascii\".This will result with a generation of a DOMError \"wf-invalid-character-in-node-name\" (as proposed in \" well-formed\").When requested by setting the parameter \" normalize-characters\" on LSSerializer to true, character normalization is performed according to the definition of fully normalized characters included in appendix E of [XML 1.1] on all data to be serialized, both markup and character data.The character normalization process affects only the data as it is being written; it does not alter the DOM's view of the document after serialization has completed.Implementations are required to support the encodings \"UTF-8\", \"UTF-16\", \"UTF-16BE\", and \"UTF-16LE\" to guarantee that data is serializable in all encodings that are required to be supported by all XML parsers.When the encoding is UTF-8, whether or not a byte order mark is serialized, or if the output is big-endian or little-endian, is implementation dependent.When the encoding is UTF-16, whether or not the output is big-endian or little-endian is implementation dependent, but a Byte Order Mark must be generated for non-character outputs, such as LSOutput.byteStream or LSOutput.systemId.When the encoding is UTF-16LE or UTF-16BE, the output is big-endian (UTF-16BE) or little-endian (UTF-16LE) and the Byte Order Mark is not be generated.In all cases, the encoding declaration, if generated, will correspond to the encoding used during the serialization (e.g. encoding=\"UTF-16\" will appear if UTF-16 was requested).Namespaces are fixed up during serialization, the serialization process will verify that namespace declarations, namespace prefixes and the namespace URI associated with elements and attributes are consistent.If inconsistencies are found, the serialized form of the document will be altered to remove them.The method used for doing the namespace fixup while serializing a document is the algorithm defined in Appendix B.1, \"Namespace normalization\", of [DOM Level 3 Core] .While serializing a document, the parameter \"discard-default-content\" controls whether or not non-specified data is serialized.While serializing, errors and warnings are reported to the application through the error handler (LSSerializer.domConfig's \" error-handler\" parameter).This specification does in no way try to define all possible errors and warnings that can occur while serializing a DOM node, but some common error and warning cases are defined.The types ( DOMError.type) of errors and warnings defined by this specification are: \"no-output-specified\" [fatal] Raised when writing to a LSOutput if no output is specified in the LSOutput. \"unbound-prefix-in-entity-reference\" [fatal] Raised if the configuration parameter \" namespaces\" is set to true and an entity whose replacement text contains unbound namespace prefixes is referenced in a location where there are no bindings for the namespace prefixes. \"In addition to raising the defined errors and warnings, implementations are expected to raise implementation specific errors and warnings for any other error and warning cases such as IO errors (file not found, permission denied,...) and so on."},
{"description": "LSSerializerFilters provide applications the ability to examine nodes as they are being serialized and decide what nodes should be serialized or not.The LSSerializerFilter interface is based on the NodeFilter interface defined in [DOM Level 2 Traversal and Range] .Document, DocumentType, DocumentFragment, Notation, Entity , and children of Attr nodes are not passed to the filter.The child nodes of an EntityReference node are only passed to the filter if the EntityReference node is skipped by the method LSParserFilter.acceptNode().When serializing an Element, the element is passed to the filter before any of its attributes are passed to the filter.Namespace declaration attributes, and default attributes (except in the case when \" discard-default-content\" is set to false), are never passed to the filter.The result of any attempt to modify a node passed to a LSSerializerFilter is implementation dependent.DOM applications must not raise exceptions in a filter.The effect of throwing exceptions from a filter is DOM implementation dependent.For efficiency, a node passed to the filter may not be the same as the one that is actually in the tree.And the actual node (node object identity) may be reused during the process of filtering and serializing a document."},
{"description": "This class provides the functionality of a \"Message Authentication Code\" (MAC) algorithm.A MAC provides a way to check the integrity of information transmitted over or stored in an unreliable medium, based on a secret key.Typically, message authentication codes are used between two parties that share a secret key in order to validate information transmitted between these parties.A MAC mechanism that is based on cryptographic hash functions is referred to as HMAC.HMAC can be used with any cryptographic hash function, e.g., SHA256 or SHA384, in combination with a secret shared key.HMAC is specified in RFC 2104.Every implementation of the Java platform is required to support the following standard Mac algorithms:These algorithms are described in the Mac section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other algorithms are supported."},
{"description": "LSResourceResolver provides a way for applications to redirect references to external resources.Applications needing to implement custom handling for external resources can implement this interface and register their implementation by setting the \"resource-resolver\" parameter of DOMConfiguration objects attached to LSParser and LSSerializer.It can also be register on DOMConfiguration objects attached to Document if the \"LS\" feature is supported.The LSParser will then allow the application to intercept any external entities, including the external DTD subset and external parameter entities, before including them.The top-level document entity is never passed to the resolveResource method.Many DOM applications will not need to implement this interface, but it will be especially useful for applications that build XML documents from databases or other specialized input sources, or for applications that use URNs.Note: LSResourceResolver is based on the SAX2 [SAX] EntityResolver interface."},
{"description": "This interface represents a progress event object that notifies the application about progress as a document is parsed.It extends the Event interface defined in [DOM Level 3 Events] .The units used for the attributes position and totalSize are not specified and can be implementation and input dependent."},
{"description": "LSParserFilters provide applications the ability to examine nodes as they are being constructed while parsing.At the time any of the filter methods are called by the parser, the owner Document and DOMImplementation objects exist and are accessible.The document element is never passed to the LSParserFilter methods, i.e. it is not possible to filter out the document element.Document, DocumentType, Notation, Entity, and Attr nodes are never passed to the acceptNode method on the filter.The child nodes of an EntityReference node are passed to the filter if the parameter \" entities\" is set to false.Note that, as described by the parameter \" entities\", unexpanded entity reference nodes are never discarded and are always passed to the filter.All validity checking while parsing a document occurs on the source document as it appears on the input stream, not on the DOM document as it is built in memory.With filters, the document in memory may be a subset of the document on the stream, and its validity may have been affected by the filtering.All default attributes must be present on elements when the elements are passed to the filter methods.All other default content must be passed to the filter methods.DOM applications must not raise exceptions in a filter.The effect of throwing exceptions from a filter is DOM implementation dependent."},
{"description": "An interface to an object that is able to build, or augment, a DOM tree from various input sources.LSParser provides an API for parsing XML and building the corresponding DOM document structure.A LSParser instance can be obtained by invoking the DOMImplementationLS.createLSParser() method.As specified in [DOM Level 3 Core] , when a document is first made available via the LSParser: there will never be two adjacent nodes of type NODE_TEXT, and there will never be empty text nodes.it is expected that the value and nodeValue attributes of an Attr node initially return the XML 1.0 normalized value.However, if the parameters \" validate-if-schema\" and \" datatype-normalization\" are set to true, depending on the attribute normalization used, the attribute values may differ from the ones obtained by the XML 1.0 attribute normalization.If the parameters \" datatype-normalization\" is set to false, the XML 1.0 attribute normalization is guaranteed to occur, and if the attributes list does not contain namespace declarations, the attributes attribute on Element node represents the property [attributes] defined in [XML Information Set] .Asynchronous LSParser objects are expected to also implement the events::EventTarget interface so that event listeners can be registered on asynchronous LSParser objects.Events supported by asynchronous LSParser objects are: load The LSParser finishes to load the document.Here is one example of how an application might dispatch progress events: Once the parser starts receiving data, a progress event is dispatched to indicate that the parsing starts.From there on, a progress event is dispatched for every 4096 bytes of data that is received and processed.This is only one example, though, and implementations can choose to dispatch progress events at any time while parsing, or not dispatch them at all.Note: All events defined in this specification use the namespace URI \"http://www.w3.org/2002/DOMLS\".While parsing an input source, errors are reported to the application through the error handler (LSParser.domConfig's \" error-handler\" parameter).This specification does in no way try to define all possible errors that can occur while parsing XML, or any other markup, but some common error cases are defined.The types (DOMError.type) of errors and warnings defined by this specification are: \"check-character-normalization-failure\" [error] Raised if the parameter \" check-character-normalization\" is set to true and a string is encountered that fails normalization checking. \"no input is specified in the LSInput object.\"pi-base-uri-not-preserved\" [warning] Raised if a processing instruction is encountered in a location where the base URI of the processing instruction can not be preserved.One example of a case where this warning will be raised is if the configuration parameter \" entities\" is set to false and the following XML file is parsed: <!And subdir/myentity.ent contains: <one> <two/> </one> <?An implementation dependent warning that may be raised if the configuration parameter \" namespaces\" is set to true and an unbound namespace prefix is encountered in an entity's replacement text.Raising this warning is not enforced since some existing parsers may not recognize unbound namespace prefixes in the replacement text of entities.\"unknown-character-denormalization\" [fatal] Raised if the configuration parameter \"ignore-unknown-character-denormalizations\" is set to false and a character is encountered for which the processor cannot determine the normalization properties. \"Raised if an unsupported encoding is encountered. \"unsupported-media-type\" [fatal] Raised if the configuration parameter \"supported-media-types-only\" is set to true and an unsupported media type is encountered.In addition to raising the defined errors and warnings, implementations are expected to raise implementation specific errors and warnings for any other error and warning cases such as IO errors (file not found, permission denied,...), XML well-formedness errors, and so on."},
{"description": "This interface represents an output destination for data.This interface allows an application to encapsulate information about an output destination in a single object, which may include a URI, a byte stream (possibly with a specified encoding), a base URI, and/or a character stream.The exact definitions of a byte stream and a character stream are binding dependent.The application is expected to provide objects that implement this interface whenever such objects are needed.The application can either provide its own objects that implement this interface, or it can use the generic factory method DOMImplementationLS.createLSOutput() to create objects that implement this interface.The LSSerializer will use the LSOutput object to determine where to serialize the output to.The LSSerializer will look at the different outputs specified in the LSOutput in the following order to know which one to output to, the first one that is not null and not an empty string will be used:LSOutput.characterStream LSOutput.byteStream LSOutput.systemId LSOutput objects belong to the application.The DOM implementation will never modify them (though it may make copies and modify the copies, if necessary)."},
{"description": "Parser or write operations may throw an LSException if the processing is stopped.The processing can be stopped due to a DOMError with a severity of DOMError.Note: As suggested in the definition of the constants in the DOMError interface, a DOM implementation may choose to continue after a fatal error, but the resulting DOM tree is then implementation dependent."},
{"description": "This interface represents an input source for data.This interface allows an application to encapsulate information about an input source in a single object, which may include a public identifier, a system identifier, a byte stream (possibly with a specified encoding), a base URI, and/or a character stream.The exact definitions of a byte stream and a character stream are binding dependent.The application is expected to provide objects that implement this interface whenever such objects are needed.The application can either provide its own objects that implement this interface, or it can use the generic factory method DOMImplementationLS.createLSInput() to create objects that implement this interface.The LSParser will use the LSInput object to determine how to read data.The LSParser will look at the different inputs specified in the LSInput in the following order to know which one to read from, the first one that is not null and not an empty string will be used: LSInput.characterStream LSInput.byteStreamIf all inputs are null, the LSParser will report a DOMError with its DOMError.type set to \"no-input-specified\" and its DOMError.severity set to DOMError.LSInput objects belong to the application.The DOM implementation will never modify them (though it may make copies and modify the copies, if necessary)."},
{"description": "This interface represents a load event object that signals the completion of a document load."},
{"description": "This abstract class defines a lookup table object.ByteLookupTable and ShortLookupTable are subclasses, which contain byte and short data, respectively.A lookup table contains data arrays for one or more bands (or components) of an image (for example, separate arrays for R, G, and B), and it contains an offset which will be subtracted from the input values before indexing into the arrays.This allows an array smaller than the native data size to be provided for a constrained input.If there is only one array in the lookup table, it will be applied to all bands.All arrays must be the same size."},
{"description": "This class implements a lookup operation from the source to the destination.The LookupTable object may contain a single array or multiple arrays, subject to the restrictions below.For Rasters, the lookup operates on bands.The number of lookup arrays may be one, in which case the same array is applied to all bands, or it must equal the number of Source Raster bands.For BufferedImages, the lookup operates on color and alpha components.The number of lookup arrays may be one, in which case the same array is applied to all color (but not alpha) components.Otherwise, the number of lookup arrays may equal the number of Source color components, in which case no lookup of the alpha component (if present) is performed.If neither of these cases apply, the number of lookup arrays must equal the number of Source color components plus alpha components, in which case lookup is performed for all color and alpha components.This allows non-uniform rescaling of multi-band BufferedImages.BufferedImage sources with premultiplied alpha data are treated in the same manner as non-premultiplied images for purposes of the lookup.That is, the lookup is done per band on the raw data of the BufferedImage source without regard to whether the data is premultiplied.If a color conversion is required to the destination ColorModel, the premultiplied state of both source and destination will be taken into account for this step.Images with an IndexColorModel cannot be used.If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used when color conversion is required.This class allows the Source to be the same as the Destination."},
{"description": "LookAndFeel, as the name implies, encapsulates a look and feel.Beyond installing a look and feel most developers never need to interact directly with LookAndFeel.Swing is built upon the foundation that each JComponent subclass has an implementation of a specific ComponentUI subclass.The ComponentUI is often referred to as \"the ui\", \"component ui\", or \"look and feel delegate\".The ComponentUI subclass is responsible for providing the look and feel specific functionality of the component.For example, JTree requires an implementation of the ComponentUI subclass TreeUI.The implementation of the specific ComponentUI subclass is provided by the LookAndFeel.Each JComponent subclass identifies the ComponentUI subclass it requires by way of the JComponent method getUIClassID.Each LookAndFeel implementation must provide an implementation of the appropriate ComponentUI subclass by specifying a value for each of Swing's ui class ids in the UIDefaults object returned from getDefaults.For example, BasicLookAndFeel uses BasicTreeUI as the concrete implementation for TreeUI.This is accomplished by BasicLookAndFeel providing the key-value pair \"TreeUI\"-\"javax.swing.plaf.basic.BasicTreeUI\", in the UIDefaults returned from getDefaults.Refer to UIDefaults.getUI(JComponent) for details on how the implementation of the ComponentUI subclass is obtained.When a LookAndFeel is installed the UIManager does not check that an entry exists for all ui class ids.As such, random exceptions will occur if the current look and feel has not provided a value for a particular ui class id and an instance of the JComponent subclass is created.Recommendations for Look and Feels As noted in UIManager each LookAndFeel has the opportunity to provide a set of defaults that are layered in with developer and system defaults.Some of Swing's components require the look and feel to provide a specific set of defaults.These are documented in the classes that require the specific default.ComponentUIs and defaults All ComponentUIs typically need to set various properties on the JComponent the ComponentUIThis is typically done when the ComponentUI is installed on the JComponent.Setting a property should only be done if the developer has not set the property.For non-primitive values it is recommended that the ComponentUI only change the property on the JComponent if the current value is null or implements UIResource.If the current value is null or implements UIResourceit indicates the property has not been set by the developer, and the ui is free to change it.For example, BasicButtonUI.installDefaults only changes the font on the JButton if the return value from button.getFont() is null or implements UIResource.On the other hand if button.getFont() returned a non-null value that did not implement UIResource thenBasicButtonUI.installDefaults would not change the JButton's font.For primitive values, such as opaque, the method installProperty should be invoked.installProperty only changes the corresponding property if the value has not been changed by the developer.ComponentUI implementations should use the various install methods provided by this class as they handle the necessary checking and install the property using the recommended guidelines.Exceptions All of the install methods provided by LookAndFeel need to access the defaults if the value of the property being changed is null or a UIResource.For example, installing the font does the following:Font font = c.getFont(); if (font == null || (font instanceof UIResource)) { c.setFont(UIManager.getFont(\"fontKey\")); } If the font is null or a UIResource, the defaults table is queried with the key fontKey.All of UIDefault's get methods throw a NullPointerException if passed in null.As such, unless otherwise noted each of the various install methods of LookAndFeel throw a NullPointerException if the current value is null or a UIResource and the supplied defaults key is null.In addition, unless otherwise specified all of the install methods throw a NullPointerException if a null component is passed in."},
{"description": "Represents an operation on a single long-valued operand that produces a long-valued result.This is the primitive type specialization of UnaryOperator for long.This is a functional interface whose functional method is applyAsLong(long)."},
{"description": "Represents a function that accepts a long-valued argument and produces an int-valued result.This is the long-to-int primitive specialization for Function.This is a functional interface whose functional method is applyAsInt(long)."},
{"description": "Represents a function that accepts a long-valued argument and produces a double-valued result.This is the long-to-double primitive specialization for Function.This is a functional interface whose functional method is applyAsDouble(long)."},
{"description": "A state object for collecting statistics such as count, min, max, sum, and average.This class is designed to work with (though does not require) streams.For example, you can compute summary statistics on a stream of longs with: LongSummaryStatistics stats =longStream.collect(LongSummaryStatistics::new, LongSummaryStatistics::accept, LongSummaryStatistics::combine); LongSummaryStatistics can be used as a Stream.collect(Collector) reduction} target for a stream."},
{"description": "This is the long-producing primitive specialization of Supplier.There is no requirement that a distinct result be returned each time the supplier is invoked.This is a functional interface whose functional method is getAsLong()."},
{"description": "A stream builder has a lifecycle, which starts in a building phase, during which elements can be added, and then transitions to a built phase, after which elements may not be added.The built phase begins begins when the build() method is called, which creates an ordered stream whose elements are the elements that were added to the stream builder, in the order they were added."},
{"description": "This is the long primitive specialization of Stream.The following example illustrates an aggregate operation using Stream and LongStream, computing the sum of the weights of the red widgets: long sum = widgets.stream() .filter(w"},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "This is the long-consuming primitive type specialization of Predicate.This is a functional interface whose functional method is test(long)."},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "A Holder class for a long that is used to store \"out\" and \"inout\" parameters in IDL methods.If an IDL method signature has an IDL long long as an \"out\" or \"inout\" parameter, the programmer must pass an instance of LongHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myLongHolder is an instance of LongHolder, the value stored in its value field can be accessed with myLongHolder.value."},
{"description": "Represents an operation that accepts a single long-valued argument and returns no result.This is the primitive type specialization of Consumer for long.Unlike most other functional interfaces, LongConsumer is expected to operate via side-effects.This is a functional interface whose functional method is accept(long)."},
{"description": "Represents a function that accepts a long-valued argument and produces a result.This is the long-consuming primitive specialization for Function.This is a functional interface whose functional method is apply(long)."},
{"description": "This class defines four categories of operations upon long buffers: Absolute and relative get and put methods that read and write single longs; Relative bulk get methods that transfer contiguous sequences of longs from this buffer into an array; and Relative bulk put methods that transfer contiguous sequences of longs from a long array or some other long buffer into this buffer; and Methods for compacting, duplicating, and slicing a long buffer.Long buffers can be created either by allocation, which allocates space for the buffer's content, by wrapping an existing long array into a buffer, or by creating a view of an existing byte buffer.Like a byte buffer, a long buffer is either direct or non-direct.A long buffer created via the wrap methods of this class will be non-direct.A long buffer created as a view of a byte buffer will be direct if, and only if, the byte buffer itself is direct.Whether or not a long buffer is direct may be determined by invoking the isDirect method.Methods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked."},
{"description": "This is the primitive type specialization of BinaryOperator for long.This is a functional interface whose functional method is applyAsLong(long, long)."},
{"description": "One or more variables that together maintain an initially zero long sum.When updates (method add(long)) are contended across threads, the set of variables may grow dynamically to reduce contention.Method sum() (or, equivalently, longValue()) returns the current total combined across the variables maintaining the sum.This class is usually preferable to AtomicLong when multiple threads update a common sum that is used for purposes such as collecting statistics, not for fine-grained synchronization control.Under low update contention, the two classes have similar characteristics.But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption.LongAdders can be used with a ConcurrentHashMap to maintain a scalable frequency map (a form of histogram or multiset).For example, to add a count to a ConcurrentHashMap<String,LongAdder> freqs, initializing if not already present, you can use freqs.computeIfAbsent(k -> new LongAdder()).increment(); This class extends Number, but does not define methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are not useful as collection keys."},
{"description": "One or more variables that together maintain a running long value updated using a supplied function.When updates (method accumulate(long)) are contended across threads, the set of variables may grow dynamically to reduce contention.Method get() (or, equivalently, longValue()) returns the current value across the variables maintaining updates.This class is usually preferable to AtomicLong when multiple threads update a common value that is used for purposes such as collecting statistics, not for fine-grained synchronization control.Under low update contention, the two classes have similar characteristics.But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption.The order of accumulation within or across threads is not guaranteed and cannot be depended upon, so this class is only applicable to functions for which the order of accumulation does not matter.The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.The function is applied with the current value as its first argument, and the given update as the second argument.For example, to maintain a running maximum value, you could supply Long::max along with Long.Class LongAdder provides analogs of the functionality of this class for the common special case of maintaining counts and sums.The call new LongAdder() is equivalent to new LongAccumulator((x, yThis class extends Number, but does not define methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are not useful as collection keys."},
{"description": "The Long class wraps a value of the primitive type long in an object.An object of type Long contains a single field whose type is long.In addition, this class provides several methods for converting a long to a String and a String to a long, as well as other constants and methods useful when dealing with a long.Implementation note: The implementations of the \"bit twiddling\" methods (such as highestOneBit and numberOfTrailingZeros) are based on material from Henry S. Warren, Jr.'s Hacker's Delight, (Addison Wesley, 2002)."},
{"description": "LogRecord objects are used to pass logging requests between the logging framework and individual log Handlers.When a LogRecord is passed into the logging framework it logically belongs to the framework and should no longer be used or updated by the client application.Note that if the client application has not specified an explicit source method name and source class name, then the LogRecord class will infer them automatically when they are first accessed (due to a call on getSourceMethodName or getSourceClassName) by analyzing the call stack.Therefore, if a logging Handler wants to pass off a LogRecord to another thread, or to transmit it over RMI, and if it wishes to subsequently obtain method name or class name information it should call one of getSourceClassName or getSourceMethodName to force the values to be filled in.Because objects in the parameters array may not be serializable, during serialization all objects in the parameters array are written as the corresponding Strings (using Object.toString).The ResourceBundle is not transmitted as part of the serialized form, but the resource bundle name is, and the recipient object's readObject method will attempt to locate a suitable resource bundle."},
{"description": "There is a single global LogManager object that is used to maintain a set of shared state about Loggers and log services.All named Loggers are stored in this namespace.These are simple key-value pairs that can be used by Handlers and other logging objects to configure themselves.The LogManager object is created during class initialization and cannot subsequently be changed.At startup the LogManager class is located using the java.util.logging.manager system property.The LogManager defines two optional system properties that allow control over the initial configuration: \"java.util.logging.config.class\" \"java.util.logging.config.file\"These two properties may be specified on the command line to the \"java\" command, or as system property definitions passed to JNI_CreateJavaVM.If the \"java.util.logging.config.class\" property is set, then the property value is treated as a class name.The given class will be loaded, an object will be instantiated, and that object's constructor is responsible for reading in the initial configuration.(That object may use other system properties to control its configuration.)The alternate configuration class can use readConfiguration(InputStream) to define properties in the LogManager.If \"java.util.logging.config.class\" property is not set, then the \"java.util.logging.config.file\" system property can be used to specify a properties file (in java.util.Properties format).The initial logging configuration will be read from this file.If neither of these properties is defined then the LogManager uses its default configuration.The default configuration is typically loaded from the properties file \"lib/logging.properties\" in the Java installation directory.The properties for loggers and Handlers will have names starting with the dot-separated name for the handler or logger.The global logging properties may include: A property \"handlers\".This defines a whitespace or comma separated list of class names for handler classes to load and register as handlers on the root Logger (the Logger named \"\").Each class name must be for a Handler class which has a default constructor.This defines a whitespace or comma separated list of class names for handlers classes to load and register as handlers to the specified logger.Each class name must be for a Handler class which has a default constructor.This defines a boolean value.By default every logger calls its parent in addition to handling the logging message itself, this often result in messages being handled by the root logger as well.When setting this property to false a Handler needs to be configured for this logger otherwise no logging messages are delivered.The property defines a whitespace or comma separated list of class names.A new instance will be created for each named class.The default constructor of each class may execute arbitrary code to update the logging configuration, such as setting logger levels, adding handlers, adding filters, etc.Note that all classes loaded during LogManager configuration are first searched on the system class path before any user class path.That includes the LogManager class, any config classes, and any handler classes.Loggers are organized into a naming hierarchy based on their dot separated names.Thus \"a.b.c\" is a child of \"a.b\", but \"a.b1\" and a.b2\" are peers.All properties whose names end with \".level\" are assumed to define log levels for Loggers.Thus \"foo.level\" defines a log level for the logger called \"foo\" and (recursively) for any of its children in the naming hierarchy.Log Levels are applied in the order they are defined in the properties file.Thus level settings for child nodes in the tree should come after settings for their parents.The property name \".level\" can be used to set the level for the root of the tree.All methods on the LogManager object are multi-thread safe."},
{"description": "The permission which the SecurityManager will check when code that is running with a SecurityManager calls one of the logging control methods (such as Logger.setLevel).Currently there is only one named LoggingPermission.This is \"control\" and it grants the ability to control the logging configuration, for example by adding or removing Handlers, by adding or removing Filters, or by changing logging levels.Programmers do not normally create LoggingPermission objects directly.Instead they are created by the security policy code based on reading the security policy file."},
{"description": "It is recommended to use the PlatformLoggingMXBean management interface that implements all attributes defined in this LoggingMXBean.The ManagementFactory.getPlatformMXBean method can be used to obtain the PlatformLoggingMXBean object representing the management interface for logging.There is a single global instance of the LoggingMXBean.This instance is an MXBean that can be obtained by calling the LogManager.getLoggingMXBean() method or from the platform MBeanServer.The ObjectName that uniquely identifies the management interface for logging within the MBeanServer is: java.util.logging:type=Logging The instance registered in the platformMBeanServer is also a PlatformLoggingMXBean."},
{"description": "The LogicalMessageContext interface extends MessageContext to provide access to a the contained message as a protocol neutral LogicalMessage"},
{"description": "The LoginContext class describes the basic methods used to authenticate Subjects and provides a way to develop an application independent of the underlying authentication technology.A Configuration specifies the authentication technology, or LoginModule, to be used with a particular application.Different LoginModules can be plugged in under an application without requiring any modifications to the application itself.In addition to supporting pluggable authentication, this class also supports the notion of stacked authentication.Applications may be configured to use more than one LoginModule.For example, one could configure both a Kerberos LoginModule and a smart card LoginModule under an application.A typical caller instantiates a LoginContext with a name and a CallbackHandler.LoginContext uses the name as the index into a Configuration to determine which LoginModules should be used, and which ones must succeed in order for the overall authentication to succeed.The CallbackHandler is passed to the underlying LoginModules so they may communicate and interact with users (prompting for a username and password via a graphical user interface, for example).Once the caller has instantiated a LoginContext, it invokes the login method to authenticate a Subject.The login method invokes the configured modules to perform their respective types of authentication (username/password, smart card pin verification, etc.).Note that the LoginModules will not attempt authentication retries nor introduce delays if the authentication fails.Such tasks belong to the LoginContext caller.If the login method returns without throwing an exception, then the overall authentication succeeded.The caller can then retrieve the newly authenticated Subject by invoking the getSubject method.Principals and Credentials associated with the Subject may be retrieved by invoking the Subject's respective getPrincipals, getPublicCredentials, and getPrivateCredentials methods.To logout the Subject, the caller calls the logout method.As with the login method, this logout method invokes the logout method for the configured modules.A LoginContext should not be used to authenticate more than one Subject.A separate LoginContext should be used to authenticate each different Subject.The following documentation applies to all LoginContext constructors:If the constructor has a Subject input parameter, the LoginContext uses the caller-specified Subject object.If the caller specifies a null Subject and a null value is permitted, the LoginContext instantiates a new Subject.If the constructor does not have a Subject input parameter, the LoginContext instantiates a new Subject.If the constructor has a Configuration input parameter and the caller specifies a non-null Configuration, the LoginContext uses the caller-specified Configuration.If the constructor does not have a Configuration input parameter, or if the caller specifies a null Configuration object, the constructor uses the following call to get the installed Configuration: config = Configuration.getConfiguration(); For both cases, the name argument given to the constructor is passed to the Configuration.getAppConfigurationEntry method.If the Configuration has no entries for the specified name, then the LoginContext calls getAppConfigurationEntry with the name, \"other\" (the default entry name).If there is no entry for \"other\", then a LoginException is thrown.When LoginContext uses the installed Configuration, the caller requires the createLoginContext.name and possibly createLoginContext.other AuthPermissions.Furthermore, the LoginContext will invoke configured modules from within an AccessController.doPrivileged call so that modules that perform security-sensitive tasks (such as connecting to remote hosts, and updating the Subject) will require the respective permissions, but the callers of the LoginContext will not require those permissions.When LoginContext uses a caller-specified Configuration, the caller does not require any createLoginContext AuthPermission.The LoginContext saves the AccessControlContext for the caller, and invokes the configured modules from within an AccessController.doPrivileged call constrained by that context.This means the caller context (stored when the LoginContext was created) must have sufficient permissions to perform any security-sensitive tasks that the modules may perform.If the constructor has a CallbackHandler input parameter, the LoginContext uses the caller-specified CallbackHandler object.If the constructor does not have a CallbackHandler input parameter, or if the caller specifies a null CallbackHandler object (and a null value is permitted), the LoginContext queries the auth.login.defaultCallbackHandler security property for the fully qualified class name of a default handler implementation.If the security property is not set, then the underlying modules will not have a CallbackHandler for use in communicating with users.The caller thus assumes that the configured modules have alternative means for authenticating the user.When the LoginContext uses the installed Configuration (instead of a caller-specified Configuration, see above), then this LoginContext must wrap any caller-specified or default CallbackHandler implementation in a new CallbackHandler implementation whose handle method implementation invokes the specified CallbackHandler's handle method in a java.security.AccessController.doPrivileged call constrained by the caller's current AccessControlContext."},
{"description": "The LogicalHandler extends Handler to provide typesafety for the message context parameter."},
{"description": "LoginModule describes the interface implemented by authentication technology providers.LoginModules are plugged in under applications to provide a particular type of authentication.While applications write to the LoginContext API, authentication technology providers implement the LoginModule interface.A Configuration specifies the LoginModule(s) to be used with a particular login application.Therefore different LoginModules can be plugged in under the application without requiring any modifications to the application itself.The LoginContext is responsible for reading the Configuration and instantiating the appropriate LoginModules.Each LoginModule is initialized with a Subject, a CallbackHandler, shared LoginModule state, and LoginModule-specific options.The Subject represents the Subject currently being authenticated and is updated with relevant Credentials if authentication succeeds.LoginModules use the CallbackHandler to communicate with users.The CallbackHandler may be used to prompt for usernames and passwords, for example.LoginModules which absolutely require a CallbackHandler to authenticate the Subject may throw a LoginException.LoginModules optionally use the shared state to share information or data among themselves.The LoginModule-specific options represent the options configured for this LoginModule by an administrator or user in the login Configuration.The options are defined by the LoginModule itself and control the behavior within it.For example, a LoginModule may define options to support debugging/testing capabilities.Options are defined using a key-value syntax, such as debug=true.The LoginModule stores the options as a Map so that the values may be retrieved using the key.Note that there is no limit to the number of options a LoginModule chooses to define.The calling application sees the authentication process as a single operation.In the first phase, the LoginModule's login method gets invoked by the LoginContext's login method.The login method for the LoginModule then performs the actual authentication (prompt for and verify a password for example) and saves its authentication status as private state information.Once finished, the LoginModule's login method either returns true (if it succeeded) or false (if it should be ignored), or throws a LoginException to specify a failure.In the failure case, the LoginModule must not retry the authentication or introduce delays.The responsibility of such tasks belongs to the application.If the application attempts to retry the authentication, the LoginModule's login method will be called again.In the second phase, if the LoginContext's overall authentication succeeded (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules succeeded), then the commit method for the LoginModule gets invoked.The commit method for a LoginModule checks its privately saved state to see if its own authentication succeeded.If the overall LoginContext authentication succeeded and the LoginModule's own authentication succeeded, then the commit method associates the relevant Principals (authenticated identities) and Credentials (authentication data such as cryptographic keys) with the Subject located within the LoginModule.If the LoginContext's overall authentication failed (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules did not succeed), then the abort method for each LoginModule gets invoked.In this case, the LoginModule removes/destroys any authentication state originally saved.Logging out a Subject involves only one phase.The LoginContext invokes the LoginModule's logout method.The logout method for the LoginModule then performs the logout procedures, such as removing Principals or Credentials from the Subject or logging session information.A LoginModule implementation must have a constructor with no arguments.This allows classes which load the LoginModule to instantiate it."},
{"description": "This is the basic login exception."},
{"description": "The LogicalMessage interface represents a protocol agnostic XML message and contains methods that provide access to the payload of the message."},
{"description": "A Logger object is used to log messages for a specific system or application component.Loggers are normally named, using a hierarchical dot-separated namespace.Logger names can be arbitrary strings, but they should normally be based on the package name or class name of the logged component, such as java.net or javax.swing.In addition it is possible to create \"anonymous\" Loggers that are not stored in the Logger namespace.Logger objects may be obtained by calls on one of the getLogger factory methods.These will either create a new Logger or return a suitable existing Logger.It is important to note that the Logger returned by one of the getLogger factory methods may be garbage collected at any time if a strong reference to the Logger is not kept.Logging messages will be forwarded to registered Handler objects, which can forward the messages to a variety of destinations, including consoles, files, OS logs, etc.Each Logger keeps track of a \"parent\" Logger, which is its nearest existing ancestor in the Logger namespace.Each Logger has a \"Level\" associated with it.This reflects a minimum Level that this logger cares about.If a Logger's level is set to null, then its effective level is inherited from its parent, which may in turn obtain it recursively from its parent, and so on up the tree.The log level can be configured based on the properties from the logging configuration file, as described in the description of the LogManager class.However it may also be dynamically changed by calls on the Logger.setLevel method.If a logger's level is changed the change may also affect child loggers, since any child logger that has null as its level will inherit its effective level from its parent.On each logging call the Logger initially performs a cheap check of the request level (e.g., SEVERE or FINE) against the effective log level of the logger.If the request level is lower than the log level, the logging call returns immediately.After passing this initial (cheap) test, the Logger will allocate a LogRecord to describe the logging message.It will then call a Filter (if present) to do a more detailed check on whether the record should be published.If that passes it will then publish the LogRecord to its output Handlers.By default, loggers also publish to their parent's Handlers, recursively up the tree.Each Logger may have a ResourceBundle associated with it.The ResourceBundle may be specified by name, using the getLogger(java.lang.This bundle will be used for localizing logging messages.If a Logger does not have its own ResourceBundle or resource bundle name, then it will inherit the ResourceBundle or resource bundle name from its parent, recursively up the tree.Most of the logger output methods take a \"msg\" argument.This msg argument may be either a raw value or a localization key.During formatting, if the logger has (or inherits) a localization ResourceBundle and if the ResourceBundle has a mapping for the msg string, then the msg string is replaced by the localized value.Typically, formatters use java.text.MessageFormat style formatting to format parameters, so for example a format string \"{0} {1}\" would format two parameters as strings.A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\" argument.These methods take a Supplier<String> function which is invoked to construct the desired log message only when the message actually is to be logged based on the effective log level thus eliminating unnecessary message construction.For example, if the developer wants to log system health status for diagnosis, with the String-accepting version, the code would look like: class DiagnosisMessages { static String systemHealthStatus() { // collect system health information ... } } ...()); With the above code, the health status is collected unnecessarily even when the log level FINER is disabled.With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled.logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus); When looking for a ResourceBundle, the logger will first look at whether a bundle was specified using setResourceBundle, and then only whether a resource bundle name was specified through the getLogger factory method.If no ResourceBundle or no resource bundle name is found, then it will use the nearest ResourceBundle or resource bundle name inherited from its parent tree.When a ResourceBundle was inherited or specified through the setResourceBundle method, then that ResourceBundle will be used.Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a ResourceBundle object, using the default Locale at the time of logging.When mapping resource bundle names to ResourceBundle objects, the logger will first try to use the Thread's context class loader to map the given resource bundle name to a ResourceBundle.If the thread context class loader is null, it will try the system class loader instead.If the ResourceBundle is still not found, it will use the class loader of the first caller of the getLogger factory method.Formatting (including localization) is the responsibility of the output Handler, which will typically call a Formatter.It may be delayed until a LogRecord is actually written to an external sink.The logging methods are grouped in five main categories: There are a set of \"log\" methods that take a log level, a message string, and optionally some parameters to the message string.There are a set of \"logp\" methods (for \"log precise\") that are like the \"log\" methods, but also take an explicit source class name and method name.There are a set of \"logrb\" method (for \"log with resource bundle\") that are like the \"logp\" method, but also take an explicit resource bundle object for use in localizing the log message.There are convenience methods for tracing method entries (the \"entering\" methods),Finally, there are a set of convenience methods for use in the very simplest cases, when a developer simply wants to log a simple string at a given log level.These methods are named after the standard Level names (\"severe\", \"warning\", \"info\", etc.) and take a single argument, a message string.For the methods that do not take an explicit source name and method name, the Logging framework will make a \"best effort\" to determine which class and method called into the logging method.Virtual machines are allowed to do extensive optimizations when JITing and may entirely remove stack frames, making it impossible to reliably locate the calling class and method.All methods on Logger are multi-thread safe.: Note that a LogManager class may provide its own implementation of named Loggers for any point in the namespace.Therefore, any subclasses of Logger (unless they are implemented in conjunction with a new LogManager class) should take care to obtain a Logger instance from the LogManager class and should delegate operations such as \"isLoggable\" and \"log(LogRecord)\" to that instance.Note that in order to intercept all logging output, subclasses need only override the log(LogRecord) method.All the other logging methods are implemented as calls on this log(LogRecord) method."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This class is available mainly for application writers, who can use it to make a persistent snapshot of a locator at any point during a document parse: Locator locator; Locator startloc; public void setLocator (Locator locator) { // note the locator this.locator = locator; } public void startDocument () { // save the location of the start of the document // for future use.new LocatorImpl(locator); } Normally, parser writers will not use this class, since it is more efficient to provide location information only when requested, rather than constantly updating a Locator object."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This is not part of core-only SAX2 distributions."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.If a SAX parser provides location information to the SAX application, it does so by implementing this interface and then passing an instance to the application using the content handler's setDocumentLocator method.The application can use the object to obtain the location of any other SAX event in the XML source document.Note that the results returned by the object will be valid only during the scope of each callback method: the application will receive unpredictable results if it attempts to use the locator at any other time, or after parsing completes.SAX parsers are not required to supply a locator, but they are very strongly encouraged to do so.If the parser supplies a locator, it must do so before reporting any other document events.If no locator has been set by the time the application receives the startDocument event, the application should assume that a locator is not available."},
{"description": "If an implementation supports this extension, the Locator provided in ContentHandler.setDocumentLocator() will implement this interface, and the http://xml.org/sax/features/use-locator2 feature flag will have the value true.This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.XMLReader implementations are not required to support this information, and it is not part of core-only SAX2 distributions."},
{"description": "Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements.They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects.A lock is a tool for controlling access to a shared resource by multiple threads.Commonly, a lock provides exclusive access to a shared resource: only one thread at a time can acquire the lock and all access to the shared resource requires that the lock be acquired first.However, some locks may allow concurrent access to a shared resource, such as the read lock of a ReadWriteLock.The use of synchronized methods or statements provides access to the implicit monitor lock associated with every object, but forces all lock acquisition and release to occur in a block-structured way: when multiple locks are acquired they must be released in the opposite order, and all locks must be released in the same lexical scope in which they were acquired.While the scoping mechanism for synchronized methods and statements makes it much easier to program with monitor locks, and helps avoid many common programming errors involving locks, there are occasions where you need to work with locks in a more flexible way.For example, some algorithms for traversing concurrently accessed data structures require the use of \"hand-over-hand\" or \"chain locking\": you acquire the lock of node A, then node B, then release A and acquire C, then release B and acquire D and so on.Implementations of the Lock interface enable the use of such techniques by allowing a lock to be acquired and released in different scopes, and allowing multiple locks to be acquired and released in any order.With this increased flexibility comes additional responsibility.The absence of block-structured locking removes the automatic release of locks that occurs with synchronized methods and statements.In most cases, the following idiom should be used: Lock l = ...; l.lock(); try { // accessthe resource protected by this lock } finally { l.unlock(); } When locking and unlocking occur in different scopes, care must be taken to ensure that all code that is executed while the lock is held is protected by try-finally or try-catch to ensure that the lock is released when necessary.Lock implementations provide additional functionality over the use of synchronized methods and statements by providing a non-blocking attempt to acquire a lock (tryLock()), an attempt to acquire the lock that can be interrupted (lockInterruptibly(), and an attempt to acquire the lock that can timeout (tryLock(long, TimeUnit)).A Lock class can also provide behavior and semantics that is quite different from that of the implicit monitor lock, such as guaranteed ordering, non-reentrant usage, or deadlock detection.If an implementation provides such specialized semantics then the implementation must document those semantics.Note that Lock instances are just normal objects and can themselves be used as the target in a synchronized statement.Acquiring the monitor lock of a Lock instance has no specified relationship with invoking any of the lock() methods of that instance.It is recommended that to avoid confusion you never use Lock instances in this way, except within their own implementation.Except where noted, passing a null value for any parameter will result in a NullPointerException being thrown.Memory Synchronization All Lock implementations must enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in The Java Language Specification (17.4 Memory Model):A successful lock operation has the same memory synchronization effects as a successful Lock action.A successful unlock operation has the same memory synchronization effects as a successful Unlock action.Unsuccessful locking and unlocking operations, and reentrant locking/unlocking operations, do not require any memory synchronization effects.Implementation Considerations The three forms of lock acquisition (interruptible, non-interruptible, and timed) may differ in their performance characteristics, ordering guarantees, or other implementation qualities.Further, the ability to interrupt the ongoing acquisition of a lock may not be available in a given Lock class.Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of lock acquisition, nor is it required to support interruption of an ongoing lock acquisition.An implementation is required to clearly document the semantics and guarantees provided by each of the locking methods.It must also obey the interruption semantics as defined in this interface, to the extent that interruption of lock acquisition is supported: which is either totally, or only on method entry.As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor responding to an interrupt over normal method return.This is true even if it can be shown that the interrupt occurred after another action may have unblocked the thread.An implementation should document this behavior."},
{"description": "A lock can be a built-in object monitor, an ownable synchronizer, or the Condition object associated with synchronizers.An ownable synchronizer is a synchronizer that may be exclusively owned by a thread and uses AbstractOwnableSynchronizer (or its subclass) to implement its synchronization property.ReentrantLock and ReentrantReadWriteLock are two examples of ownable synchronizers provided by the platform.MXBean Mapping LockInfo is mapped to a CompositeData as specified in the from method."},
{"description": "Basic thread blocking primitives for creating locks and other synchronization classes.This class associates, with each thread that uses it, a permit (in the sense of the Semaphore class).A call to park will return immediately if the permit is available, consuming it in the process; otherwise it may block.A call to unpark makes the permit available, if it was not already available.(Unlike with Semaphores though, permits do not accumulate.There is at most one.)Methods park and unpark provide efficient means of blocking and unblocking threads that do not encounter the problems that cause the deprecated methods Thread.suspend and Thread.resume to be unusable for such purposes: Races between one thread invoking park and another thread trying to unpark it will preserve liveness, due to the permit.The park method may also return at any other time, for \"no reason\", so in general must be invoked within a loop that rechecks conditions upon return.In this sense park serves as an optimization of a \"busy wait\" that does not waste as much time spinning, but must be paired with an unpark to be effective.The three forms of park each also support a blocker object parameter.This object is recorded while the thread is blocked to permit monitoring and diagnostic tools to identify the reasons that threads are blocked.(Such tools may access blockers using method getBlocker(Thread).)The use of these forms rather than the original forms without this parameter is strongly encouraged.The normal argument to supply as a blocker within a lock implementation is this.These methods are designed to be used as tools for creating higher-level synchronization utilities, and are not in themselves useful for most concurrency control applications.The park method is designed for use only in constructions of the form: while (!canProceed()) { ... LockSupport.park(this); } where neither canProceed nor any other actions prior to the call to park entail locking or blocking.Because only one permit is associated with each thread, any intermediary uses of park could interfere with its intended effects.Here is a sketch of a first-in-first-out non-reentrant lock class: class FIFOMutex { private final AtomicBoolean locked = new AtomicBoolean(false); private final Queue<Thread> waiters =new ConcurrentLinkedQueue<Thread>(); public void lock() { boolean wasInterrupted = false; Thread current = Thread.currentThread(); waiters.add(current); // Block while not first in queue or cannot acquire lock while (waiters.peek() !="},
{"description": "All the information provided by a Location is optional.For example an application may only report line numbers."},
{"description": "LocateRegistry is used to obtain a reference to a bootstrap remote object registry on a particular host (including the local host), or to create a remote object registry that accepts calls on a specific port.Note that a getRegistry call does not actually make a connection to the remote host.It simply creates a local reference to the remote registry and will succeed even if no registry is running on the remote host.Therefore, a subsequent method invocation to a remote registry returned as a result of this method may fail."},
{"description": "This is the super class of all the locale sensitive service provider interfaces (SPIs).Locale sensitive service provider interfaces are interfaces that correspond to locale sensitive classes in the java.text and java.util packages.The interfaces enable the construction of locale sensitive objects and the retrieval of localized names for these packages.Locale sensitive factory methods and methods for name retrieval in the java.text and java.util packages use implementations of the provider interfaces to offer support for locales beyond the set of locales supported by the Java runtime environment itself.Packaging of Locale Sensitive Service Provider Implementations Implementations of these locale sensitive services are packaged using the Java Extension Mechanism as installed extensions.A provider identifies itself with a provider-configuration file in the resource directory META-INF/services, using the fully qualified provider interface class name as the file name.The file should contain a list of fully-qualified concrete provider class names, one per line.A line is terminated by any one of a line feed ('\\n'), a carriage return ('\\r'), or a carriage return followed immediately by a line feed.Space and tab characters surrounding each name, as well as blank lines, are ignored.The comment character is '#' ('#'); on each line all characters following the first comment character are ignored.The file must be encoded in UTF-8.If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored.The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself.The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file.For example, an implementation of the DateFormatProvider class should take the form of a jar file which contains the file: META-INF/services/java.text.spi.the file java.text.spi.DateFormatProvider should have a line such as: com.foo.DateFormatProviderImpl which is the fully qualified class name of the class implementing DateFormatProvider.Invocation of Locale Sensitive Services Locale sensitive factory methods and methods for name retrieval in the java.text and java.util packages invoke service provider methods when needed to support the requested locale.The methods first check whether the Java runtime environment itself supports the requested locale, and use its support if available.Otherwise, they call the isSupportedLocale methods of installed providers for the appropriate interface to find one that supports the requested locale.If such a provider is found, its other methods are called to obtain the requested object or name.When checking whether a locale is supported, the locale's extensions are ignored by default.If neither the Java runtime environment itself nor an installed provider supports the requested locale, the methods go through a list of candidate locales and repeat the availability check for each until a match is found.The algorithm used for creating a list of candidate locales is same as the one used by ResourceBundle by default (see getCandidateLocales for the details).Even if a locale is resolved from the candidate list, methods that return requested objects or names are invoked with the original requested locale including Locale extensions.The Java runtime environment must support the root locale for all locale sensitive services in order to guarantee that this process terminates.Providers of names (but not providers of other objects) are allowed to return null for some name requests even for locales that they claim to support by including them in their return value for getAvailableLocales.Similarly, the Java runtime environment itself may not have all names for all locales that it supports.This is because the sets of objects for which names are requested can be large and vary over time, so that it's not always feasible to cover them completely.If the Java runtime environment or a provider returns null instead of a name, the lookup will proceed as described above as if the locale was not supported.Starting from JDK8, the search order of locale sensitive services can be configured by using the \"java.locale.providers\" system property.This system property declares the user's preferred order for looking up the locale sensitive services separated by a comma.It is only read at the Java runtime startup, so the later call to System.setProperty() won't affect the order.For example, if the following is specified in the property: java.locale.providers=SPI,JRE where \"SPI\" represents the locale sensitive services implemented in the installed SPI providers, and \"JRE\" represents the locale sensitive services in the Java Runtime Environment, the locale sensitive services in the SPI providers are looked up first.There are two other possible locale sensitive service providers, i.e., \"CLDR\" which is a provider based on Unicode Consortium's CLDR Project, and \"HOST\" which is a provider that reflects the user's custom settings in the underlying operating system.These two providers may not be available, depending on the Java Runtime Environment implementation.Specifying \"JRE,SPI\" is identical to the default behavior, which is compatibile with the prior releases."},
{"description": "It is a class which implements all the operations in the org.omg.CORBA.Object interface.Local interfaces are implemented by using CORBA::LocalObject to provide implementations of Object pseudo operations and any other ORB-specific support mechanisms that are appropriate for such objects.Therefore, the LocalObject type is not defined in IDL, but is specified in each language mapping.Methods that do not apply to local objects throw an org.omg.CORBA.NO_IMPLEMENT exception with the message, \"This is a locally contrained object.\"Narrowing and widening references to LocalObjects must work as for regular object references.LocalObject is to be used as the base class of locally constrained objects, such as those in the PortableServer module.The specification here is based on the CORBA Components Volume I - orbos/99-07-01"},
{"description": "LocalTime is an immutable date-time object that represents a time, often viewed as hour-minute-second.Time is represented to nanosecond precision.For example, the value \"13:45.30.123456789\" can be stored in a LocalTime.This class does not store or represent a date or time-zone.Instead, it is a description of the local time as seen on a wall clock.It cannot represent an instant on the time-line without additional information such as an offset or time-zone.The ISO-8601 calendar system is the modern civil calendar system used today in most of the world.This API assumes that all calendar systems use the same representation, this class, for time-of-day.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of LocalTime may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "This class expresses a Language Range defined in RFC 4647 Matching of Language Tags.A language range is an identifier which is used to select language tag(s) meeting specific requirements by using the mechanisms described in Locale Matching.A list which represents a user's preferences and consists of language ranges is called a Language Priority List.There are two types of language ranges: basic and extended.In RFC 4647, the syntax of language ranges is expressed in ABNF as follows: basic-language-range =For example, \"en\" (English), \"ja-JP\" (Japanese, Japan), \"*\" (special language range which matches any language tag) are basic language ranges, whereas \"*-CH\" (any languages, Switzerland), \"es-*\" (Spanish, any regions), and \"zh-Hant-"},
{"description": "An abstract class for service providers that provide localized names for the Locale class."},
{"description": "This enum provides constants to select a filtering mode for locale matching.As an example, think of two Language Priority Lists each of which includes only one language range and a set of following language tags: de (German) de-DE (German, Germany) de-Deva (German, in Devanagari script) de-Deva-DE (German, in Devanagari script, Germany) de-DE-1996 (German, Germany, orthography of 1996) de-Latn-DE (German, in Latin script, Germany) de-Latn-DE-1996 (German, in Latin script, Germany, orthography of 1996)Performs extended filtering and returns \"de-DE\", \"de-Deva-DE\", \"de-DE-1996\", \"de-Latn-DE\", and \"de-Latn-DE-1996\".EXTENDED_FILTERING Performs extended filtering and returns \"de-DE\", \"de-Deva-DE\", \"de-DE-1996\", \"de-Latn-DE\", and \"de-Latn-DE-1996\".IGNORE_EXTENDED_RANGES Performs basic filtering and returns \"de-DE\" and \"de-DE-1996\".Performs basic filtering and returns null because nothing matches.Performs basic filtering and returns \"de-DE\" and \"de-DE-1996\" because \"de-*-DE\" is mapped to \"de-DE\".Throws IllegalArgumentException because \"de-*-DE\" is not a valid basic language range."},
{"description": "These locale categories are used to get/set the default locale for the specific functionality represented by the category."},
{"description": "LocalDate is an immutable date-time object that represents a date, often viewed as year-month-day.Other date fields, such as day-of-year, day-of-week and week-of-year, can also be accessed.For example, the value \"2nd October 2007\" can be stored in a LocalDate.This class does not store or represent a time or time-zone.Instead, it is a description of the date, as used for birthdays.It cannot represent an instant on the time-line without additional information such as an offset or time-zone.The ISO-8601 calendar system is the modern civil calendar system used today in most of the world.It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time.For most applications written today, the ISO-8601 rules are entirely suitable.However, any application that makes use of historical dates, and requires them to be accurate will find the ISO-8601 approach unsuitable.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of LocalDate may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "LocalDateTime is an immutable date-time object that represents a date-time, often viewed as year-month-day-hour-minute-second.Other date and time fields, such as day-of-year, day-of-week and week-of-year, can also be accessed.Time is represented to nanosecond precision.For example, the value \"2nd October 2007 at 13:45.30.123456789\" can be stored in a LocalDateTime.This class does not store or represent a time-zone.Instead, it is a description of the date, as used for birthdays, combined with the local time as seen on a wall clock.It cannot represent an instant on the time-line without additional information such as an offset or time-zone.The ISO-8601 calendar system is the modern civil calendar system used today in most of the world.It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time.For most applications written today, the ISO-8601 rules are entirely suitable.However, any application that makes use of historical dates, and requires them to be accurate will find the ISO-8601 approach unsuitable.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of LocalDateTime may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "Builder is used to build instances of Locale from values configured by the setters.Unlike the Locale constructors, the Builder checks if a value configured by a setter satisfies the syntax requirements defined by the Locale class.A Locale object created by a Builder is well-formed and can be transformed to a well-formed IETF BCP 47 language tag without losing information.Note: The Locale class does not provide any syntactic restrictions on variant, while BCP 47 requires each variant subtag to be 5 to 8 alphanumerics or a single numeric followed by 3 alphanumerics.The method setVariant throws IllformedLocaleException for a variant that does not satisfy this restriction.If it is necessary to support such a variant, use a Locale constructor.However, keep in mind that a Locale object created this way might lose the variant information when transformed to a BCP 47 language tag.The following example shows how to create a Locale object with the Builder.new Builder().setLanguage(\"sr\").setScript(\"Latn\").setRegion(\"RS\").build(); Builders can be reused; clear() resets all fields to their default values."},
{"description": "A Locale object represents a specific geographical, political, or cultural region.An operation that requires a Locale to perform its task is called locale-sensitive and uses the Locale to tailor information for the user.For example, displaying a number is a locale-sensitive operation\u2014 the number should be formatted according to the customs and conventions of the user's native country, region, or culture.The Locale class implements IETF BCP 47 which is composed of RFC 4647\"Tags for Identifying Languages\" with support for the LDML (UTS#35, \"Unicode Locale Data Markup Language\")A Locale object logically consists of the fields described below.language ISO 639 alpha-2 or alpha-3 language code, or registered language subtags up to 8 alpha letters (for future enhancements).When a language has both an alpha-2 code and an alpha-3 code, the alpha-2 code must be used.You can find a full list of valid language codes in the IANA Language Subtag Registry (search for \"Type: language\").The language field is case insensitive, but Locale always canonicalizes to lower case.Well-formed language values have the form [a-zA-Z]{2,8}.Note that this is not the the full BCP47 language production, since it excludes extlang.They are not needed since modern three-letter language codes replace them.You can find a full list of valid script codes in the IANA Language Subtag Registry (search for \"Type: script\").The script field is case insensitive, but Locale always canonicalizes to title case (the first letter is upper case and the rest of the letters are lower case).Well-formed script values have the form [a-zA-Z]{4} Example: \"Latn\" (Latin), \"Cyrl\"You can find a full list of valid country and region codes in the IANA Language Subtag Registry (search for \"Type: region\").The country (region) field is case insensitive, but Locale always canonicalizes to upper case.Well-formed country/region values have the form [a-zA-Z]{2} | [0-9]{3} Example: \"US\" (United States), \"FR\" (France), \"029\"Where there are two or more variant values each indicating its own semantics, these values should be ordered by importance, with most important first, separated by underscore('_').Also BCP 47 subtags are strictly used to indicate additional variations that define a language or its dialects that are not covered by any combinations of language, script and region subtags.You can find a full list of valid variant codes in the IANA Language Subtag Registry (search for \"Type: variant\").However, the variant field in Locale has historically been used for any kind of variation, not just language variations.For example, some supported variants available in Java SE Runtime Environments indicate alternative cultural behaviors such as calendar type or number script.In BCP 47 this kind of information, which does not identify the language, is supported by extension subtags or private use subtags.Well-formed variant values have the form SUBTAG (('_'|'-') SUBTAG)(Note: BCP 47 only uses hyphen ('-') as a delimiter, this is more lenient).The extensions in Locale implement the semantics and syntax of BCP 47 extension subtags and private use subtags.The extensions are case insensitive, but Locale canonicalizes all extension keys and values to lower case.Note that extensions cannot have empty values.Well-formed keys are single characters from the set [0-9a-zA-Z].Well-formed values have the form SUBTAG ('-' SUBTAG)* where for the key 'x' SUBTAG = [0-9a-zA-Z]{1,8} and for other keys SUBTAG =(that is, 'x' allows single-character subtags).Although BCP 47 requires field values to be registered in the IANA Language Subtag Registry, the Locale class does not provide any validation features.The Builder only checks if an individual field satisfies the syntactic requirement (is well-formed), but does not validate the value itself.Unicode locale/language extension UTS#35, \"Unicode Locale Data Markup Language\" defines optional attributes and keywords to override or refine the default behavior associated with a locale.A keyword is represented by a pair of key and type.For example, \"nu-thai\" indicates that Thai local digits (value:\"thai\") should be used for formatting numbers (key:\"nu\").The keywords are mapped to a BCP 47 extension value using the extension key 'u' (UNICODE_LOCALE_EXTENSION).The above example, \"nu-thai\", becomes the extension \"u-nu-thai\".codeThus, when a Locale object contains Unicode locale attributes and keywords, getExtension(UNICODE_LOCALE_EXTENSION) will return a String representing this information, for example, \"nu-thai\".The Locale class also provides getUnicodeLocaleAttributes(), getUnicodeLocaleKeys(), and getUnicodeLocaleType(java.lang.String) which allow you to access Unicode locale attributes and key/type pairs directly.When represented as a string, the Unicode Locale Extension lists attributes alphabetically, followed by key/type sequences with keys listed alphabetically (the order of subtags comprising a key's type is fixed when the type is defined)A well-formed locale key has the form [0-9a-zA-Z]{2}.A well-formed locale type has the form \"\" | [0-9a-zA-Z]{3,8} ('-' [0-9a-zA-Z]{3,8})* (it can be empty, or a series of subtags 3-8 alphanums in length).A well-formed locale attribute has the form [0-9a-zA-Z]{3,8}(it is a single subtag with the same form as a locale type subtag).Although the LDML specification defines various keys and values, actual locale-sensitive service implementations in a Java Runtime Environment might not support any particular Unicode locale attributes or key/type pairs.Creating a Locale There are several different ways to create a Locale object.you can construct a Locale object that conforms to BCP 47 syntax.Constructors The Locale class provides three constructors: Locale(String language)These constructors allow you to create a Locale object with language, country and variant, but you cannot specify script or extensions.String) creates a Locale object for a well-formed BCP 47 language tag.The Locale class provides a number of convenient constants that you can use to create Locale objects for commonly used locales.For example, the following creates a Locale object for the United States: Locale.If an application or a system is internationalized and provides localized resources for multiple locales, it sometimes needs to find one or more locales (or language tags) which meet each user's specific preferences.Note that a term \"language tag\" is used interchangeably with \"locale\" in this locale matching documentation.In order to do matching a user's preferred locales to a set of language tags, RFC 4647 Matching of Language Tags defines two mechanisms: filtering and lookup.Filtering is used to get all matching locales, whereas lookup is to choose the best matching locale.Matching is done case-insensitively.These matching mechanisms are described in the following sections.A user's preference is called a Language Priority List and is expressed as a list of language ranges.There are syntactically two types of language ranges: basic and extended.Filtering The filtering operation returns all matching language tags.It is defined in RFC 4647 as follows: \"In filtering, each language range represents the least specific language tag (that is, the language tag with fewest number of subtags) that is an acceptable match.All of the language tags in the matching set of tags will have an equal or greater number of subtags than the language range.Every non-wildcard subtag in the language range will appear in every one of the matching language tags.\" There are two types of filtering: filtering for basic language ranges (called \"basic filtering\") and filtering for extended language ranges (called \"extended filtering\").They may return different results by what kind of language ranges are included in the given Language Priority List.FilteringMode is a parameter to specify how filtering should be done.The lookup operation returns the best matching language tags.It is defined in RFC 4647 as follows: \"By contrast with filtering, each language range represents the most specific tag that is an acceptable match.The first matching tag found, according to the user's priority, is considered the closest match and is the item returned.\" For example, if a Language Priority List consists of two language ranges, \"zh-Hant-TW\" and \"en-US\", in prioritized order, lookup method progressively searches the language tags below in order to find the best matching language tag. 1.If there is a language tag which matches completely to a language range above, the language tag is returned.*\" is the special language range, and it is ignored in lookup.If multiple language tags match as a result of the subtag '*' included in a language range, the first matching language tag returned by an Iterator over a Collection of language tags is treated as the best matching one.Use of Locale Once you've created a Locale you can query it for information about itself.You can use getDisplayCountry to get the name of the country suitable for displaying to the user.Similarly, you can use getDisplayLanguage to get the name of the language suitable for displaying to the user.Interestingly, the getDisplayXXX methods are themselves locale-sensitive and have two versions: one that uses the default DISPLAY locale and one that uses the locale specified as an argument.The Java Platform provides a number of classes that perform locale-sensitive operations.Classes such as NumberFormat have several convenience methods for creating a default object of that type.For example, the NumberFormat class provides these three convenience methods for creating a default NumberFormat object:Each of these methods has two variants; one with an explicit locale and one without; the latter uses the default FORMAT locale: NumberFormat.getInstance(myLocale) NumberFormat.getCurrencyInstance(myLocale) NumberFormat.getPercentInstance(myLocale)A Locale is the mechanism for identifying the kind of object (NumberFormat) that you would like to get.The locale is just a mechanism for identifying objects, not a container for the objects themselves.In order to maintain compatibility with existing usage, Locale's constructors retain their behavior prior to the Java Runtime Environment version 1.7.The same is largely true for the toString method.In particular, clients who parse the output of toString into language, country, and variant fields can continue to do so (although this is strongly discouraged), although the variant field will have additional information in it if script or extensions are present.In addition, BCP 47 imposes syntax restrictions that are not imposed by Locale's constructors.This means that conversions between some Locales and BCP 47 language tags cannot be made without losing information.Thus toLanguageTag cannot represent the state of locales whose language, country, or variant do not conform to BCP 47.Because of these issues, it is recommended that clients migrate away from constructing non-conforming locales and use the forLanguageTag and Locale.Clients desiring a string representation of the complete locale can then always rely on toLanguageTag for this purpose.Special cases For compatibility reasons, two non-conforming locales are treated as special cases.These are ja_JP_JP and th_TH_TH.These are ill-formed in BCP 47 since the variants are too short.To ease migration to BCP 47, these are treated specially during construction.These two cases (and only these) cause a constructor to generate an extension, all other values behave exactly as they did prior to Java 7.Java has used ja_JP_JP to represent Japanese as used in Japan together with the Japanese Imperial calendar.This is now representable using a Unicode locale extension, by specifying the Unicode locale key ca (for \"calendar\") and type japanese.When the Locale constructor is called with the arguments \"ja\", \"JP\", \"JP\", the extension \"u-ca-japanese\" is automatically added.Java has used th_TH_TH to represent Thai as used in Thailand together with Thai digits.This is also now representable using a Unicode locale extension, by specifying the Unicode locale key nu (for \"number\") and value thai.When the Locale constructor is called with the arguments \"th\", \"TH\", \"TH\", the extension \"u-nu-thai\" is automatically added.Serialization During serialization, writeObject writes all fields to the output stream, including extensions.During deserialization, readResolve adds extensions as described in Special Cases, only for the two cases th_TH_TH and ja_JP_JP.Legacy language codes Locale's constructor has always converted three language codes to their earlier, obsoleted forms:he maps to iw, yi maps to ji, and id maps to in.This continues to be the case, in order to not break backwards compatibility.The APIs added in 1.7 map between the old and new language codes, maintaining the old codes internal to Locale (so that getLanguage and toString reflect the old code), but using the new codes in the BCP 47 language tag APIs (so that toLanguageTag reflects the new one).This preserves the equivalence between Locales no matter which code or API is used to construct them.Java's default resource bundle lookup mechanism also implements this mapping, so that resources can be named using either convention, see ResourceBundle.The Locale constructors have always specified that the language and the country param be two characters in length, although in practice they have accepted any length.The specification has now been relaxed to allow language codes of two to eight characters and country (region) codes of two to three characters, and in particular, three-letter language codes and three-digit region codes as specified in the IANA Language Subtag Registry.For compatibility, the implementation still does not impose a length constraint."},
{"description": "ListResourceBundle is an abstract subclass of ResourceBundle that manages resources for a locale in a convenient and easy to use list.Subclasses must override getContents and provide an array, where each item in the array is a pair of objects.The first element of each pair is the key, which must be a String, and the second element is the value associated with that key.The following example shows two members of a resource bundle family with the base name \"MyResources\".\"MyResources\" is the default member of the bundle family, and \"MyResources_fr\" is the French member.These members are based on ListResourceBundle (a related example shows how you can add a bundle to this family that's based on a properties file).The keys in this example are of the form \"s1\" etc.The actual keys are entirely up to your choice, so long as they are the same as the keys you use in your program to retrieve the objects from the bundle.ListResourceBundle { protected Object[]real object, not just string // END OF MATERIAL TO LOCALIZE }; } } public class MyResources_fr extendsListResourceBundle { protected Object[]\"}, // MessageFormat pattern {\"s2\", \"1\"}, // location of {0} in pattern {\"s3\", \"Mon disque\"}, // sample disk name {\"s4\", \"ne contient pas de fichiers\"}, // first ChoiceFormat choice {\"s5\", \"contient un fichier\"}, // second ChoiceFormat choice {\"s6\", \"contient {0,number} fichiers\"}, // third ChoiceFormat choice {\"s7\", \"3 mars 1996\"}, // sample date {\"s8\", new Dimension(1,3)} // real object, not just string // END OF MATERIAL TO LOCALIZE }; } } The implementation of a ListResourceBundle subclass must be thread-safe if it's simultaneously used by multiple threads.The default implementations of the methods in this class are thread-safe."},
{"description": "An event that characterizes a change in selection.The change is limited to a a single inclusive interval.The selection of at least one index within the range will have changed.A decent ListSelectionModel implementation will keep the range as small as possible.ListSelectionListeners will generally query the source of the event for the new selected status of each potentially changed row.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This interface represents the current state of the selection for any of the components that display a list of values with stable indices.The selection is modeled as a set of intervals, each interval represents a contiguous range of selected list elements.The methods for modifying the set of selected intervals all take a pair of indices, index0 and index1, that represent a closed interval, i.e. the interval includes both index0 and index1."},
{"description": "This interface defines the methods components like JList use to get the value of each cell in a list and the length of the list.Logically the model is a vector, indices vary from 0 to ListDataModel.getSize() - 1.Any change to the contents or length of the data model must be reported to all of the ListDataListeners."},
{"description": "The specified MBean listener does not exist in the repository."},
{"description": "An iterator for lists that allows the programmer to traverse the list in either direction, modify the list during iteration, and obtain the iterator's current position in the list.A ListIterator has no current element; its cursor position always lies between the element that would be returned by a call to previous() and the element that would be returned by a call to next().An iterator for a list of length n has n+1 possible cursor positions, as illustrated by the carets (^) below: Element(0) Element(1) Element(2) ...Note that the remove() and set(Object) methods are not defined in terms of the cursor position; they are defined to operate on the last element returned by a call to next() or previous().This interface is a member of the Java Collections Framework."},
{"description": "Defines an event that encapsulates changes to a list.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Identifies components that can be used as \"rubber stamps\" to paint the cells in a JList.For example, to use a JLabel as a ListCellRenderer, you would write something like this: class MyCellRenderer extends JLabel implements ListCellRenderer<Object> { public MyCellRenderer() { setOpaque(true); }// check if this cell represents the current DnD drop location JList.WHITE; // check if this cell is selected } else if (isSelected) { background = Color."},
{"description": "The user of this interface has precise control over where in the list each element is inserted.The user can access elements by their integer index (position in the list), and search for elements in the list.Unlike sets, lists typically allow duplicate elements.More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all.It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare.The List interface places additional stipulations, beyond those specified in the Collection interface, on the contracts of the iterator, add, remove, equals, and hashCode methods.Declarations for other inherited methods are also included here for convenience.The List interface provides four methods for positional (indexed) access to list elements.Lists (like Java arrays) are zero based.Note that these operations may execute in time proportional to the index value for some implementations (the LinkedList class, for example).Thus, iterating over the elements in a list is typically preferable to indexing through it if the caller does not know the implementation.The List interface provides a special iterator, called a ListIterator, that allows element insertion and replacement, and bidirectional access in addition to the normal operations that the Iterator interface provides.A method is provided to obtain a list iterator that starts at a specified position in the list.The List interface provides two methods to search for a specified object.From a performance standpoint, these methods should be used with caution.In many implementations they will perform costly linear searches.The List interface provides two methods to efficiently insert and remove multiple elements at an arbitrary point in the list.Note: While it is permissible for lists to contain themselves as elements, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a list.Some list implementations have restrictions on the elements that they may contain.For example, some implementations prohibit null elements, and some have restrictions on the types of their elements.Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException.Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter.More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the list may throw an exception or it may succeed, at the option of the implementation.Such exceptions are marked as \"optional\" in the specification for this interface.This interface is a member of the Java Collections Framework."},
{"description": "The List component presents the user with a scrolling list of text items.The list can be set up so that the user can choose either one item or multiple items.; lst.add(\"Saturn\"); lst.add(\"Uranus\"); lst.add(\"Neptune\"); lst.add(\"Pluto\"); cnt.add(lst); where cnt is a container, produces the following scrolling list: If the List allows multiple selections, then clicking on an item that is already selected deselects it.In the preceding example, only one item from the scrolling list can be selected at a time, since the second argument when creating the new scrolling list is false.If the List does not allow multiple selections, selecting an item causes any other selected item to be deselected.Note that the list in the example shown was created with four visible rows.Once the list has been created, the number of visible rows cannot be changed.A default List is created with four rows, so that lst = new List() is equivalent to list = new List(4, false).Beginning with Java\u00a01.1, the Abstract Window Toolkit sends the List object all mouse, keyboard, and focus events that occur over it.(The old AWT event model is being maintained only for backwards compatibility, and its use is discouraged.)When an item is selected or deselected by the user, AWT sends an instance of ItemEvent to the list.When the user double-clicks on an item in a scrolling list, AWT sends an instance of ActionEvent to the list following the item event.AWT also generates an action event when the user presses the return key while an item in the list is selected.If an application wants to perform some action based on an item in this list being selected or activated by the user, it should implement ItemListener or ActionListener as appropriate and register the new listener to receive events from this list.For multiple-selection scrolling lists, it is considered a better user interface to use an external gesture (such as clicking on a button) to trigger the action."},
{"description": "This class represents a Reference whose contents is a name, called the link name, that is bound to an atomic name in a context.The name is a URL, or a name to be resolved relative to the initial context, or if the first character of the name is \".\", the name is relative to the context in which the link is bound.Normal resolution of names in context operations always follow links.Resolution of the link name itself may cause resolution to pass through other links.This gives rise to the possibility of a cycle of links whose resolution could not terminate normally.As a simple means to avoid such non-terminating resolutions, service providers may define limits on the number of links that may be involved in any single operation invoked by the caller.A LinkRef contains a single StringRefAddr, whose type is \"LinkAddress\", and whose contents is the link name.The class name field of the Reference is that of this (LinkRef) class.LinkRef is bound to a name using the normal Context.bind()/rebind(), and DirContext.bind()/rebind().() is used to retrieve the link itself if the terminal atomic name is bound to a link.Many naming systems support a native notion of link that may be used within the naming system itself.JNDI does not specify whether there is any relationship between such native links and JNDI links.A LinkRef instance is not synchronized against concurrent access by multiple threads.Threads that need to access a LinkRef instance concurrently should synchronize amongst themselves and provide the necessary locking."},
{"description": "The following table provides a summary description of what the permission allows, and discusses the risks of granting code the permission.What the Permission Allows Risks of Allowing this Permission hard Ability to add an existing file to a directory.This is sometimes known as creating a link, or hard link.Extreme care should be taken when granting this permission.It allows linking to any file or directory in the file system thus allowing the attacker access to all files.Extreme care should be taken when granting this permission.It allows linking to any file or directory in the file system thus allowing the attacker to access to all files."},
{"description": "Defines the options as to how symbolic links are handled."},
{"description": "This exception is thrown when a loop was detected will attempting to resolve a link, or an implementation specific limit on link counts has been reached.Synchronization and serialization issues that apply to LinkException apply directly here."},
{"description": "This exception is used to describe problems encounter while resolving links.Addition information is added to the base NamingException for pinpointing the problem with the link.Analogous to how NamingException captures name resolution information, LinkException captures \"link\"-name resolution information pinpointing the problem encountered while resolving a link.Link Resolved Name.Portion of link name that has been resolved.Link Resolved Object.Object to which resolution of link name proceeded.Portion of link name that has not been resolved.A LinkException instance is not synchronized against concurrent multithreaded access.Multiple threads trying to access and modify a single LinkException instance should lock the object."},
{"description": "The head of the queue is that element that has been on the queue the longest time for some producer.The tail of the queue is that element that has been on the queue the shortest time for some producer.Beware that, unlike in most collections, the size method is NOT a constant-time operation.Because of the asynchronous nature of these queues, determining the current number of elements requires a traversal of the elements, and so may report inaccurate results if this collection is modified during traversal.For example, an iterator operating concurrently with an addAll operation might view only some of the added elements.This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces.This class is a member of the Java Collections Framework."},
{"description": "All of the operations perform as could be expected for a doubly-linked list.Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.If multiple threads access a linked list concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally.(A structural modification is any operation that adds or deletes one or more elements; merely setting the value of an element is not a structural modification.)This is typically accomplished by synchronizing on some object that naturally encapsulates the list.If no such object exists, the list should be \"wrapped\" using the Collections.synchronizedList method.This is best done at creation time, to prevent accidental unsynchronized access to the list:; The iterators returned by this class's iterator and listIterator methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the Iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException.Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast iterators throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.This class is a member of the Java Collections Framework."},
{"description": "The head of the queue is that element that has been on the queue the longest time.The tail of the queue is that element that has been on the queue the shortest time.New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.Linked queues typically have higher throughput than array-based queues but less predictable performance in most concurrent applications.The optional capacity bound constructor argument serves as a way to prevent excessive queue expansion.The capacity, if unspecified, is equal to Integer.Linked nodes are dynamically created upon each insertion unless this would bring the queue above capacity.This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces.This class is a member of the Java Collections Framework."},
{"description": "This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries.This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order).Note that insertion order is not affected if a key is re-inserted into the map.(A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)This implementation spares its clients from the unspecified, generally chaotic ordering provided by HashMap (and Hashtable), without incurring the increased cost associated with TreeMap.It can be used to produce a copy of a map that has the same order as the original, regardless of the original map's implementation: void foo(Map m){ Map copy = new LinkedHashMap(m); ... } This technique is particularly useful if a module takes a map on input, copies it, and later returns results whose order is determined by that of the copy.(Clients generally appreciate having things returned in the same order they were presented.)A special constructor is provided to create a linked hash map whose order of iteration is the order in which its entries were last accessed, from least-recently accessed to most-recently (access-order).This kind of map is well-suited to building LRU caches.Invoking the put, putIfAbsent, get, getOrDefault, compute, computeIfAbsent, computeIfPresent, or merge methods results in an access to the corresponding entry (assuming it exists after the invocation completes).The replace methods only result in an access of the entry if the value is replaced.The putAll method generates one entry access for each mapping in the specified map, in the order that key-value mappings are provided by the specified map's entry set iterator.No other methods generate entry accesses.In particular, operations on collection-views do not affect the order of iteration of the backing map.Entry) method may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map.This class provides all of the optional Map operations, and permits null elements.Like HashMap, it provides constant-time performance for the basic operations (add, contains and remove), assuming the hash function disperses elements properly among the buckets.Performance is likely to be just slightly below that of HashMap, due to the added expense of maintaining the linked list, with one exception: Iteration over the collection-views of a LinkedHashMap requires time proportional to the size of the map, regardless of its capacity.Iteration over a HashMap is likely to be more expensive, requiring time proportional to its capacity.A linked hash map has two parameters that affect its performance: initial capacity and load factor.They are defined precisely as for HashMap.Note, however, that the penalty for choosing an excessively high value for initial capacity is less severe for this class than for HashMap, as iteration times for this class are unaffected by capacity.If multiple threads access a linked hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally.This is typically accomplished by synchronizing on some object that naturally encapsulates the map.If no such object exists, the map should be \"wrapped\" using the Collections.synchronizedMap method.This is best done at creation time, to prevent accidental unsynchronized access to the map:Map m = Collections.synchronizedMap(new LinkedHashMap(...)); A structural modification is any operation that adds or deletes one or more mappings or, in the case of access-ordered linked hash maps, affects iteration order.In insertion-ordered linked hash maps, merely changing the value associated with a key that is already contained in the map is not a structural modification.In access-ordered linked hash maps, merely querying the map with get is a structural modification. )The iterators returned by the iterator method of the collections returned by all of this class's collection view methods are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException.Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast iterators throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.The spliterators returned by the spliterator method of the collections returned by all of this class's collection view methods are late-binding, fail-fast, and additionally report Spliterator.This class is a member of the Java Collections Framework."},
{"description": "This implementation differs from HashSet in that it maintains a doubly-linked list running through all of its entries.This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order).Note that insertion order is not affected if an element is re-inserted into the set.(An element e is reinserted into a set s if s.add(e) is invoked when s.contains(e) would return true immediately prior to the invocation.)This implementation spares its clients from the unspecified, generally chaotic ordering provided by HashSet, without incurring the increased cost associated with TreeSet.It can be used to produce a copy of a set that has the same order as the original, regardless of the original set's implementation:{ Set copy = new LinkedHashSet(s); ... } This technique is particularly useful if a module takes a set on input, copies it, and later returns results whose order is determined by that of the copy.(Clients generally appreciate having things returned in the same order they were presented.)This class provides all of the optional Set operations, and permits null elements.Like HashSet, it provides constant-time performance for the basic operations (add, contains and remove), assuming the hash function disperses elements properly among the buckets.Performance is likely to be just slightly below that of HashSet, due to the added expense of maintaining the linked list, with one exception: Iteration over a LinkedHashSet requires time proportional to the size of the set, regardless of its capacity.Iteration over a HashSet is likely to be more expensive, requiring time proportional to its capacity.A linked hash set has two parameters that affect its performance: initial capacity and load factor.They are defined precisely as for HashSet.Note, however, that the penalty for choosing an excessively high value for initial capacity is less severe for this class than for HashSet, as iteration times for this class are unaffected by capacity.If multiple threads access a linked hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally.This is typically accomplished by synchronizing on some object that naturally encapsulates the set.If no such object exists, the set should be \"wrapped\" using the Collections.synchronizedSet method.This is best done at creation time, to prevent accidental unsynchronized access to the set:Set s = Collections.synchronizedSet(new LinkedHashSet(...)); The iterators returned by this class's iterator method are fail-fast:if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException.Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast iterators throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.This class is a member of the Java Collections Framework."},
{"description": "Subclasses of LinkageError indicate that a class has some dependency on another class; however, the latter class has incompatibly changed after the compilation of the former class."},
{"description": "A LineUnavailableException is an exception indicating that a line cannot be opened because it is unavailable.This situation arises most commonly when a requested line is already in use by another application."},
{"description": "The optional capacity bound constructor argument serves as a way to prevent excessive expansion.The capacity, if unspecified, is equal to Integer.Linked nodes are dynamically created upon each insertion unless this would bring the deque above capacity.Most operations run in constant time (ignoring time spent blocking).Exceptions include remove, removeFirstOccurrence, removeLastOccurrence, contains, iterator.remove(), and the bulk operations, all of which run in linear time.This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces.This class is a member of the Java Collections Framework."},
{"description": "A buffered character-input stream that keeps track of line numbers.This class defines methods setLineNumber(int) and getLineNumber() for setting and getting the current line number respectively.By default, line numbering begins at 0.This number increments at every line terminator as the data is read, and can be changed with a call to setLineNumber(int).Note however, that setLineNumber(int) does not actually change the current position in the stream; it only changes the value that will be returned by getLineNumber().A line is considered to be terminated by any one of a line feed ('\\n'), a carriage return ('\\r'), or a carriage return followed immediately by a linefeed."},
{"description": "Instances of classes that implement the LineListener interface can register to receive events when a line's status changes."},
{"description": "This class incorrectly assumes that bytes adequately represent characters.As of JDK\u00a01.1, the preferred way to operate on character streams is via the new character-stream classes, which include a class for counting line numbers."},
{"description": "Type inner class identifies what kind of event occurred on a line.Static instances are provided for the common types (OPEN, CLOSE, START, and STOP)."},
{"description": "The LineMetrics class allows access to the metrics needed to layout characters along a line and to layout of a set of lines.A LineMetrics object encapsulates the measurement information associated with a run of text.Fonts can have different metrics for different ranges of characters.The getLineMetrics methods of Font take some text as an argument and return a LineMetrics object describing the metrics of the initial number of characters in that text, as returned by getNumChars()."},
{"description": "The LineBreakMeasurer class allows styled text to be broken into lines (or segments) that fit within a particular visual advance.This is useful for clients who wish to display a paragraph of text that fits within a specific width, called the wrapping width.LineBreakMeasurer is constructed with an iterator over styled text.The iterator's range should be a single paragraph in the text.LineBreakMeasurer maintains a position in the text for the start of the next text segment.Initially, this position is the start of text.Paragraphs are assigned an overall direction (either left-to-right or right-to-left)All segments obtained from a paragraph have the same direction as the paragraph.Segments of text are obtained by calling the method nextLayout, which returns a TextLayout representing the text that fits within the wrapping width.The nextLayout method moves the current position to the end of the layout returned from nextLayout.LineBreakMeasurer implements the most commonly used line-breaking policy: Every word that fits within the wrapping width is placed on the line.If the first word does not fit, then all of the characters that fit within the wrapping width are placed on the line.At least one character is placed on each line.The TextLayout instances returned by LineBreakMeasurer treat tabs like 0-width spaces.Clients who wish to obtain tab-delimited segments for positioning should use the overload of nextLayout which takes a limiting offset in the text.The limiting offset should be the first character after the tab.The TextLayout objects returned from this method end at the limit provided (or before, if the text between the current position and the limit won't fit entirely within the wrapping width).Clients who are laying out tab-delimited text need a slightly different line-breaking policy after the first segment has been placed on a line.Instead of fitting partial words in the remaining space, they should place words which don't fit in the remaining space entirely on the next line.This change of policy can be requested in the overload of nextLayout which takes a boolean parameter.If this parameter is true, nextLayout returns null if the first word won't fit in the given space.In general, if the text used to construct the LineBreakMeasurer changes, a new LineBreakMeasurer must be constructed to reflect the change.(The old LineBreakMeasurer continues to function properly, but it won't be aware of the text change.)Nevertheless, if the text change is the insertion or deletion of a single character, an existing LineBreakMeasurer can be 'updated' by calling insertChar or deleteChar.Updating an existing LineBreakMeasurer is much faster than creating a new one.Clients who modify text based on user typing should take advantage of these methods.; // let styledText be an AttributedCharacterIterator containing at least // one character LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, frc); float wrappingWidth = getSize().width - 15; while (measurer.getPosition() < fStyledText.length()) { TextLayout layout = measurer.nextLayout(wrappingWidth);For simplicity, the overall text direction is assumed to be left-to-rightpublic void paint(Graphics graphics) { float leftMargin = 10, rightMargin = 310; float[] tabStops = { 100, 250 }; //assume styledText is an AttributedCharacterIterator, and the number // of tabs in styledText is tabCount int[] tabLocations = new int[tabCount+1]; int i = 0; for (char c = styledText.first(); c !=Now tabLocations has an entry for every tab's offset in // the text.For convenience, the last entry is tabLocations // is the offset of the last character in the text.LineBreakMeasurer measurer = new LineBreakMeasurer(styledText); int currentTab = 0; float verticalPos = 20; while (measurer.getPosition() < styledText.getEndIndexAll segments on a line // must be computed before any drawing can occur, since //we must know the largest ascent on the line.TextLayouts are computed and stored in a Vector; // their horizontal positions are stored in a parallel // Vector.false; boolean lineComplete = false; float maxAscent = 0, maxDescent = 0; float horizontalPos = leftMargin; Vector layouts = new Vector(1); Vector penPositions = new Vector(1); while (!lineComplete) { float wrappingWidth = rightMargin - horizontalPos; TextLayout layout ="},
{"description": "This Line2D represents a line segment in (x,y) coordinate space.This class, like all of the Java 2D API, uses a default coordinate system called user space in which the y-axis values increase downward and x-axis values increase to the right.This class is only the abstract superclass for all objects that store a 2D line segment.The actual storage representation of the coordinates is left to the subclass."},
{"description": "Info object contains information about a line.Info itself is the Java class of the line.Info adds other kinds of information about the line.This additional information depends on which Line subinterface is implemented by the kind of line that the Line.Info can be retrieved using various methods of the Line, Mixer, and AudioSystem interfaces.Other such methods let you pass a Line.Info as an argument, to learn whether lines matching the specified configuration are available and to obtain them."},
{"description": "The LineEvent class encapsulates information that a line sends its listeners whenever the line opens, closes, starts, or stops.Each of these four state changes is represented by a corresponding type of event.A listener receives the event as a parameter to its update method.By querying the event, the listener can learn the type of event, the line responsible for the event, and how much data the line had processed when the event occurred.Although this class implements Serializable, attempts to serialize a LineEvent object will fail."},
{"description": "The LinearGradientPaint class provides a way to fill a Shape with a linear color gradient pattern.The user may specify two or more gradient colors, and this paint will provide an interpolation between each color.The user also specifies start and end points which define where in user space the color gradient should begin and end.The user must provide an array of floats specifying how to distribute the colors along the gradient.These values should range from 0.0 to 1.0 and act like keyframes along the gradient (they mark where the gradient should be exactly a particular color).In the event that the user does not set the first keyframe value equal to 0 and/or the last keyframe value equal to 1, keyframes will be created at these positions and the first and last colors will be replicated there.So, if a user specifies the following arrays to construct a gradient: {Color.RED}, {.3f, .7f} this will be converted to a gradient with the following keyframes: {Color.The user may also select what action the LinearGradientPaint object takes when it is filling the space outside the start and end points by setting CycleMethod to either REFLECTION or REPEAT.The distances between any two colors in any of the reflected or repeated copies of the gradient are the same as the distance between those same two colors between the start and end points.Note that some minor variations in distances may occur due to sampling at the granularity of a pixel.If no cycle method is specified, NO_CYCLE will be chosen by default, which means the endpoint colors will be used to fill the remaining area.The colorSpace parameter allows the user to specify in which colorspace the interpolation should be performed, default sRGB or linearized RGB.The following code demonstrates typical usage of LinearGradientPaint:Point2D start = new Point2D.Float(0, 0); Point2D end = new Point2D.Float(50, 50); float[] dist = {0.0f, 0.2f, 1.0f}; Color[] colors = {Color.; This code will create a LinearGradientPaint which interpolates between red and white for the first 20% of the gradient and between white and blue for the remaining 80%.This image demonstrates the example code above for each of the three cycle methods:"},
{"description": "A class which implements a line border of arbitrary thickness and of a single color.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The Line interface represents a mono or multi-channel audio feed.A line is an element of the digital audio \"pipeline,\" such as a mixer, an input or output port, or a data path into or out of a mixer.A line can have controls, such as gain, pan, and reverb.The controls themselves are instances of classes that extend the base Control class.The Line interface provides two accessor methods for obtaining the line's controls: getControls returns the entire set, and getControl returns a single control of specified type.Lines exist in various states at different times.When a line opens, it reserves system resources for itself, and when it closes, these resources are freed for other objects or applications.An open line need not be processing data, however.Such processing is typically initiated by subinterface methods such as SourceDataLine.write and TargetDataLine.read.You can register an object to receive notifications whenever the line's state changes.The object must implement the LineListener interface, which consists of the single method update.This method will be invoked when a line opens and closes (and, if it's a DataLine, when it starts and stops).An object can be registered to listen to multiple lines.The event it receives in its update method will specify which line created the event, what type of event it was (OPEN, CLOSE, START, or STOP), and how many sample frames the line had processed at the time the event occurred.Certain line operations, such as open and close, can generate security exceptions if invoked by unprivileged code when the line is a shared audio resource."},
{"description": "This exception is thrown when a method terminates abnormally due to a user or system specified limit.This is different from a InsufficientResourceException in that LimitExceededException is due to a user/system specified limit.For example, running out of memory to complete the request would be an insufficient resource.The client asking for 10 answers and getting back 11 is a size limit exception.Examples of these limits include client and server configuration limits such as size, time, number of hops, etc.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "The LifespanPolicy specifies the lifespan of the objects implemented in the created POA.The default is TRANSIENT."},
{"description": "The LifespanPolicy specifies the lifespan of the objects implemented in the created POA.The default is TRANSIENT."},
{"description": "The LifespanPolicyValue can have the following values.The objects implemented in the POA cannot outlive the POA instance in which they are first created.PERSISTENT - The objects implemented in the POA can outlive the process in which they are first created."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This is an optional extension handler for SAX2 to provide lexical information about an XML document, such as comments and CDATA section boundaries.XML readers are not required to recognize this handler, and it is not part of core-only SAX2 distributions.The events in the lexical handler apply to the entire document, not just to the document element, and all lexical handler events must appear between the content handler's startDocument and endDocument events.If the reader does not report lexical events, it will throw a SAXNotRecognizedException when you attempt to register the handler."},
{"description": "The Level class defines a set of standard logging levels that can be used to control logging output.The logging Level objects are ordered and are specified by ordered integers.Enabling logging at a given level also enables logging at all higher levels.Clients should normally use the predefined Level constants such as Level.The levels in descending order are: SEVERE (highest value)In addition there is a level OFF that can be used to turn off logging, and a level ALL that can be used to enable logging of all messages.It is possible for third parties to define additional logging levels by subclassing Level.In such cases subclasses should take care to chose unique integer level values and to ensure that they maintain the Object uniqueness property across serialization by defining a suitable readResolve method."},
{"description": "A lease contains a unique VM identifier and a lease duration.A Lease object is used to request and grant leases to remote object references."},
{"description": "This abstract class is used to represent an LDAP referral exception.It extends the base ReferralException by providing a getReferralContext() method that accepts request controls.LdapReferralException is an abstract class.Concrete implementations of it determine its synchronization and serialization properties.A Control[] array passed as a parameter to the getReferralContext() method is owned by the caller.The service provider will not modify the array or keep a reference to it, although it may keep references to the individual Control objects in the array."},
{"description": "ComponentPlacement is an enumeration of the possible ways two components can be placed relative to each other.ComponentPlacement is used by the LayoutStyle method getPreferredGap."},
{"description": "Parameters used as input for the LDAP CertStore algorithm.This class is used to provide necessary configuration parameters (server name and port number) to implementations of the LDAP CertStore algorithm.Unless otherwise specified, the methods defined in this class are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "LayoutStyle provides information about how to position components.This class is primarily useful for visual tools and layout managers.Most developers will not need to use this class.You typically don't set or create a LayoutStyle."},
{"description": "This interface represents a context in which you can perform operations with LDAPv3-style controls and perform LDAPv3-style extended operations.For applications that do not require such controls or extended operations, the more generic javax.naming.directory.DirContext should be used instead.This interface provides support for LDAP v3 controls.At a high level, this support allows a user program to set request controls for LDAP operations that are executed in the course of the user program's invocation of Context/DirContext methods, and read response controls resulting from LDAP operations.At the implementation level, there are some details that developers of both the user program and service providers need to understand in order to correctly use request and response controls.There are two types of request controls:Request controls that affect how a connection is created Request controls that affect context methodsThe former is used whenever a connection needs to be established or re-established with an LDAP server.The latter is used when all other LDAP operations are sent to the LDAP server.The reason why a distinction between these two types of request controls is necessary is because JNDI is a high-level API that does not deal directly with connections.It is the job of service providers to do any necessary connection management.Consequently, a single connection may be shared by multiple context instances, and a service provider is free to use its own algorithms to conserve connection and network usage.Thus, when a method is invoked on the context instance, the service provider might need to do some connection management in addition to performing the corresponding LDAP operations.For connection management, it uses the connection request controls, while for the normal LDAP operations, it uses the context request controls.Unless explicitly qualified, the term \"request controls\" refers to context request controls.There are two ways in which a context instance gets its request controls: ldapContext.newInstance(reqCtls)ldapContext.setRequestControls(reqCtls) where ldapContext is an instance of LdapContext.Specifying null or an empty array for reqCtls means no request controls.newInstance() creates a new instance of a context using reqCtls, while setRequestControls() updates an existing context instance's request controls to reqCtls.Unlike environment properties, request controls of a context instance are not inherited by context instances that are derived from it.Derived context instances have null as their context request controls.You must set the request controls of a derived context instance explicitly using setRequestControls().A context instance's request controls are retrieved using the method getRequestControls().There are three ways in which connection request controls are set: new InitialLdapContext(env, connCtls) refException.getReferralContext(env, connCtls) ldapContext.reconnect(connCtls); where refException is an instance of LdapReferralException, and ldapContext is an instance of LdapContext.Specifying null or an empty array for connCtls means no connection request controls.Like environment properties, connection request controls of a context are inherited by contexts that are derived from it.Typically, you initialize the connection request controls using the InitialLdapContext constructor or LdapReferralContext.getReferralContext().These connection request controls are inherited by contexts that share the same connection--that is, contexts derived from the initial or referral contexts.Invoking ldapContext.reconnect() affects only the connection used by ldapContext and any new contexts instances that are derived form ldapContext.Contexts that previously shared the connection with ldapContext remain unchanged.That is, a context's connection request controls must be explicitly changed and is not affected by changes to another context's connection request controls.A context instance's connection request controls are retrieved using the method getConnectControls().A service provider supports connection and context request controls in the following ways.Context request controls must be associated on a per context instance basis while connection request controls must be associated on a per connection instance basis.The service provider must look for the connection request controls in the environment property \"java.naming.ldap.control.connect\" and pass this environment property on to context instances that it creates.The method LdapContext.getResponseControls() is used to retrieve the response controls generated by LDAP operations executed as the result of invoking a Context/DirContext operation.The result is all of the responses controls generated by the underlying LDAP operations, including any implicit reconnection.A Control[] array passed as a parameter to any method is owned by the caller.The service provider will not modify the array or keep a reference to it, although it may keep references to the individual Control objects in the array.A Control[] array returned by any method is immutable, and may not subsequently be modified by either the caller or the service provider."},
{"description": "This class represents a distinguished name as specified by RFC 2253.A distinguished name, or DN, is composed of an ordered list of components called relative distinguished names, or RDNs.Details of a DN's syntax are described in RFC 2253.This class resolves a few ambiguities found in RFC 2253 as follows: RFC 2253 leaves the term \"whitespace\" undefined.(\" \") is used in its place.Whitespace is allowed on either side of ',', ';', '=', and '+'.Such whitespace is accepted but not generated by this code, and is ignored when comparing names.String names passed to LdapName or returned by it use the full Unicode character set.They may also contain characters encoded into UTF-8 with each octet represented by a three-character substring such as \"\\\\B4\".They may not, however, contain characters encoded into UTF-8 with each octet represented by a single character in the string: the meaning would be ambiguous.LdapName will properly parse all valid names, but does not attempt to detect all possible violations when parsing invalid names.It is \"generous\" in accepting invalid names.The \"validity\" of a name is determined ultimately when it is supplied to an LDAP server, which may accept or reject the name based on factors such as its schema information and interoperability considerations.When names are tested for equality, attribute types, both binary and string values, are case-insensitive.String values with different but equivalent usage of quoting, escaping, or UTF8-hex-encoding are considered equal.The components of a LDAP name, that is, RDNs, are numbered.The indexes of a LDAP name with n RDNs range from 0 to n-1.This range may be written as [0,n).The right most RDN is at index 0, and the left most RDN is at index n-1.For example, the distinguished name: \"CN=Steve Kille, O=Isode Limited, C=GB\" is numbered in the following sequence ranging from 0 to 2: {C=GB, O=An empty LDAP name is represented by an empty RDN list.Concurrent multithreaded read-only access of an instance of LdapName need not be synchronized.Unless otherwise noted, the behavior of passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown."},
{"description": "Defines an interface for classes that know how to layout Containers based on a layout constraints object.This interface extends the LayoutManager interface to deal with layouts explicitly in terms of constraint objects that specify how and where components should be added to the layout.This minimal extension to LayoutManager is intended for tool providers who wish to the creation of constraint-based layouts.It does not yet provide full, general support for custom constraint-based layout managers."},
{"description": "Graphics, javax.swing.JComponent) method performs the painting of the JLayer and eventDispatched(AWTEvent, JLayer) method is notified about any AWTEvents which have been generated by a JLayer or any of its subcomponents.The LayerUI differs from the UI delegates of the other components, because it is LookAndFeel independent and is not updated by default when the system LookAndFeel is changed.The subclasses of LayerUI can either be stateless and shareable by multiple JLayers or not shareable."},
{"description": "This is an exception that is thrown whenever an attempt is made to delete the last owner of an Access Control List."},
{"description": "LayoutPath provides a mapping between locations relative to the baseline and points in user space.Locations consist of an advance along the baseline, and an offset perpendicular to the baseline at the advance.Positive values along the perpendicular are in the direction that is 90 degrees clockwise from the baseline vector.Locations are represented as a Point2D, where x is the advance and y is the offset."},
{"description": "Defines the interface for classes that know how to lay out Containers.Swing's painting architecture assumes the children of a JComponent do not overlap."},
{"description": "A SortingFocusTraversalPolicy which sorts Components based on their size, position, and orientation.Based on their size and position, Components are roughly categorized into rows and columns.For a Container with horizontal orientation, columns run left-to-right or right-to-left, and rows run top- to-bottom.For a Container with vertical orientation, columns run top-to- bottom and rows run left-to-right or right-to-left.All columns in a row are fully traversed before proceeding to the next row."},
{"description": "Underlying security services instantiate and pass a LanguageCallback to the handle method of a CallbackHandler to retrieve the Locale used for localizing text."},
{"description": "A LabelView is a styled chunk of text that represents a view mapped over an element in the text model.It caches the character level attributes used for rendering."},
{"description": "Methods to facilitate the creation of simple \"function objects\" that implement one or more interfaces by delegation to a provided MethodHandle, possibly after type adaptation and partial evaluation of arguments.These methods are typically used as bootstrap methods for invokedynamic call sites, to support the lambda expression and method reference expression features of the Java Programming Language.Indirect access to the behavior specified by the provided MethodHandle proceeds in order through three phases: Linkage occurs when the methods in this class are invoked.They take as arguments an interface to be implemented (typically a functional interface, one with a single abstract method), a name and signature of a method from that interface to be implemented, a method handle describing the desired implementation behavior for that method, and possibly other additional metadata, and produce a CallSite whose target can be used to create suitable function objects.Linkage may involve dynamically loading a new class that implements the target interface.The CallSite can be considered a \"factory\" for function objects and so these linkage methods are referred to as \"metafactories\".Capture occurs when the CallSite's target is invoked, typically through an invokedynamic call site, producing a function object.This may occur many times for a single factory CallSite.Capture may involve allocation of a new function object, or may return an existing function object.The behavior MethodHandle may have additional parameters beyond those of the specified interface method; these are referred to as captured parameters, which must be provided as arguments to the CallSite target, and which may be early-bound to the behavior MethodHandle.The number of captured parameters and their types are determined during linkage.Invocation occurs when an implemented interface method is invoked on a function object.This may occur many times for a single function object.The method referenced by the behavior MethodHandle is invoked with the captured arguments and any additional arguments provided on invocation, as if by MethodHandle.invoke(Object...).It is sometimes useful to restrict the set of inputs or results permitted at invocation.For example, when the generic interface Predicate<T> is parameterized as Predicate<String>, the input must be a String, even though the method to implement allows any Object.At linkage time, an additional MethodType parameter describes the \"instantiated\" method type; on invocation, the arguments and eventual result are checked against this MethodType.This class provides two forms of linkage methods: a standard version (metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)) using an optimized protocol, and an alternate version altMetafactory(MethodHandles.The alternate version is a generalization of the standard version, providing additional control over the behavior of the generated function objects via flags and additional arguments.The alternate version adds the ability to manage the following attributes of function objects: Bridging.It is sometimes useful to implement multiple variations of the method signature, involving argument or return type adaptation.This occurs when multiple distinct VM signatures for a method are logically considered to be the same method by the language.The flag FLAG_BRIDGES indicates that a list of additional MethodTypes will be provided, each of which will be implemented by the resulting function object.These methods will share the same name and instantiated type.If needed, more than one interface can be implemented by the function object.(These additional interfaces are typically marker interfaces with no methods.)The flag FLAG_MARKERS indicates that a list of additional interfaces will be provided, each of which should be implemented by the resulting function object.The generated function objects do not generally support serialization.Serializable function objects will use, as their serialized form, instances of the class SerializedLambda, which requires additional assistance from the capturing class (the class described by the MethodHandles.invokedType (describing the CallSite signature) has K parameters of types (D1..Dk) and return type Rd;samMethodType (describing the implemented method type) has N parameters, of types (U1..Un) and return type Ru;implMethod (the MethodHandle providing the implementation has M parameters, of types (A1..Am) and return type Ra (if the method describes an instance method, the method type of this method handle already includes an extra first argument corresponding to the receiver); instantiatedMethodType (allowing restrictions on invocation) has N parameters, of types (T1..Then the following linkage invariants must hold: Rd is an interface implMethod isa direct method handle samMethodType and instantiatedMethodType have the same arity N, and for i=1..N, Ti and Ui are the same type, or Ti and Ui are both reference types and Ti is a subtype of UiEither Rt and Ru are the same type, or both are reference types and Rt is a subtype of Ru K + N =..N, Ti is adaptable to Aj, where j=i+kThe return type Rt is void, or the return type Ra is not void and is adaptable to Rt Further, at capture time, if implMethod corresponds to an instance method, and there are any capture arguments (K > 0), then the first capture argument (corresponding to the receiver) must be non-null.A type Q is considered adaptable to S as follows: QSLink-time checksInvocation-time checksPrimitivePrimitive Q can be converted to S via a primitive widening conversionNone PrimitiveReference S is a supertype of the Wrapper(Q): Q is a primitive wrapper and Primitive(Q) can be widened to S for return types: If Q is a primitive wrapper, check that Primitive(Q) can be widened to SIf Q is not a primitive wrapper, cast Q to the base Wrapper(S); for example Number for numeric types ReferenceReference for parameter types: S is a supertype of Q for return types: none Cast from Q to S"},
{"description": "A Label object is a component for placing text in a container.A label displays a single line of read-only text.The text can be changed by the application, but a user cannot edit it directly.CENTER, 10, 10)); add(new Label(\"Hi There!\"));add(new Label(\"Another Label\")); produces the following labels:"},
{"description": "A KeyValue object contains a single public key that may be useful in validating the signature.The XML schema definition is defined as: <element name=\"KeyValue\" type=\"ds:KeyValueType\"/> <complexType name=\"KeyValueTypeA KeyValue instance may be created by invoking the newKeyValue method of the KeyInfoFactory class, and passing it a PublicKey representing the value of the public key.Here is an example of creating a KeyValue from a DSAPublicKey of a Certificate stored in a KeyStore: KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType; PublicKey dsaPublicKey = keyStore.getCertificate(\"myDSASigningCert\").getPublicKey(); KeyInfoFactory factory = KeyInfoFactory.getInstance(\"DOM\"); KeyValue keyValue = factory.newKeyValue(dsaPublicKey); This class returns the DSAKeyValue and RSAKeyValue elements as objects of type DSAPublicKey and RSAPublicKey, respectively.Note that not all of the fields in the schema are accessible as parameters of these types."},
{"description": "This class encapsulates a keytab file.A Kerberos JAAS login module that obtains long term secret keys from a keytab file should use this class.The login module will store an instance of this class in the private credential set of a Subject during the commit phase of the authentication process.If a KeyTab object is obtained from getUnboundInstance() or getUnboundInstance(java.io.File), it is unbound and thus can be used by any service principal.Otherwise, if it's obtained from getInstance(KerberosPrincipal) or getInstance(KerberosPrincipal, java.io.File), it is bound to the specific service principal and can only be used by it.File) were created when there was no support for unbound keytabs.An object created with either of these methods are considered to be bound to an unknown principal, which means, its isBound() returns true and getPrincipal() returns null.It might be necessary for the application to be granted a PrivateCredentialPermission if it needs to access the KeyTab instance from a Subject.This permission is not needed when the application depends on the default JGSS Kerberos mechanism to access the KeyTab.In that case, however, the application will need an appropriate ServicePermission.The keytab file format is described at http://www.ioplex.com/utilities/keytab.txt."},
{"description": "A KeyStroke represents a key action on the keyboard, or equivalent input device.KeyStrokes can correspond to only a press or release of a particular key, just as KEY_PRESSED and KEY_RELEASED KeyEvents do; alternately, they can correspond to typing a specific Java character, just as KEY_TYPED KeyEvents do.In all cases, KeyStrokes can specify modifiers (alt, shift, control, meta, altGraph, or a combination thereof) which must be present during the action for an exact match.KeyStrokes are used to define high-level (semantic) action events.Instead of trapping every keystroke and throwing away the ones you are not interested in, those keystrokes you care about automatically initiate actions on the Components with which they are registered.Client code cannot create a KeyStroke; a variant of getKeyStroke must be used instead.These factory methods allow the KeyStroke implementation to cache and share instances efficiently.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class defines the Service Provider Interface (SPI) for the KeyStore class.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a keystore for a particular keystore type."},
{"description": "This is the generic KeyStore exception."},
{"description": "A parameters object for X509KeyManagers that encapsulates a List of KeyStore."},
{"description": "A KeyStore entry that holds a trusted Certificate."},
{"description": "The information stored in a ProtectionParameter object protects the contents of a keystore.For example, protection parameters may be used to check the integrity of keystore data, or to protect the confidentiality of sensitive keystore data (such as a PrivateKey)."},
{"description": "A KeyStore entry that holds a PrivateKey and corresponding certificate chain."},
{"description": "A KeyStore entry that holds a SecretKey."},
{"description": "It comprises a name and one or more values."},
{"description": "An instance of this class encapsulates the information needed to instantiate and initialize a KeyStore object.This makes it possible to decouple configuration from KeyStore object creation and e.g. delay a password prompt until it is needed."},
{"description": "A (transparent) specification of the key material that constitutes a cryptographic key.If the key is stored on a hardware device, its specification may contain information that helps identify the key on the device.A key may be specified in an algorithm-specific way, or in an algorithm-independent encoding format (such as ASN.1).For example, a DSA private key may be specified by its components x, p, q, and g (see DSAPrivateKeySpec), or it may be specified using its DER encoding (see PKCS8EncodedKeySpec).This interface contains no methods or constants.Its only purpose is to group (and provide type safety for) all key specifications.All key specifications must implement this interface."},
{"description": "This class represents a storage facility for cryptographic keys and certificates.A KeyStore manages different types of entries.Each type of entry implements the KeyStore.This type of entry holds a cryptographic PrivateKey, which is optionally stored in a protected format to prevent unauthorized access.It is also accompanied by a certificate chain for the corresponding public key.Private keys and certificate chains are used by a given entity for self-authentication.Applications for this authentication include software distribution organizations which sign JAR files as part of releasing and/or licensing software.This type of entry holds a cryptographic SecretKey, which is optionally stored in a protected format to prevent unauthorized access.This type of entry contains a single public key Certificate belonging to another party.It is called a trusted certificate because the keystore owner trusts that the public key in the certificate indeed belongs to the identity identified by the subject (owner) of the certificate.This type of entry can be used to authenticate other parties.Each entry in a keystore is identified by an \"alias\" string.In the case of private keys and their associated certificate chains, these strings distinguish among the different ways in which the entity may authenticate itself.For example, the entity may authenticate itself using different certificate authorities, or using different public key algorithms.In order to avoid problems, it is recommended not to use aliases in a KeyStore that only differ in case.Whether keystores are persistent, and the mechanisms used by the keystore if it is persistent, are not specified here.This allows use of a variety of techniques for protecting sensitive (e.g., private or secret) keys.Smart cards or other integrated cryptographic engines (SafeKeyper) are one option, and simpler mechanisms such as files may also be used (in a variety of formats).Typical ways to request a KeyStore object include relying on the default type and providing a specific keystore type.To rely on the default type: KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType()); The system will return a keystore implementation for the default type.To provide a specific keystore type: KeyStore ks = KeyStore.getInstance(\"JKS\"); The system will return the most preferred implementation of the specified keystore type available in the environment.getPassword(); try (FileInputStream fis = new FileInputStream(\"keyStoreName\")) { ks.load(fis, password); } To create an empty keystore using the above load method, pass null as the InputStream argument.Once the keystore has been loaded, it is possible to read existing entries from the keystore, or to write new entries into the keystore:ks.setEntry(\"secretKeyAlias\", skEntry, protParam); // store away the keystore try (FileOutputStream fos = new FileOutputStream(\"newKeyStoreName\")) { ks.store(fos, password); } Note that although the same password may be used to load the keystore, to protect the private key entry, to protect the secret key entry, and to store the keystore (as is shown in the sample code above), different passwords or other protection parameters may also be used.Every implementation of the Java platform is required to support the following standard KeyStore type:PKCS12 This type is described in the KeyStore section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other types are supported."},
{"description": "At a minimum, a KeySelectorResult contains the Key selected by the KeySelector.Implementations of this interface may add methods to return implementation or algorithm specific information, such as a chain of certificates or debugging information."},
{"description": "A KeySelectorException can contain a cause: another throwable that caused this KeySelectorException to get thrown."},
{"description": "The purpose of the key that is to be selected."},
{"description": "A selector that finds and returns a key using the data contained in a KeyInfo object.An example of an implementation of this class is one that searches a KeyStore for trusted keys that match information contained in a KeyInfo."},
{"description": "Note that a serialized Key may contain sensitive information which should not be exposed in untrusted environments."},
{"description": "This class defines the Service Provider Interface (SPI) for the KeyPairGenerator class, which is used to generate pairs of public and private keys.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a key pair generator for a particular algorithm.In case the client does not explicitly initialize the KeyPairGenerator (via a call to an initialize method), each provider must supply (and document) a default initialization.For example, the Sun provider uses a default modulus size (keysize) of 1024 bits."},
{"description": "The KeyPairGenerator class is used to generate pairs of public and private keys.Key pair generators are constructed using the getInstance factory methods (static methods that return instances of a given class).A Key pair generator for a particular algorithm creates a public/private key pair that can be used with this algorithm.It also associates algorithm-specific parameters with each of the generated keys.There are two ways to generate a key pair: in an algorithm-independent manner, and in an algorithm-specific manner.The only difference between the two is the initialization of the object:All key pair generators share the concepts of a keysize and a source of randomness.The keysize is interpreted differently for different algorithms (e.g., in the case of the DSA algorithm, the keysize corresponds to the length of the modulus).There is an initialize method in this KeyPairGenerator class that takes these two universally shared types of arguments.There is also one that takes just a keysize argument, and uses the SecureRandom implementation of the highest-priority installed provider as the source of randomness.(If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness is used.)Since no other parameters are specified when you call the above algorithm-independent initialize methods, it is up to the provider what to do about the algorithm-specific parameters (if any) to be associated with each of the keys.If the algorithm is the DSA algorithm, and the keysize (modulus size) is 512, 768, or 1024, then the Sun provider uses a set of precomputed values for the p, q, and g parameters.If the modulus size is not one of the above values, the Sun provider creates a new set of parameters.Other providers might have precomputed parameter sets for more than just the three modulus sizes mentioned above.Still others might not have a list of precomputed parameters at all and instead always create new parameter sets.Algorithm-Specific Initialization For situations where a set of algorithm-specific parameters already exists (e.g., so-called community parameters in DSA), there are two initialize methods that have an AlgorithmParameterSpec argument.One also has a SecureRandom argument, while the the other uses the SecureRandom implementation of the highest-priority installed provider as the source of randomness.(If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness is used.)In case the client does not explicitly initialize the KeyPairGenerator (via a call to an initialize method), each provider must supply (and document) a default initialization.For example, the Sun provider uses a default modulus size (keysize) of 1024 bits.Note that this class is abstract and extends from KeyPairGeneratorSpi for historical reasons.Application developers should only take notice of the methods defined in this KeyPairGenerator class; all the methods in the superclass are intended for cryptographic service providers who wish to supply their own implementations of key pair generators.Every implementation of the Java platform is required to support the following standard KeyPairGenerator algorithms and keysizes in parentheses: DiffieHellman (1024)These algorithms are described in the KeyPairGenerator section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other algorithms are supported."},
{"description": "A KeyName object contains a string value which may be used by the signer to communicate a key identifier to the recipient.The XML Schema Definition is defined as: <element name=\"KeyName\" type=\"string\"/>A KeyName instance may be created by invoking the newKeyName method of the KeyInfoFactory class, and passing it a String representing the name of the key; for example: KeyInfoFactory factory = KeyInfoFactory.getInstance(\"DOM\"); KeyName keyName ="},
{"description": "This class acts as a factory for key managers based on a source of key material.Each key manager manages a specific type of key material for use by secure sockets.The key material is based on a KeyStore and/or provider specific sources."},
{"description": "This class defines the Service Provider Interface (SPI) for the KeyManagerFactory class.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular key manager factory."},
{"description": "This is the base interface for JSSE key managers.KeyManagers are responsible for managing the key material which is used to authenticate the local SSLSocket to its peer.If no key material is available, the socket will be unable to present authentication credentials.KeyManagers are created by either using a KeyManagerFactory, or by implementing one of the KeyManager subclasses."},
{"description": "This is the general key management exception for all operations dealing with key management.Examples of subclasses of KeyManagementException that developers might create for giving more detailed information could include: KeyIDConflictException KeyAuthorizationFailureException"},
{"description": "The bindings are basically name-value pairs that potentially resolve in a hierarchy."},
{"description": "This class is a simple holder for a key pair (a public key and a private key).It does not enforce any security, and, when initialized, should be treated like a PrivateKey."},
{"description": "The class that is interested in processing a keyboard event either implements this interface (and all the methods it contains) or extends the abstract KeyAdapter class (overriding only the methods of interest).The listener object created from that class is then registered with a component using the component's addKeyListener method.The relevant method in the listener object is then invoked, and the KeyEvent is passed to it."},
{"description": "A KeyInfo contains a list of XMLStructures, each of which contain information that enables the recipient(s) to obtain the key needed to validate an XML signature.The XML Schema Definition is defined as: <element name=\"KeyInfo\" type=\"ds:KeyInfoType\"/> <complexType name=\"KeyInfoType\" mixed=\"true\"> <choice maxOccurs=\"unbounded\"> <element ref=\"ds:KeyName\"/> <element ref=\"ds:A KeyInfo instance may be created by invoking one of the newKeyInfo methods of the KeyInfoFactory class, and passing it a list of one or more XMLStructures and an optional id parameter; for example: KeyInfoFactory factory = KeyInfoFactory.getInstance(\"DOM\");KeyInfo keyInfo = factory.newKeyInfo (Collections.singletonList(factory.newKeyName(\"Alice\"), \"keyinfo-1\")); KeyInfo objects can also be marshalled to XML by invoking the marshal method."},
{"description": "This class defines the Service Provider Interface (SPI) for the KeyFactory class.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a key factory for a particular algorithm.Key factories are used to convert keys (opaque cryptographic keys of type Key) into key specifications (transparent representations of the underlying key material), and vice versa.That is, they allow you to build an opaque key object from a given key specification (key material), or to retrieve the underlying key material of a key object in a suitable format.Multiple compatible key specifications may exist for the same key.For example, a DSA public key may be specified using DSAPublicKeySpec or X509EncodedKeySpec.A key factory can be used to translate between compatible key specifications.A provider should document all the key specifications supported by its key factory."},
{"description": "This class provides the functionality of a secret (symmetric) key generator.Key generators are constructed using one of the getInstance class methods of this class.KeyGenerator objects are reusable, i.e., after a key has been generated, the same KeyGenerator object can be re-used to generate further keys.There are two ways to generate a key: in an algorithm-independent manner, and in an algorithm-specific manner.The only difference between the two is the initialization of the object:All key generators share the concepts of a keysize and a source of randomness.There is an init method in this KeyGenerator class that takes these two universally shared types of arguments.There is also one that takes just a keysize argument, and uses the SecureRandom implementation of the highest-priority installed provider as the source of randomness (or a system-provided source of randomness if none of the installed providers supply a SecureRandom implementation), and one that takes just a source of randomness.Since no other parameters are specified when you call the above algorithm-independent init methods, it is up to the provider what to do about the algorithm-specific parameters (if any) to be associated with each of the keys.Algorithm-Specific Initialization For situations where a set of algorithm-specific parameters already exists, there are two init methods that have an AlgorithmParameterSpec argument.One also has a SecureRandom argument, while the other uses the SecureRandom implementation of the highest-priority installed provider as the source of randomness (or a system-provided source of randomness if none of the installed providers supply a SecureRandom implementation).In case the client does not explicitly initialize the KeyGenerator (via a call to an init method), each provider must supply (and document) a default initialization.Every implementation of the Java platform is required to support the following standard KeyGenerator algorithms with the keysizes in parentheses: AES (128) DES (56) DESede (168)These algorithms are described in the KeyGenerator section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other algorithms are supported."},
{"description": "Each instance of KeyInfoFactory supports a specific XML mechanism type.To create a KeyInfoFactory, call one of the static getInstance methods, passing in the XML mechanism type desired, for example: KeyInfoFactory factory = KeyInfoFactory.getInstance(\"DOM\"); The objects that this factory produces will be based on DOM and abide by the DOM interoperability requirements as defined in the DOM Mechanism Requirements section of the API overview.KeyInfoFactory implementations are registered and loaded using the Provider mechanism.For example, a service provider that supports the DOM mechanism would be specified in the Provider subclass as: put(\"KeyInfoFactory.DOM\", \"org.example.DOMKeyInfoFactory\"); Also, the XMLStructures that are created by this factory may contain state specific to the KeyInfo and are not intended to be reusable.An implementation MUST minimally support the default mechanism type: DOM.Note that a caller must use the same KeyInfoFactory instance to create the XMLStructures of a particular KeyInfo object.The behavior is undefined if XMLStructures from different providers or different mechanism types are used together.The static methods of this class are guaranteed to be thread-safe.Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.However, this is not true for the non-static methods defined by this class.Unless otherwise documented by a specific provider, threads that need to access a single KeyInfoFactory instance concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating a different KeyInfoFactory instance need not synchronize."},
{"description": "This class defines the Service Provider Interface (SPI) for the KeyGenerator class.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a key generator for a particular algorithm."},
{"description": "Key factories are used to convert keys (opaque cryptographic keys of type Key) into key specifications (transparent representations of the underlying key material), and vice versa.That is, they allow you to build an opaque key object from a given key specification (key material), or to retrieve the underlying key material of a key object in a suitable format.Multiple compatible key specifications may exist for the same key.For example, a DSA public key may be specified using DSAPublicKeySpec or X509EncodedKeySpec.A key factory can be used to translate between compatible key specifications.The following is an example of how to use a key factory in order to instantiate a DSA public key from its encoding.Assume Alice has received a digital signature from Bob.Bob also sent her his public key (in encoded format) to verify his signature.Alice then performs the following actions: X509EncodedKeySpec bobPubKeySpec = new X509EncodedKeySpec(bobEncodedPubKey); KeyFactory keyFactory = KeyFactory.getInstance(\"DSA\"); PublicKey bobPubKey = keyFactory.generatePublic(bobPubKeySpec); Signature sig = Signature.getInstance(\"DSA\"); sig.initVerify(bobPubKey);sig.verify(signature); Every implementation of the Java platform is required to support the following standard KeyFactory algorithms:These algorithms are described in the KeyFactory section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other algorithms are supported."},
{"description": "This is the basic key exception."},
{"description": "A KeyEventPostProcessor cooperates with the current KeyboardFocusManager in the final resolution of all unconsumed KeyEvents.KeyEventPostProcessors registered with the current KeyboardFocusManager will receive KeyEvents after the KeyEvents have been dispatched to and handled by their targets.KeyEvents that would have been otherwise discarded because no Component in the application currently owns the focus will also be forwarded to registered KeyEventPostProcessors.This will allow applications to implement features that require global KeyEvent post-handling, such as menu shortcuts.By default, the current KeyboardFocusManager will be the final KeyEventPostProcessor in the chain.The current KeyboardFocusManager cannot be completely deregistered as a KeyEventPostProcessor.However, if a KeyEventPostProcessor reports that no further post-processing of the KeyEvent should take place, the AWT will consider the event fully handled and will take no additional action with regard to the event.(While it is possible for client code to register the current KeyboardFocusManager as a KeyEventPostProcessor one or more times, this is usually unnecessary and not recommended.)"},
{"description": "A KeyEventDispatcher cooperates with the current KeyboardFocusManager in the targeting and dispatching of all KeyEvents.KeyEventDispatchers registered with the current KeyboardFocusManager will receive KeyEvents before they are dispatched to their targets, allowing each KeyEventDispatcher to retarget the event, consume it, dispatch the event itself, or make other changes.Note that KeyboardFocusManager itself implements KeyEventDispatcher.By default, the current KeyboardFocusManager will be the sink for all KeyEvents not dispatched by the registered KeyEventDispatchers.The current KeyboardFocusManager cannot be completely deregistered as a KeyEventDispatcher.However, if a KeyEventDispatcher reports that it dispatched the KeyEvent, regardless of whether it actually did so, the KeyboardFocusManager will take no further action with regard to the KeyEvent.(While it is possible for client code to register the current KeyboardFocusManager as a KeyEventDispatcher one or more times, this is usually unnecessary and not recommended.)"},
{"description": "This runtime exception is thrown to indicate that the index of a row to be added to a tabular data instance is already used to refer to another row in this tabular data instance."},
{"description": "This class defines the Service Provider Interface (SPI) for the KeyAgreement class.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular key agreement algorithm.The keys involved in establishing a shared secret are created by one of the key generators (KeyPairGenerator or KeyGenerator), a KeyFactory, or as a result from an intermediate phase of the key agreement protocol (engineDoPhase).For each of the correspondents in the key exchange, engineDoPhase needs to be called.For example, if the key exchange is with one other party, engineDoPhase needs to be called once, with the lastPhase flag set to true.If the key exchange is with two other parties, engineDoPhase needs to be called twice, the first time setting the lastPhase flag to false, and the second time setting it to true.There may be any number of parties involved in a key exchange."},
{"description": "This class provides the functionality of a key agreement (or key exchange) protocol.The keys involved in establishing a shared secret are created by one of the key generators (KeyPairGenerator or KeyGenerator), a KeyFactory, or as a result from an intermediate phase of the key agreement protocol.For example, if this key exchange is with one other party, doPhase needs to be called once, with the lastPhase flag set to true.If this key exchange is with two other parties, doPhase needs to be called twice, the first time setting the lastPhase flag to false, and the second time setting it to true.There may be any number of parties involved in a key exchange.Every implementation of the Java platform is required to support the following standard KeyAgreement algorithm: DiffieHellman This algorithm is described in the KeyAgreement section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other algorithms are supported."},
{"description": "The methods in this class are empty.This class exists as convenience for creating listener objects.(If you implement the KeyListener interface, you have to define all of the methods in it.This abstract class defines null methods for them all, so you can only have to define methods for events you care about.)When a key is pressed, released, or typed, the relevant method in the listener object is invoked, and the KeyEvent is passed to it."},
{"description": "An event which indicates that a keystroke occurred in a component.This low-level event is generated by a component object (such as a text field) when a key is pressed, released, or typed.The event is passed to every KeyListener or KeyAdapter object which registered to receive such events using the component's addKeyListener method.(KeyAdapter objects implement the KeyListener interface.)Each such listener object gets this KeyEvent when the event occurs.\"Key typed\" events are higher-level and generally do not depend on the platform or keyboard layout.They are generated when a Unicode character is entered, and are the preferred way to find out about character input.In the simplest case, a key typed event is produced by a single key press (e.g., 'a').Often, however, characters are produced by series of key presses (e.g., 'shift' + 'a'), and the mapping from key pressed events to key typed events may be many-to-one or many-to-many.Key releases are not usually necessary to generate a key typed event, but there are some cases where the key typed event is not generated until a key is released (e.g., entering ASCII sequences via the Alt-Numpad method in Windows).No key typed events are generated for keys that don't generate Unicode characters (e.g., action keys, modifier keys, etc.).The getKeyChar method always returns a valid Unicode character or CHAR_UNDEFINED.Character input is reported by KEY_TYPED events: KEY_PRESSED and KEY_RELEASED events are not necessarily associated with character input.Therefore, the result of the getKeyChar method is guaranteed to be meaningful only for KEY_TYPED events.For key pressed and key released events, the getKeyCode method returns the event's keyCode.For key typed events, the getKeyCode method always returns VK_UNDEFINED.The getExtendedKeyCode method may also be used with many international keyboard layouts.Key pressed\" and \"key released\" events are lower-level and depend on the platform and keyboard layout.They are generated whenever a key is pressed or released, and are the only way to find out about keys that don't generate character input (e.g., action keys, modifier keys, etc.).The key being pressed or released is indicated by the getKeyCode and getExtendedKeyCode methods, which return a virtual key code.Virtual key codes are used to report which keyboard key has been pressed, rather than a character generated by the combination of one or more keystrokes (such as \"A\", which comes from shift and \"a\").For example, pressing the Shift key will cause a KEY_PRESSED event with a VK_SHIFT keyCode, while pressing the 'a' key will result in a VK_A keyCode.Separately, a KEY_TYPED event with a keyChar value of 'A' is generated.But in some cases (e.g. auto-repeat or input method is activated)the order could be different (and platform dependent).Notes: Key combinations which do not result in Unicode characters, such as action keys like F1 and the HELP key, do not generate KEY_TYPED events.Not all keyboards or systems are capable of generating all virtual key codes.No attempt is made in Java to generate these keys artificially.Virtual key codes do not identify a physical key: they depend on the platform and keyboard layout.For example, the key that generates VK_Q when using a U.S. keyboard layout will generate VK_A when using a French keyboard layout.The key that generates VK_Q when using a U.S. keyboard layout also generates a unique code for Russian or Hebrew layout.There is no a VK_ constant for these and many other codes in various layouts.These codes may be obtained by using getExtendedKeyCode and are used whenever a VK_ constant is used.Not all characters have a keycode associated with them.For example, there is no keycode for the question mark because there is no keyboard for which it appears on the primary layer.In order to support the platform-independent handling of action keys, the Java platform uses a few additional virtual key constants for functions that would otherwise have to be recognized by interpreting virtual key codes and modifiers.For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES is returned instead of VK_CONVERT with the ALT modifier.As specified in Focus Specification key events are dispatched to the focus owner by default.Aside from those keys that are defined by the Java language (VK_ENTER, VK_BACK_SPACE, and VK_TAB), do not rely on the values of the VK_ constants.Sun reserves the right to change these values as needed to accommodate a wider range of keyboards in the future.An unspecified behavior will be caused if the id parameter of any particular KeyEvent instance is not in the range from KEY_FIRST to KEY_LAST."},
{"description": "The KeyboardFocusManager is responsible for managing the active and focused Windows, and the current focus owner.The focus owner is defined as the Component in an application that will typically receive all KeyEvents generated by the user.The focused Window is the Window that is, or contains, the focus owner.Only a Frame or a Dialog can be the active Window.The native windowing system may denote the active Window or its children with special decorations, such as a highlighted title bar.The active Window is always either the focused Window, or the first Frame or Dialog that is an owner of the focused Window.The KeyboardFocusManager is both a centralized location for client code to query for the focus owner and initiate focus changes, and an event dispatcher for all FocusEvents, WindowEvents related to focus, and KeyEvents.In such a scenario, there will be one KeyboardFocusManager per context.Other browsers place all applets into the same context, implying that there will be only a single, global KeyboardFocusManager for all applets.No matter how many contexts there may be, however, there can never be more than one focus owner, focused Window, or active Window, per ClassLoader."},
{"description": "The Key interface is the top-level interface for all keys.It defines the functionality shared by all key objects.All keys have three characteristics:An Algorithm This is the key algorithm for that key.The key algorithm is usually an encryption or asymmetric operation algorithm (such as DSA or RSA), which will work with those algorithms and with related algorithms (such as MD5 with RSA, SHA-1 with RSA, Raw DSA, etc.)The name of the algorithm of a key is obtained using the getAlgorithm method.This is an external encoded form for the key used when a standard representation of the key is needed outside the Java Virtual Machine, as when transmitting the key to some other party.The key is encoded according to a standard format (such as X.509 SubjectPublicKeyInfo or PKCS#8), and is returned using the getEncoded method.Note: The syntax of the ASN.1 type SubjectPublicKeyInfo is defined as follows:SEQUENCE { algorithm OBJECT IDENTIFIER, parameters ANY DEFINEDA Format This is the name of the format of the encoded key.It is returned by the getFormat method.Keys are generally obtained through key generators, certificates, or various Identity classes used to manage keys.Keys may also be obtained from key specifications (transparent representations of the underlying key material) through the use of a key factory (see KeyFactory).A Key should use KeyRep as its serialized representation.Note that a serialized Key may contain sensitive information which should not be exposed in untrusted environments."},
{"description": "This class encapsulates a Kerberos ticket and associated information as viewed from the client's point of view.It captures all information that the Key Distribution Center (KDC) sends to the client in the reply message KDC-REP defined in the Kerberos Protocol Specification (RFC 4120).All Kerberos JAAS login modules that authenticate a user to a KDC should use this class.Where available, the login module might even read this information from a ticket cache in the operating system instead of directly communicating with the KDC.During the commit phase of the JAAS authentication process, the JAAS login module should instantiate this class and store the instance in the private credential set of a Subject.It might be necessary for the application to be granted a PrivateCredentialPermission if it needs to access a KerberosTicket instance from a Subject.This permission is not needed when the application depends on the default JGSS Kerberos mechanism to access the KerberosTicket.In that case, however, the application will need an appropriate ServicePermission.Note that this class is applicable to both ticket granting tickets and other regular service tickets.A ticket granting ticket is just a special case of a more generalized service ticket."},
{"description": "This class encapsulates a Kerberos principal."},
{"description": "A JWindow is a container that can be displayed anywhere on the user's desktop.It does not have the title bar, window-management buttons, or other trimmings associated with a JFrame, but it is still a \"first-class citizen\" of the user's desktop, and can exist anywhere on it.The JWindow component contains a JRootPane as its only child.The contentPane should be the parent of any children of the JWindow.As a convenience, the add, remove, and setLayout methods of this class are overridden, so that they delegate calls to the corresponding methods of the ContentPane.For example, you can add a child component to a window as follows: window.add(child); And the child will be added to the contentPane.Attempting to set it to null will cause the JWindow to throw an exception.The default contentPane will have a BorderLayout manager set on it.In a multi-screen environment, you can create a JWindow on a different screen device.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class encapsulates a long term secret key for a Kerberos principal.All Kerberos JAAS login modules that obtain a principal's password and generate the secret key from it should use this class.Sometimes, such as when authenticating a server in the absence of user-to-user authentication, the login module will store an instance of this class in the private credential set of a Subject during the commit phase of the authentication process.A Kerberos service using a keytab to read secret keys should use the KeyTab class, where latest keys can be read when needed.It might be necessary for the application to be granted a PrivateCredentialPermission if it needs to access the KerberosKey instance from a Subject.This permission is not needed when the application depends on the default JGSS Kerberos mechanism to access the KerberosKey.In that case, however, the application will need an appropriate ServicePermission."},
{"description": "The \"viewport\" or \"porthole\" through which you see the underlying information.When you scroll, what moves is the viewport.It is like peering through a camera's viewfinder.Moving the viewfinder upwards brings new things into view at the top of the picture and loses things that were at the bottom.By default, JViewport is opaque.We have implemented a faster scrolling algorithm that does not require a buffer to draw in.The algorithm works as follows: The view and parent view and checked to see if they are JComponents, if they aren't, stop and repaint the whole viewport.If the viewport is obscured by an ancestor, stop and repaint the whole viewport.Compute the region that will become visible, if it is as big as the viewport, stop and repaint the whole view region.The next time paint is invoked on the viewport, if the clip region is smaller than the viewport size a timer is kicked off to repaint the whole region.Compared to the non backing store case this approach will greatly reduce the painted region.This approach can cause slower times than the backing store approach when the viewport is obscured by another window, or partially offscreen.When another window obscures the viewport the copyArea will copy garbage and a paint event will be generated by the system to inform us we need to paint the newly exposed region.The only way to handle this is to repaint the whole viewport, which can cause slower performance than the backing store case.In most applications very rarely will the user be scrolling while the viewport is obscured by another window or offscreen, so this optimization is usually worth the performance hit when obscured.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A set of date fields that provide access to Julian Days.The Julian Day is a standard way of expressing date and time commonly used in the scientific community.It is expressed as a decimal number of whole days where days start at midday.This class represents variations on Julian Days that count whole days from midnight.The fields are implemented relative to EPOCH_DAY.The fields work with all chronologies."},
{"description": "The Kernel class defines a matrix that describes how a specified pixel and its surrounding pixels affect the value computed for the pixel's position in the output image of a filtering operation.The X origin and Y origin indicate the kernel matrix element that corresponds to the pixel position for which an output value is being computed."},
{"description": "DynamicUtilTreeNode can wrap vectorsIt is dynamic in that it will only create the children as necessary.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "EmptySelectionModel is a TreeSelectionModel that does not allow anything to be selected.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A control that displays a set of hierarchical data as an outline.You can find task-oriented documentation and examples of using trees in How to Use Trees, a section in The Java Tutorial.A specific node in a tree can be identified either by a TreePath (an object that encapsulates a node and all of its ancestors), or by its display row, where each row in the display area displays one node.An expanded node is a non-leaf node (as identified by TreeModel.isLeaf(node) returning false) that will displays its children when all its ancestors are expanded.A collapsed node is one which hides them.A hidden node is one which is under a collapsed ancestor.All of a viewable nodes parents are expanded, but may or may not be displayed.A displayed node is both viewable and in the display area, where it can be seen.() setVisibleRowCount() The next group of JTree methods use \"visible\" to mean \"viewable\" (under an expanded parent):isVisible() makeVisible() If you are interested in knowing when the selection changes implement the TreeSelectionListener interface and add the instance using the method addTreeSelectionListener.valueChanged will be invoked when the selection changes, that is if the user clicks twice on the same node valueChanged will only be invoked once.If you are interested in detecting either double-click events or when a user clicks on a node, regardless of whether or not it was selected, we recommend you do the following: final JTree tree = ...; MouseListener ml = new MouseAdapter() { public void mousePressed(MouseEvent e) { int selRow =This example obtains both the path and row, but you only need to get the one you're interested in.To use JTree to display compound nodes (for example, nodes containing both a graphic icon and text), subclass TreeCellRenderer and use setCellRenderer(javax.swing.tree.Like all JComponent classes, you can use InputMap and ActionMap to associate an Action object with a KeyStroke and execute the action under specified conditions.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Typically components provide api to automate the process of using ToolTips.For example, any Swing component can use the JComponent setToolTipText method to specify the text for a standard tooltip.A component that wants to create a custom ToolTip display can override JComponent's createToolTip method and use a subclass of this class.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "JToolBar provides a component that is useful for displaying commonly used Actions or controls.With most look and feels, the user can drag out a tool bar into a separate window (unless the floatable property is set to false).For drag-out to work correctly, it is recommended that you add JToolBar instances to one of the four \"sides\" of a container whose layout manager is a BorderLayout, and do not add children to any of the other four \"sides\".Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The JRadioButton and JCheckBox classes are subclasses of this class.Buttons can be configured, and to some degree controlled, by Actions.Using an Action with a button has many benefits beyond directly configuring a button.Refer to Swing Components Supporting Action for more details, and you can find more information in How to Use Actions, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A text component that can be marked up with attributes that are represented graphically.You can find how-to information and examples of using text panes in Using Text Components, a section in The Java Tutorial.This component models paragraphs that are composed of runs of character level attributes.Each paragraph may have a logical style attached to it which contains the default attributes to use if not overridden by attributes set on the paragraph or character run.Components and images may be embedded in the flow of text.For a discussion on how newlines are handled, see DefaultEditorKit.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "JTextComponent is the base class for swing text components.It tries to be compatible with the java.awt.TextComponent class where it can reasonably do so.You can find information on how to use the functionality this class provides in General Rules for Using Text Components, a section in The Java Tutorial.The caret is a pluggable object in swing text components.Notification of changes to the caret position and the selection are sent to implementations of the CaretListener interface that have been registered with the text component.The UI will install a default caret unless a customized caret has been set.it's position accordingly if an insertion occurs before or at the caret position or a removal occurs before the caret position.DefaultCaret tries to make itself visible which may lead to scrolling of a text component within JScrollPane.The default caret behavior can be changed by the DefaultCaret.setUpdatePolicy(int) method.Note: Non-editable text components also have a caret though it may not be painted.Commands Text components provide a number of commands that can be used to manipulate the component.This is essentially the way that the component expresses its capabilities.These are expressed in terms of the swing Action interface, using the TextAction implementation.The set of commands supported by the text component can be found with the getActions() method.These actions can be bound to key events, fired from buttons, etc.The text components support flexible and internationalized text input, using keymaps and the input method framework, while maintaining compatibility with the AWT listener model.A Keymap lets an application bind key strokes to actions.In order to allow keymaps to be shared across multiple text components, they can use actions that extend TextAction.TextAction can determine which JTextComponent most recently has or had focus and therefore is the subject of the action (In the case that the ActionEvent sent to the action doesn't contain the target text component as its source).The input method framework lets text components interact with input methods, separate software components that preprocess events to let users enter thousands of different characters using keyboards with far fewer keys.JTextComponent is an active client of the framework, so it implements the preferred user interface for interacting with input methods.As a consequence, some key events do not reach the text component because they are handled by an input method, and some text input reaches the text component as committed text within an InputMethodEvent instead of as a key event.The complete text input is the combination of the characters in keyTyped key events and committed text in input method events.The AWT listener model lets applications attach event listeners to components in order to bind events to actions.Swing encourages the use of keymaps instead of listeners, but maintains compatibility with listeners by giving the listeners a chance to steal an event by consuming it.Keyboard event and input method events are handled in the following stages, with each stage capable of consuming the event:registered key listeners registered input method listeners 4.input method handling in JTextComponent 5.To maintain compatibility with applications that listen to key events but are not aware of input method events, the input method handling in stage 4 provides a compatibility mode for components that do not process input method events.For these components, the committed text is converted to keyTyped key events and processed in the key event pipeline starting at stage 3 instead of in the input method event pipeline.By default the component will create a keymap (named DEFAULT_KEYMAP) that is shared by all JTextComponent instances as the default keymap.Typically a look-and-feel implementation will install a different keymap that resolves to the default keymap for those bindings not found in the different keymap.The minimal bindings include: inserting content into the editor for the printable keys.The text components have a model-view split.A text component pulls together the objects used to represent the model, view, and controller.The text document model may be shared by other views which act as observers of the model (e.g. a document may be shared by multiple components).The model is defined by the Document interface.This is intended to provide a flexible text storage mechanism that tracks change during edits and can be extended to more sophisticated models.The model interfaces are meant to capture the capabilities of expression given by SGML, a system used to express a wide variety of content.Each modification to the document causes notification of the details of the change to be sent to all observers in the form of a DocumentEvent which allows the views to stay up to date with the model.This event is sent to observers that have implemented the DocumentListener interface and registered interest with the model being observed.The capability of determining the location of text in the view is provided.There are two methods, modelToView(int) and viewToModel(java.awt.Undo/Redo support Support for an edit history mechanism is provided to allow undo/redo operations.The text component does not itself provide the history buffer by default, but does provide the UndoableEdit records that can be used in conjunction with a history buffer to provide the undo/redo support.The support is provided by the Document model, which allows one to attach UndoableEditListener implementations.The swing text components provide some support of thread safe operations.Because of the high level of configurability of the text components, it is possible to circumvent the protection provided.The protection primarily comes from the model, so the documentation of AbstractDocument describes the assumptions of the protection provided.The methods that are safe to call asynchronously are marked with comments.For a discussion on how newlines are handled, see DefaultEditorKit.Printing support Several print methods are provided for basic document printing.If more advanced printing is needed, use the getPrintable(java.text.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A JTextArea is a multi-line area that displays plain text.It is intended to be a lightweight component that provides source compatibility with the java.awt.TextArea class where it can reasonably do so.You can find information and examples of using all the text components in Using Text Components, a section in The Java Tutorial.This component has capabilities not found in the java.awt.TextArea class.The superclass should be consulted for additional capabilities.Alternative multi-line text classes with more capabilities are JTextPane and JEditorPane.The java.awt.TextArea internally handles scrolling.JTextArea is different in that it doesn't manage scrolling, but implements the swing Scrollable interface.This allows it to be placed inside a JScrollPane if scrolling behavior is desired, and used directly if scrolling is not desired.The java.awt.TextArea has the ability to do line wrapping.This was controlled by the horizontal scrolling policy.Since scrolling is not done by JTextArea directly, backward compatibility must be provided another way.JTextArea has a bound property for line wrapping that controls whether or not it will wrap lines.By default, the line wrapping property is set to false (not wrapped).java.awt.TextArea has two properties rows and columns that are used to determine the preferred size.JTextArea uses these properties to indicate the preferred size of the viewport when placed inside a JScrollPane to match the functionality provided by java.awt.TextArea.JTextArea has a preferred size of what is needed to display all of the text, so that it functions properly inside of a JScrollPane.If the value for rows or columns is equal to zero, the preferred size along that axis is used for the viewport preferred size along the same axis.The java.awt.TextArea could be monitored for changes by adding a TextListener for TextEvents.In the JTextComponent based components, changes are broadcasted from the model via a DocumentEvent to DocumentListeners.The DocumentEvent gives the location of the change and the kind of change if desired.The code fragment might look something like: DocumentListener myListener = ??; JTextAreamyArea = ??; myArea.getDocument().addDocumentListener(myListener); Newlines For a discussion on how newlines are handled, see DefaultEditorKit.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This is the object which manages the header of the JTable.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "JTextField is a lightweight component that allows the editing of a single line of text.JTextField is intended to be source-compatible with java.awt.TextField where it is reasonable to do so.This component has capabilities not found in the java.awt.TextField class.The superclass should be consulted for additional capabilities.JTextField has a method to establish the string used as the command string for the action event that gets fired.The java.awt.TextField used the text of the field as the command string for the ActionEvent.JTextField will use the command string set with the setActionCommand method if not null, otherwise it will use the text of the field as a compatibility with java.awt.TextField.The method setEchoChar and getEchoChar are not provided directly to avoid a new implementation of a pluggable look-and-feel inadvertently exposing password characters.To provide password-like services a separate class JPasswordField extends JTextField to provide this service with an independently pluggable look-and-feel.The java.awt.TextField could be monitored for changes by adding a TextListener for TextEvent's.In the JTextComponent based components, changes are broadcasted from the model via a DocumentEvent to DocumentListeners.The DocumentEvent gives the location of the change and the kind of change if desired.The code fragment might look something like: \u00a0 DocumentListener myListener = ??; \u00a0 JTextField; \u00a0 myArea.getDocument().addDocumentListener(myListener); The horizontal alignment of JTextField can be set to be left justified, leading justified, centered, right justified or trailing justified./trailing justification is useful if the required size of the field text is smaller than the size allocated to it.This is determined by the setHorizontalAlignment and getHorizontalAlignment methods.How the text field consumes VK_ENTER events depends on whether the text field has any action listeners.If so, then VK_ENTER results in the listeners getting an ActionEvent, and the VK_ENTER event is consumed.This is compatible with how AWT text fields handle VK_ENTER events.If the text field has no action listeners, then as of v 1.3 the VK_ENTER event is not consumed.Instead, the bindings of ancestor components are processed, which enables the default button feature of JFC/Swing to work.Customized fields can easily be created by extending the model and changing the default model provided.For example, the following piece of code will create a field that holds only upper case characters.It will work even if text is pasted into from the clipboard or it is altered via programmatic changes. \u00a0public class UpperCaseField extends JTextField {\u00a0\u00a0 public UpperCaseField(int cols) {\u00a0 super(cols);\u00a0 }\u00a0\u00a0 protected Document createDefaultModel() {\u00a0 return new UpperCaseDocument();\u00a0 }\u00a0\u00a0 static class UpperCaseDocument extends PlainDocument {\u00a0\u00a0 public void insertString(int offs, String str,();\u00a0 for (int i = 0; i < upper.length; i++) {\u00a0 upper[i] = Character.toUpperCase(upper[i]);\u00a0 }\u00a0 super.insertString(offs, new String(upper), a);\u00a0 }\u00a0 }\u00a0} Warning:Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A component that lets the user switch between a group of components by clicking on a tab with a given title and/or icon.Tabs/components are added to a TabbedPane object by using the addTab and insertTab methods.A tab is represented by an index corresponding to the position it was added in, where the first tab has an index equal to 0 and the last tab has an index equal to the tab count minus 1.The TabbedPane uses a SingleSelectionModel to represent the set of tab indices and the currently selected index.If the tab count is greater than 0, then there will always be a selected index, which by default will be initialized to the first tab.If the tab count is 0, then the selected index will be -1.The tab title can be rendered by a Component.For example, the following produce similar results: // In this case the look and feel renders the title for the tab. tabbedPane.addTab(\"Tab\", myComponent); // In this case the custom component is responsible for rendering the // title of the tab.tabbedPane.addTab(null, myComponent); tabbedPane.setTabComponentAt(0, new JLabel(\"Tab\")); The latter is typically used when you want a more complex user interaction that requires custom components on the tab.For example, you could provide a custom component that animates or one that has widgets for closing the tab.If you specify a component for a tab, the JTabbedPane will not render any text or icon you have specified for the tab.Do not use setVisible directly on a tab component to make it visible, use setSelectedComponent or setSelectedIndex methods instead.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "An editor for a JSpinner whose model is a SpinnerDateModel.The value of the editor is displayed with a JFormattedTextField whose format is defined by a DateFormatter instance whose minimum and maximum properties are mapped to the SpinnerDateModel."},
{"description": "A simple base class for more specialized editors that displays a read-only view of the model's current value with a JFormattedTextField.Subclasses can configure the JFormattedTextField to create an editor that's appropriate for the type of model they support and they may want to override the stateChanged and propertyChanged methods, which keep the model and the text field in sync.This class defines a dismiss method that removes the editors ChangeListener from the JSpinner that it's part of.The setEditor method knows about DefaultEditor.dismiss, so if the developer replaces an editor that's derived from JSpinner.DefaultEditor its ChangeListener connection back to the JSpinner will be removed.However after that, it's up to the developer to manage their editor listeners.Similarly, if a subclass overrides createEditor, it's up to the subclasser to deal with their editor subsequently being replaced (with setEditor).We expect that in most cases, and in editor installed with setEditor or created by a createEditor override, will not be replaced anyway.This class is the LayoutManager for it's single JFormattedTextField child.By default the child is just centered with the parents insets."},
{"description": "An editor for a JSpinner whose model is a SpinnerListModel."},
{"description": "An editor for a JSpinner whose model is a SpinnerNumberModel.The value of the editor is displayed with a JFormattedTextField whose format is defined by a NumberFormatter instance whose minimum and maximum properties are mapped to the SpinnerNumberModel."},
{"description": "JSplitPane is used to divide two (and only two) Components.The two Components are graphically divided based on the look and feel implementation, and the two Components can then be interactively resized by the user.Information on using JSplitPane is in How to Use Split Panes in The Java Tutorial.The two Components in a split pane can be aligned left to right using JSplitPane.The preferred way to change the size of the Components is to invoke setDividerLocation where location is either the new x or y position, depending on the orientation of the JSplitPane.To resize the Components to their preferred sizes invoke resetToPreferredSizes.When the user is resizing the Components the minimum size of the Components is used to determine the maximum/minimum position the Components can be set to.If the minimum size of the two components is greater than the size of the split pane the divider will not allow you to resize it.When the user resizes the split pane the new space is distributed between the two components based on the resizeWeight property.A value of 0, the default, indicates the right/bottom component gets all the space, where as a value of 1 indicates the left/top component gets all the space.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The JTable is used to display and edit regular two-dimensional tables of cells.The JTable has many facilities that make it possible to customize its rendering and editing but provides defaults for these features so that simple tables can be set up easily.{ public int getColumnCount() { return 10; } public int getRowCount() { return 10;} public Object getValueAt(int row, int col) { return new Integer(row*col); } }; JTable table = new JTable(dataModel); JScrollPane scrollpane = new JScrollPane(table); JTables are typically placed inside of a JScrollPane.By default, a JTable will adjust its width such that a horizontal scrollbar is unnecessary.Note that if you wish to use a JTable in a standalone view (outside of a JScrollPane) and want the header displayed, you can get it using getTableHeader() and display it separately.You can set up a row sorter in either of two ways:Set the autoCreateRowSorter property to true, so that the JTable creates a RowSorter for you.When designing applications that use the JTable it is worth paying close attention to the data structures that will represent the table's data.The DefaultTableModel is a model implementation that uses a Vector of Vectors of Objects to store the cell values.As well as copying the data from an application into the DefaultTableModel, it is also possible to wrap the data in the methods of the TableModel interface so that the data can be passed to the JTable directly, as in the example above.This often results in more efficient applications because the model is free to choose the internal representation that best suits the data.A good rule of thumb for deciding whether to use the AbstractTableModel or the DefaultTableModel is to use the AbstractTableModel as the base class for creating subclasses and the DefaultTableModel when subclassing is not required.The \"TableExample\" directory in the demo area of the source distribution gives a number of complete examples of JTable usage, covering how the JTable can be used to provide an editable view of data taken from a database and how to modify the columns in the display to use specialized renderers and editors.The JTable uses integers exclusively to refer to both the rows and the columns of the model that it displays.The JTable simply takes a tabular range of cells and uses getValueAt(int, int) to retrieve the values from the model during painting.It is important to remember that the column and row indexes returned by various JTable methods are in terms of the JTable (the view) and are not necessarily the same indexes used by the model.By default, columns may be rearranged in the JTable so that the view's columns appear in a different order to the columns in the model.This does not affect the implementation of the model at all: when the columns are reordered, the JTable maintains the new order of the columns internally and converts its column indices before querying the model.So, when writing a TableModel, it is not necessary to listen for column reordering events as the model will be queried in its own coordinate system regardless of what is happening in the view.In the examples area there is a demonstration of a sorting algorithm making use of exactly this technique to interpose yet another coordinate system where the order of the rows is changed, rather than the order of the columns.Similarly when using the sorting and filtering functionality provided by RowSorter the underlying TableModel does not need to know how to do sorting, rather RowSorter will handle it.Coordinate conversions will be necessary when using the row based methods of JTable with the underlying TableModel.All of JTables row based methods are in terms of the RowSorter, which is not necessarily the same as that of the underlying TableModel.For example, the selection is always in terms of JTable so that when using RowSorter you will need to convert using convertRowIndexToView or convertRowIndexToModel.The following shows how to convert coordinates from JTable to that of the underlying model:table.getSelectedRows(); for (int i = 0; i < selection.length; i++) { selection[i] = table.convertRowIndexToModel(selection[i]); } // selection is now in terms of the underlying TableModel By defaultif sorting is enabled JTable will persist the selection and variable row heights in terms of the model on sorting.Visually the selection may change, but in terms of the underlying model it will remain the same.The one exception to that is if the model index is no longer visible or was removed.For example, if row 0 in terms of model was filtered out the selection will be empty after the sort.J2SE 5 adds methods to JTable to provide convenient access to some common printing needs.Simple new print() methods allow for quick and easy addition of printing support to your application.method is available for more advanced printing needs.As for all JComponent classes, you can use InputMap and ActionMap to associate an Action object with a KeyStroke and execute the action under specified conditions.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A single line input field that lets the user select a number or an object value from an ordered sequence.Spinners typically provide a pair of tiny arrow buttons for stepping through the elements of the sequence.The keyboard up/down arrow keys also cycle through the elements.The user may also be allowed to type a (legal) value directly into the spinner.Although combo boxes provide similar functionality, spinners are sometimes preferred because they don't require a drop down list that can obscure important data.A JSpinner's sequence value is defined by its SpinnerModel.The model can be specified as a constructor argument and changed with the model property.SpinnerModel classes for some common types are provided:A JSpinner has a single child component that's responsible for displaying and potentially changing the current element or value of the model, which is called the editor.The editor is created by the JSpinner's constructor and can be changed with the editor property.The JSpinner's editor stays in sync with the model by listening for ChangeEvents.If the user has changed the value displayed by the editor it is possible for the model's value to differ from that of the editor.To make sure the model has the same value as the editor use the commitEdit method, eg: try { spinner.commitEdit(); } catch (ParseException pe) { //the last valid value, you could revert the spinner to show that: JComponent editor = spinner.getEditor(); if (editor instanceof DefaultEditor) { ((DefaultEditor)editor).getTextField().setValue(spinner.getValue()); } // reset the value to some known value: spinner.setValue(fallbackValue);// or treat the last valid value as the current, in which // case you don't need to do anything. } return spinner.getValue(); For information and examples of using spinner see How to Use Spinners, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A component that lets the user graphically select a value by sliding a knob within a bounded interval.The knob is always positioned at the points that match integer values within the specified interval.The slider can show both major tick marks, and minor tick marks between the major ones.The number of values between the tick marks is controlled with setMajorTickSpacing and setMinorTickSpacing.Painting of tick marks is controlled by setPaintTicks.Sliders can also print text labels at regular intervals (or at arbitrary locations) along the slider track.Painting of labels is controlled by setLabelTable and setPaintLabels.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A JScrollPane manages a viewport, optional vertical and horizontal scroll bars, and optional row and column heading viewports.You can find task-oriented documentation of JScrollPane in How to Use Scroll Panes, a section in The Java Tutorial.Note that JScrollPane does not support heavyweight components.The JViewport provides a window, or \"viewport\" onto a data source -- for example, a text file.That data source is the \"scrollable client\" (aka data model) displayed by the JViewport view.A JScrollPane basically consists of JScrollBars, a JViewport, and the wiring between them, as shown in the diagram at right.In addition to the scroll bars and viewport, a JScrollPane can have a column header and a row header.Each of these is a JViewport object that you specify with setRowHeaderView, and setColumnHeaderView.The column header viewport automatically scrolls left and right, tracking the left-right scrolling of the main viewport.The row header acts in a similar fashion.Where two scroll bars meet, the row header meets the column header, or a scroll bar meets one of the headers, both components stop short of the corner, leaving a rectangular space which is, by default, empty.These spaces can potentially exist in any number of the four corners.In the previous diagram, the top right space is present and identified by the label \"corner component\".Any number of these empty spaces can be replaced by using the setCorner method to add a component to a particular corner.(Note: The same component cannot be added to multiple corners.)This is useful if there's some extra decoration or function you'd like to add to the scroll pane.The size of each corner component is entirely determined by the size of the headers and/or scroll bars that surround it.A corner component will only be visible if there is an empty space in that corner for it to exist in.If the scroll pane's vertical scrollbar is not present, perhaps because the view component hasn't grown large enough to require it, then the corner component will not be shown (since there is no empty space in that corner created by the meeting of the header and vertical scroll bar).Forcing the scroll bar to always be shown, using setVerticalScrollBarPolicy(VERTICAL_SCROLLBAR_ALWAYS), will ensure that the space for the corner component always exists.To add a border around the main viewport, you can use setViewportBorder.(Of course, you can also add a border around the whole scroll pane using setBorder.)A common operation to want to do is to set the background color that will be used if the main viewport view is smaller than the viewport, or is not opaque.This can be accomplished by setting the background color of the viewport, via scrollPane.getViewport().setBackground().The reason for setting the color of the viewport and not the scrollpane is that by default JViewport is opaque which, among other things, means it will completely fill in its background using its background color.Therefore when JScrollPane draws its background the viewport will usually draw over it.By default JScrollPane uses ScrollPaneLayout to handle the layout of its child Components.ScrollPaneLayout determines the size to make the viewport view in one of two ways: If the view implements Scrollable a combination of getPreferredScrollableViewportSize, getScrollableTracksViewportWidth and getScrollableTracksViewportHeightis used, otherwise getPreferredSize is used.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The user positions the knob in the scrollbar to determine the contents of the viewing area.The program typically adjusts the display so that the end of the scrollbar represents the end of the displayable contents, or 100% of the contents.The start of the scrollbar is the beginning of the displayable contents, or 0%.The position of the knob within those bounds then translates to the corresponding percentage of the displayable contents.Typically, as the position of the knob in the scrollbar changes a corresponding change is made to the position of the JViewport on the underlying view, changing the contents of the JViewport.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The following image shows the relationships between the classes that use root panes.The \"heavyweight\" components (those that delegate to a peer, or native component on the host system) are shown with a darker, heavier box.The four heavyweight JFC/Swing containers (JFrame, JDialog, JWindow, and JApplet) are shown in relation to the AWT classes they extend.These four components are the only heavyweight containers in the Swing library.All five of these JFC/Swing containers implement the RootPaneContainer interface, and they all delegate their operations to a JRootPane (shown with a little \"handle\" on top).The JComponent method getRootPane can be used to obtain the JRootPane that contains a given component.The diagram at right shows the structure of a JRootPane.A JRootpane is made up of a glassPane, an optional menuBar, and a contentPane.(The JLayeredPane manages the menuBar and the contentPane.)The glassPane sits over the top of everything, where it is in a position to intercept mouse movements.Since the glassPane (like the contentPane) can be an arbitrary component, it is also possible to set up the glassPane for drawing.Lines and images on the glassPane can then range over the frames underneath without being limited by their boundaries.Although the menuBar component is optional, the layeredPane, contentPane, and glassPane always exist.Attempting to set them to null generates an exception.To add components to the JRootPane (other than the optional menu bar), you add the object to the contentPane of the JRootPane, like this: rootPane.getContentPane().add(child); The same principle holds true for setting layout managers, removing components, listing children, etc.All these methods are invoked on the contentPane instead of on the JRootPane.Note: The default layout manager for the contentPane is a BorderLayout manager.However, the JRootPane uses a custom LayoutManager.So, when you want to change the layout manager for the components you added to a JRootPane, be sure to use code like this: rootPane.getContentPane().setLayout(new; If a JMenuBar component is set on the JRootPane, it is positioned along the upper edge of the frame.The contentPane is adjusted in location and size to fill the remaining area.(The JMenuBar and the contentPane are added to the layeredPane component at the JLayeredPane.The layeredPane is the parent of all children in the JRootPane -- both as the direct parent of the menu and the grandparent of all components added to the contentPane.It is an instance of JLayeredPane, which provides the ability to add components at several layers.This capability is very useful when working with menu popups, dialog boxes, and dragging -- situations in which you need to place a component on top of all other components in the pane.The glassPane sits on top of all other components in the JRootPane.That provides a convenient place to draw above all other components, and makes it possible to intercept mouse events, which is useful both for dragging and for drawing.Developers can use setVisible on the glassPane to control when the glassPane displays over the other children.By default the glassPane is not visible.The custom LayoutManager used by JRootPane ensures that: The glassPane fills the entire viewable area of the JRootPane (bounds - insets).The layeredPane fills the entire viewable area of the JRootPane.The menuBar is positioned at the upper edge of the layeredPane.The contentPane fills the entire viewable area, minus the menuBar, if present.Any other views in the JRootPane view hierarchy are ignored.If you replace the LayoutManager of the JRootPane, you are responsible for managing all of these views.So ordinarily you will want to be sure that you change the layout manager for the contentPane rather than for the JRootPane itself!The painting architecture of Swing requires an opaque JComponent to exist in the containment hierarchy above all other components.This is typically provided by way of the content pane.If you replace the content pane, it is recommended that you make the content pane opaque by way of setOpaque(true).Additionally, if the content pane overrides paintComponent, it will need to completely fill in the background in an opaque color in paintComponent.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A JRadioButtonMenuItem is a menu item that is part of a group of menu items in which only one item in the group can be selected.The selected item displays its selected state.Selecting it causes any other selected item to switch to the unselected state.Menu items can be configured, and to some degree controlled, by Actions.Using an Action with a menu item has many benefits beyond directly configuring a menu item.Refer to Swing Components Supporting Action for more details, and you can find more information in How to Use Actions, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A component that visually displays the progress of some task.As the task progresses towards completion, the progress bar displays the task's percentage of completion.This percentage is typically represented visually by a rectangle which starts out empty and gradually becomes filled in as the task progresses.In addition, the progress bar can display a textual representation of this percentage.JProgressBar uses a BoundedRangeModel as its data model, with the value property representing the \"current\" state of the task, and the minimum and maximum properties representing the beginning and end points, respectively.To indicate that a task of unknown length is executing, you can put a progress bar into indeterminate mode.While the bar is in indeterminate mode, it animates constantly to show that work is occurring.As soon as you can determine the task's length and amount of progress, you should update the progress bar's value and switch it back to determinate mode.Here is an example of creating a progress bar, where task is an object (representing some piece of work) which returns information about the progress of the task:progressBar = new JProgressBar(0, task.getLengthOfTask());progressBar.setValue(0);progressBar.setStringPainted(true); Here is an example of querying the current state of the task, and using the returned value to update the progress bar:; Here is an example of putting a progress bar into indeterminate mode, and then switching back to determinate mode once the length of the task is known:the task of (initially) unknown length begins:progressBar.setIndeterminate(true);...//doWarning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "An implementation of a radio button -- an item that can be selected or deselected, and which displays its state to the user.Used with a ButtonGroup object to create a group of buttons in which only one button at a time can be selected.Note: The ButtonGroup object is a logical grouping -- not a physical grouping.To create a button panel, you should still create a JPanel or similar container-object and add a Border to it to set it off from surrounding components.Buttons can be configured, and to some degree controlled, by Actions.Using an Action with a button has many benefits beyond directly configuring a button.Refer to Swing Components Supporting Action for more details, and you can find more information in How to Use Actions, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "JSeparator provides a general purpose component for implementing divider lines - most commonly used as a divider between menu items that breaks them up into logical groupings.Instead of using JSeparator directly, you can use the JMenu or JPopupMenu addSeparator method to create and add a separator.JSeparators may also be used elsewhere in a GUI wherever a visual divider is useful.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "An implementation of a popup menu -- a small window that pops up and displays a series of choices.A JPopupMenu is used for the menu that appears when the user selects an item on the menu bar.It is also used for \"pull-right\" menu that appears when the selects a menu item that activates it.you want a menu to appear.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class adds the ability to set JPEG quantization and Huffman tables when using the built-in JPEG reader plug-in.An instance of this class will be returned from the getDefaultImageReadParam methods of the built-in JPEG ImageReader.The sole purpose of these additions is to allow the specification of tables for use in decoding abbreviated streams.The built-in JPEG reader will also accept an ordinary ImageReadParam, which is sufficient for decoding non-abbreviated streams.While tables for abbreviated streams are often obtained by first reading another abbreviated stream containing only the tables, in some applications the tables are fixed ahead of time.This class allows the tables to be specified directly from client code.If no tables are specified either in the stream or in a JPEGImageReadParam, then the stream is presumed to use the \"standard\" visually lossless tables.The default JPEGImageReadParam returned by the getDefaultReadParam method of the builtin JPEG reader contains no tables.Default tables may be obtained from the table classes JPEGQTable and JPEGHuffmanTable.If a stream does contain tables, the tables given in a JPEGImageReadParam are ignored.Furthermore, if the first image in a stream does contain tables and subsequent ones do not, then the tables given in the first image are used for all the abbreviated images.Once tables have been read from a stream, they can be overridden only by tables subsequently read from the same stream.In order to specify new tables, the setInput method of the reader must be called to change the stream.Note that this class does not provide a means for obtaining the tables found in a stream.These may be extracted from a stream by consulting the IIOMetadata object returned by the reader."},
{"description": "JPasswordField is a lightweight component that allows the editing of a single line of text where the view indicates something was typed, but does not show the original characters.You can find further information and examples in How to Use Text Fields, a section in The Java Tutorial.JPasswordField is intended to be source-compatible with java.awt.TextField used with echoChar set.It is provided separately to make it easier to safely change the UI for the JTextField without affecting password entries.By default, JPasswordField disables input methods; otherwise, input characters could be visible while they were composed using input methods.If an application needs the input methods support, please use the inherited method, enableInputMethods(true).Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class adds the ability to set JPEG quantization and Huffman tables when using the built-in JPEG writer plug-in, and to request that optimized Huffman tables be computed for an image.An instance of this class will be returned from the getDefaultImageWriteParam methods of the built-in JPEG ImageWriter.The principal purpose of these additions is to allow the specification of tables to use in encoding abbreviated streams.The built-in JPEG writer will also accept an ordinary ImageWriteParam, in which case the writer will construct the necessary tables internally.In either case, the quality setting in an ImageWriteParam has the same meaning as for the underlying library: 1.00 means a quantization table of all 1's, 0.75 means the \"standard\", visually lossless quantization table, and 0.00 means aquantization table of all 255's.While tables for abbreviated streams are often specified by first writing an abbreviated stream containing only the tables, in some applications the tables are fixed ahead of time.This class allows the tables to be specified directly from client code.Normally, the tables are specified in the IIOMetadata objects passed in to the writer, and any tables included in these objects are written to the stream.If no tables are specified in the metadata, then an abbreviated stream is written.If no tables are included in the metadata and no tables are specified in a JPEGImageWriteParam, then an abbreviated stream is encoded using the \"standard\" visually lossless tables.This class is necessary for specifying tables when an abbreviated stream must be written without writing any tables to a stream first.In order to use this class, the metadata object passed into the writer must contain no tables, and no stream metadata must be provided.The default JPEGImageWriteParam returned by the getDefaultWriteParam method of the writer contains no tables.Default tables are included in the default IIOMetadata objects returned by the writer.If the metadata does contain tables, the tables given in a JPEGImageWriteParam are ignored.Furthermore, once a set of tables has been written, only tables in the metadata can override them for subsequent writes, whether to the same stream or a different one.In order to specify new tables using this class, the reset method of the writer must be called."},
{"description": "The elements appear in natural order (as opposed to zig-zag order).Static variables are provided for the \"standard\" tables taken from Annex K of the JPEG specification, as well as the default tables conventionally used for visually lossless encoding."},
{"description": "Fields are provided for the \"standard\" tables taken from Annex K of the JPEG specification.These are the tables used as defaults."},
{"description": "JPanel is a generic lightweight container.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "1.0 Background The Joinable interface provides the methods for getting and setting a match column, which is the basis for forming the SQL JOIN formed by adding RowSet objects to a JoinRowSet object.Any standard RowSet implementation may implement the Joinable interface in order to be added to a JoinRowSet object.Implementing this interface gives a RowSet object the ability to use Joinable methods, which set, retrieve, and get information about match columns.An application may add a RowSet object that has not implemented the Joinable interface to a JoinRowSet object, but to do so it must use one of the JoinRowSet.addRowSet methods that takes both a RowSet object and a match column or an array of RowSet objects and an array of match columns.In addition, most RowSet objects extend the BaseRowSet class.For example: class MyRowSetImpl extends BaseRowSet implements CachedRowSet, Joinable { : : } 2.0 Usage GuidelinesThe methods in the Joinable interface allow a RowSet object to set a match column, retrieve a match column, or unset a match column, which is the column upon which an SQL JOIN can be based.An instance of a class that implements these methods can be added to a JoinRowSet object to allow an SQL JOIN relationship to be established.jrs.addRowSet(crs); In the previous example, crs is a CachedRowSet object that has implemented the Joinable interface.In the following example, crs2 has not, so it must supply the match column as an argument to the addRowSet method.This example assumes that column 1 is the match column.CachedRowSet crs2 = new MyRowSetImpl(); crs2.populate((ResultSet)rs); JoinRowSet jrs2 = new JoinRowSetImpl(); jrs2.addRowSet(crs2, 1); The JoinRowSet interface makes it possible to get data from one or more RowSet objects consolidated into one table without having to incur the expense of creating a connection to a database.It is therefore ideally suited for use by disconnected RowSet objects.Nevertheless, any RowSet object may implement this interface regardless of whether it is connected or disconnected.Note that a JdbcRowSet object, being always connected to its data source, can become part of an SQL JOIN directly without having to become part of a JoinRowSet object.The index array passed into the setMatchColumn methods indicates how many match columns are being set (the length of the array) in addition to which columns will be used for the match.Joinable.setMatchColumn(i); Subsequent match columns may be added as follows to a different Joinable object (a RowSet object that has implemented the Joinable interface).w = {3, 2, 5, 3}; Joinable2.setMatchColumn(w); When an application adds two or more RowSet objects to a JoinRowSet object, the order of the indexes in the array is particularly important.If overlap or underlap occurs, the match column data is maintained in the event an additional Joinable RowSet is added and needs to relate to the match column data.Therefore, applications can set multiple match columns in any order, but this order has a direct effect on the outcome of the SQL JOIN.This assertion applies in exactly the same manner when column names are used rather than column indexes to indicate match columns."},
{"description": "Class JobStateReasons is a printing attribute class, a set of enumeration values, that provides additional information about the job's current state, i.e., information that augments the value of the job's JobState attribute.Instances of JobStateReason do not appear in a Print Job's attribute set directly.Rather, a JobStateReasons attribute appears in the Print Job's attribute set.The JobStateReasons attribute contains zero, one, or more than one JobStateReason objects which pertain to the Print Job's status.The printer adds a JobStateReason object to the Print Job's JobStateReasons attribute when the corresponding condition becomes true of the Print Job, and the printer removes the JobStateReason object again when the corresponding condition becomes false, regardless of whether the Print Job's overall JobState also changed.Class JobStateReasons inherits its implementation from class java.util.HashSet.Unlike most printing attributes which are immutable once constructed, class JobStateReasons is designed to be mutable; you can add JobStateReason objects to an existing JobStateReasons object and remove them again.However, like class java.util.HashSet, class JobStateReasons is not multiple thread safe.If a JobStateReasons object will be used by multiple threads, be sure to synchronize its operations (e.g., using a synchronized set view obtained from class java.util.Collections).The string value returned by each individual() method gives the IPP keyword value.The category name returned by getName() gives the IPP attribute name."},
{"description": "The JoinRowSet interface provides a mechanism for combining related data from different RowSet objects into one JoinRowSet object, which represents an SQL JOIN.In other words, a JoinRowSet object acts as a container for the data from RowSet objects that form an SQL JOIN relationship.The Joinable interface provides the methods for setting, retrieving, and unsetting a match column, the basis for establishing an SQL JOIN relationship.The match column may alternatively be set by supplying it to the appropriate version of the JointRowSet method addRowSet.1.0 Overview Disconnected RowSet objects (CachedRowSet objects and implementations extending the CachedRowSet interface) do not have a standard way to establish an SQL JOIN between RowSet objects without the expensive operation of reconnecting to the data source.The JoinRowSet interface is specifically designed to address this need.Any RowSet object can be added to a JoinRowSet object to become part of an SQL JOIN relationship.This means that both connected and disconnected RowSet objects can be part of a JOIN.RowSet objects operating in a connected environment (JdbcRowSet objects) are encouraged to use the database to which they are already connected to establish SQL JOIN relationships between tables directly.However, it is possible for a JdbcRowSet object to be added to a JoinRowSet object if necessary.Any number of RowSet objects can be added to an instance of JoinRowSet provided that they can be related in an SQL JOIN.By definition, the SQL JOIN statement is used to combine the data contained in two or more relational database tables based upon a common attribute.The Joinable interface provides the methods for establishing a common attribute, which is done by setting a match column.The match column commonly coincides with the primary key, but there is no requirement that the match column be the same as the primary key.By establishing and then enforcing column matches, a JoinRowSet object establishes JOIN relationships between RowSet objects without the assistance of an available relational database.The type of JOIN to be established is determined by setting one of the JoinRowSet constants using the method setJoinType.The following SQL JOIN types can be set: CROSS_JOIN FULL_JOIN INNER_JOIN - the default if no JOIN type has been set LEFT_OUTER_JOIN RIGHT_OUTER_JOIN Note that if no type is set, the JOIN will automatically be an inner join.The comments for the fields in the JoinRowSet interface explain these JOIN types, which are standard SQL JOIN types.Using a JoinRowSet Object for Creating a JOIN When a JoinRowSet object is created, it is empty.The first RowSet object to be added becomes the basis for the JOIN relationship.Applications must determine which column in each of the RowSet objects to be added to the JoinRowSet object should be the match column.All of the RowSet objects must contain a match column, and the values in each match column must be ones that can be compared to values in the other match columns.The columns do not have to have the same name, though they often do, and they do not have to store the exact same data type as long as the data types can be compared.A match column can be be set in two ways: By calling the Joinable method setMatchColumn This is the only method that can set the match column before a RowSet object is added to a JoinRowSet object.The RowSet object must have implemented the Joinable interface in order to use the method setMatchColumn.Once the match column value has been set, this method can be used to reset the match column at any time.By calling one of the versions of the JoinRowSet method addRowSet that takes a column name or number (or an array of column names or numbers)Four of the five addRowSetmethods take a match column as a parameter.These four methods set or reset the match column at the time a RowSet object is being added to a JoinRowSet object.3.0 Sample Usage The following code fragment adds two CachedRowSet objects to a JoinRowSet object.Note that in this example, no SQL JOIN type is set, so the default JOIN type, which is INNER_JOIN, is established.In the following code fragment, the table EMPLOYEES, whose match column is set to the first column (EMP_ID), is added to the JoinRowSet object jrs.Then the table ESSP_BONUS_PLAN, whose match column is likewise the EMP_ID column, is added.When this second table is added to jrs, only the rows in ESSP_BONUS_PLAN whose EMP_ID value matches an EMP_ID value in the EMPLOYEES table are added.In this case, everyone in the bonus plan is an employee, so all of the rows in the table ESSP_BONUS_PLAN are added to the JoinRowSet object.In this example, both CachedRowSet objects being added have implemented the Joinable interface and can therefore call the Joinable method setMatchColumn.* FROM EMPLOYEES\"); CachedRowSet empl =EMP_ID is the first column jrs.addRowSet(bonus); At this point, jrs is an inside JOIN of the two RowSet objects based on their EMP_ID columns.The application can now browse the combined data as if it were browsing one single RowSet object.Because jrs is itself a RowSet object, an application can navigate or modify it using RowSet methods.jrs.first(); int employeeID = jrs.getInt(1); String employeeName = jrs.getString(2); Note that because the SQL JOIN must be enforced when an application adds a second or subsequent RowSet object, there may be an initial degradation in performance while the JOIN is being performed.The following code fragment adds an additional CachedRowSet object.In this case, the match column (EMP_ID) is set when the CachedRowSet object is added to the JoinRowSet object.(); four01k.populate(rs3); jrs.addRowSet(four01k, 1); The JoinRowSet object jrs now contains values from all three tables.The data in each row in four01k in which the value for the EMP_ID column matches a value for the EMP_ID column in jrs has been added to jrs.The JoinRowSet interface supplies several methods for adding RowSet objects and for getting information about the JoinRowSet object.Methods for adding one or more RowSet objects These methods allow an application to add one RowSet object at a time or to add multiple RowSet objects at one time.In either case, the methods may specify the match column for each RowSet object being added.Methods for getting information One method retrieves the RowSet objects in the JoinRowSet object, and another method retrieves the RowSet names.WHERE clause used behind the scenes to form the JOIN or a text description of what the WHERE clause does.Methods related to the type of JOIN One method sets the JOIN type, and five methods find out whether the JoinRowSet object supports a given type.A method to make a separate copy of the JoinRowSet object This method creates a copy that can be persisted to the data source."},
{"description": "Class JobSheets is a printing attribute class, an enumeration, that determines which job start and end sheets, if any, must be printed with a job.Class JobSheets declares keywords for standard job sheets values.Implementation- or site-defined names for a job sheets attribute may also be created by defining a subclass of class JobSheets.The effect of a JobSheets attribute on multidoc print jobs (jobs with multiple documents) may be affected by the MultipleDocumentHandling job attribute, depending on the meaning of the particular JobSheets value.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value.For a subclass, the attribute value must be localized to give the IPP name and natural language values."},
{"description": "Class JobStateReason is a printing attribute class, an enumeration, that provides additional information about the job's current state, i.e., information that augments the value of the job's JobState attribute.Class JobStateReason defines standard job state reason values.A Print Service implementation only needs to report those job state reasons which are appropriate for the particular implementation; it does not have to report every defined job state reason.Instances of JobStateReason do not appear in a Print Job's attribute set directly.Rather, a JobStateReasons attribute appears in the Print Job's attribute set.The JobStateReasons attribute contains zero, one, or more than one JobStateReason objects which pertain to the Print Job's status.The printer adds a JobStateReason object to the Print Job's JobStateReasons attribute when the corresponding condition becomes true of the Print Job, and the printer removes the JobStateReason object again when the corresponding condition becomes false, regardless of whether the Print Job's overall JobState also changed.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "JobState is a printing attribute class, an enumeration, that identifies the current state of a print job.Class JobState defines standard job state values.A Print Service implementation only needs to report those job states which are appropriate for the particular implementation; it does not have to report every defined job state.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "JOptionPane makes it easy to pop up a standard dialog box that prompts users for a value or informs them of something.While the JOptionPane class may appear complex because of the large number of methods, almost all uses of this class are one-line calls to one of the static showXxxDialog methods shown below: Method Name Description showConfirmDialogTell the user about something that has happened.Each of these methods also comes in a showInternalXXX flavor, which uses an internal frame to hold the dialog box (see JInternalFrame).Multiple convenience methods have also been defined -- overloaded versions of the basic methods that use different parameter lists.Each showXxxDialog method blocks the caller until the user's interaction is complete.The basic appearance of one of these dialog boxes is generally similar to the picture at the right, although the various look-and-feels are ultimately responsible for the final result.In particular, the look-and-feels will adjust the layout to accommodate the option pane's ComponentOrientation property.The parameters to these methods follow consistent patterns:parentComponent Defines the Component that is to be the parent of this dialog box.It is used in two ways: the Frame that contains it is used as the Frame parent for the dialog box, and its screen coordinates are used in the placement of the dialog box.In general, the dialog box is placed just below the component.This parameter may be null, in which case a default Frame is used as the parent, and the dialog will be centered on the screen (depending on the L&F).In the most common usage, message is just a String or String constant.However, the type of this parameter is actually Object.Its interpretation depends on its type:Object[]An array of objects is interpreted as a series of messages (one per object) arranged in a vertical stack.The interpretation is recursive -- each object in the array is interpreted according to its type.ComponentThe Component is displayed in the dialog.IconThe Icon is wrapped in a JLabel and displayed in the dialog.othersThe object is converted to a String by calling its toString method.The result is wrapped in a JLabel and displayed.The Look and Feel manager may lay out the dialog differently depending on this value, and will often provide a default icon.QUESTION_MESSAGE PLAIN_MESSAGE optionTypeDefines the set of option buttons that appear at the bottom of the dialog box:You aren't limited to this set of option buttons.You can provide any buttons you want using the options parameter.optionsA more detailed description of the set of option buttons that will appear at the bottom of the dialog box.The usual value for the options parameter is an array of Strings.But the parameter type is an array of Objects.A button is created for each object depending on its type:ComponentThe component is added to the button row directly.IconA JButton is created with this as its label.otherThe Object is converted to a string using its toString method and the result is used to label a JButton.iconA decorative icon to be placed in the dialog box.A default value for this is determined by the messageType parameter.When the selection is changed, setValue is invoked, which generates a PropertyChangeEvent.If a JOptionPane has configured to all inputINPUT_VALUE_PROPERTY can also be listened to, to determine when the user has input or selected a value.When one of the showXxxDialog methods returns an integer, the possible values are: YES_OPTIONShow an error dialog that displays the message, 'alert':yes/no and message 'choose one':JOptionPane.showConfirmDialog(null, \"choose one\", \"choose one\", JOptionPane.yes/no/cancel and message 'please choose one' and title information:Direct Use: To create and use an JOptionPane directly, the standard pattern is roughly as follows: JOptionPane pane =; //If there is not an array of option buttons: if(options =there is an array of option buttons: for(int counter = 0, maxCounter =Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Class JobPrioritySupported is an integer valued printing attribute class that specifies whether a Print Service instance supports the JobPriority attribute and the number of different job priority levels supported.The client can always specify any JobPriority value from 1 to 100 for a job.However, the Print Service instance may support fewer than 100 different job priority levels.If this is the case, the Print Service instance automatically maps the client-specified job priority value to one of the supported job priority levels, dividing the 100 job priority values equally among the available job priority levels.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobOriginatingUserName is a printing attribute class, a text attribute, that contains the name of the end user that submitted the print job.If possible, the printer sets this attribute to the most authenticated printable user name that it can obtain from the authentication service that authenticated the submitted Print Request.If such is not available, the printer uses the value of the RequestingUserName attribute supplied by the client in the Print Request's attribute set.If no authentication service is available, and the client did not supply a RequestingUserName attribute, the printer sets the JobOriginatingUserName attribute to an empty (zero-length) string.IPP Compatibility: The string value gives the IPP name value.The locale gives the IPP natural language.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobName is a printing attribute class, a text attribute, that specifies the name of a print job.A job's name is an arbitrary string defined by the client.It does not need to be unique between different jobs.A Print Job's JobName attribute is set to the value supplied by the client in the Print Request's attribute set.If, however, the client does not supply a JobName attribute in the Print Request, the printer, when it creates the Print Job, must generate a JobName.The printer should generate the value of the Print Job's JobName attribute from the first of the following sources that produces a value: (1) the DocumentName attribute of the first (or only) doc in the job, (2) the URL of the first (or only) doc in the job, if the doc's print data representation object is a URL, or (3) any other piece of Print Job specific and/or document content information.IPP Compatibility: The string value gives the IPP name value.The locale gives the IPP natural language.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobMediaSheetsCompleted is an integer valued printing attribute class that specifies the number of media sheets which have completed marking and stacking for the entire job so far, whether those sheets have been processed on one side or on both.The JobMediaSheetsCompleted attribute describes the progress of the job.This attribute is intended to be a counter.That is, the JobMediaSheetsCompleted value for a job that has not started processing must be 0.When the job's JobState is PROCESSING or PROCESSING_STOPPED, the JobMediaSheetsCompleted value is intended to increase as the job is processed; it indicates the amount of the job that has been processed at the time the Print Job's attribute set is queried or at the time a print job event is reported.When the job enters the COMPLETED, CANCELED, or ABORTED states, the JobMediaSheetsCompleted value is the final value for the job.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobMessageFromOperator is a printing attribute class, a text attribute, that provides a message from an operator, system administrator, or \"intelligent\" process to indicate to the end user the reasons for modification or other management action taken on a job.A Print Job's attribute set includes zero instances or one instance of a JobMessageFromOperator attribute, not more than one instance.A new JobMessageFromOperator attribute replaces an existing JobMessageFromOperator attribute, if any.In other words, JobMessageFromOperator is not intended to be a history log.If it wishes, the client can detect changes to a Print Job's JobMessageFromOperator attribute and maintain the client's own history log of the JobMessageFromOperator attribute values.The string value gives the IPP name value.The locale gives the IPP natural language.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobPriority is an integer valued printing attribute class that specifies a print job's priority.If a JobPriority attribute is specified for a Print Job, it specifies a priority for scheduling the job.A higher value specifies a higher priority.The value 1 indicates the lowest possible priority.The value 100 indicates the highest possible priority.Among those jobs that are ready to print, a printer must print all jobs with a priority value of n before printing those with a priority value of n-1 for all n.If the client does not specify a JobPriority attribute for a Print Job and the printer does support the JobPriority attribute, the printer must use an implementation-defined default JobPriority value.The client can always specify any job priority value from 1 to 100 for a job.However, a Print Service instance may support fewer than 100 different job priority levels.If this is the case, the Print Service instance automatically maps the client-specified job priority value to one of the supported job priority levels, dividing the 100 job priority values equally among the available job priority levels.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobMediaSheetsSupported is a printing attribute class, a set of integers, that gives the supported values for a JobMediaSheets attribute.It is restricted to a single contiguous range of integers; multiple non-overlapping ranges are not allowed.This gives the lower and upper bounds of the total sizes of print jobs in number of media sheets that the printer will accept.The JobMediaSheetsSupported attribute's canonical array form gives the lower and upper bound for the range of values to be included in an IPP \"job-media-sheets-supported\" attribute.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobMediaSheets is an integer valued printing attribute class that specifies the total number of media sheets to be produced for this job.The JobMediaSheets attribute describes the size of the job.This attribute is not intended to be a counter; it is intended to be useful routing and scheduling information if known.The printer may try to compute the JobMediaSheets attribute's value if it is not supplied in the Print Request.Even if the client does supply a value for the JobMediaSheets attribute in the Print Request, the printer may choose to change the value if the printer is able to compute a value which is more accurate than the client supplied value.The printer may be able to determine the correct value for the JobMediaSheets attribute either right at job submission time or at any later point in time.Unlike the JobKOctets and JobImpressions attributes, the JobMediaSheets value must include the multiplicative factors contributed by the number of copies specified by the Copies attribute and a \"number of copies\" instruction embedded in the document data, if any.This difference allows the system administrator to control the lower and upper bounds of both (1) the size of the document(s) with JobKOctetsSupported and JobImpressionsSupported and (2) the size of the job with JobMediaSheetsSupported.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobKOctetsSupported is a printing attribute class, a set of integers, that gives the supported values for a JobKOctets attribute.It is restricted to a single contiguous range of integers; multiple non-overlapping ranges are not allowed.This gives the lower and upper bounds of the total sizes of print jobs in units of K octets (1024 octets) that the printer will accept.The JobKOctetsSupported attribute's canonical array form gives the lower and upper bound for the range of values to be included in an IPP \"job-k-octets-supported\" attribute.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobKOctetsProcessed is an integer valued printing attribute class that specifies the total number of print data octets processed so far in K octets, i.e., in units of 1024 octets.The value must be rounded up, so that a job between 1 and 1024 octets inclusive must be indicated as being 1K octets, 1025 to 2048 inclusive must be 2K, etc.For a multidoc print job (a job with multiple documents), the JobKOctetsProcessed value is computed by adding up the individual documents' number of octets processed so far, then rounding up to the next K octets value.The JobKOctetsProcessed attribute describes the progress of the job.This attribute is intended to be a counter.That is, the JobKOctetsProcessed value for a job that has not started processing must be 0.When the job's JobState is PROCESSING or PROCESSING_STOPPED, the JobKOctetsProcessed value is intended to increase as the job is processed; it indicates the amount of the job that has been processed at the time the Print Job's attribute set is queried or at the time a print job event is reported.When the job enters the COMPLETED, CANCELED, or ABORTED states, the JobKOctetsProcessed value is the final value for the job.For implementations where multiple copies are produced by the interpreter with only a single pass over the data, the final value of the JobKOctetsProcessed attribute must be equal to the value of the JobKOctets attribute.For implementations where multiple copies are produced by the interpreter by processing the data for each copy, the final value must be a multiple of the value of the JobKOctets attribute.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobKOctets is an integer valued printing attribute class that specifies the total size of the document(s) in K octets, i.e., in units of 1024 octets requested to be processed in the job.The value must be rounded up, so that a job between 1 and 1024 octets must be indicated as being 1K octets, 1025 to 2048 must be 2K octets, etc.For a multidoc print job (a job with multiple documents), the JobKOctets value is computed by adding up the individual documents' sizes in octets, then rounding up to the next K octets value.The JobKOctets attribute describes the size of the job.This attribute is not intended to be a counter; it is intended to be useful routing and scheduling information if known.The printer may try to compute the JobKOctets attribute's value if it is not supplied in the Print Request.Even if the client does supply a value for the JobKOctets attribute in the Print Request, the printer may choose to change the value if the printer is able to compute a value which is more accurate than the client supplied value.The printer may be able to determine the correct value for the JobKOctets attribute either right at job submission time or at any later point in time.The JobKOctets value must not include the multiplicative factors contributed by the number of copies specified by the Copies attribute, independent of whether the device can process multiple copies without making multiple passes over the job or document data and independent of whether the output is collated or not.Thus the value is independent of the implementation and indicates the size of the document(s) measured in K octets independent of the number of copies.The JobKOctets value must also not include the multiplicative factor due to a copies instruction embedded in the document data.If the document data actually includes replications of the document data, this value will include such replication.In other words, this value is always the size of the source document data, rather than a measure of the hardcopy output to be produced.The size of a doc is computed based on the print data representation class as specified by the doc's DocFlavor, as shown in the table below.Length of the character array x 2 java.lang.String Length of the string x 2 java.io.Reader Number of characters read from the stream* * In these cases the Print Service itself generates the print data sent to the printer.If the Print Service supports the JobKOctets attribute, for these cases the Print Service itself must calculate the size of the print data, replacing any JobKOctets value the client specified.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobImpressionsSupported is a printing attribute class, a set of integers, that gives the supported values for a JobImpressions attribute.It is restricted to a single contiguous range of integers; multiple non-overlapping ranges are not allowed.This gives the lower and upper bounds of the total sizes of print jobs in number of impressions that the printer will accept.The JobImpressionsSupported attribute's canonical array form gives the lower and upper bound for the range of values to be included in an IPP \"job-impressions-supported\" attribute.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobImpressionsCompleted is an integer valued printing attribute class that specifies the number of impressions completed for the job so far.For printing devices, the impressions completed includes interpreting, marking, and stacking the output.The JobImpressionsCompleted attribute describes the progress of the job.This attribute is intended to be a counter.That is, the JobImpressionsCompleted value for a job that has not started processing must be 0.When the job's JobState is PROCESSING or PROCESSING_STOPPED, the JobImpressionsCompleted value is intended to increase as the job is processed; it indicates the amount of the job that has been processed at the time the Print Job's attribute set is queried or at the time a print job event is reported.When the job enters the COMPLETED, CANCELED, or ABORTED states, the JobImpressionsCompleted value is the final value for the job.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobImpressions is an integer valued printing attribute class that specifies the total size in number of impressions of the document(s) being submitted.An \"impression\" is the image (possibly many print-stream pages in different configurations) imposed onto a single media page.The JobImpressions attribute describes the size of the job.This attribute is not intended to be a counter; it is intended to be useful routing and scheduling information if known.The printer may try to compute the JobImpressions attribute's value if it is not supplied in the Print Request.Even if the client does supply a value for the JobImpressions attribute in the Print Request, the printer may choose to change the value if the printer is able to compute a value which is more accurate than the client supplied value.The printer may be able to determine the correct value for the JobImpressions attribute either right at job submission time or at any later point in time.As with JobKOctets, the JobImpressions value must not include the multiplicative factors contributed by the number of copies specified by the Copies attribute, independent of whether the device can process multiple copies without making multiple passes over the job or document data and independent of whether the output is collated or not.Thus the value is independent of the implementation and reflects the size of the document(s) measured in impressions independent of the number of copies.As with JobKOctets, the JobImpressions value must also not include the multiplicative factor due to a copies instruction embedded in the document data.If the document data actually includes replications of the document data, this value will include such replication.In other words, this value is always the number of impressions in the source document data, rather than a measure of the number of impressions to be produced by the job.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "Class JobHoldUntil is a printing attribute class, a date-time attribute, that specifies the exact date and time at which the job must become a candidate for printing.If the value of this attribute specifies a date-time that is in the future, the printer should add the JobStateReason value of JOB_HOLD_UNTIL_SPECIFIED to the job's JobStateReasons attribute, must move the job to the PENDING_HELD state, and must not schedule the job for printing until the specified date-time arrives.When the specified date-time arrives, the printer must remove the JobStateReason value of JOB_HOLD_UNTIL_SPECIFIED from the job's JobStateReasons attribute, if present.If there are no other job state reasons that keep the job in the PENDING_HELD state, the printer must consider the job as a candidate for processing by moving the job to the PENDING state.If the specified date-time has already passed, the job must be a candidate for processing immediately.Thus, one way to make the job immediately become a candidate for processing is to specify a JobHoldUntil attribute constructed like this (denoting a date-time of January 1, 1970, 00:00:00 GMT): JobHoldUntil immediately =; If the client does not supply this attribute in a Print Request and the printer supports this attribute, the printer must use its (implementation-dependent) default JobHoldUntil value at job submission time (unlike most job template attributes that are used if necessary at job processing time).IPP Compatibility: Although IPP supports a \"job-hold-until\" attribute specified as a keyword, IPP does not at this time support a \"job-hold-until\" attribute specified as a date and time.However, the date and time can be converted to one of the standard IPP keywords with some loss of precision; for example, a JobHoldUntil value with today's date and 9:00pm local time might be converted to the standard IPP keyword \"night\".The category name returned by getName() gives the IPP attribute name."},
{"description": "It is used to control how the sheets of multiple copies of a single document are collated."},
{"description": "These impositions are in compliance with IPP 1.1."},
{"description": "Principals such as this JMXPrincipal may be associated with a particular Subject to augment that Subject with an additional identity.Authorization decisions can then be based upon the Principals associated with a Subject."},
{"description": "Instances of this class are immutable.The address is an Abstract Service URL for SLP, as defined in RFC 2609 and amended by RFC 3111.It must look like this::protocol:sap Here, protocol is the transport protocol to be used to connect to the connector server.It is a string of one or more ASCII characters, each of which is a letter, a digit, or one of the characters + or -.The first character must be a letter.Uppercase letters are converted into lowercase ones.sap is the address at which the connector server is found.This address uses a subset of the syntax defined by RFC 2609 for IP-based protocols.It is a subset because the user@host syntax is not supported.The other syntaxes defined by RFC 2609 are not currently supported by this class.-path] Square brackets [] indicate optional parts of the address.Not all protocols will recognize all optional parts.The host is a host name, an IPv4 numeric host address, or an IPv6 numeric address enclosed in square brackets.The port is a decimal port number. 0 means a default or anonymous port, depending on the protocol.The port cannot be supplied without a host.The url-path, if any, begins with a slash (/) or a semicolon (;) and continues to the end of the address.It can contain attributes using the semicolon syntax specified in RFC 2609.Those attributes are not parsed by this class and incorrect attribute syntax is not detected.Although it is legal according to RFC 2609 to have a url-path that begins with a semicolon, not all implementations of SLP allow it, so it is recommended to avoid that syntax.Case is not significant in the initial service:jmx:protocol string or in the host part of the address.Depending on the protocol, case can be significant in the url-path."},
{"description": "Exception thrown by JMXConnectorFactory and JMXConnectorServerFactory when a provider exists for the required protocol but cannot be used for some reason."},
{"description": "Exception thrown as the result of a remote MBeanServer method invocation when an Error is thrown while processing the invocation in the remote MBean server.A JMXServerErrorException instance contains the original Error that occurred as its cause."},
{"description": "A set of attributes which control a print job.Instances of this class control the number of copies, default selection, destination, print dialog, file and printer names, page ranges, multiple document handling (including collation), and multi-page imposition (such as duplex) of every print job which uses the instance.Attribute names are compliant with the Internet Printing Protocol (IPP) 1.1 where possible.To use a method which takes an inner class type, pass a reference to one of the constant fields of the inner class.Client code cannot create new instances of the inner class types because none of those classes has a public constructor.COMMON); } } Every IPP attribute which supports an attributeName-default value has a corresponding setattributeNameToDefault method."},
{"description": "Instances of this interface are created by JMXConnectorServerFactory as part of its newJMXConnectorServer method."},
{"description": "A JMX API connector server is attached to an MBean server, and establishes connections to that MBean server for remote clients.A newly-created connector server is inactive, and does not yet listen for connections.Only when its start method has been called does it start listening for connections."},
{"description": "There are no instances of this class.Connections are usually made using the connect method of this class.More advanced applications can separate the creation of the connector client, using newJMXConnector and the establishment of the connection itself, using JMXConnector.connect(Map).Each client is created by an instance of JMXConnectorProvider.Suppose the given JMXServiceURL looks like \"service:jmx:protocol:remainder\".Then the factory will attempt to find the appropriate JMXConnectorProvider for protocol.A provider package list is searched for as follows: If the environment parameter to newJMXConnector contains the key jmx.remote.protocol.provider.pkgs then the associated value is the provider package list.Otherwise, if the system property jmx.remote.protocol.provider.pkgs exists, then its value is the provider package list.Otherwise, there is no provider package list.The provider package list is a string that is interpreted as a list of non-empty Java package names separated by vertical bars (|).If the provider package list is not a String, or if it contains an element that is an empty string, a JMXProviderException is thrown.If the provider package list exists and is not empty, then for each element pkg of the list, the factory will attempt to load the class pkg.protocol.ClientProviderIf the environment parameter to newJMXConnector contains the key jmx.remote.protocol.provider.class.loader then the associated value is the class loader to use to load the provider.If the associated value is not an instance of ClassLoader, an IllegalArgumentException is thrown.If the jmx.remote.protocol.provider.class.loader key is not present in the environment parameter, the calling thread's context class loader is used.If the attempt to load this class produces a ClassNotFoundException, the search for a handler continues with the next element of the list.Otherwise, a problem with the provider found is signalled by a JMXProviderException whose cause indicates the underlying exception, as follows: if the attempt to load the class produces an exception other than ClassNotFoundException, that is the cause; if Class.newInstance() for the class produces an exception, that is the cause.If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for protocol, or it will throw a MalformedURLException if there is none.An implementation may choose to find providers by other means.For example, it may support the JAR conventions for service providers, where the service interface is JMXConnectorProvider.Every implementation must support the RMI connector protocol with the default RMI transport, specified with string rmi.An implementation may optionally support the RMI connector protocol with the RMI/IIOP transport, specified with the string iiop.Once a provider is found, the result of the newJMXConnector method is the result of calling newJMXConnector on the provider.The Map parameter passed to the JMXConnectorProvider is a new read-only Map that contains all the entries that were in the environment parameter to JMXConnectorFactory.newJMXConnector, if there was one.Additionally, if the jmx.remote.protocol.provider.class.loader key is not present in the environment parameter, it is added to the new read-only Map.The associated value is the calling thread's context class loader."},
{"description": "Instances of this interface are created by JMXConnectorFactory as part of its newJMXConnector method."},
{"description": "A connector server is attached to an MBean server.It listens for client connection requests and creates a connection for each one.A connector server is associated with an MBean server either by registering it in that MBean server, or by passing the MBean server to its constructor.It only starts listening for client connections when the start method is called.A connector server stops listening for client connections when the stop method is called or when the connector server is unregistered from its MBean server.Stopping a connector server does not unregister it from its MBean server.Each time a client connection is made or broken, a notification of class JMXConnectionNotification is emitted."},
{"description": "There are no instances of this class.Each connector server is created by an instance of JMXConnectorServerProvider.Suppose the given JMXServiceURL looks like \"service:jmx:protocol:remainder\".Then the factory will attempt to find the appropriate JMXConnectorServerProvider for protocol.A provider package list is searched for as follows: If the environment parameter to newJMXConnectorServer contains the keythen the associated value is the provider package list.Otherwise, if the system property jmx.remote.protocol.provider.pkgs exists, then its value is the provider package list.Otherwise, there is no provider package list.The provider package list is a string that is interpreted as a list of non-empty Java package names separated by vertical bars (|).If the provider package list is not a String, or if it contains an element that is an empty string, a JMXProviderException is thrown.If the provider package list exists and is not empty, then for each element pkg of the list, the factory will attempt to load the class pkg.protocol.ServerProviderIf the environment parameter to newJMXConnectorServer contains the key jmx.remote.protocol.provider.class.loader then the associated value is the class loader to use to load the provider.If the associated value is not an instance of ClassLoader, an IllegalArgumentException is thrown.If the jmx.remote.protocol.provider.class.loader key is not present in the environment parameter, the calling thread's context class loader is used.If the attempt to load this class produces a ClassNotFoundException, the search for a handler continues with the next element of the list.Otherwise, a problem with the provider found is signalled by a JMXProviderException whose cause indicates the underlying exception, as follows: if the attempt to load the class produces an exception other than ClassNotFoundException, that is the cause; if Class.newInstance() for the class produces an exception, that is the cause.If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for protocol, or it will throw a MalformedURLException if there is none.An implementation may choose to find providers by other means.For example, it may support the JAR conventions for service providers, where the service interface is JMXConnectorServerProvider.Every implementation must support the RMI connector protocol with the default RMI transport, specified with string rmi.An implementation may optionally support the RMI connector protocol with the RMI/IIOP transport, specified with the string iiop.Once a provider is found, the result of the newJMXConnectorServer method is the result of calling newJMXConnectorServer on the provider.The Map parameter passed to the JMXConnectorServerProvider is a new read-only Map that contains all the entries that were in the environment parameter to JMXConnectorServerFactory.newJMXConnectorServer, if there was one.Additionally, if the jmx.remote.protocol.provider.class.loader key is not present in the environment parameter, it is added to the new read-only Map.The associated value is the calling thread's context class loader."},
{"description": "An object of this type can be used to establish a connection to a connector server.A newly-created object of this type is unconnected.However, objects created by JMXConnectorFactory.connect are already connected."},
{"description": "These notifications are sent by connector servers (instances of JMXConnectorServer) and by connector clients (instances of JMXConnector).For certain connectors, a session can consist of a sequence of connections.Connection-opened and connection-closed notifications will be sent for each one.The notification type is one of the following:jmx.remote.connection.failed A client connection has failed unexpectedly.jmx.remote.connection.notifs.lost A client connection has potentially lost notifications.This notification only appears on the client side.The timeStamp of the notification is a time value (consistent with System.currentTimeMillis()) indicating when the notification was constructed."},
{"description": "Interface to define how remote credentials are converted into a JAAS Subject.This interface is used by the RMI Connector Server, and can be used by other connector servers.The user-defined authenticator instance is passed to the connector server in the environment map as the value of the attribute JMXConnectorServer.For connector servers that use only this authentication system, if this attribute is not present or its value is null then no user authentication will be performed and full access to the methods exported by the MBeanServerConnection object will be allowed.If authentication is successful then an authenticated subject filled in with its associated principals is returned.Authorization checks will be then performed based on the given set of principals."},
{"description": "Implemented by objects that can have a JMXServiceURL address.All JMXConnectorServer objects implement this interface.Depending on the connector implementation, a JMXConnector object may implement this interface too.JMXConnector objects for the RMI Connector are instances of RMIConnector which implements this interface.An object implementing this interface might not have an address at a given moment.This is indicated by a null return value from getAddress()."},
{"description": "There are no instances of this class."},
{"description": "A menu item is essentially a button sitting in a list.When the user selects the \"button\", the action associated with the menu item is performed.A JMenuItem contained in a JPopupMenu performs exactly that function.Menu items can be configured, and to some degree controlled, by Actions.Using an Action with a menu item has many benefits beyond directly configuring a menu item.Refer to Swing Components Supporting Action for more details, and you can find more information in How to Use Actions, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "You add JMenu objects to the menu bar to construct a menu.When the user selects a JMenu object, its associated JPopupMenu is displayed, allowing the user to select one of the JMenuItems on it.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package.By default, pressing the Tab key does not transfer focus from a JMenuBar which is added to a container together with other Swing components, because the focusTraversalKeysEnabled property of JMenuBar is set to false.To resolve this, you should call the JMenuBar.setFocusTraversalKeysEnabled(true) method."},
{"description": "It does not include the runtime exceptions."},
{"description": "An implementation of a menu -- a popup window containing JMenuItems that is displayed when the user selects an item on the JMenuBar.In addition to JMenuItems, a JMenu can also contain JSeparators.In essence, a menu is a button with an associated JPopupMenu.If the \"button\" is on the JMenuBar, the menu is a top-level window.If the \"button\" is another menu item, then the JPopupMenu is \"pull-right\" menu.Menus can be configured, and to some degree controlled, by Actions.Using an Action with a menu has many benefits beyond directly configuring a menu.Refer to Swing Components Supporting Action for more details, and you can find more information in How to Use Actions, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This component represents an iconified version of a JInternalFrame.This API should NOT BE USED by Swing applications, as it will go away in future versions of Swing as its functionality is moved into JInternalFrame.This class is public only so that UI objects can display a desktop icon.If an application wants to display a desktop icon, it should create a JInternalFrame instance and iconify it.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A component that displays a list of objects and allows the user to select one or more items.A separate model, ListModel, maintains the contents of the list.It's easy to display an array or Vector of objects, using the JList constructor that automatically builds a read-only ListModel instance for you: //Create a JList that displays strings from an array String[] data = {\"one\", \"two\", \"three\", \"four\"}; JList<String> myList = new JList<String>(data); // Create a JList that displays the superclasses of JList.class, by // creating it with a Vector populated with this data Vector<Class<?// The automatically created model is stored in JList's \"model\" // property, which you can retrieve ListModel<Class<?i++) { System.out.println(model.getElementAt(i)); } A ListModel can be supplied directly to a JList by way of a constructor or the setModel method.The contents need not be static - the number of items, and the values of items can change over time.A correct ListModel implementation notifies the set of javax.swing.event.ListDataListeners that have been added to it, each time a change occurs.These changes are characterized by a javax.swing.event.ListDataEvent, which identifies the range of list indices that have been modified, added, or removed.JList's ListUI is responsible for keeping the visual representation up to date with changes, by listening to the model.Simple, dynamic-content, JList applications can use the DefaultListModel class to maintain list elements.This class implements the ListModel interface and also provides a java.util.Vector-like API.Applications that need a more custom ListModel implementation may instead wish to subclass AbstractListModel, which provides basic support for managing and notifying listeners.This list model has about 2^16 elements.MAX_VALUE; } public String getElementAt(int index) { return \"Index \" + index; } }; The selection state of a JList is managed by another separate model, an instance of ListSelectionModel.JList is initialized with a selection model on construction, and also contains methods to query or set this selection model.Additionally, JList provides convenient methods for easily managing the selection.These methods, such as setSelectedIndex and getSelectedValue, are cover methods that take care of the details of interacting with the selection model.By default, JList's selection model is configured to allow any combination of items to be selected at a time; selection mode MULTIPLE_INTERVAL_SELECTION.The selection mode can be changed on the selection model directly, or via JList's cover method.Responsibility for updating the selection model in response to user gestures lies with the list's ListUI.A correct ListSelectionModel implementation notifies the set of javax.swing.event.ListSelectionListeners that have been added to it each time a change to the selection occurs.These changes are characterized by a javax.swing.event.ListSelectionEvent, which identifies the range of the selection change.The preferred way to listen for changes in list selection is to add ListSelectionListeners directly to the JList.JList then takes care of listening to the the selection model and notifying your listeners of change.Responsibility for listening to selection changes in order to keep the list's visual representation up to date lies with the list's ListUI.Painting of cells in a JList is handled by a delegate called a cell renderer, installed on the list as the cellRenderer property.The renderer provides a java.awt.Component that is used like a \"rubber stamp\" to paint the cells.Each time a cell needs to be painted, the list's ListUI asks the cell renderer for the component, moves it into place, and has it paint the contents of the cell by way of its paint method.A default cell renderer, which uses a JLabel component to render, is installed by the lists's ListUI.You can substitute your own renderer using code like this: //class MyCellRenderer extends JLabel implements ListCellRenderer<Object> { final static ImageIcon longIcon = new ImageIcon(\"long.gif\");This is the only method defined by ListCellRenderer.We just reconfigure the JLabel each time we're called.the list Object value, // value to display int index, // cell index boolean isSelected, // is the cell selected boolean cellHasFocus)does the cell have focus { String s =MyCellRenderer()); Another job for the cell renderer is in helping to determine sizing information for the list.By default, the list's ListUI determines the size of cells by asking the cell renderer for its preferred size for each list item.This can be expensive for large lists of items.To avoid these calculations, you can set a fixedCellWidth and fixedCellHeight on the list, or have these values calculated automatically based on a single prototype value: JList<String; // We don't want the JList implementation to compute the width // or height of all of the list cells, so we give it a stringthat's as big as we'll need for any cell.It uses this to // compute values for the fixedCellWidth and fixedCellHeight // properties.To create a list that scrolls, make it the viewport view of a JScrollPane.Or in two steps: JScrollPane scrollPane = new JScrollPane(); scrollPane.getViewport().setView(myList); JList doesn't provide any special handling of double or triple (or N) mouse clicks, but it's easy to add a MouseListener if you wish to take action on these events.Use the locationToIndex method to determine what cell was clicked.For example: MouseListener mouseListener = new MouseAdapter() { public void mouseClicked(MouseEvent e) { if (e.getClickCount() == 2) { int index = list.locationToIndex(e.getPoint()); System.out.println(\"Double clicked on Item \" + index); } } }; list.addMouseListener(mouseListener); Warning: Swing is not thread safe.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "JLayeredPane adds depth to a JFC/Swing container, allowing components to overlap each other when needed.An Integer object specifies each component's depth in the container, where higher-numbered components sit \"on top\" of other components.For convenience, JLayeredPane divides the depth-range into several different layers.Putting a component into one of those layers makes it easy to ensure that components overlap properly, without having to worry about specifying numbers for specific depths:PALETTE_LAYER The palette layer sits over the default layer.Useful for floating toolbars and palettes, so they can be positioned above other components.They will appear on top of any toolbars, palettes, or standard components in the container.That way, the popup windows associated with combo boxes, tooltips, and other help text will appear above the component, palette, or dialog that generated them.When dragging a component, reassigning it to the drag layer ensures that it is positioned over every other component in the container.When finished dragging, it can be reassigned to its normal layer.The JLayeredPane methods moveToFront(Component), moveToBack(Component) and setPosition can be used to reposition a component within its layer.The setLayer method can also be used to change the component's current layer.Details JLayeredPane manages its list of children like Container, but allows for the definition of a several layers within itself.Children in the same layer are managed exactly like the normal Container object, with the added feature that when children components overlap, children in higher layers display above the children in lower layers.Each layer is a distinct integer number.The layer attribute can be set on a Component by passing an Integer object during the add call.DEFAULT_LAYER); or layeredPane.add(child, new Integer(10)); The layer attribute can also be set on a Component by calling layeredPaneParent.setLayer(child, 10) on the JLayeredPane that is the parent of component.The layer should be set before adding the child to the parent.Higher number layers display above lower number layers.So, using numbers for the layers and letters for individual components, a representative list order would look like this: 5a, 5b, 5c, 2a, 2b, 2c, 1a where the leftmost components are closest to the top of the display.A component can be moved to the top or bottom position within its layer by calling moveToFront or moveToBack.The position of a component within a layer can also be specified directly.Valid positions range from 0 up to one less than the number of components in that layer.A value of -1 indicates the bottommost position.A value of 0 indicates the topmost position.Unlike layer numbers, higher position values are lower in the display.Note: This sequence (defined by java.awt.Container) is the reverse of the layer numbering sequence.Usually though, you will use moveToFront, moveToBack, and setLayer.Here are some examples using the method add(Component, layer, position):Calling add(5x, 5, -1) results in: 5a, 5b, 5c, 5x, 2a, 2b, 2c, 1a Calling add(5z, 5, 2) results in: 5a, 5b, 5z, 5c, 5x, 2a, 2b, 2c, 1a Calling add(3a,Note: that these layers are simply a logical construct and LayoutManagers will affect all child components of this container without regard for layer settings.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "JLayer is a universal decorator for Swing components which enables you to implement various advanced painting effects as well as receive notifications of all AWTEvents generated within its borders.JLayer delegates the handling of painting and input events to a LayerUI object, which performs the actual decoration.This combination enables you to enrich existing components by adding new advanced functionality such as temporary locking of a hierarchy, data tips for compound components, enhanced mouse scrolling etc and so on.JLayer is a good solution if you only need to do custom painting over compound component or catch input events from its subcomponents.This custom layerUI will fill the layer with translucent green // and print out all mouseMotion events generated within its borders LayerUI// paint the layer as is super.paint(g, c);// fill it with the translucent green g.setColor(new Color(0, 128, 0, 128)); g.fillRect(0, 0, c.getWidth(), c.getHeight()); } public void installUI(JComponent c) { super.installUI(c); // enable mouse motion events for the layer's subcomponents ((JLayer) c).setLayerEventMask(AWTEvent.MOUSE_MOTION_EVENT_MASK); } public void uninstallUI(JComponent c) { super.uninstallUI(c); // reset the layer event mask ((JLayer) c).setLayerEventMask(0); } // overridden method which catches MouseMotion events public void eventDispatched(AWTEvent e, JLayer<?; // create the layer for the panel using our custom layerUI return new JLayer<JComponent>(panel, layerUI); } private static void createAndShowGUI() { final JFrame frame =; frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // work with the layer as with any other Swing component frame.add(createLayer()); frame.setSize(200, 200); frame.setLocationRelativeTo(null); frame.setVisible(true); } public static voidmain(String[] args) throws Exception { SwingUtilities.invokeAndWait(new Runnable() { public void run() { createAndShowGUI(); } }); } } Note: JLayer doesn't support the following methods: Container.add(java.awt.Component, Object, int) using any of of them will cause UnsupportedOperationException to be thrown, to add a component to JLayer use setView(Component) or setGlassPane(JPanel)."},
{"description": "A lightweight object that provides many of the features of a native frame, including dragging, closing, becoming an icon, resizing, title display, and support for a menu bar.Generally, you add JInternalFrames to a JDesktopPane.The UI delegates the look-and-feel-specific actions to the DesktopManager object maintained by the JDesktopPane.The JInternalFrame content pane is where you add child components.As a convenience, the add, remove, and setLayout methods of this class are overridden, so that they delegate calls to the corresponding methods of the ContentPane.For example, you can add a child component to an internal frame as follows: internalFrame.add(child); And the child will be added to the contentPane.The content pane is actually managed by an instance of JRootPane, which also manages a layout pane, glass pane, and optional menu bar for the internal frame.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "An extended version of java.awt.Frame that adds support for the JFC/Swing component architecture.You can find task-oriented documentation about using JFrame in The Java Tutorial, in the section How to Make Frames.The JFrame class is slightly incompatible with Frame.Like all other JFC/Swing top-level containers, a JFrame contains a JRootPane as its only child.The content pane provided by the root pane should, as a rule, contain all the non-menu components displayed by the JFrame.This is different from the AWT Frame case.As a convenience, the add, remove, and setLayout methods of this class are overridden, so that they delegate calls to the corresponding methods of the ContentPane.For example, you can add a child component to a frame as follows: frame.add(child); And the child will be added to the contentPane.Attempting to set it to null will cause the JFrame to throw an exception.The default content pane will have a BorderLayout manager set on it.Unlike a Frame, a JFrame has some notion of how to respond when the user attempts to close the window.The default behavior is to simply hide the JFrame when the user closes the window.To change the default behavior, you invoke the method setDefaultCloseOperation(int).To make the JFrame behave the same as a Frame instance, use setDefaultCloseOperation(WindowConstants.For more information on content panes and other features that root panes provide, see Using Top-Level Containers in The Java Tutorial.In a multi-screen environment, you can create a JFrame on a different screen device.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A label does not react to input events.As a result, it cannot get the keyboard focus.A label can, however, display a keyboard alternative as a convenience for a nearby component that has a keyboard alternative but can't display it.A JLabel object can display either text, an image, or both.You can specify where in the label's display area the label's contents are aligned by setting the vertical and horizontal alignment.By default, labels are vertically centered in their display area.Text-only labels are leading edge aligned, by default; image-only labels are horizontally centered, by default.You can also specify the position of the text relative to the image.By default, text is on the trailing edge of the image, with the text and image vertically aligned.A label's leading and trailing edge are determined from the value of its ComponentOrientation property.At present, the default ComponentOrientation setting maps the leading edge to left and the trailing edge to right.Finally, you can use the setIconTextGap method to specify how many pixels should appear between the text and the image.The default is 4 pixels.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Instances of AbstractFormatterFactory are used by JFormattedTextField to obtain instances of AbstractFormatter which in turn are used to format values.AbstractFormatterFactory can return different AbstractFormatters based on the state of the JFormattedTextField, perhaps returning different AbstractFormatters when the JFormattedTextField has focus vs when it doesn't have focus."},
{"description": "Instances of AbstractFormatter are used by JFormattedTextField to handle the conversion both from an Object to a String, and back from a String to an Object.AbstractFormatters can also enforce editing policies, or navigation policies, or manipulate the JFormattedTextField in any way it sees fit to enforce the desired policy.An AbstractFormatter can only be active in one JFormattedTextField at a time.JFormattedTextField invokes install when it is ready to use it followed by uninstall when done.Subclasses that wish to install additional state should override install and message super appropriately.Subclasses must override the conversion methods stringToValue and valueToString.Optionally they can override getActions, getNavigationFilter and getDocumentFilter to restrict the JFormattedTextField in a particular way.Subclasses that allow the JFormattedTextField to be in a temporarily invalid state should invoke setEditValid at the appropriate times."},
{"description": "JFormattedTextField extends JTextField adding support for formatting arbitrary values, as well as retrieving a particular object once the user has edited the text.The following illustrates configuring a JFormattedTextField to edit dates: JFormattedTextField ftf = new JFormattedTextField(); ftf.setValue(new Date()); Once a JFormattedTextField has been created, you can listen for editing changes by way of adding a PropertyChangeListener and listening for PropertyChangeEvents with the property name value.JFormattedTextField allows configuring what action should be taken when focus is lost.The possible configurations are: ValueDescription JFormattedTextField.COMMIT Commits the current value.If the value being edited isn't considered a legal value by the AbstractFormatter that is, a ParseException is thrown, then the value will not change, and then edited value will persist.COMMIT_OR_REVERT Similar to COMMIT, but if the value isn't legal, behave like REVERT.PERSIST Do nothing, don't obtain a new AbstractFormatter, and don't update the value.The default is JFormattedTextField.To lock the focus down while the JFormattedTextField is an invalid edit state you can attach an InputVerifier.The following code snippet shows a potential implementation of such an InputVerifier: public class FormattedTextFieldVerifier extends InputVerifier { public boolean verify(JComponent input) { if (input instanceof JFormattedTextField) {} public boolean shouldYieldFocus(JComponent input) { return verify(input); } } Alternatively, you could invoke commitEdit, which would also commit the value.JFormattedTextField does not do the formatting it self, rather formatting is done through an instance of JFormattedTextField.AbstractFormatter which is obtained from an instance of JFormattedTextField.AbstractFormatter are notified when they become active by way of the install method, at which point the JFormattedTextField.AbstractFormatter can install whatever it needs to, typically a DocumentFilter.Similarly when JFormattedTextField no longer needs the AbstractFormatter, it will invoke uninstall.JFormattedTextField typically queries the AbstractFormatterFactory for an AbstractFormat when it gains or loses focus.Although this can change based on the focus lost policy.If the focus lost policy is JFormattedTextField.Similarly if the focus lost policy is JFormattedTextField.COMMIT and an exception is thrown from stringToValue, the AbstractFormatterFactory will not be queried when focus is lost or gained.AbstractFormatter is also responsible for determining when values are committed to the JFormattedTextField.AbstractFormatters will make new values available on every edit, and others will never commit the value.You can force the current value to be obtained from the current JFormattedTextField.commitEdit will be invoked whenever return is pressed in the JFormattedTextField.If an AbstractFormatterFactory has not been explicitly set, one will be set based on the Class of the value type after setValue has been invoked (assuming value is non-null).For example, in the following code an appropriate AbstractFormatterFactory and AbstractFormatter will be created to handle formatting of numbersAs the AbstractFormatter will typically install a DocumentFilter on the Document, and a NavigationFilter on the JFormattedTextFieldyou should not install your own.If you do, you are likely to see odd behavior in that the editing policy of the AbstractFormatter will not be enforced.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "JFileChooser provides a simple mechanism for the user to choose a file.The following code pops up a file chooser for the user's home directory that sees only .jpgAPPROVE_OPTION) { System.out.println(\"You chose to open this file: \" + chooser.getSelectedFile().getName());"},
{"description": "A container used to create a multiple-document interface or a virtual desktop.You create JInternalFrame objects and add them to the JDesktopPane.JDesktopPane extends JLayeredPane to manage the potentially overlapping internal frames.It also maintains a reference to an instance of DesktopManager that is set by the UI class for the current look and feel (L&F).Note that JDesktopPane does not support borders.This class is normally used as the parent of JInternalFrames to provide a pluggable DesktopManager object to the JInternalFrames.The installUI of the L&F specific implementation is responsible for setting the desktopManager variable appropriately.When the parent of a JInternalFrame is a JDesktopPane, it should delegate most of its behavior to the desktopManager (closing, resizing, etc).Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Defines the constants that are used to identify generic SQL types, called JDBC types."},
{"description": "To use a component that inherits from JComponent, you must place the component in a containment hierarchy whose root is a top-level Swing container.Top-level Swing containers -- such as JFrame, JDialog, and JApplet -- are specialized components that provide a place for other Swing components to paint themselves.The JComponent class provides: The base class for both standard and custom components that use the Swing architecture.A \"pluggable look and feel\" (L&F) that can be specified by the programmer or (optionally) selected by the user at runtime.The look and feel for each component is provided by a UI delegate -- an object that descends from ComponentUI.Support for tool tips -- short descriptions that pop up when the cursor lingers over a component.JComponent contains all of the methods in the Accessible interface, but it doesn't actually implement the interface.That is the responsibility of the individual classes that extend JComponent.Object) methods, you can associate name-object pairs with any object that descends from JComponent.An infrastructure for painting that includes double buffering and support for borders.For more information see Painting and How to Use Borders, both of which are sections in The Java Tutorial.For example, JTable documents the default row height as 16.Each JComponent subclass that has a ComponentUI will create the ComponentUI as part of its constructor.In order to provide a particular look and feel each ComponentUI may set properties back on the JComponent that created it.For example, a custom look and feel may require JTables to have a row height of 24.The documented defaults are the value of a property BEFORE the ComponentUI has been installed.If you need a specific value for a particular property you should explicitly set it.In release 1.4, the focus subsystem was rearchitected.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "You can find how-to information and examples of using editor panes in Using Text Components, a section in The Java Tutorial.This component uses implementations of the EditorKit to accomplish its behavior.It effectively morphs into the proper kind of text editor for the kind of content it is given.The content type that editor is bound to at any given time is determined by the EditorKit currently installed.If the content is set to a new URL, its type is used to determine the EditorKit that should be used to load the content.By default, the following types of content are known: text/plain Plain text, which is the default the type given isn't recognized.The kit used in this case is an extension of DefaultEditorKit that produces a wrapped plain text view.The kit used in this case is the class javax.swing.text.html.HTMLEditorKit which provides HTML 3.2 support.The kit used in this case is the class javax.swing.text.rtf.RTFEditorKit which provides a limited support of the Rich Text Format.There are several ways to load content into this component.The setText method can be used to initialize the component from a string.In this case the current EditorKit will be used, and the content type will be expected to be of this type.The read method can be used to initialize the component from a Reader.Note that if the content type is HTML, relative references (e.g. for things like images) can't be resolved unless the <base> tag is used or the Base property on HTMLDocument is set.In this case the current EditorKit will be used, and the content type will be expected to be of this type.The setPage method can be used to initialize the component from a URL.In this case, the content type will be determined from the URL, and the registered EditorKit for that content type will be set.Some kinds of content may provide hyperlink support by generating hyperlink events.The HTML EditorKit will generate hyperlink events if the JEditorPane is not editable (JEditorPane.setEditable(false); has been called).If HTML frames are embedded in the document, the typical response would be to change a portion of the current document.The following code fragment is a possible hyperlink listener implementation, that treats HTML frame events specially, and simply displays any other activated hyperlinks. \u00a0 (HTMLDocument)pane.getDocument();\u00a0 doc.processHTMLFrameHyperlinkEvent(evt);\u00a0 } else {\u00a0 try {\u00a0 pane.setPage(e.getURL());\u00a0 } catch (Throwable t) {\u00a0 t.printStackTrace();\u00a0 }\u00a0 }\u00a0 }\u00a0 }\u00a0 } For information on customizing how text/html is rendered please see W3C_LENGTH_UNITS and HONOR_DISPLAY_PROPERTIES Culturally dependent information in some documents is handled through a mechanism called character encoding.Character encoding is an unambiguous mapping of the members of a character set (letters, ideographs, digits, symbols, or control functions) to specific numeric code values.It represents the way the file is stored.When the file is passed to an user agent (JEditorPane)it is converted to the document character set (ISO-10646 aka Unicode).There are multiple ways to get a character set mapping to happen with JEditorPane.One way is to specify the character set as a parameter of the MIME type.This will be established by a call to the setContentType method.If the content is loaded by the setPage method the content type will have been set according to the specification of the URL.It the file is loaded directly, the content type would be expected to have been set prior to loading.Another way the character set can be specified is in the document itself.This requires reading the document prior to determining the character set that is desired.To handle this, it is expected that the EditorKit.read operation throw a ChangedCharSetException which will be caught.The read is then restarted with a new Reader that uses the character set specified in the ChangedCharSetException (which is an IOException).For a discussion on how newlines are handled, see DefaultEditorKit.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "You can use this class to create a custom dialog, or invoke the many class methods in JOptionPane to create a variety of standard dialogs.The JDialog component contains a JRootPane as its only child.The contentPane should be the parent of any children of the JDialog.As a convenience, the add, remove, and setLayout methods of this class are overridden, so that they delegate calls to the corresponding methods of the ContentPane.For example, you can add a child component to a dialog as follows: dialog.add(child); And the child will be added to the contentPane.Attempting to set it to null generates an exception.The default contentPane has a BorderLayout manager set on it.In a multi-screen environment, you can create a JDialog on a different screen device than its owner.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The standard interface that all standard implementations of JdbcRowSet must implement.Overview A wrapper around a ResultSet object that makes it possible to use the result set as a JavaBeans\u2122 component.Thus, a JdbcRowSet object can be one of the Beans that a tool makes available for composing an application.Because a JdbcRowSet is a connected rowset, that is, it continually maintains its connection to a database using a JDBC technology-enabled driver, it also effectively makes the driver a JavaBeans component.Because it is always connected to its database, an instance of JdbcRowSet can simply take calls invoked on it and in turn call them on its ResultSet object.As a consequence, a result set can, for example, be a component in a Swing application.Another advantage of a JdbcRowSet object is that it can be used to make a ResultSet object scrollable and updatable.All RowSet objects are by default scrollable and updatable.If the driver and database being used do not support scrolling and/or updating of result sets, an application can populate a JdbcRowSet object with the data of a ResultSet object and then operate on the JdbcRowSet object as if it were the ResultSet object.The reference implementation of the JdbcRowSet interface, JdbcRowSetImpl, provides an implementation of the default constructor.A new instance is initialized with default values, which can be set with new values as needed.In general, this method does the following: establishes a connection with a database creates a PreparedStatement object and sets any of its placeholder parameters executes the statement to create a ResultSet object If the execute method is successful, it will set the appropriate private JdbcRowSet fields with the following: a Connection object -- the connection between the rowset and the database a PreparedStatement object -- the query that produces the result set a ResultSet object -- the result set that the rowset's command produced and that is being made, in effect, a JavaBeans componentIf these fields have not been set, meaning that the execute method has not executed successfully, no methods other than execute and close may be called on the rowset.All other public methods will throw an exception.Before calling the execute method, however, the command and properties needed for establishing a connection must be set.The following code fragment creates a JdbcRowSetImpl object, sets the command and connection properties, sets the placeholder parameter, and then invokes the method execute.jrs.setURL(\"jdbc:myDriver:myAttribute\"); jrs.setUsername(\"cervantes\"); jrs.setPassword(\"sancho\"); jrs.setString(1, \"BIOGRAPHY\"); jrs.execute(); The variable jrs now represents an instance of JdbcRowSetImpl that is a thin wrapper around the ResultSet object containing all the rows in the table TITLES where the type of book is biography.At this point, operations called on jrs will affect the rows in the result set, which is effectively a JavaBeans component."},
{"description": "The interface that defines a KeySelectionManager.To qualify as a KeySelectionManager, the class needs to implement the method that identifies the list index given a character and the combo box data model."},
{"description": "A component that combines a button or editable field and a drop-down list.The user can select a value from the drop-down list, which appears at the user's request.If you make the combo box editable, then the combo box includes an editable field into which the user can type a value.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "If selected, the menu item typically appears with a checkmark next to it.If unselected or deselected, the menu item appears without a checkmark.Like a regular menu item, a check box menu item can have either text or a graphic icon associated with it, or both.Either isSelected/setSelected or getState/setState can be used to determine/specify the menu item's selection state.The preferred methods are isSelected and setSelected, which work for all menus and buttons.The getState and setState methods exist for compatibility with other component sets.Menu items can be configured, and to some degree controlled, by Actions.Using an Action with a menu item has many benefits beyond directly configuring a menu item.Refer to Swing Components Supporting Action for more details, and you can find more information in How to Use Actions, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "JColorChooser provides a pane of controls designed to allow a user to manipulate and select a color.This class provides three levels of API:A static convenience method which shows a modal color-chooser dialog and returns the color selected by the user.A static convenience method for creating a color-chooser dialog where ActionListeners can be specified to be invoked when the user presses one of the dialog buttons.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "An implementation of a check box -- an item that can be selected or deselected, and which displays its state to the user.By convention, any number of check boxes in a group can be selected.Buttons can be configured, and to some degree controlled, by Actions.Using an Action with a button has many benefits beyond directly configuring a button.Refer to Swing Components Supporting Action for more details, and you can find more information in How to Use Actions, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Buttons can be configured, and to some degree controlled, by Actions.Using an Action with a button has many benefits beyond directly configuring a button.Refer to Swing Components Supporting Action for more details, and you can find more information in How to Use Actions, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "JAXP Source implementation that marshals a JAXB-generated object.This utility class is useful to combine JAXB with other Java/XML technologies.The following example shows how to use JAXB to marshal a document for transformation by XSLT.MyObject o = // get JAXB content tree //jaxbContext is a JAXBContext object from which 'o' is created.TransformerFactory.newInstance(); Transformer t = tf.newTransformer(new StreamSource(\"test.xsl\")); // run transformation t.transform(source,new StreamResult(System.out)); The fact that JAXBSource derives from SAXSource is an implementation detail.The XMLReader object obtained by the getXMLReader method shall be used only for parsing the InputSource object returned by the getInputSource method.Similarly the InputSource object obtained by the getInputSource method shall be used only for being parsed by the XMLReader object returned by the getXMLReader."},
{"description": "JAXP Result implementation that unmarshals a JAXB object.This utility class is useful to combine JAXB with other Java/XML technologies.The following example shows how to use JAXB to unmarshal a document resulting from an XSLT transformation.; // run transformation t.transform(new StreamSource(\"document.xml\"),result); // obtain the unmarshalled content tree Object o = result.getResult(); The fact that JAXBResult derives from SAXResult is an implementation detail.In particular it shall never attempt to call the setHandler, setLexicalHandler, and setSystemId methods."},
{"description": "This class is for JAXB permissions.A JAXBPermission contains a name (also referred to as a \"target name\") but no actions list; you either have the named permission or you don't.The target name is the name of the JAXB permission (see below).The following table lists all the possible JAXBPermission target names, and for each provides a description of what the permission allows and a discussion of the risks of granting code the permission.What the Permission AllowsRisks of Allowing this Permission setDatatypeConverter Allows the code to set VM-wide DatatypeConverterInterface via the setDatatypeConverter method that all the methods on DatatypeConverter uses.Malicious code can set DatatypeConverterInterface, which has VM-wide singleton semantics, before a genuine JAXB implementation sets one.This allows malicious code to gain access to objects that it may otherwise not have access to, such as Frame.getFrames() that belongs to another application running in the same JVM."},
{"description": "Intially, the intent of this class is to just conceptualize how a JAXB application developer can access xml binding information, independent if binding model is java to schema or schema to java.The factory method to get a JAXBIntrospector instance is JAXBContext.createJAXBIntrospector()."},
{"description": "This is the root exception class for all JAXB exceptions."},
{"description": "This class represents information about an Xml Element from both the element declaration within a schema and the element instance value within an xml document with the following properties element's xml tag name value represents the element instance's atttribute(s) and content model element declaration's declaredType (xs:element @type attribute) scope of element declaration boolean nil property.The declaredType and scope property are the JAXB class binding for the xml type definition.Scope is either JAXBElement.There is a property constraint that if value is null, then nil must be true.The converse is not true to enable representing a nil element with attribute(s).If nil is true, it is possible that value is non-null so it can hold the value of the attributes associated with a nil element."},
{"description": "Class that defines convenience methods for common, simple use of JAXB.Methods defined in this class are convenience methods that combine several basic operations in the JAXBContext, Unmarshaller, and Marshaller.They are designed to be the prefered methods for developers new to JAXB.They have the following characterstics: Generally speaking, the performance is not necessarily optimal.It is expected that people who need to write performance critical code will use the rest of the JAXB API directly.Errors that happen during the processing is wrapped into DataBindingException (which will have JAXBException as its cause.It is expected that people who prefer the checked exception would use the rest of the JAXB API directly.In addition, the unmarshal methods have the following characteristic:Schema validation is not performed on the input XML.The processing will try to continue even if there are errors in the XML, as much as possible.Only as the last resort, this method fails with DataBindingException.Similarly, the marshal methods have the following characteristic: The processing will try to continue even if the Java object tree does not meet the validity requirement.Only as the last resort, this method fails with DataBindingException.All the methods on this class require non-null arguments to all parameters.The unmarshal methods either fail with an exception or return a non-null value."},
{"description": "The JAXBContext class provides the client's entry point to the JAXB API.It provides an abstraction for managing the XML/Java binding information necessary to implement the JAXB binding framework operations:A client application normally obtains new instances of this class using one of these two styles for newInstance methods, although there are other specialized forms of the method available: JAXBContext.newInstance( \"com.acme.foo:com.acme.bar\" )The JAXBContext instance is initialized from a list of colon separated Java package names.Each java package contains JAXB mapped classes, schema-derived classes and/or user annotated classes.Additionally, the java package may contain JAXB package annotations that must be processed.The JAXBContext instance is initialized with class(es)passed as parameter(s) and classes that are statically reachable from these class(es).SPEC REQUIREMENT: the provider must supply an implementation class containing the following method signatures: public static JAXBContext createContext( String contextPath, ClassLoader classLoader, Map<String,Object> properties ) throws JAXBException public static JAXBContext createContext( Class[] classes, Map<String,Object> properties ) throws JAXBExceptionThe following JAXB 1.0 requirement is only required for schema to java interface/implementation binding.It does not apply to JAXB annotated classes.JAXB Providers must generate a jaxb.properties file in each package containing schema derived classes.The property file must contain a property named javax.xml.bind.context.factory whose value is the name of the class that implements the createContext APIs.The class supplied by the provider does not have to be assignable to javax.xml.bind.JAXBContext, it simply has to provide a class that implements the createContext APIs.In addition, the provider must call the DatatypeConverter.setDatatypeConverter api prior to any client invocations of the marshal and unmarshal methods.This is necessary to configure the datatype converter that will be used during these operations.Unmarshalling The Unmarshaller class provides the client application the ability to convert XML data into a tree of Java content objects.The unmarshal method allows for any global XML element declared in the schema to be unmarshalled as the root of an instance document.Additionally, the unmarshal method allows for an unrecognized root element that has an xsi:type attribute's value that references a type definition declared in the schema to be unmarshalled as the root of an instance document.The JAXBContext object allows the merging of global elements and type definitions across a set of schemas (listed in the contextPath).Since each schema in the schema set can belong to distinct namespaces, the unification of schemas to an unmarshalling context should be namespace independent.This means that a client application is able to unmarshal XML documents that are instances of any of the schemas listed in the contextPath.The client application may also generate Java content trees explicitly rather than unmarshalling existing XML data.For all JAXB-annotated value classes, an application can create content using constructors.For schema-derived interface/implementation classes and for the creation of elements that are not bound to a JAXB-annotated class, an application needs to have access and knowledge about each of the schema derived ObjectFactory classes that exist in each of java packages contained in the contextPath.For each schema derived java class, there is a static factory method that produces objects of that type.For example, assume that after compiling a schema, you have a package com.acme.foo that contains a schema derived interface named PurchaseOrder.In order to create objects of that type, the client application would use the factory method like this: com.acme.foo.PurchaseOrder po = com.acme.foo.ObjectFactory.createPurchaseOrder(); Once the client application has an instance of the the schema derived object, it can use the mutator methods to set content on it.SPEC REQUIREMENT: the provider must generate a class in each package that contains all of the necessary object factory methods for that package named ObjectFactory as well as the static newInstance( javaContentInterface )The Marshaller class provides the client application the ability to convert a Java content tree back into XML data.There is no difference between marshalling a content tree that is created manually using the factory methods and marshalling a content tree that is the result an unmarshal operation.Clients can marshal a java content tree back to XML data to a java.io.OutputStream or a java.io.Writer.The marshalling process can alternatively produce SAX2 event streams to a registered ContentHandler or produce a DOM Node object.Client applications have control over the output encoding as well as whether or not to marshal the XML data as a complete document or as a fragment.Here is a simple example that unmarshals an XML document and then marshals it back out: JAXBContext jc = JAXBContext.newInstance( \"com.acme.foo\" ); // unmarshal from foo.xmljc.createMarshaller(); m.marshal( fooObj, System.out ); Validation Validation has been changed significantly since JAXB 1.0.This means that you are advised not to use this class and, in fact, it may not even be available depending on your JAXB provider.JAXB 1.0 client applications that rely on Validator will still work properly when deployed with the JAXB 1.0 runtime system.In JAXB 2.0, the Unmarshaller has included convenince methods that expose the JAXP 1.3 javax.xml.validation framework.The following JAXB 1.0 restriction only applies to binding schema to interfaces/implementation classes.Since this binding does not require a common runtime system, a JAXB client application must not attempt to mix runtime objects (JAXBContext, Marshaller, etc. ) from different providers.This does not mean that the client application isn't portable, it simply means that a client has to use a runtime system provided by the same provider that was used to compile the schema.Discovery of JAXB implementation When one of the newInstance methods is called, a JAXB implementation is discovered by the following steps.String) method, in the order they are specified, jaxb.properties file is looked up in its package, by using the associated classloader \u2014 this is the owner class loader for a Class argument, and for a package the specified ClassLoader.If such a file is discovered, it is loaded as a property file, and the value of the JAXB_CONTEXT_FACTORY key will be assumed to be the provider factory class.This class is then loaded by the associated classloader discussed above.This phase of the look up allows some packages to force the use of a certain JAXB implementation.(For example, perhaps the schema compiler has generated some vendor extension in the code.)If the system property JAXB_CONTEXT_FACTORY exists, then its value is assumed to be the provider factory class.This file follows the standard service descriptor convention, and if such a file exists, its content is assumed to be the provider factory class.This phase of the look up is for automatic discovery.It allows users to just put a JAXB implementation in a classpath and use it without any furhter configuration.Finally, if all the steps above fail, then the rest of the look up is unspecified.That said, the recommended behavior is to simply look for some hard-coded platform default JAXB implementation.This phase of the look up is so that JavaSE can have its own JAXB implementation as the last resort.method (see newInstance(Class[], Map) for the parameter semantics) are invoked to create a JAXBContext."},
{"description": "All methods in this interface might throw a SecurityException if a security exception occurs.Unless explicitly allowed, all methods in this interface might throw a NullPointerException if given a null argument."},
{"description": "Before calling the call method, additional aspects of the task can be configured, for example, by calling the setProcessors method."},
{"description": "In this context, file means an abstraction of regular files and other sources of data.When constructing new JavaFileObjects, the file manager must determine where to create them.For example, if a file manager manages regular files on a file system, it would most likely have a current/working directory to use as default location when creating or finding files.A number of hints can be provided to a file manager as to where to create files.Any file manager might choose to ignore these hints.Such class names must be given in the Java Virtual Machine internal form of fully qualified class and interface names.The internal form is defined in chapter four of The Java\u2122 Virtual Machine Specification.The case of names is significant.For example, some file systems have case-insensitive, case-aware file names.File objects representing such files should take care to preserve case by using File.getCanonicalFile() or similar means.If the system is not case-aware, file objects must use other means to preserve case.A relative name is a non-null, non-empty sequence of path segments separated by '/'. '.'A valid relative name must match the \"path-rootless\" rule of RFC\u00a03986, section\u00a03.3.All methods in this interface might throw a SecurityException.An object of this interface is not required to support multi-threaded access, that is, be synchronized.However, it must support concurrent access to different file objects created by this object.Implementation note: a consequence of this requirement is that a trivial implementation of output to a JarOutputStream is not a sufficient implementation.That is, rather than creating a JavaFileObject that returns the JarOutputStream directly, the contents must be cached until closed and then written to the JarOutputStream.Unless explicitly allowed, all methods in this interface might throw a NullPointerException if given a null argument."},
{"description": "The JarOutputStream class is used to write the contents of a JAR file to any output stream.It extends the class java.util.zip.ZipOutputStream with support for writing an optional Manifest entry.The Manifest can be used to specify meta-information about the JAR file and its entries."},
{"description": "The compiler might generate diagnostics during compilation (for example, error messages).If a diagnostic listener is provided, the diagnostics will be supplied to the listener.If no listener is provided, the diagnostics will be formatted in an unspecified format and written to the default output, which is System.err unless otherwise specified.Even if a diagnostic listener is supplied, some diagnostics might not fit in a Diagnostic and will be written to the default output.A compiler tool has an associated standard file manager, which is the file manager that is native to the tool (or built-in).The standard file manager can be obtained by calling getStandardFileManager.A compiler tool must function with any file manager as long as any additional requirements as detailed in the methods below are met.If no file manager is provided, the compiler tool will use a standard file manager such as the one returned by getStandardFileManager.An instance implementing this interface must conform to The Java\u2122 Language Specification and generate class files conforming to The Java\u2122 Virtual Machine Specification.The versions of these specifications are defined in the Tool interface.RELEASE_6 or higher must also support annotation processing.The compiler relies on two services: diagnostic listener and file manager.Although most classes and interfaces in this package defines an API for compilers (and tools in general) the interfaces DiagnosticListener, JavaFileManager, FileObject, and JavaFileObject are not intended to be used in applications.Instead these interfaces are intended to be implemented and used to provide customized services for a compiler and thus defines an SPI for compilers.There are a number of classes and interfaces in this package which are designed to ease the implementation of the SPI to customize the behavior of a compiler:Every compiler which implements this interface provides a standard file manager for operating on regular files.The StandardJavaFileManager interface defines additional methods for creating file objects from regular files.The standard file manager serves two purposes: basic building block for customizing how a compiler reads and writes files sharing between multiple compilation tasks Reusing a file manager can potentially reduce overhead of scanning the file system and reading jar files.Although there might be no reduction in overhead, a standard file manager must work with multiple sequential compilations making the following example a recommended coding pattern: File[]DiagnosticCollector Used to collect diagnostics in a list, for example: Iterable<?on line %d in %s%n\", diagnostic.getLineNumber(), diagnostic.getSource().toUri()); fileManager.close(); ForwardingJavaFileManager, ForwardingFileObject, and ForwardingJavaFileObject Subclassing is not available for overriding the behavior of a standard file manager as it is created by calling a method on a compiler, not by invoking a constructor.These classes makes it easy to forward most calls to a given file manager or file object while allowing customizing behavior.compilationUnits).call(); SimpleJavaFileObject This class provides a basic file object implementation which can be used as building block for creating file objects.For example, here is how to define a file object which represent source code stored in a string: /*/ public class JavaSourceFromString extends SimpleJavaFileObject { /@param name the name of the compilation unit represented by this file object* @param code the source code for the compilation unit represented by this file object"},
{"description": "The syntax of a JAR URL is: jar:<url>!/{entry} for example:Quux.class Jar URLs should be used to refer to a JAR file or entries in a JAR file.The example above is a JAR URL which refers to a JAR entry.If the entry name is omitted, the URL refers to the whole JAR file:http://www.foo.com/bar/baz.jar!/ Users should cast the generic URLConnection to a JarURLConnection when they know that the URL they created is a JAR URL, and they need JAR-specific functionality.For example: URL url = new URL(\"jar:file:/home/duke/duke.jar!/\"); JarURLConnection jarConnection = (JarURLConnection)url.openConnection(); Manifest manifest = jarConnection.getManifest(); JarURLConnection instances can only be used to read from JAR files.It is not possible to get a OutputStream to modify or write to the underlying JAR file using this class.http://www.foo.com/bar/baz.jar!/COM/foo/ !/ is referred to as the separator.When constructing a JAR url via new URL(context, spec), the following rules apply: if there is no context URL and the specification passed to the URL constructor doesn't contain a separator, the URL is considered to refer to a JarFile.if there is a context URL, the context URL is assumed to refer to a JAR file or a Jar directory.if the specification begins with a '/', the Jar directory is ignored, and the spec is considered to be at the root of the Jar file."},
{"description": "The JarInputStream class is used to read the contents of a JAR file from any input stream.It extends the class java.util.zip.ZipInputStream with support for reading an optional Manifest entry.The Manifest can be used to store meta-information about the JAR file and its entries."},
{"description": "The JarFile class is used to read the contents of a jar file from any file that can be opened with java.io.RandomAccessFile.It extends the class java.util.zip.ZipFileThe Manifest can be used to specify meta-information about the jar file and its entries.Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown.If the verify flag is on when opening a signed jar file, the content of the file is verified against its signature embedded inside the file.Please note that the verification process does not include validating the signer's certificate.A caller should inspect the return value of JarEntry.getCodeSigners() to further determine if the signature can be trusted."},
{"description": "An extended version of java.applet.Applet that adds support for the JFC/Swing component architecture.You can find task-oriented documentation about using JApplet in The Java Tutorial, in the section How to Make Applets.The JApplet class is slightly incompatible with java.applet.Applet.JApplet contains a JRootPane as its only child.The contentPane should be the parent of any children of the JApplet.As a convenience, the add, remove, and setLayout methods of this class are overridden, so that they delegate calls to the corresponding methods of the ContentPane.For example, you can add a child component to an applet as follows: applet.add(child); And the child will be added to the contentPane.Attempting to set it to null will cause the JApplet to throw an exception.The default contentPane will have a BorderLayout manager set on it.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This date operates using the Japanese Imperial calendar.This calendar system is primarily used in Japan.The Japanese Imperial calendar system is the same as the ISO calendar system apart from the era-based year numbering.The proleptic-year is defined to be equal to the ISO proleptic-year.Japan introduced the Gregorian calendar starting with Meiji 6.Only Meiji and later eras are supported; dates before Meiji 6, January 1 are not supported.Calling japaneseDate.get(YEAR_OF_ERA) will return 24.Calling japaneseDate.get(YEAR) will return 2012.Calling japaneseDate.get(ERA) will return 2, corresponding to JapaneseChronology.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of JapaneseDate may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "This class specifies an initialization vector (IV).Examples which use IVs are ciphers in feedback mode, e.g., DES in CBC mode and RSA ciphers with OAEP encoding operation."},
{"description": "This chronology defines the rules of the Japanese Imperial calendar system.This calendar system is primarily used in Japan.The Japanese Imperial calendar system is the same as the ISO calendar system apart from the era-based year numbering.Japan introduced the Gregorian calendar starting with Meiji 6.Only Meiji and later eras are supported; dates before Meiji 6, January 1 are not supported.The supported ChronoField instances are: DAY_OF_WEEK DAY_OF_MONTH DAY_OF_YEAR EPOCH_DAY MONTH_OF_YEAR PROLEPTIC_MONTH YEAR_OF_ERA YEAR ERA"},
{"description": "Signals that an error of some sort has occurred while reading from or writing to a JAR file."},
{"description": "This class is used to represent a JAR file entry."},
{"description": "The Japanese government defines the official name and start date of each era.Eras are consecutive and their date ranges do not overlap, so the end date of one era is always the day before the start date of the next era.The Java SE Platform supports all eras defined by the Japanese government, beginning with the Meiji era.Each era is identified in the Platform by an integer value and a name.The of(int) and valueOf(String) methods may be used to obtain a singleton instance of JapaneseEra for each era.The values() method returns the singleton instances of all supported eras.For convenience, this class declares a number of public static final fields that refer to singleton instances returned by the values() method."},
{"description": "Iterator takes the place of Enumeration in the Java Collections Framework.Iterators differ from enumerations in two ways: Iterators allow the caller to remove elements from the underlying collection during the iteration with well-defined semantics.This interface is a member of the Java Collections Framework."},
{"description": "Implementing this interface allows an object to be the target of the \"for-each loop\" statement."},
{"description": "The class that is interested in processing an item event implements this interface.The object created with that class is then registered with a component using the component's addItemListener method."},
{"description": "The interface for objects which contain a set of items for which zero or more can be selected."},
{"description": "This class defines fields and units that are specific to the ISO calendar system.The ISO-8601 standard is based on the standard civic 12 month year.This is commonly divided into four quarters, often abbreviated as Q1, Q2, Q3 and Q4.January, February and March are in Q1.April, May and June are in Q2.July, August and September are in Q3.October, November and December are in Q4.The complete date is expressed using three fields: DAY_OF_QUARTER - the day within the quarter, from 1 to 90, 91 or 92 QUARTER_OF_YEAR - the week within the week-based-year YEAR - the standard ISO year Week based yearsThe ISO-8601 standard was originally intended as a data interchange format, defining a string format for dates and times.However, it also defines an alternate way of expressing the date, based on the concept of week-based-year.The date is expressed using three fields: DAY_OF_WEEK - the standard field defining the day-of-week from Monday (1) to Sunday (7) WEEK_OF_WEEK_BASED_YEAR - the week within the week-based-year WEEK_BASED_YEAR - the week-based-year The week-based-year itself is defined relative to the standard ISO proleptic year.It differs from the standard year in that it always starts on a Monday.The first week of a week-based-year is the first Monday-based week of the standard ISO year that has at least 4 days in the new year.If January 1st is Monday then week 1 starts on January 1stIf January 1st is Tuesday then week 1 starts on December 31st of the previous standard yearIf January 1st is Wednesday then week 1 starts on December 30th of the previous standard yearIf January 1st is Thursday then week 1 starts on December 29th of the previous standard yearIf January 1st is Friday then week 1 starts on January 4thIf January 1st is Saturday then week 1 starts on January 3rdIf January 1st is Sunday then week 1 starts on January 2ndThere are 52 weeks in most week-based years, however on occasion there are 53 weeks."},
{"description": "This high-level event is generated by an ItemSelectable object (such as a List) when an item is selected or deselected by the user.The event is passed to every ItemListener object which registered to receive such events using the component's addItemListener method.The object that implements the ItemListener interface gets this ItemEvent when the event occurs.The listener is spared the details of processing individual mouse movements and mouse clicks, and can instead process a \"meaningful\" (semantic) event like \"item selected\" or \"item deselected\".An unspecified behavior will be caused if the id parameter of any particular ItemEvent instance is not in the range from ITEM_FIRST to ITEM_LAST.The stateChange of any ItemEvent instance takes one of the following values:Assigning the value different from listed above will cause an unspecified behavior."},
{"description": "The ISO-8601 standard does not define eras.A definition has therefore been created with two eras - 'Current era' (CE) for years on or after 0001-01-01 (ISO), and 'Before current era' (BCE) for years before that.year-of-era era proleptic-year 2CE2 1CE1 1BCE0 2BCE-1 Do not use ordinal() to obtain the numeric representation of IsoEra."},
{"description": "This is the Operations interface for the mapping from IRObject.Several interfaces are used as base interfaces for objects in the Interface Repository (IR).A common set of operations is used to locate objects within the Interface Repository.Some of these operations are defined in the IRObject.All IR objects inherit from the IRObject interface, which provides an operation for identifying the actual type of the object.(The IDL base interface IRObject represents the most generic interface from which all other Interface Repository interfaces are derived, even the Repository itself.)All java implementations of IR objects must implement the IRObjectOperations interface."},
{"description": "An IRObject IDL interface represents the most generic interfacefrom which all other Interface Repository interfaces are derived,even the Repository itself."},
{"description": "Interceptor used to establish tagged components in the profiles within an IOR.In some cases, a portable ORB service implementation may need to add information describing the server's or object's ORB service related capabilities to object references in order to enable the ORB service implementation in the client to function properly.This is supported through the IORInterceptor and IORInfo interfaces."},
{"description": "This chronology defines the rules of the ISO calendar system.This calendar system is based on the ISO-8601 standard, which is the de facto world calendar.era - There are two eras, 'Current Era' (CE) and 'Before Current Era' (BCE).year-of-era - The year-of-era is the same as the proleptic-year for the current CE era.For the BCE era before the ISO epoch the year increases from 1 upwards as time goes backwards.The proleptic year is the same as the year-of-era for the current era.For the previous era, years have zero, then negative values.month-of-year - There are 12 months in an ISO year, numbered from 1 to 12.day-of-month - There are between 28 and 31 days in each of the ISO month, numbered from 1 to 31.Months 4, 6, 9 and 11 have 30 days, Months 1, 3, 5, 7, 8, 10 and 12Month 2 has 28 days, or 29 in a leap year.day-of-year - There are 365 days in a standard ISO year and 366 in a leap year.The days are numbered from 1 to 365 or 1 to 366.leap-year - Leap years occur every 4 years, except where the year is divisble by 100 and not divisble by 400."},
{"description": "Signals that an I/O exception of some sort has occurred.This class is the general class of exceptions produced by failed or interrupted I/O operations."},
{"description": "The ORB passes an instance of its implementation of this interface as a parameter to IORInterceptor.establish_components."},
{"description": "Interceptor used to establish tagged components in the profiles within an IOR.In some cases, a portable ORB service implementation may need to add information describing the server's or object's ORB service related capabilities to object references in order to enable the ORB service implementation in the client to function properly.This is supported through the IORInterceptor and IORInfo interfaces."},
{"description": "The ORB passes an instance of its implementation of this interface as a parameter to IORInterceptor.establish_components."},
{"description": "Invoker hides the detail of calling into application endpoint implementation.Container hands over an implementation of Invoker to JAX-WS runtime, and jax-ws runtime calls invoke(java.lang.reflect.Finally, Invoker does the actual invocation of web service on endpoint instance.Container also injects the provided WebServiceContext and takes care of invoking javax.annotation.PostConstruct methods, if present, on the endpoint implementation."},
{"description": "This interface provides a dispatching mechanism for an incoming call.It is invoked by the ORB to dispatch a request to a servant."},
{"description": "An event which executes the run() method on a Runnable when dispatched by the AWT event dispatcher thread.This class can be used as a reference implementation of ActiveEvent rather than declaring a new class and defining dispatch().Instances of this class are placed on the EventQueue by calls to invokeLater and invokeAndWait.Client code can use this fact to write replacement functions for invokeLater and invokeAndWait without writing special-case code in any AWTEventListener objects.An unspecified behavior will be caused if the id parameter of any particular InvocationEvent instance is not in the range from INVOCATION_FIRST to INVOCATION_LAST."},
{"description": "The optional interface implemented by ScriptEngines whose methods allow the invocation of procedures in scripts that have previously been executed."},
{"description": "InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor.As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.The \"target exception\" that is provided at construction time and accessed via the getTargetException() method is now known as the cause, and may be accessed via the Throwable.getCause() method, as well as the aforementioned \"legacy method.\""},
{"description": "InvocationHandler is the interface implemented by the invocation handler of a proxy instance.Each proxy instance has an associated invocation handler.When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler."},
{"description": "This exception indicates that the request carried an invalid transaction context.For example, this exception could be raised if an error occured when trying to register a resource."},
{"description": "The serialVersionUID of this class is 1190536278266811217L."},
{"description": "The InvalidSeq exception is thrown by all operations on dynamic anys that take a sequence (Java array) as an argument, when that sequence is invalid."},
{"description": "This exception is raised when, in a role, the number of referenced MBeans in given value is less than expected minimum degree, or the number of referenced MBeans in provided value exceeds expected maximum degree, or one referenced MBean in the value is not an Object of the MBean class expected for that role, or an MBean provided for that role does not exist."},
{"description": "This exception is thrown when the specification of the SearchControls for a search operation is invalid.For example, if the scope is set to a value other than OBJECT_SCOPE, ONELEVEL_SCOPE, SUBTREE_SCOPE, this exception is thrown.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "This exception is raised when relation id provided for a relation is already used."},
{"description": "This exception is raised when, in a role info, its minimum degree is greater than its maximum degree."},
{"description": "This exception is raised when, in a relation type, there is already a relation type with that name, or the same name has been used for two different role infos, or no role info provided, or one null role info provided."},
{"description": "This exception is thrown when the specification of a search filter is invalid.The expression of the filter may be invalid, or there may be a problem with one of the parameters passed to the filter.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "Unchecked exception thrown when path string cannot be converted into a Path because the path string contains invalid characters, or the path string is invalid for other file system specific reasons."},
{"description": "This runtime exception is thrown to indicate that the open type of an open data value is not the one expected."},
{"description": "This exception, designed for use by the JCA/JCE engine classes, is thrown when an invalid parameter is passed to a method."},
{"description": "This is the exception for invalid parameter specifications."},
{"description": "Thrown to indicate that an operation could not complete because the input did not conform to the appropriate XML document type for a collection of preferences, as per the Preferences specification."},
{"description": "Indicates that one or more deserialized objects failed validation tests.The argument should provide the reason for the failure."},
{"description": "This exception indicates that the name being specified does not conform to the naming syntax of a naming system.This exception is thrown by any of the methods that does name parsing (such as those in Context, DirContext, CompositeName and CompoundName).Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "Thrown to indicate that an operation could not complete because the input did not conform to the appropriate XML document type for a collection of properties, as per the Properties specification.Note, that although InvalidPropertiesFormatException inherits Serializable interface from Exception, it is not intended to be Serializable.Appropriate serialization methods are implemented to throw NotSerializableException."},
{"description": "The InvalidName exception is raised when ORB.resolve_initial_references is passed a name for which there is no initial reference."},
{"description": "This exception is thrown by various methods in the java.awt.dnd package.It is usually thrown to indicate that the target in question is unable to undertake the requested operation that the present time, since the underlying DnD system is not in the appropriate state."},
{"description": "This is the exception for invalid key specifications."},
{"description": "Thrown when the Serialization runtime detects one of the following problems with a Class.The serial version of the class does not match that of the class descriptor read from the streamThe class contains unknown datatypes The class does not have an accessible no-arg constructor"},
{"description": "Unchecked exception thrown when an attempt is made to reset a buffer when its mark is not defined."},
{"description": "This runtime exception is thrown to indicate that a method parameter which was expected to be an item name of a composite data or a row index of a tabular data is not valid."},
{"description": "This is the exception for invalid Keys (invalid encoding, wrong length, uninitialized, etc)."},
{"description": "This class is thrown when an attempt is made to add to an attribute a value that conflicts with the attribute's schema definition.This could happen, for example, if attempting to add an attribute with no value when the attribute is required to have at least one value, or if attempting to add more than one value to a single valued-attribute, or if attempting to add a value that conflicts with the syntax of the attribute.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "This exception is thrown when an attempt is made to add or modify an attribute set that has been specified incompletely or incorrectly.This could happen, for example, when attempting to add or modify a binding, or to create a new subcontext without specifying all the mandatory attributes required for creation of the object.Another situation in which this exception is thrown is by specification of incompatible attributes within the same attribute set, or attributes in conflict with that specified by the object's schema.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "This exception is thrown when an attempt is made to add to create an attribute with an invalid attribute identifier.The validity of an attribute identifier is directory-specific.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "This is the exception for invalid or inappropriate algorithm parameters."},
{"description": "Thrown when an attempt is made to apply either of the following: A subquery expression to an MBean or a qualified attribute expression to an MBean of the wrong class.This exception is used internally by JMX during the evaluation of a query.User code does not usually see it."},
{"description": "The value specified is not valid for the attribute."},
{"description": "This exception may be thrown on any method for which Activity context is accessed and indicates that the attempted invocation or the Activity context associated with the attempted invocation is incompatible with the Activity's current state.It may also be thrown by a container if Activity context is received on a method for which Activity context is forbidden.This exception will be propagated across J2EE Activity Service ORB boundaries via an org.omg.CORBA.INVALID_ACTIVITY system exception.An application should handle this error by attempting to complete the Activity."},
{"description": "For example, the repository ID may have incorrect syntax or the addressing information may be invalid.This exception is raised by ORB::string_to_object if the passed string does not decode correctly.An ORB may choose to detect calls via nil references (but is not obliged to do detect them).INV_OBJREF is used to indicate this.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "Exception thrown when an invalid flag was passed to an operation (for example, when creating a DII request).It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "The INVALID_ACTIVITY system exception may be raised on the Activity or Transaction services' resume methods if a transaction or Activity is resumed in a context different to that from which it was suspended.It is also raised when an attempted invocation is made that is incompatible with the Activity's current state."},
{"description": "Exception thrown when the request carried an invalid transaction context.For example, this exception could be raised if an error occurred when trying to register a resource.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "It may be raised if, for example, an identifier passed to the interface repository does not conform to IDL identifier syntax, or if an illegal operation name is used with the DII.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "Invalid is thrown by dynamic any operations when a bad DynAny or Any is passed as a parameter."},
{"description": "Represents an operation on a single int-valued operand that produces an int-valued result.This is the primitive type specialization of UnaryOperator for int.This is a functional interface whose functional method is applyAsInt(int)."},
{"description": "Represents a function that accepts an int-valued argument and produces a long-valued result.This is the int-to-long primitive specialization for Function.This is a functional interface whose functional method is applyAsLong(int)."},
{"description": "Represents a function that accepts an int-valued argument and produces a double-valued result.This is the int-to-double primitive specialization for Function.This is a functional interface whose functional method is applyAsDouble(int)."},
{"description": "This is the int-producing primitive specialization of Supplier.There is no requirement that a distinct result be returned each time the supplier is invoked.This is a functional interface whose functional method is getAsInt()."},
{"description": "A state object for collecting statistics such as count, min, max, sum, and average.This class is designed to work with (though does not require) streams.For example, you can compute summary statistics on a stream of ints with: IntSummaryStatistics stats = intStream.collect(IntSummaryStatistics::new, IntSummaryStatistics::accept, IntSummaryStatistics::combine); IntSummaryStatistics can be used as a reduction target for a stream."},
{"description": "A stream builder has a lifecycle, which starts in a building phase, during which elements can be added, and then transitions to a built phase, after which elements may not be added.The built phase begins when the build() method is called, which creates an ordered stream whose elements are the elements that were added to the stream builder, in the order they were added."},
{"description": "The Introspector class provides a standard way for tools to learn about the properties, events, and methods supported by a target Java Bean.For each of those three kinds of information, the Introspector will separately analyze the bean's class and superclasses looking for either explicit or implicit information and use that information to build a BeanInfo object that comprehensively describes the target bean.For each class \"Foo\", explicit information may be available if there exists a corresponding \"FooBeanInfo\" class that provides a non-null value when queried for the information.We first look for the BeanInfo class by taking the full package-qualified name of the target bean class and appending \"BeanInfo\" to form a new class name.If this fails, then we take the final classname component of this name, and look for that class in each of the packages specified in the BeanInfo package search path.Thus for a class such as \"sun.xyz.OurButton\" we would first look for a BeanInfo class called \"sun.xyz.OurButtonBeanInfo\" and if that failed we'd look in each package in the BeanInfo search path for an OurButtonBeanInfo class.With the default search path, this would mean looking for \"sun.beans.infos.OurButtonBeanInfo\".If a class provides explicit BeanInfo about itself then we add that to the BeanInfo information we obtained from analyzing any derived classes, but we regard the explicit information as being definitive for the current class and its base classes, and do not proceed any further up the superclass chain.If we don't find explicit BeanInfo on a class, we use low-level reflection to study the methods of the class and apply standard design patterns to identify property accessors, event sources, or public methods.We then proceed to analyze the class's superclass and add in the information from it (and possibly on up the superclass chain)."},
{"description": "Thrown when an exception happens during Introspection.Typical causes include not being able to map a string class name to a Class object, not being able to resolve a string method name, or specifying a method name that has the wrong type signature for its intended use."},
{"description": "An exception occurred during the introspection of an MBean."},
{"description": "A Holder class for an int that is used to store \"out\" and \"inout\" parameters in IDL methods.If an IDL method signature has an IDL long as an \"out\" or \"inout\" parameter, the programmer must pass an instance of IntHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myIntHolder is an instance of IntHolder, the value stored in its value field can be accessed with myIntHolder.value."},
{"description": "Represents a function that accepts an int-valued argument and produces a result.This is the int-consuming primitive specialization for Function.This is a functional interface whose functional method is apply(int)."},
{"description": "Exception raised when an ORB cannot reach the interface repository, or some other failure relating to the interface repository is detected.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "Standard exception thrown when an invocation cannot be made because of an incompatibility between Policy overrides that apply to the particular invocation.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "An intersection type can be either implicitly or explicitly declared in a program.For example, the bound of the type parameter <T extends Number & Runnable> is an (implicit) intersection type.As of RELEASE_8, this is represented by an IntersectionType with Number and Runnable as its bounds."},
{"description": "A channel that implements this interface is asynchronously closeable: If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the channel's close method.This will cause the blocked thread to receive an AsynchronousCloseException.A channel that implements this interface is also interruptible: If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the blocked thread's interrupt method.This will cause the channel to be closed, the blocked thread to receive a ClosedByInterruptException, and the blocked thread's interrupt status to be set.If a thread's interrupt status is already set and it invokes a blocking I/O operation upon a channel then the channel will be closed and the thread will immediately receive a ClosedByInterruptException; its interrupt status will remain set.A channel supports asynchronous closing and interruption if, and only if, it implements this interface.This can be tested at runtime, if necessary, via the instanceof operator."},
{"description": "An InterruptedIOException is thrown to indicate that an input or output transfer has been terminated because the thread performing it was interrupted."},
{"description": "For example, an application might interrupt a thread that is performing a search.If the search supports being interrupted, it will throw InterruptedNamingException.Whether an operation is interruptible and when depends on its implementation (as provided by the service providers).Different implementations have different ways of protecting their resources and objects from being damaged due to unexpected interrupts.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "Checked exception received by a thread when a timeout elapses before an asynchronous operation completes."},
{"description": "InternationalFormatter extends DefaultFormatter, using an instance of java.text.Format to handle the conversion to a String, and the conversion from a String.If getAllowsInvalid() is false, this will ask the Format to format the current text on every edit.You can specify a minimum and maximum value by way of the setMinimum and setMaximum methods.In order for this to work the values returned from stringToValue must be comparable to the min/max values by way of the Comparable interface.Be careful how you configure the Format and the InternationalFormatter, as it is possible to create a situation where certain values can not be input.Consider the date format 'M/d/yy', an InternationalFormatter that is always valid (setAllowsInvalid(false)), is in overwrite mode (setOverwriteMode(true)) and the date 7/1/99.In this case the user will not be able to enter a two digit month or day of month.To avoid this, the format should be 'MM/dd/yy'.If InternationalFormatter is configured to only allow valid values (setAllowsInvalid(false)), every valid edit will result in the text of the JFormattedTextField being completely reset from the Format.The cursor position will also be adjusted as literal characters are added/removed from the resulting String.InternationalFormatter's behavior of stringToValue is slightly different than that of DefaultTextFormatter, it does the following: parseObject is invoked on the Format specified by setFormat If a Class has been set for the values (setValueClass), supers implementation is invoked to convert the value returned from parseObject to the appropriate class.If a ParseException has not been thrown, and the value is outside the min/max a ParseException is thrown.InternationalFormatter implements stringToValue in this manner so that you can specify an alternate Class than Format may return.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity.Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.The following code can be used to achieve this effect:Clears interrupted status!"},
{"description": "This class is functionally equivalent to the WindowListener class in the AWT."},
{"description": "A FocusTraversalPolicy which can optionally provide an algorithm for determining a JInternalFrame's initial Component.The initial Component is the first to receive focus when the JInternalFrame is first selected.By default, this is the same as the JInternalFrame's default Component to focus."},
{"description": "This is the int primitive specialization of Stream.The following example illustrates an aggregate operation using Stream and IntStream, computing the sum of the weights of the red widgets: int sum"},
{"description": "An AWTEvent that adds support for JInternalFrame objects as the event source.This class has the same event types as WindowEvent, although different IDs are used.Help on handling internal frame events is in How to Write an Internal Frame Listener, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The methods in this class are empty.This class exists as convenience for creating listener objects, and is functionally equivalent to the WindowAdapter class in the AWT."},
{"description": "This is the int-consuming primitive type specialization of Predicate.This is a functional interface whose functional method is test(int)."},
{"description": "Thrown to indicate some unexpected internal error has occurred in the Java Virtual Machine."},
{"description": "All Portable Interceptors implement Interceptor."},
{"description": "This exception indicates an internal failure in an ORB, for example, if an ORB has detected corruption of its internal data structures.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception.See the section meaning of minor codes to see the minor codes for this exception."},
{"description": "This class represents a Network Interface address.In short it's an IP address, a subnet mask and a broadcast address when the address is an IPv4 one."},
{"description": "All Portable Interceptors implement Interceptor."},
{"description": "Class IntegerSyntax is an abstract base class providing the common implementation of all attributes with integer values.Under the hood, an integer attribute is just an integer.You can get an integer attribute's integer value by calling getValue()."},
{"description": "An instrument is a sound-synthesis algorithm with certain parameter settings, usually designed to emulate a specific real-world musical instrument or to achieve a specific sort of sound effect.Instruments are typically stored in collections called soundbanks.Before the instrument can be used to play notes, it must first be loaded onto a synthesizer, and then it must be selected for use on one or more channels, via a program-change command.MIDI notes that are subsequently received on those channels will be played using the sound of the selected instrument."},
{"description": "Represents an operation that accepts a single int-valued argument and returns no result.This is the primitive type specialization of Consumer for int.Unlike most other functional interfaces, IntConsumer is expected to operate via side-effects.This is a functional interface whose functional method is accept(int)."},
{"description": "The Integer class wraps a value of the primitive type int in an object.An object of type Integer contains a single field whose type is int.In addition, this class provides several methods for converting an int to a String and a String to an int, as well as other constants and methods useful when dealing with an int.Implementation note: The implementations of the \"bit twiddling\" methods (such as highestOneBit and numberOfTrailingZeros) are based on material from Henry S. Warren, Jr.'s Hacker's Delight, (Addison Wesley, 2002)."},
{"description": "This is the primitive type specialization of BinaryOperator for int.This is a functional interface whose functional method is applyAsInt(int, int)."},
{"description": "This class defines four categories of operations upon int buffers:Absolute and relative get and put methods that read and write single ints; Relative bulk get methods that transfer contiguous sequences of ints from this buffer into an array; and Relative bulk put methods that transfer contiguous sequences of ints from an int array or some other int buffer into this buffer; and Methods for compacting, duplicating, and slicing an int buffer.Int buffers can be created either by allocation, which allocates space for the buffer's content, by wrapping an existing int array into a buffer, or by creating a view of an existing byte buffer.Like a byte buffer, an int buffer is either direct or non-direct.A int buffer created via the wrap methods of this class will be non-direct.An int buffer created as a view of a byte buffer will be direct if, and only if, the byte buffer itself is direct.Whether or not an int buffer is direct may be determined by invoking the isDirect method.Methods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked."},
{"description": "This class provides services needed to instrument Java programming language code.Instrumentation is the addition of byte-codes to methods for the purpose of gathering data to be utilized by tools.Since the changes are purely additive, these tools do not modify application state or behavior.Examples of such benign tools include monitoring agents, profilers, coverage analyzers, and event loggers.There are two ways to obtain an instance of the Instrumentation interface: When a JVM is launched in a way that indicates an agent class.In that case an Instrumentation instance is passed to the premain method of the agent class.When a JVM provides a mechanism to start agents sometime after the JVM is launched.In that case an Instrumentation instance is passed to the agentmain method of the agent code.These mechanisms are described in the package specification.Once an agent acquires an Instrumentation instance, the agent may call methods on the instance at any time."},
{"description": "This exception is thrown when resources are not available to complete the requested operation.This might due to a lack of resources on the server or on the client.There are no restrictions to resource types, as different services might make use of different resources.Such restrictions might be due to physical limits and/or administrative quotas.Examples of limited resources are internal buffers, memory, network bandwidth.InsufficientResourcesException is different from LimitExceededException in that the latter is due to user/system specified limits.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "Thrown when an application tries to use the Java new construct to instantiate an abstract class or an interface.Normally, this error is caught by the compiler; this error can only occur at run time if the definition of a class has incompatibly changed."},
{"description": "Thrown when an application tries to create an instance of a class using the newInstance method in class Class, but the specified class object cannot be instantiated.The instantiation can fail for a variety of reasons including but not limited to: the class object represents an abstract class, an interface, an array class, a primitive type, or void the class has no nullary constructor"},
{"description": "The specified MBean does not exist in the repository."},
{"description": "This class models a single instantaneous point on the time-line.This might be used to record event time-stamps in the application.The range of an instant requires the storage of a number larger than a long.To achieve this, the class stores a long representing epoch-seconds and an int representing nanosecond-of-second, which will always be between 0 and 999,999,999.The epoch-seconds are measured from the standard Java epoch of 1970-01-01T00:00:00Z where instants after the epoch have positive values, and earlier instants have negative values.For both the epoch-second and nanosecond parts, a larger value is always later on the time-line than a smaller value.The length of the solar day is the standard way that humans measure time.This has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds, forming a 86400 second day.Modern timekeeping is based on atomic clocks which precisely define an SI second relative to the transitions of a Caesium atom.The length of an SI second was defined to be very close to the 86400th fraction of a day.Unfortunately, as the Earth rotates the length of the day varies.In addition, over time the average length of the day is getting longer as the Earth slows.As a result, the length of a solar day in 2012 is slightly longer than 86400 SI seconds.The actual length of any given day and the amount by which the Earth is slowing are not predictable and can only be determined by measurement.The UT1 time-scale captures the accurate length of day, but is only available some time after the day has completed.The UTC time-scale is a standard approach to bundle up all the additional fractions of a second from UT1 into whole seconds, known as leap-seconds.A leap-second may be added or removed depending on the Earth's rotational changes.As such, UTC permits a day to have 86399 SI seconds or 86401 SI seconds where necessary in order to keep the day aligned with the Sun.The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds.Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and alterations to the length of the notional second.As of 2012, discussions are underway to change the definition of UTC again, with the potential to remove leap seconds or introduce other changes.Given the complexity of accurate timekeeping described above, this Java API defines its own time-scale, the Java Time-Scale.The Java Time-Scale divides each calendar day into exactly 86400 subdivisions, known as seconds.These seconds may differ from the SI second.It closely matches the de facto international civil time scale, the definition of which changes from time to time.The Java Time-Scale has slightly different definitions for different segments of the time-line, each based on the consensus international time scale that is used as the basis for civil time.Whenever the internationally-agreed time scale is modified or replaced, a new segment of the Java Time-Scale must be defined for it.Each segment must meet these requirements: the Java Time-Scale shall closely match the underlying international civil time scale; the Java Time-Scale shall exactly match the international civil time scale at noon each day; the Java Time-Scale shall have a precisely-defined relationship to the international civil time scale.There are currently, as of 2013, two segments in the Java time-scale.For the segment from 1972-11-03 (exact boundary discussed below) until further notice, the consensus international time scale is UTC (with leap seconds).In this segment, the Java Time-Scale is identical to UTC-SLS.This is identical to UTC on days that do not have a leap second.On days that do have a leap second, the leap second is spread equally over the last 1000 seconds of the day, maintaining the appearance of exactly 86400 seconds per day.For the segment prior to 1972-11-03, extending back arbitrarily far, the consensus international time scale is defined to be UT1, applied proleptically, which is equivalent to the (mean) solar time on the prime meridian (Greenwich).In this segment, the Java Time-Scale is identical to the consensus international time scale.The exact boundary between the two segments is the instant where UT1 = UTC between 1972-11-03T00:00 and 1972-11-04T12:00.Implementations of the Java time-scale using the JSR-310 API are not required to provide any clock that is sub-second accurate, or that progresses monotonically or smoothly.Implementations are therefore not required to actually perform the UTC-SLS slew or to otherwise be aware of leap seconds.JSR-310 does, however, require that implementations must document the approach they use when defining a clock representing the current instant.The Java time-scale is used for all date-time classes.This includes Instant, LocalDate, LocalTime, OffsetDateTime, ZonedDateTime and Duration.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of Instant may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "An Insets object is a representation of the borders of a container.It specifies the space that a container must leave at each of its edges.The space can be a border, a blank space, or a title."},
{"description": "The MBean is already registered in the repository."},
{"description": "The purpose of this class is to help clients support smooth focus navigation through GUIs with text fields.Such GUIs often need to ensure that the text entered by the user is valid (for example, that it's in the proper format) before allowing the user to navigate out of the text field.To do this, clients create a subclass of InputVerifier and, using JComponent's setInputVerifier method, attach an instance of their subclass to the JComponent whose input they want to validate.Before focus is transfered to another Swing component that requests it, the input verifier's shouldYieldFocus method is called.The following example has two text fields, with the first one expecting the string \"pass\" to be entered by the user.If that string is entered in the first text field, then the user can advance to the second text field either by clicking in it or by pressing TAB.However, if another string is entered in the first text field, then the user will be unable to transfer focus to the second text field.*; // This program demonstrates the use of the Swing InputVerifier class.It creates two text fields; the first of the text fields expects the // string \"pass\" as input, and will allow focus to advance out of it // only after that string is typed in by the user.public class VerifierTest extends JFrame { public VerifierTest() { JTextField tf1 = new JTextField (\"Type \\\"pass\\\" here\"); getContentPane().add (tf1, BorderLayout.addWindowListener(l); } class PassVerifier extends InputVerifier { public boolean verify(JComponent input)"},
{"description": "UnicodeBlock class, these constants do not directly correspond to Unicode code blocks."},
{"description": "InputStream provides for the reading of all of the mapped IDL types from the stream.It extends org.omg.CORBA.portable.InputStream.This class defines new methods that were added for CORBA 2.3."},
{"description": "InputStream is the Java API for reading IDL types from CDR marshal streams.These methods are used by the ORB to unmarshal IDL types as well as to extract IDL types out of Anys.The _array versions of the methods can be directly used to read sequences and arrays of IDL types."},
{"description": "This abstract class is the superclass of all classes representing an input stream of bytes.Applications that need to define a subclass of InputStream must always provide a method that returns the next byte of input."},
{"description": "An InputStreamReader is a bridge from byte streams to character streams: It reads bytes and decodes them into characters using a specified charset.The charset that it uses may be specified by name or may be given explicitly, or the platform's default charset may be accepted.Each invocation of one of an InputStreamReader's read() methods may cause one or more bytes to be read from the underlying byte-input stream.To enable the efficient conversion of bytes to characters, more bytes may be read ahead from the underlying stream than are necessary to satisfy the current read operation."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This class allows a SAX application to encapsulate information about an input source in a single object, which may include a public identifier, a system identifier, a byte stream (possibly with a specified encoding), and/or a character stream.There are two places that the application can deliver an input source to the parser: as the argument to the Parser.parse method, or as the return value of the EntityResolver.resolveEntity method.The SAX parser will use the InputSource object to determine how to read XML input.If there is a character stream available, the parser will read that stream directly, disregarding any text encoding declaration found in that stream.If there is no character stream, but there is a byte stream, the parser will use that byte stream, using the encoding specified in the InputSource or else (if no encoding is specified) autodetecting the character encoding using an algorithm such as the one in the XML specification.If neither a character stream nor a byte stream is available, the parser will attempt to open a URI connection to the resource identified by the system identifier.An InputSource object belongs to the application: the SAX parser shall never modify it in any way(it may modify a copy if necessary).However, standard processing of both byte and character streams is to close them on as part of end-of-parse cleanup, so applications should not attempt to re-use such streams after they have been handed to a parser."},
{"description": "Thrown by a Scanner to indicate that the token retrieved does not match the pattern for the expected type, or that the token is out of range for the expected type."},
{"description": "InputMethodRequests defines the requests that a text editing component has to handle in order to work with input methods.The component can implement this interface itself or use a separate object that implements it.The object implementing this interface must be returned from the component's getInputMethodRequests method.The text editing component also has to provide an input method event listener.The interface is designed to support one of two input user interfaces: on-the-spot input, where the composed text is displayed as part of the text component's text body.below-the-spot input, where the composed text is displayed in a separate composition window just below the insertion point where the text will be inserted when it is committed.Note that, if text is selected within the component's text body, this text will be replaced by the committed text upon commitment; therefore it is not considered part of the context that the text is input into."},
{"description": "An InputMethodHighlight is used to describe the highlight attributes of text being composed.The description can be at two levels: at the abstract level it specifies the conversion state and whether the text is selected; at the concrete level it specifies style attributes used to render the highlight.An InputMethodHighlight must provide the description at the abstract level; it may or may not provide the description at the concrete level.If no concrete style is provided, a renderer should use Toolkit.mapInputMethodHighlight(java.awt.im.InputMethodHighlight) to map to a concrete style.The abstract description consists of three fields: selected, state, and variation.selected indicates whether the text range is the one that the input method is currently working on, for example, the segment for which conversion candidates are currently shown in a menu.state represents the conversion state.State values are defined by the input method framework and should be distinguished in all mappings from abstract to concrete styles.These state values are recommended for use before and after the main conversion step of text composition, say, before and after kana->kanji or pinyin->hanzi conversion.The variation field allows input methods to express additional information about the conversion results.InputMethodHighlight instances are typically used as attribute values returned from AttributedCharacterIterator for the INPUT_METHOD_HIGHLIGHT attribute.They may be wrapped into Annotation instances to indicate separate text segments."},
{"description": "A text editing component has to install an input method event listener in order to work with input methods.The text editing component also has to provide an instance of InputMethodRequests."},
{"description": "Defines the interface for an input method that supports complex text input.Input methods traditionally support text input for languages that have more characters than can be represented on a standard-size keyboard, such as Chinese, Japanese, and Korean.However, they may also be used to support phonetic text input for English or character reordering for Thai.Subclasses of InputMethod can be loaded by the input method framework; they can then be selected either through the API (InputContext.selectInputMethod) or the user interface (the input method selection menu)."},
{"description": "Defines methods that provide sufficient information about an input method to enable selection and loading of that input method."},
{"description": "A subclass of javax.swing.InputMap that implements UIResource.UI classes which provide a InputMap should use this class."},
{"description": "InputMap provides a binding between an input event (currently only KeyStrokes are used) and an Object.InputMaps are usually used with an ActionMap, to determine an Action to perform when a key is pressed.An InputMap can have a parent that is searched for bindings not defined in the InputMap.As with ActionMap if you create a cycle, eg: InputMap am = new InputMap(); InputMap bm =; bm.setParent(am); some of the methods will cause a StackOverflowError to be thrown."},
{"description": "Provides methods that input methods can use to communicate with their client components or to request other services.This interface is implemented by the input method framework, and input methods call its methods on the instance they receive through InputMethod.setInputMethodContext(java.awt.im.spi.There should be no other implementors or callers."},
{"description": "Input method events contain information about text that is being composed using an input method.Whenever the text changes, the input method sends an event.If the text component that's currently using the input method is an active client, the event is dispatched to that component.Otherwise, it is dispatched to a separate composition window.The text included with the input method event consists of two parts: committed text and composed text.The two parts together replace any uncommitted composed text sent in previous events, or the currently selected committed text.Committed text should be integrated into the text component's persistent data, it will not be sent again.Composed text may be sent repeatedly, with changes to reflect the user's editing operations.Committed text always precedes composed text."},
{"description": "Two methods handle both input methods and keyboard layouts:selectInputMethod lets a client component select an input method or keyboard layout by locale, getLocale lets a client component obtain the locale of the current input method or keyboard layout.The other methods more specifically support interaction with input methods: They let client components control the behavior of input methods, and dispatch events from the client component to the input method.By default, one InputContext instance is created per Window instance, and this input context is shared by all components within the window's container hierarchy.However, this means that only one text input operation is possible at any one time within a window, and that the text needs to be committed when moving the focus from one text component to another.If this is not desired, text components can create their own input context instances.The Java Platform supports input methods that have been developed in the Java programming language, using the interfaces in the java.awt.im.spi package, and installed into a Java SE Runtime Environment as extensions.Implementations may also support using the native input methods of the platforms they run on; however, not all platforms and locales provide input methods.Keyboard layouts are provided by the host platform.Input methods are unavailable if (a) no input method written in the Java programming language has been installed and (b) the Java Platform implementation or the underlying platform does not support native input methods.In this case, input contexts can still be created and used; their behavior is specified with the individual methods below."},
{"description": "This class is the starting context for performing LDAPv3-style extended operations and controls.See javax.naming.InitialContext and javax.naming.InitialDirContext for details on synchronization, and the policy for how an initial context is created.When you create an initial context (InitialLdapContext), you can specify a list of request controls.These controls will be used as the request controls for any implicit LDAP \"bind\" operation performed by the context or contexts derived from the context.The request controls supplied to the initial context constructor are not used as the context request controls for subsequent context operations such as searches and lookups.Context request controls are set and updated by using setRequestControls().As shown, there can be two different sets of request controls associated with a context: connection request controls and context request controls.This is required for those applications needing to send critical controls that might not be applicable to both the context operation and any implicit LDAP \"bind\" operation.A typical user program would do the following:InitialLdapContext lctx = new InitialLdapContext(env, critConnCtls); lctx.setRequestControls(critModCtls); lctx.modifyAttributes(name, mods); Controls[] respCtls = lctx.getResponseControls(); It specifies first the critical controls for creating the initial context (critConnCtls), and then sets the context's request controls (critModCtls) for the context operation.If for some reason lctx needs to reconnect to the server, it will use critConnCtls.Service provider implementors should read the \"Service Provider\" section in the LdapContext class description for implementation details."},
{"description": "Exception thrown when an ORB has encountered a failure during its initialization, such as failure to acquire networking resources or detecting a configuration error.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "Input events are delivered to listeners before they are processed normally by the source where they originated.This allows listeners and component subclasses to \"consume\" the event so that the source will not process them in their default manner.For example, consuming mousePressed events on a Button component will prevent the Button from being activated."},
{"description": "This class is the starting context for performing directory operations.The documentation in the class description of InitialContext (including those for synchronization) apply here."},
{"description": "This interface represents a builder that creates initial context factories.The JNDI framework allows for different initial context implementations to be specified at runtime.An initial context is created using an initial context factory.A program can install its own builder that creates initial context factories, thereby overriding the default policies used by the framework, by calling NamingManager.setInitialContextFactoryBuilder().The InitialContextFactoryBuilder interface must be implemented by such a builder."},
{"description": "This interface represents a factory that creates an initial context.The JNDI framework allows for different initial context implementations to be specified at runtime.The initial context is created using an initial context factory.An initial context factory must implement the InitialContextFactory interface, which provides a method for creating instances of initial context that implement the Context interface.In addition, the factory class must be public and must have a public constructor that accepts no arguments."},
{"description": "This class is the starting context for performing naming operations.All naming operations are relative to a context.The initial context implements the Context interface and provides the starting point for resolution of names.When the initial context is constructed, its environment is initialized with properties defined in the environment parameter passed to the constructor, and in any application resource files.In addition, a small number of standard JNDI properties may be specified as system properties or as applet parameters (through the use of Context.These special properties are listed in the field detail sections of the Context and LdapContext interface documentation.JNDI determines each property's value by merging the values from the following two sources, in order: The first occurrence of the property from the constructor's environment parameter and (for appropriate properties) the applet parameters and system properties.For each property found in both of these two sources, or in more than one application resource file, the property's value is determined as follows.If the property is one of the standard JNDI properties that specify a list of JNDI factories (see Context), all of the values are concatenated into a single colon-separated list.For other properties, only the first value found is used.The initial context implementation is determined at runtime.The default policy uses the environment property \"java.naming.factory.initial\", which contains the class name of the initial context factory.An exception to this policy is made when resolving URL strings, as described below.When a URL string (a String of the form scheme_id:rest_of_name) is passed as a name parameter to any method, a URL context factory for handling that scheme is located and used to resolve the URL.If no such factory is found, the initial context specified by \"java.naming.factory.initial\" is used.Similarly, when a CompositeName object whose first component is a URL string is passed as a name parameter to any method, a URL context factory is located and used to resolve the first name component.See NamingManager.getURLContext() for a description of how URL context factories are located.This default policy of locating the initial context and URL context factories may be overridden by calling NamingManager.setInitialContextFactoryBuilder().This exception can be thrown during any interaction with the InitialContext, not only when the InitialContext is constructed.For example, the implementation of the initial context might lazily retrieve the context only when actual methods are invoked on it.The application should not have any dependency on when the existence of an initial context is determined.When the environment property \"java.naming.factory.initial\" is non-null, the InitialContext constructor will attempt to create the initial context specified therein.At that time, the initial context factory involved might throw an exception if a problem is encountered.However, it is provider implementation-dependent when it verifies and indicates to the users of the initial context any environment property- or connection- related problems.It can do so lazily--delaying until an operation is performed on the context, or eagerly, at the time the context is constructed.An InitialContext instance is not synchronized against concurrent access by multiple threads.Multiple threads each manipulating a different InitialContext instance need not synchronize.Threads that need to access a single InitialContext instance concurrently should synchronize amongst themselves and provide the necessary locking."},
{"description": "If an Inherited meta-annotation is present on an annotation type declaration, and the user queries the annotation type on a class declaration, and the class declaration has no annotation for this type, then the class's superclass will automatically be queried for the annotation type.This process will be repeated until an annotation for this type is found, or the top of the class hierarchy (Object) is reached.If no superclass has an annotation for this type, then the query will indicate that the class in question has no such annotation.Note that this meta-annotation type has no effect if the annotated type is used to annotate anything other than a class.Note also that this meta-annotation only causes annotations to be inherited from superclasses; annotations on implemented interfaces have no effect."},
{"description": "This class extends ThreadLocal to provide inheritance of values from parent thread to child thread: when a child thread is created, the child receives initial values for all inheritable thread-local variables for which the parent has values.Normally the child's values will be identical to the parent's; however, the child's value can be made an arbitrary function of the parent's by overriding the childValue method in this class.Inheritable thread-local variables are used in preference to ordinary thread-local variables when the per-thread-attribute being maintained in the variable (e.g., User ID, Transaction ID) must be automatically transmitted to any child threads that are created."},
{"description": "This class implements a stream filter for uncompressing data in the \"deflate\" compression format.It is also used as the basis for other decompression filters, such as GZIPInputStream."},
{"description": "This class provides support for general purpose decompression using the popular ZLIB compression library.The ZLIB compression library was initially developed as part of the PNG graphics standard and is not protected by patents.It is fully described in the specifications at the java.util.zip package description.The following code fragment demonstrates a trivial compression and decompression of a string using Deflater and Inflater."},
{"description": "This class implements an IP Socket Address (IP address + port number)It can also be a pair (hostname + port number), in which case an attempt will be made to resolve the hostname.If resolution fails then the address is said to be unresolved but can still be used on some circumstances like connecting through a proxy.It provides an immutable object used by sockets for binding, connecting, or as returned values.The wildcard is a special local IP address.It usually means \"any\" and can only be used for bind operations."},
{"description": "This class represents an Internet Protocol (IP) address.An IP address is either a 32-bit or 128-bit unsigned number used by IP, a lower-level protocol on which protocols like UDP and TCP are built.The IP address architecture is defined by RFC\u00a0790: Assigned Numbers, RFC\u00a01918: Address Allocation for Private Internets, RFC\u00a02365:An instance of an InetAddress consists of an IP address and possibly its corresponding host name (depending on whether it is constructed with a host name or whether it has already done reverse host name resolution).Address types unicast An identifier for a single interface.A packet sent to a unicast address is delivered to the interface identified by that address.It must never be assigned to any node.It indicates the absence of an address.One example of its use is as the target of bind, which allows a server to accept a client connection on any interface, in case the server host has multiple interfaces.The unspecified address must not be used as the destination address of an IP packet.The Loopback Addresses -- This is the address assigned to the loopback interface.Anything sent to this IP address loops around and becomes IP input on the local host.This address is often used when testing a client.A packet sent to a multicast address is delivered to all interfaces identified by that address.Link-local addresses are designed to be used for addressing on a single link for purposes such as auto-address configuration, neighbor discovery, or when no routers are present.Site-local addresses are designed to be used for addressing inside of a site without the need for a global prefix.Global addresses are unique across the internet.Textual representation of IP addresses The textual representation of an IP address is address family specific.There is a couple of System Properties affecting how IPv4Host Name Resolution Host name-to-IP address resolution is accomplished through the use of a combination of local machine configuration information and network naming services such as the Domain Name System (DNS) and Network Information Service(NIS).The particular naming services(s) being used is by defaultthe local machine configured one.For any host name, its corresponding IP address is returned.Reverse name resolution means that for any IP address, the host associated with the IP address is returned.The InetAddress class provides methods to resolve host names to their IP addresses and vice versa.InetAddress Caching The InetAddress class has a cache to store successful as well as unsuccessful host name resolutions.By default, when a security manager is installed, in order to protect against DNS spoofing attacks, the result of positive host name resolutions are cached forever.When a security manager is not installed, the default behavior is to cache entries for a finite (implementation dependent) period of time.The result of unsuccessful host name resolution is cached for a very short period of time (10 seconds) to improve performance.If the default behavior is not desired, then a Java security property can be set to a different Time-to-live (TTL) value for positive caching.Likewise, a system admin can configure a different negative caching TTL value when needed.Two Java security properties control the TTL values used for positive and negative host name resolution caching:networkaddress.cache.ttl Indicates the caching policy for successful name lookups from the name service.The value is specified as as integer to indicate the number of seconds to cache the successful lookup.The default setting is to cache for an implementation specific period of time.A value of -1 indicates \"cache forever\". networkaddress.cache.negative.ttl(default: 10) Indicates the caching policy for un-successful name lookups from the name service.The value is specified as as integer to indicate the number of seconds to cache the failure for un-successful lookups.A value of 0 indicates \"never cache\".A value of -1 indicates \"cache forever\"."},
{"description": "This class represents an Internet Protocol version 6 (IPv6) address.Textual representation of IP addresses Textual representation of IPv6 address used as input to methods takes one of the following forms: The preferred form is x:x:x:x:x:x:x, where the 'x's are the hexadecimal values of the eight 16-bit pieces of the address.This is the full form.For example, 1080:0:0:0:8:800:200C:417A Note that it is not necessary to write the leading zeros in an individual field.However, there must be at least one numeral in every field, except as described below.Due to some methods of allocating certain styles of IPv6 addresses, it will be common for addresses to contain long strings of zero bits.In order to make writing addresses containing zero bits easier, a special syntax is available to compress the zeros.The use of \"::\" indicates multiple groups of 16-bits of zeros.For example, 1080::8:800:200C:417A An alternative form that is sometimes more convenient when dealing with a mixed environment of IPv4 and IPv6d.d.d.d, where the 'x's are the hexadecimal values of the six high-order 16-bit pieces of the address, and the 'd's are the decimal values of the four low-order 8-bit pieces of the standard IPv4 representation address, for example, ::FFFF:129.144.52.38 ::129.144.52.38 where \"::FFFF:d.d.d.d\" and \"::d.d.d.d\" are, respectively, the general forms of an IPv4-mapped IPv6 address and an IPv4-compatible IPv6 address.Note that the IPv4 portion must be in the \"d.d.d.d\" form.::FFFF:d is valid, however it is an unconventional representation of the IPv4-compatible IPv6 address, ::255.255.0.d while \"::d\" corresponds to the general IPv6 address \"0:0:0:0:0:0:0:d\".For methods that return a textual representation as output value, the full form is used.Inet6Address will return the full form because it is unambiguous when used in combination with other textual data.:w.x.y.z, this IPv6 address is used to represent an IPv4 address.It allows the native program to use the same address data structure and also the same socket when communicating with both IPv4 and IPv6 nodes.In InetAddress and Inet6Address, it is used for internal representation; it has no functional role.Java will never return an IPv4-mapped address.These classes can take an IPv4-mapped address as input, both in byte array and text representation.However, it will be converted into an IPv4 address.The textual representation of IPv6 addresses as described above can be extended to specify IPv6 scoped addresses.This extension to the basic addressing architecture is described in [draft-ietf-ipngwg-scoping-arch-04.txt].Because link-local and site-local addresses are non-global, it is possible that different hosts may have the same destination address and may be reachable through different interfaces on the same originating system.In this case, the originating system is said to be connected to multiple zones of the same scope.In order to disambiguate which is the intended destination zone, it is possible to append a zone identifier (or scope_id) to an IPv6 address.The general format for specifying the scope_id is the following:The IPv6-address is a literal IPv6 address as described above.The scope_id refers to an interface on the local system, and it can be specified in two ways.This must be a positive integer that identifies the particular interface and scope as understood by the system.Usually, the numeric values can be determined through administration tools on the system.Each interface may have multiple values, one for each scope.If the scope is unspecified, then the default value used is zero.This must be the exact string that is returned by NetworkInterface.getName() for the particular interface in question.When an Inet6Address is created in this way, the numeric scope-id is determined at the time the object is created by querying the relevant NetworkInterface.Note also, that the numeric scope_id can be retrieved from Inet6Address instances returned from the NetworkInterface class.This can be used to find out the current scope ids configured on the system."},
{"description": "Thrown to indicate that an index of some sort (such as to an array, to a string, or to a vector) is out of range.Applications can subclass this class to indicate similar exceptions."},
{"description": "An IndexedPropertyDescriptor describes a property that acts like an array and has an indexed read and/or indexed write method to access specific elements of the array.An indexed property may also provide simple non-indexed read and write methods.If these are present, they read and write arrays of the type returned by the indexed read method."},
{"description": "The IndexColorModel class is a ColorModel class that works with pixel values consisting of a single sample that is an index into a fixed colormap in the default sRGB color space.The colormap specifies red, green, blue, and optional alpha components corresponding to each index.All components are represented in the colormap as 8-bit unsigned integral values.Some constructors allow the caller to specify \"holes\" in the colormap by indicating which colormap entries are valid and which represent unusable colors via the bits set in a BigInteger object.This color model is similar to an X11 PseudoColor visual.Some constructors provide a means to specify an alpha component for each pixel in the colormap, while others either provide no such means or, in some cases, a flag to indicate whether the colormap data contains alpha values.If no alpha is supplied to the constructor, an opaque alpha component (alpha = 1.0) is assumed for each entry.An optional transparent pixel value can be supplied that indicates a pixel to be made completely transparent, regardless of any alpha component supplied or assumed for that pixel value.Note that the color components in the colormap of an IndexColorModel objects are never pre-multiplied with the alpha components.The transparency of an IndexColorModel object is determined by examining the alpha components of the colors in the colormap and choosing the most specific value after considering the optional alpha values and any transparent index specified.The transparency value is Transparency.OPAQUE only if all valid colors in the colormap are opaque and there is no valid transparent pixel.If all valid colors in the colormap are either completely opaque (alpha = 1.0) or completely transparent (alpha = 0.0), which typically occurs when a valid transparent pixel is specified, the value is Transparency.Otherwise, the value is Transparency.TRANSLUCENT, indicating that some valid color has an alpha component that is neither completely transparent nor completely opaque (0.0 < alpha < 1.0).If an IndexColorModel object has a transparency value of Transparency.OPAQUE, then the hasAlpha and getNumComponents methods (both inherited from ColorModel) return false and 3, respectively.For any other transparency value, hasAlpha returns true and getNumComponents returns 4.The values used to index into the colormap are taken from the least significant n bits of pixel representations where n is based on the pixel size specified in the constructor.For pixel sizes smaller than 8 bits, n is rounded up to a power of two (3 becomes 4 and 5,6,7 become 8).For pixel sizes between 8 and 16 bits, n is equal to the pixel size.Pixel sizes larger than 16 bits are not supported by this class.Higher order bits beyond n are ignored in pixel representations.Index values greater than or equal to the map size, but less than 2n, are undefined and return 0 for all color and alpha components.For those methods that use a primitive array pixel representation of type transferType, the array length is always one.The transfer types supported are DataBuffer.A single int pixel representation is valid for all objects of this class, since it is always possible to represent pixel values used with this class in a single int.Therefore, methods that use this representation do not throw an IllegalArgumentException due to an invalid pixel value.Many of the methods in this class are final.The reason for this is that the underlying native graphics code makes assumptions about the layout and operation of this class and those assumptions are reflected in the implementations of the methods here that are marked final.You can subclass this class for other reasons, but you cannot override or modify the behaviour of those methods."},
{"description": "An \"IndexedPropertyChange\" event gets delivered whenever a component that conforms to the JavaBeans\u2122 specification (a \"bean\") changes a bound indexed property.This class is an extension of PropertyChangeEvent but contains the index of the property that has changed.Null values may be provided for the old and the new values if their true values are not known.An event source may send a null object as the name to indicate that an arbitrary set of if its properties have changed.In this case the old and new values should also be null."},
{"description": "This class represents an Internet Protocol version 4 (IPv4) address.Administratively Scoped IP Multicast Textual representation of IP addresses Textual representation of IPv4 address used as input to methods takes one of the following forms: d.d.d.d d.d.dd.d d When four parts are specified, each is interpreted as a byte of data and assigned, from left to right, to the four bytes of an IPv4 address.When a three part address is specified, the last part is interpreted as a 16-bit quantity and placed in the right most two bytes of the network address.This makes the three part address format convenient for specifying Class B net- work addresses as 128.net.host.When a two part address is supplied, the last part is interpreted as a 24-bit quantity and placed in the right most three bytes of the network address.This makes the two part address format convenient for specifying Class A network addresses as net.host.When only one part is given, the value is stored directly in the network address without any byte rearrangement.For methods that return a textual representation as output value, the first form, i.e. a dotted-quad string, is used.Historically the IPv4 TTL field in the IP header has doubled as a multicast scope field: a TTL of 0 means node-local, 1 means link-local, up through 32 means site-local, up through 64 means region-local, up through 128 means continent-local, and up through 255 are global."},
{"description": "The Indirection exception is a Java specific system exception.It is thrown when the ORB's input stream is called to demarshal a value that is encoded as an indirection that is in the process of being demarshaled.This can occur when the ORB input stream calls the ValueHandler to demarshal an RMI value whose state contains a recursive reference to itself.Because the top-level ValueHandler.read_value() call has not yet returned a value, the ORB input stream's indirection table does not contain an entry for an object with the stream offset specified by the indirection tag.The stream offset is returned in the exception's offset field."},
{"description": "Thrown when an incompatible class change has occurred to some class definition.The definition of some class, on which the currently executing method depends, has since changed."},
{"description": "This policy specifies whether implicit activation of servants is supported in the created POA."},
{"description": "ImplicitActivationPolicyValue has the following semantics.This requires SYSTEM_ID and RETAIN policies to be set."},
{"description": "InconsistentTypeCode is thrown when an attempt is made to create a dynamic any with a type code that does not match the particular subclass of DynAny."},
{"description": "Thrown to indicate that a program has attempted to access an element of an annotation type that was added to the annotation type definition after the annotation was compiled (or serialized).This exception will not be thrown if the new element has a default value.This exception can be thrown by the API used to read annotations reflectively."},
{"description": "This policy specifies whether implicit activation of servants is supported in the created POA."},
{"description": "The ImagingOpException is thrown if one of the BufferedImageOp or RasterOp filter methods cannot process the image."},
{"description": "Each ImageWriterSpi provides several types of information about the ImageWriter class with which it is associated.The name of the vendor who defined the SPI class and a brief description of the class are available via the getVendorName, getDescription, and getVersion methods.These methods may be internationalized to provide locale-specific output.These methods are intended mainly to provide short, human-writable information that might be used to organize a pop-up menu or other list.Lists of format names, file suffixes, and MIME types associated with the service may be obtained by means of the getFormatNames, getFileSuffixes, and getMIMEType methods.These methods may be used to identify candidate ImageWriters for writing a particular file or stream based on manual format selection, file naming, or MIME associations.A more reliable way to determine which ImageWriters are likely to be able to parse a particular data stream is provided by the canEncodeImage method.This methods allows the service provider to inspect the actual image contents.Finally, an instance of the ImageWriter class associated with this service provider may be obtained by calling the createWriterInstance method.Any heavyweight initialization, such as the loading of native libraries or creation of large tables, should be deferred at least until the first invocation of this method."},
{"description": "Instances of this class or its subclasses are used to supply prescriptive \"how-to\" information to instances of ImageWriter.A plug-in for a specific image format may define a subclass of this class, and return objects of that class from the getDefaultWriteParam method of its ImageWriter implementation.For example, the built-in JPEG writer plug-in will return instances of javax.imageio.plugins.jpeg.JPEGImageWriteParam.The region of the image to be written is determined by first intersecting the actual bounds of the image with the rectangle specified by IIOParam.setSourceRegion, if any.If the resulting rectangle has a width or height of zero, the writer will throw an IIOException.If the intersection is non-empty, writing will commence with the first subsampled pixel and include additional pixels within the intersected bounds according to the horizontal and vertical subsampling factors specified by IIOParam.setSourceSubsampling.Individual features such as tiling, progressive encoding, and compression may be set in one of four modes.MODE_DISABLED disables the features; MODE_DEFAULT enables the feature with writer-controlled parameter values; MODE_EXPLICIT enables the feature and allows the use of a set method to provide additional parameters; and MODE_COPY_FROM_METADATA copies relevant parameter values from the stream and image metadata objects passed to the writer.The default for all features is MODE_COPY_FROM_METADATA.Non-standard features supplied in subclasses are encouraged, but not required to use a similar scheme.Plug-in writers may extend the functionality of ImageWriteParam by providing a subclass that implements additional, plug-in specific interfaces.It is up to the plug-in to document what interfaces are available and how they are to be used.Writers will silently ignore any extended features of an ImageWriteParam subclass of which they are not aware.Also, they may ignore any optional features that they normally disable when creating their own ImageWriteParam instances via getDefaultWriteParam.Note that unless a query method exists for a capability, it must be supported by all ImageWriter implementations (e.g. progressive encoding is optional, but subsampling must be supported)."},
{"description": "This exception indicates that an implementation limit was exceeded in the ORB run time.For example, an ORB may reach the maximum number of references it can hold simultaneously in an address space, the size of a parameter may have exceeded the allowed maximum, or an ORB may impose a maximum on the number of clients or servers that can run simultaneously.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "This class must be subclassed by classes that write out images in the context of the Java Image I/O framework.ImageWriter objects are normally instantiated by the service provider class for the specific format.Service provider classes are registered with the IIORegistry, which uses them for format recognition and presentation of available format readers and writers."},
{"description": "If the image is unable to be loaded any text specified via the ALT attribute will be rendered.While this class has been part of swing for a while now, it is public as of 1.4."},
{"description": "A class that allows the format of an image (in particular, its SampleModel and ColorModel) to be specified in a convenient manner."},
{"description": "Any image may be transcoded (written to a different format than the one it was originally stored in) simply by performing a read operation followed by a write operation.However, loss of data may occur in this process due to format differences.In general, the best results will be achieved when format-specific metadata objects can be created to encapsulate as much information about the image and its associated metadata as possible, in terms that are understood by the specific ImageWriter used to perform the encoding.An ImageTranscoder may be used to convert the IIOMetadata objects supplied by the ImageReader (representing per-stream and per-image metadata) into corresponding objects suitable for encoding by a particular ImageWriter.In the case where the methods of this interface are being called directly on an ImageWriter, the output will be suitable for that writer.The internal details of converting an IIOMetadata object into a writer-specific format will vary according to the context of the operation.Typically, an ImageWriter will inspect the incoming object to see if it implements additional interfaces with which the writer is familiar.This might be the case, for example, if the object was obtained by means of a read operation on a reader plug-in written by the same vendor as the writer.In this case, the writer may access the incoming object by means of its plug-in specific interfaces.In this case, the re-encoding may be close to lossless if the image file format is kept constant.If the format is changing, the writer may still attempt to preserve as much information as possible.If the incoming object does not implement any additional interfaces known to the writer, the writer has no choice but to access it via the standard IIOMetadata interfaces such as the tree view provided by IIOMetadata.getAsTree.In this case, there is likely to be significant loss of information.An independent ImageTranscoder essentially takes on the same role as the writer plug-in in the above examples.It must be familiar with the private interfaces used by both the reader and writer plug-ins, and manually instantiate an object that will be usable by the writer.The resulting metadata objects may be used by the writer directly.No independent implementations of ImageTranscoder are provided as part of the standard API.Instead, the intention of this interface is to provide a way for implementations to be created and discovered by applications as the need arises."},
{"description": "Instances of this class or its subclasses are used to supply prescriptive \"how-to\" information to instances of ImageReader.An image encoded as part of a file or stream may be thought of extending out in multiple dimensions: the spatial dimensions of width and height, a number of bands, and a number of progressive decoding passes.This class allows a contiguous (hyper)rectangular subarea of the image in all of these dimensions to be selected for decoding.Finally, color and format conversions may be specified by controlling the ColorModel and SampleModel of the destination image, either by providing a BufferedImage or by using an ImageTypeSpecifier.An ImageReadParam object is used to specify how an image, or a set of images, will be converted on input from a stream in the context of the Java Image I/O framework.A plug-in for a specific image format will return instances of ImageReadParam from the getDefaultReadParam method of its ImageReader implementation.The state maintained by an instance of ImageReadParam is independent of any particular image being decoded.When actual decoding takes place, the values set in the read param are combined with the actual properties of the image being decoded from the stream and the destination BufferedImage that will receive the decoded pixel data.For example, the source region set using setSourceRegion will first be intersected with the actual valid source area.The result will be translated by the value returned by getDestinationOffset, and the resulting rectangle intersected with the actual valid destination area to yield the destination area that will be written.The parameters specified by an ImageReadParam are applied to an image as follows.First, if a rendering size has been set by setSourceRenderSize, the entire decoded image is rendered at the size given by getSourceRenderSize.Otherwise, the image has its natural size given by ImageReader.getWidth and ImageReader.getHeight.Next, the image is clipped against the source region specified by getSourceXOffset, getSourceYOffset, getSourceWidth, and getSourceHeight.The resulting region is then subsampled according to the factors given in IIOParam.setSourceSubsampling.The first pixel, the number of pixels per row, and the number of rows all depend on the subsampling settings.This rectangle is offset by (getDestinationOffset().x, getDestinationOffset().y) and clipped against the destination bounds.If no destination image has been set, the destination is defined to have a width of getDestinationOffset().x+ h so that all pixels of the source region may be written to the destination.Pixels that land, after subsampling, within the destination image, and that are written in one of the progressive passes specified by getSourceMinProgressivePass and getSourceNumProgressivePasses are passed along to the next step.Finally, the source samples of each pixel are mapped into destination bands according to the algorithm described in the comment for setDestinationBands.Plug-in writers may extend the functionality of ImageReadParam by providing a subclass that implements additional, plug-in specific interfaces.It is up to the plug-in to document what interfaces are available and how they are to be used.Readers will silently ignore any extended features of an ImageReadParam subclass of which they are not aware.Also, they may ignore any optional features that they normally disable when creating their own ImageReadParam instances via getDefaultReadParam.Note that unless a query method exists for a capability, it must be supported by all ImageReader implementations (e.g. source render size is optional, but subsampling must be supported)."},
{"description": "This class must be subclassed by classes that read in images in the context of the Java Image I/O framework.ImageReader objects are normally instantiated by the service provider interface (SPI) class for the specific format.Service provider classes (e.g., instances of ImageReaderSpi) are registered with the IIORegistry, which uses them for format recognition and presentation of available format readers and writers.When an input source is set (using the setInput method), it may be marked as \"seek forward only\".This setting means that images contained within the input source will only be read in order, possibly allowing the reader to avoid caching portions of the input containing data associated with images that have been read previously."},
{"description": "Each ImageReaderSpi provides several types of information about the ImageReader class with which it is associated.The name of the vendor who defined the SPI class and a brief description of the class are available via the getVendorName, getDescription, and getVersion methods.These methods may be internationalized to provide locale-specific output.These methods are intended mainly to provide short, human-readable information that might be used to organize a pop-up menu or other list.Lists of format names, file suffixes, and MIME types associated with the service may be obtained by means of the getFormatNames, getFileSuffixes, and getMIMETypes methods.These methods may be used to identify candidate ImageReaders for decoding a particular file or stream based on manual format selection, file naming, or MIME associations (for example, when accessing a file over HTTP or as an email attachment).A more reliable way to determine which ImageReaders are likely to be able to parse a particular data stream is provided by the canDecodeInput method.This methods allows the service provider to inspect the actual stream contents.Finally, an instance of the ImageReader class associated with this service provider may be obtained by calling the createReaderInstance method.Any heavyweight initialization, such as the loading of native libraries or creation of large tables, should be deferred at least until the first invocation of this method."},
{"description": "The interface for objects which can produce the image data for Images.Each image contains an ImageProducer which is used to reconstruct the image whenever it is needed, for example, when a new size of the Image is scaled, or when the width or height of the Image is being requested."},
{"description": "This class is designed to reduce the number of methods that must be implemented by subclasses."},
{"description": "This interface allows arbitrary objects to be \"wrapped\" by instances of ImageOutputStream.For example, a particular ImageOutputStreamSpi might allow a generic OutputStream to be used as a destination; another might output to a File or to a device such as a serial port.By treating the creation of ImageOutputStreams as a pluggable service, it becomes possible to handle future output destinations without changing the API.Also, high-performance implementations of ImageOutputStream (for example, native implementations for a particular platform) can be installed and used transparently by applications."},
{"description": "This interface allows arbitrary objects to be \"wrapped\" by instances of ImageInputStream.For example, a particular ImageInputStreamSpi might allow a generic InputStream to be used as an input source; another might take input from a URL.By treating the creation of ImageInputStreams as a pluggable service, it becomes possible to handle future input sources without changing the API.Also, high-performance implementations of ImageInputStream (for example, native implementations for a particular platform) can be installed and used transparently by applications."},
{"description": "Various output destinations, such as OutputStreams and Files, as well as future fastI/O destinations may be \"wrapped\" by a suitable implementation of this interface for use by the Image I/O API.Unlike a standard OutputStream, ImageOutputStream extends its counterpart, ImageInputStream.Thus it is possible to read from the stream as it is being written.The same seek and flush positions apply to both reading and writing, although the semantics for dealing with a non-zero bit offset before a byte-aligned write are necessarily different from the semantics for dealing with a non-zero bit offset before a byte-aligned read.When reading bytes, any bit offset is set to 0 before the read; when writing bytes, a non-zero bit offset causes the remaining bits in the byte to be written as 0s.The byte-aligned write then starts at the next byte position."},
{"description": "This class is designed to reduce the number of methods that must be implemented by subclasses.In particular, this class handles most or all of the details of byte order interpretation, buffering, mark/reset, discarding, closing, and disposing."},
{"description": "An asynchronous update interface for receiving notifications about Image information as the Image is constructed."},
{"description": "This class implements a filter for the set of interface methods that are used to deliver data from an ImageProducer to an ImageConsumer.It is meant to be used in conjunction with a FilteredImageSource object to produce filtered versions of existing images.It is a base class that provides the calls needed to implement a \"Null filter\" which has no effect on the data being passed through.Filters should subclass this class and override the methods which deal with the data that needs to be filtered and modify it as necessary."},
{"description": "The abstract class Image is the superclass of all classes that represent graphical images.The image must be obtained in a platform-specific manner."},
{"description": "The ImageGraphicAttribute class is an implementation of GraphicAttribute which draws images in a TextLayout."},
{"description": "Builder to indicate that an argument is not a well-formed BCP 47 tag."},
{"description": "An implementation of the Icon interface that paints Icons from Images.Images that are created from a URL, filename or byte array are preloaded using MediaTracker to monitor the loaded state of the image.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Various input sources, such as InputStreams and Files, as well as future fast/O sources may be \"wrapped\" by a suitable implementation of this interface for use by the Image I/O API."},
{"description": "When a consumer is added to an image producer, the producer delivers all of the data about the image using the method calls defined in this interface."},
{"description": "Thrown to indicate that a thread is not in an appropriate state for the requested operation."},
{"description": "Signals that a method has been invoked at an illegal or inappropriate time.In other words, the Java environment or Java application is not in an appropriate state for the requested operation."},
{"description": "The IllegalPathStateException represents an exception that is thrown if an operation is performed on a path that is in an illegal state with respect to the particular operation being performed, such as appending a path segment to a GeneralPath without an initial moveto."},
{"description": "Thrown to indicate that a thread has attempted to wait on an object's monitor or to notify other threads waiting on an object's monitor without owning the specified monitor."},
{"description": "Unchecked exception thrown when the format width is a negative value other than -1 or is otherwise unsupported."},
{"description": "Unchecked exception thrown when the precision is a negative value other than -1, the conversion does not support a precision, or the value is otherwise unsupported."},
{"description": "Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown."},
{"description": "Unchecked exception thrown when a format string contains an illegal syntax or a format specifier that is incompatible with the given arguments.Only explicit subtypes of this exception which correspond to specific errors should be instantiated."},
{"description": "Unchecked exception thrown when the argument corresponding to the format specifier is of an incompatible type.Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown."},
{"description": "Unchecked exception thrown when a character with an invalid Unicode code point as defined by Character.isValidCodePoint(int) is passed to the Formatter.Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown."},
{"description": "Thrown by an implementation of ClassFileTransformer.transform when its input parameters are invalid.This may occur either because the initial class file bytes were invalid or a previously applied transform corrupted the bytes."},
{"description": "Unchecked exception thrown when an attempt is made to open a channel in a group that was not created by the same provider."},
{"description": "Signals that an AWT component is not in an appropriate state for the requested operation."},
{"description": "This exception is thrown when the length of data provided to a block cipher is incorrect, i.e., does not match the block size of the cipher."},
{"description": "Unchecked exception thrown when a blocking-mode-specific operation is invoked upon a channel in the incorrect blocking mode."},
{"description": "An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor."},
{"description": "Thrown to indicate that a method has been passed an illegal or inappropriate argument."},
{"description": "Thrown if an application attempts to access or modify a field, or to call a method that it does not have access to.Normally, this error is caught by the compiler; this error can only occur at run time if the definition of a class has incompatibly changed."},
{"description": "Fatal errors cause the relevant read method to throw an IIOException.Localization is handled by associating a Locale with each IIOWriteWarningListener as it is registered with an ImageWriter.It is up to the ImageWriter to provide localized messages."},
{"description": "Service provider classes may be detected at run time by means of meta-information in the JAR files containing them.The intent is that it be relatively inexpensive to load and inspect all available service provider classes.These classes may them be used to locate and instantiate more heavyweight classes that will perform actual work, in this case instances of ImageReader, ImageWriter, ImageTranscoder, ImageInputStream, and ImageOutputStream.Service providers found on the system classpath (typically the lib/ext directory in the Java installation directory) are automatically loaded as soon as this class is instantiated.When the registerApplicationClasspathSpis method is called, service provider instances declared in the meta-information section of JAR files on the application class path are loaded.To declare a service provider, a services subdirectory is placed within the META-INF directory that is present in every JAR file.This directory contains a file for each service provider interface that has one or more implementation classes present in the JAR file.For example, if the JAR file contained a class named com.mycompany.imageio.MyFormatReaderSpi which implements the ImageReaderSpi interface, the JAR file would contain a file named: META-INF/services/javax.imageio.spi.Implementations of these interfaces should avoid complex dependencies on other classes and on native code.It is also possible to manually add service providers not found automatically, as well as to remove those that are using the interfaces of the ServiceRegistry class.Thus the application may customize the contents of the registry as it sees fit."},
{"description": "Fatal errors cause the relevant read method to throw an IIOException.Localization is handled by associating a Locale with each IIOReadWarningListener as it is registered with an ImageReader.It is up to the ImageReader to provide localized messages."},
{"description": "An interface to be implemented by objects that can determine the settings of an IIOParam object, either by putting up a GUI to obtain values from a user, or by other means.This interface merely specifies a generic activate method that invokes the controller, without regard for how the controller obtains values (i.e., whether the controller puts up a GUI or merely computesa set of values is irrelevant to this interface).Within the activate method, a controller obtains initial values by querying the IIOParam object's get methods, modifies values by whatever means, then invokes the IIOParam object's set methods to modify the appropriate settings.Normally, these set methods will be invoked all at once at a final commit in order that a cancel operation not disturb existing values.In general, applications may expect that when the activate method returns true, the IIOParam object is ready for use in a read or write operation.Vendors may choose to provide GUIs for the IIOParam subclasses they define for a particular plug-in.These can be set up as default controllers in the corresponding IIOParam subclasses.Applications may override any default GUIs and provide their own controllers embedded in their own framework.All that is required is that theactivate method behave modally (not returning until either cancelled or committed), though it need not put up an explicitly modal dialog.Such a non-modal GUI component would be coded roughly as follows: class MyGUI extends SomeComponent implements IIOParamController { public MyGUI() { //; // go to sleep until either cancelled or committed boolean ret = false; if (!cancelled) { // set values on param ret = true; } setEnabled(false); // enable any components disabled above return ret; } Alternatively, an algorithmic process such as a database lookup or the parsing of a command line could be used as a controller, in which case the activate method would simply look up or compute the settings, call the IIOParam.setXXX methods, and return true."},
{"description": "A superclass of all classes describing how streams should be decoded or encoded.This class contains all the variables and methods that are shared by ImageReadParam and ImageWriteParam.This class provides mechanisms to specify a source region and a destination region.When reading, the source is the stream and the in-memory image is the destination.In the case of writing, destination regions may be used only with a writer that supports pixel replacement.Decimation subsampling may be specified for both readers and writers, using a movable subsampling grid.Subsets of the source and destination bands may be selected."},
{"description": "A class representing a node in a meta-data tree, which implements the org.w3c.dom.Element interface and additionally allows for the storage of non-textual objects via the getUserObject and setUserObject methods.This class is not intended to be used for general XML processing.In particular, Element nodes created within the Image I/O API are not compatible with those created by Sun's standard implementation of the org.w3.dom API.In particular, the implementation is tuned for simple uses and may not perform well for intensive processing.Namespaces are ignored in this implementation.Note: The DOM Level 3 specification added a number of new methods to the Node, Element and Attr interfaces that are not of value to the IIOMetadataNode implementation or specification.Calling such methods on an IIOMetadataNode, or an Attr instance returned from an IIOMetadataNode will result in a DOMException being thrown."},
{"description": "This interface receives general indications of decoding progress (via the imageProgress and thumbnailProgress methods), and events indicating when an entire image has been updated (via the imageStarted, imageComplete, thumbnailStarted and thumbnailComplete methods).Applications that wish to be informed of pixel updates as they happen (for example, during progressive decoding), should provide an IIOReadUpdateListener."},
{"description": "Unchecked exception thrown when a string that is not a legal charset name is used as such."},
{"description": "In addition, a static instance representing the standard, plug-in neutral javax_imageio_1.0 format is provided by the getStandardFormatInstance method.In order to supply localized descriptions of elements and attributes, a ResourceBundle with a base name of this.getClass().getName() + \"Resources\" should be supplied via the usual mechanism used by ResourceBundle.getBundle.Briefly, the subclasser supplies one or more additional classes according to a naming convention (by default, the fully-qualified name of the subclass extending IIMetadataFormatImpl, plus the string \"Resources\", plus the country, language, and variant codes separated by underscores).At run time, calls to getElementDescription or getAttributeDescription will attempt to load such classes dynamically according to the supplied locale, and will use either the element name, or the element name followed by a '/' character followed by the attribute name as a key.This key will be supplied to the ResourceBundle's getString method, and the resulting localized description of the node or attribute is returned.The subclass may supply a different base name for the resource bundles using the setResourceBaseName method.A subclass may choose its own localization mechanism, if so desired, by overriding the supplied implementations of getElementDescription and getAttributeDescription."},
{"description": "An interface to be implemented by objects that can determine the settings of an IIOMetadata object, either by putting up a GUI to obtain values from a user, or by other means.This interface merely specifies a generic activate method that invokes the controller, without regard for how the controller obtains values (i.e., whether the controller puts up a GUI or merely computesa set of values is irrelevant to this interface).Within the activate method, a controller obtains initial values by querying the IIOMetadata object's settings, either using the XML DOM tree or a plug-in specific interface, modifies values by whatever means, then modifies the IIOMetadata object's settings, using either the setFromTree or mergeTree methods, or a plug-in specific interface.In general, applications may expect that when the activate method returns true, the IIOMetadata object is ready for use in a write operation.Vendors may choose to provide GUIs for the IIOMetadata subclasses they define for a particular plug-in.These can be set up as default controllers in the corresponding IIOMetadata subclasses.Alternatively, an algorithmic process such as a database lookup or the parsing of a command line could be used as a controller, in which case the activate method would simply look up or compute the settings, call methods on IIOMetadata to set its state, and return true."},
{"description": "Document structures are described by a set of constraints on the type and number of child elements that may belong to a given parent element type, the names, types, and values of attributes that may belong to an element, and the type and values of Object reference that may be stored at a node.: classes that implement this interface should contain a method declared as public static getInstance() which returns an instance of the class.Commonly, an implementation will construct only a single instance and cache it for future invocations of getInstance.The structures that may be described by this class are a subset of those expressible using XML document type definitions (DTDs), with the addition of some basic information on the datatypes of attributes and the ability to store an Object reference within a node.In the future, XML Schemas could be used to represent these structures, and many others.The differences between IIOMetadataFormat-described structures and DTDs are as follows: Elements may not contain text or mix text with embedded tags.The children of an element must conform to one of a few simple patterns, described in the documentation for the CHILD_* constants; The in-memory representation of an elements may contain a reference to an Object.There is no provision for representing such objects textually."},
{"description": "An abstract class to be extended by objects that represent metadata (non-image data) associated with images and streams.These objects, however, provide the ability to access their internal information as a tree of IIOMetadataNode objects that support the XML DOM interfaces as well as additional interfaces for storing non-textual data and retrieving information about legal data values.The format of such trees is plug-in dependent, but plug-ins may choose to support a plug-in neutral format described below.A single plug-in may support multiple metadata formats, whose names maybe determined by calling getMetadataFormatNames.The plug-in may also support a single special format, referred to as the \"native\" format, which is designed to encode its metadata losslessly.This format will typically be designed specifically to work with a specific file format, so that images may be loaded and saved in the same format with no loss of metadata, but may be less useful for transferring metadata between an ImageReader and an ImageWriter for different image formats.To convert between two native formats as losslessly as the image file formats will allow, an ImageTranscoder object must be used."},
{"description": "An IIOInvalidTreeException is thrown when an attempt by an IIOMetadata object to parse a tree of IIOMetadataNodes fails.The node that led to the parsing error may be stored.As with any parsing error, the actual error may occur at a different point that that where it is detected.The node returned by getOffendingNode should merely be considered as a clue to the actual nature of the problem."},
{"description": "The image data may take the form of either a RenderedImage, or a Raster.Reader methods that return an IIOImage will always return a BufferedImage using the RenderedImage reference.Writer methods that accept an IIOImage will always accept a RenderedImage, and may optionally accept a Raster.Exactly one of getRenderedImage and getRaster will return a non-null value.Subclasses are responsible for ensuring this behavior."},
{"description": "IdUniquenessPolicyValue can have the following values.UNIQUE_ID - Servants activated with that POA support exactly one Object Id. MULTIPLE_ID - a servant activated with that POA may support one or more Object Ids."},
{"description": "IIOByteBuffer is used by ImageInputStream to supply a sequence of bytes to the caller, possibly with fewer copies than using the conventional read methods that take a user-supplied byte array.The byte array referenced by an IIOByteBuffer will generally be part of an internal data structure belonging to an ImageReader implementation; its contents should be considered read-only and must not be modified."},
{"description": "This reference, if non-null, refers to the event that caused this exception to occur.For example, an IOException while reading from a File would be stored there."},
{"description": "The IdUniquenessPolicy specifies whether the servants activated in the created POA must have unique object i identities.The default is UNIQUE_ID."},
{"description": "The IdUniquenessPolicy specifies whether the servants activated in the created POA must have unique object i identities.The default is UNIQUE_ID."},
{"description": "This interface must be implemented by all IDLType objects.The IDLType is inherited by all IR objects that represent IDL types, including interfaces, typedefs, and anonymous types."},
{"description": "Internationalized domain names can use characters from the entire range of Unicode, while traditional domain names are restricted to ASCII characters.ACE is an encoding of Unicode strings that uses only ASCII characters and can be used with software (such as the Domain Name System) that only understands traditional domain names.Internationalized domain names are defined in RFC 3490.RFC 3490 defines two operations:These 2 operations employ Nameprep algorithm, which is a profile of Stringprep, and Punycode algorithm to convert domain name string back and forth.The behavior of aforementioned conversion process can be adjusted by various flags: If the ALLOW_UNASSIGNED flag is used, the domain name string to be converted can contain code points that are unassigned in Unicode 3.2, which is the Unicode version on which IDN conversion is based.If the flag is not used, the presence of such unassigned code points is treated as an error.If the USE_STD3_ASCII_RULES flag is used, ASCII strings are checked against RFC 1122 and RFC 1123.It is an error if they don't meet the requirements.These flags can be logically OR'ed together.The security consideration is important with respect to internationalization domain name support.For example, English domain names may be homographed - maliciously misspelled by substitution of non-Latin letters.Applications are responsible for taking adequate security measures when using international domain names."},
{"description": "An interface with no members whose only purpose is to serve as a marker indicating that an implementing class is a Java value type from IDL that has a corresponding Helper class.RMI IIOP serialization looks for such a marker to perform marshalling/unmarshalling."},
{"description": "Its functionality has been replaced by java.security.KeyStore, the java.security.cert package, and java.security.Principal."},
{"description": "An abstract interface inherited by all Interface Repository (IR) objects that represent OMG IDL types.It provides access to the TypeCode object describing the type and is used in defining the other interfaces wherever definitions of IDLType must be referenced."},
{"description": "This class implements the Map interface with a hash table, using reference-equality in place of object-equality when comparing keys (and values).In other words, in an IdentityHashMap, two keys k1 and k2 are considered equal if and only if (k1==k2).This class is not a general-purpose Map implementation!While this class implements the Map interface, it intentionally violates Map's general contract, which mandates the use of the equals method when comparing objects.This class is designed for use only in the rare cases wherein reference-equality semantics are required.A typical use of this class is topology-preserving object graph transformations, such as serialization or deep-copying.To perform such a transformation, a program must maintain a \"node table\" that keeps track of all the object references that have already been processed.The node table must not equate distinct objects even if they happen to be equal.Another typical use of this class is to maintain proxy objects.For example, a debugging facility might wish to maintain a proxy object for each object in the program being debugged.This class provides all of the optional map operations, and permits null values and the null key.This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.This class provides constant-time performance for the basic operations (get and put), assuming the system identity hash function (System.identityHashCode(Object)) disperses elements properly among the buckets.This class has one tuning parameter (which affects performance but not semantics): expected maximum size.This parameter is the maximum number of key-value mappings that the map is expected to hold.Internally, this parameter is used to determine the number of buckets initially comprising the hash table.The precise relationship between the expected maximum size and the number of buckets is unspecified.If the size of the map (the number of key-value mappings) sufficiently exceeds the expected maximum size, the number of buckets is increased.Increasing the number of buckets (\"rehashing\") may be fairly expensive, so it pays to create identity hash maps with a sufficiently large expected maximum size.On the other hand, iteration over collection views requires time proportional to the number of buckets in the hash table, so it pays not to set the expected maximum size too high if you are especially concerned with iteration performance or memory usage.If multiple threads access an identity hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally.(A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with a key that an instance already contains is not a structural modification.)This is typically accomplished by synchronizing on some object that naturally encapsulates the map.If no such object exists, the map should be \"wrapped\" using the Collections.synchronizedMap method.This is best done at creation time, to prevent accidental unsynchronized access to the map: Map m = Collections.synchronizedMap(new IdentityHashMap(...)); The iterators returned by the iterator method of the collections returned by all of this class's \"collection view methods\" are fail-fast:if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException.Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast iterators throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness:fail-fast iterators should be used only to detect bugs.Implementation note: This is a simple linear-probe hash table, as described for example in texts by Sedgewick and Knuth.The array alternates holding keys and values.(This has better locality for large tables than does using separate arrays.)For many JRE implementations and operation mixes, this class will yield better performance than HashMap (which uses chaining rather than linear-probing).This class is a member of the Java Collections Framework."},
{"description": "IdAssignmentPolicy specifies whether Object Ids in the created POA are generated by the application or by the ORB.The default is SYSTEM_ID."},
{"description": "Its functionality has been replaced by java.security.KeyStore, the java.security.cert package, and java.security.Principal."},
{"description": "The IdAssignmentPolicyValue can have the following values.USER_ID - Objects created with that POA are assigned Object Ids only by the application.SYSTEM_ID - Objects created with that POA are assigned Object Ids only by the POA.If the POA also has the PERSISTENT policy, assigned Object Ids must be unique across all instantiations of the same POA."},
{"description": "IdAssignmentPolicy specifies whether Object Ids in the created POA are generated by the application or by the ORB.The default is SYSTEM_ID."},
{"description": "Icon decorator that implements the view interface.The entire element is used to represent the icon.This acts as a gateway from the display-only View implementations to interactive lightweight icons (that is, it allows icons to be embedded into the View hierarchy.The parent of the icon is the container that is handed out by the associated view factory."},
{"description": "An Icon wrapper class which implements UIResource.UI classes which set icon properties should use this class to wrap any icons specified as defaults.This class delegates all method invocations to the Icon \"delegate\" object specified at construction.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A subclass of the ICC_Profile class which represents profiles which meet the following criteria: the color space type of the profile is TYPE_GRAY and the profile includes the grayTRCTag and mediaWhitePointTag tags.Examples of this kind of profile are monochrome input profiles, monochrome display profiles, and monochrome output profiles.The getInstance methods in the ICC_Profile class will return an ICC_ProfileGray object when the above conditions are met.The advantage of this class is that it provides a lookup table that Java or native methods may be able to use directly to optimize color conversion in some cases.To transform from a GRAY device profile color space to the CIEXYZ Profile Connection Space, the device gray component is transformed by a lookup through the tone reproduction curve (TRC).The result is treated as the achromatic component of the PCS.\u00a0 The inverse transform is done by converting the PCS Y components to device Gray via the inverse of the grayTRC."},
{"description": "An ICC_ColorSpace object can be constructed from an appropriate ICC_Profile.Typically, an ICC_ColorSpace would be associated with an ICC Profile which is either an input, display, or output profile (see the ICC specification).There are also device link, abstract, color space conversion, and named color profiles.These are less useful for tagging a color or image, but are useful for other purposes (in particular device link profiles can provide improved performance for converting from one device's color space to another's).ICC Profiles represent transformations from the color space of the profile (e.g. a monitor) to a Profile Connection Space (PCS).Profiles of interest for tagging images or colors have a PCS which is one of the two specific device independent spaces (one CIEXYZ space and one CIELab space) defined in the ICC Profile Format Specification.Most profiles of interest either have invertible transformations or explicitly specify transformations going both directions."},
{"description": "The ICC_ColorSpace class is an implementation of the abstract ColorSpace class.This representation of device independent and device dependent color spaces is based on the International Color Consortium Specification ICC.1:2001-12, File Format for Color Profiles (see http://www.color.org).Typically, a Color or ColorModel would be associated with an ICC Profile which is either an input, display, or output profile (see the ICC specification).There are other types of ICC Profiles, e.g. abstract profiles, device link profiles, and named color profiles, which do not contain information appropriate for representing the color space of a color, image, or device (see ICC_Profile).Attempting to create an ICC_ColorSpace object from an inappropriate ICC Profile is an error.ICC Profiles represent transformations from the color space of the profile (e.g. a monitor) to a Profile Connection Space (PCS).Profiles of interest for tagging images or colors have a PCS which is one of the device independent spaces (one CIEXYZ space and two CIELab spaces) defined in the ICC Profile Format Specification.Most profiles of interest either have invertible transformations or explicitly specify transformations going both directions.Should an ICC_ColorSpace object be used in a way requiring a conversion from PCS to the profile's native space and there is inadequate data to correctly perform the conversion, the ICC_ColorSpace object will produce output in the specified type of color space (e.g. TYPE_RGB, TYPE_CMYK, etc.), but the specific color values of the output data will be undefined.The details of this class are not important for simple applets, which draw in a default color space or manipulate and display imported images with a known color space.At most, such applets would need to get one of the default color spaces via ColorSpace.getInstance()."},
{"description": "The ICC_ProfileRGB class is a subclass of the ICC_Profile class that represents profiles which meet the following criteria: The profile's color space type is RGB.The profile includes the redColorantTag, greenColorantTag, blueColorantTag, redTRCTag, greenTRCTag, blueTRCTag, and mediaWhitePointTag tags.The ICC_Profile getInstance method will return an ICC_ProfileRGB object when these conditions are met.Three-component, matrix-based input profiles and RGB display profiles are examples of this type of profile.This profile class provides color transform matrices and lookup tables that Java or native methods can use directly to optimize color conversion in some cases.To transform from a device profile color space to the CIEXYZ Profile Connection Space, each device color component is first linearized by a lookup through the corresponding tone reproduction curve (TRC).The resulting linear RGB components are converted to the CIEXYZ PCS using a a 3x3 matrix constructed from the RGB colorants. \u00a0 The inverse transform is performed by converting PCS XYZ components to linear RGB components through the inverse of the above 3x3 matrix, and then converting linear RGB to device RGB through inverses of the TRCs."},
{"description": "Each HttpURLConnection instance is used to make a single request but the underlying network connection to the HTTP server may be transparently shared by other instances.Calling the close() methods on the InputStream or OutputStream of an HttpURLConnection after a request may free network resources associated with this instance but has no effect on any shared persistent connection.Calling the disconnect() method may close the underlying socket if a persistent connection is otherwise idle at that time.The HTTP protocol handler has a few settings that can be accessed through System Properties.This covers Proxy settings as well as various other settings.Security permissions If a security manager is installed, and if a method is called which results in an attempt to open a connection, the caller must possess either:-a \"connect\" SocketPermission to the host/port combination of the destination URL or a URLPermission that permits this request.If automatic redirection is enabled, and this request is redirected to another destination, then the caller must also have permission to connect to the redirected host/URL."},
{"description": "HyperlinkEvent is used to notify interested parties that something has happened with respect to a hypertext link.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "HttpsURLConnection extends HttpURLConnection with support for https-specific features.This class uses HostnameVerifier and SSLSocketFactory.There are default implementations defined for both classes.However, the implementations can be replaced on a per-class (static) or per-instance basis.All new HttpsURLConnections instances will be assigned the \"default\" static values at instance creation, but they can be overriden by calling the appropriate per-instance set method(s) before connecting."},
{"description": "This class encapsulates a HTTP request received and a response to be generated in one exchange.It provides methods for examining the request from the client, and for building and sending the response.A HttpExchange must be closed to free or reuse underlying resources.The effect of failing to close an exchange is undefined."},
{"description": "A handler which is invoked to process HTTP requests.JAX-WS runtime provides the implementation for this and sets it using HttpContext.setHandler(HttpHandler) during Endpoint.publish(HttpContext)"},
{"description": "The HTTPException exception represents a XML/HTTP fault.Since there is no standard format for faults or exceptions in XML/HTTP messaging, only the HTTP status code is captured."},
{"description": "The HTTPBinding interface is an abstraction for the XML/HTTP binding."},
{"description": "HttpContext represents a mapping between the root URI path of a web service to a HttpHandler which is invoked to handle requests destined for that path on the associated container.Container provides the implementation for this and it matches web service requests to corresponding HttpContext objects."},
{"description": "This is a writer for HTMLDocuments."},
{"description": "Interface to be supported by the parser.This enables providing a different parser while reusing some of the implementation provided by this editor kit."},
{"description": "HTMLFrameHyperlinkEvent is used to notify interested parties that link was activated in a frame."},
{"description": "The result of parsing drives these callback methods.The flush method will be the last method called, to give the receiver a chance to flush any pending data into the document."},
{"description": "An HttpCookie object represents an HTTP cookie, which carries state information between server and user agent.Cookie is widely adopted to create stateful sessions.There are 3 HTTP cookie specifications: Netscape draft RFC 2109 - http://www.ietf.org/rfc/rfc2109.txt RFC 2965- http://www.ietf.org/rfc/rfc2965.txt HttpCookie class can accept all these 3 forms of syntax."},
{"description": "The second tag, addTag, identifies the first tag that should be added to the document as seen in the HTML string.One important thing to remember, is that the parser is going to generate all the appropriate tags, even if they aren't in the HTML string passed in.For example, lets say you wanted to create an action to insert a table into the body.The parentTag would be HTML.Tag.BODY, addTag would be HTML.Tag.TABLE, and the string could be something like <table><tr><td></td></tr></table>.There is also an option to supply an alternate parentTag and addTag.These will be checked for if there is no parentTag at offset."},
{"description": "An abstract Action providing some convenience methods that may be useful in inserting HTML into an existing document.NOTE: None of the convenience methods obtain a lock on the document.If you have another thread modifying the text these methods may have inconsistent behavior, or return the wrong thing."},
{"description": "The Swing JEditorPane text component supports different kinds of content via a plug-in mechanism called an EditorKit.Because HTML is a very popular format of content, some support is provided by default.The default support is provided by this class, which supports HTML version 3.2 (with some extensions), and is migrating toward version 4.0.The <applet> tag is not supported, but some support is provided for the <object> tag.There are several goals of the HTML EditorKit provided, that have an effect upon the way that HTML is modeled.These have influenced its design in a substantial way.Support editing It might seem fairly obvious that a plug-in for JEditorPane should provide editing support, but that fact has several design considerations.There are a substantial number of HTML documents that don't properly conform to an HTML specification.These must be normalized somewhat into a correct form if one is to edit them.Additionally, users don't like to be presented with an excessive amount of structure editing, so using traditional text editing gestures is preferred over using the HTML structure exactly as defined in the HTML document.The modeling of HTML is provided by the class HTMLDocument.Its documentation describes the details of how the HTML is modeled.The editing support leverages heavily off of the text package.To maximize the usefulness of this kit, a great deal of effort has gone into making it extendable.These are some of the features.The default parser is the Hot Java parser which is DTD based.The default parser is in a separate package called parser below this package.The parser drives the ParserCallback, which is provided by HTMLDocument.To change the callback, subclass HTMLDocument and reimplement the createDefaultDocument method to return document that produces a different reader.Although the Document provides HTML support by default, there is nothing preventing support of non-HTML tags that result in alternative element structures.The default view of the models are provided as a hierarchy of View implementations, so one can easily customize how a particular element is displayed or add capabilities for new kinds of elements by providing new View implementations.The default set of views are provided by the HTMLFactory class.This can be easily changed by subclassing or replacing the HTMLFactory and reimplementing the getViewFactory method to return the alternative factory.The View implementations work primarily off of CSS attributes, which are kept in the views.This makes it possible to have multiple views mapped over the same model that appear substantially different.This can be especially useful for printing.For most HTML attributes, the HTML attributes are converted to CSS attributes for display.This helps make the View implementations more general purpose Asynchronous Loading Larger documents involve a lot of parsing and take some time to load.By default, this kit produces documents that will be loaded asynchronously if loaded using JEditorPane.setPage.This is controlled by a property on the document.The method createDefaultDocument can be overriden to change this.The batching of work is done by the HTMLDocument.The actual work is done by the DefaultStyledDocument and AbstractDocument classes in the text package.Customization from current LAF HTML provides a well known set of features without exactly specifying the display characteristics.Swing has a theme mechanism for its look-and-feel implementations.It is desirable for the look-and-feel to feed display characteristics into the HTML views.An user with poor vision for example would want high contrast and larger than typical fonts.The support for this is provided by the StyleSheet class.The presentation of the HTML can be heavily influenced by the setting of the StyleSheet property on the EditorKit.Not lossy An EditorKit has the ability to be read and save documents.It is generally the most pleasing to users if there is no loss of data between the two operation.The policy of the HTMLEditorKit will be to store things not recognized or not necessarily visible so they can be subsequently written out.The model of the HTML document should therefore contain all information discovered while reading the document.This is constrained in some ways by the need to support editing (i.e. incorrect documents sometimes must be normalized).The guiding principle is that information shouldn't be lost, but some might be synthesized to produce a more correct model or it might be rearranged."},
{"description": "The following table describes what this factory will build by default.TagView created HTML.Tag."},
{"description": "If reliable access to the document is not already ensured by the context under which the iterator is being used, its use should be performed under the protection of Document.render."},
{"description": "A document that models HTML.The purpose of this model is to support both browsing and editing.As a result, the structure described by an HTML document is not exactly replicated by default.The element structure that is modeled by default, is built by the class HTMLDocument.HTMLReader, which implements the HTMLEditorKit.To change the structure one can subclass HTMLReader, and reimplement the method getReader(int) to return the new reader implementation.The documentation for HTMLReader should be consulted for the details of the default structure created.The intent is that the document be non-lossy (although reproducing the HTML format may result in a different format).The elements are identified by the StyleContext.NameAttribute attribute, which should always have a value of type HTML.Tag that identifies the kind of element.Some of the elements (such as comments) are synthesized.The HTMLFactory uses this attribute to determine what kind of view to build.This document supports incremental loading.The TokenThreshold property controls how much of the parse is buffered before trying to update the element structure of the document.This property is set by the EditorKit so that subclasses can disable it.The Base property determines the URL against which relative URLs are resolved.By default, this will be the Document.if the value of the property is a URL.If a <BASE> tag is encountered, the base will become the URL specified by that tag.Because the base URL is a property, it can of course be set directly.The default content storage mechanism for this document is a gap buffer (GapContent).Alternatives can be supplied by using the constructor that takes a Content implementation.In addition to the methods provided by Document and StyledDocument for mutating an HTMLDocument, HTMLDocument provides a number of convenience methods.The following methods can be used to insert HTML content into an existing document.The following examples illustrate using these methods.Each example assumes the HTML document is initialized in the following way:> <body> <div id=\"BOX\"All the methods for modifying an HTML document require an Element.Elements can be obtained from an HTML document by using the method getElement(Element e, Object attribute, Object value).It returns the first descendant element that contains the specified attribute with the given value, in depth-first order.P) returns the first paragraph element.A convenient shortcut for locating elements is the method getElement(String); returns an element whose ID attribute matches the specified value.For example, d.getElement(\"BOX\") returns the DIV element.method can also be used for finding all occurrences of the specified HTML tag in the document.Inserting elements Elements can be inserted before or after the existing children of any non-leaf element by using the methods insertAfterStart and insertBeforeEnd.For example, if e is the DIV element, d.insertAfterStart(e, \"<ul><li>List Item</li></ul>\") inserts the list before the first paragraph, and d.insertBeforeEnd(e, \"<ul><li>List Item</li></ul>\") inserts the list after the last paragraph.The DIV block becomes the parent of the newly inserted elements.Sibling elements can be inserted before or after any element by using the methods insertBeforeStart and insertAfterEnd.For example, if e is the DIV element, d.insertBeforeStart(e, \"<ul><li>List Item</li></ul>\") inserts the list before the DIV element, and d.insertAfterEnd(e, \"<ul><li>List Item</li></ul>\") inserts the list after the DIV element.The newly inserted elements become siblings of the DIV element.Replacing elements Elements and all their descendants can be replaced by using the methods setInnerHTML and setOuterHTML.For example, if e is the DIV element, d.setInnerHTML(e, \"<ul><li>List Item</li></ul>\") replaces all children paragraphs with the list, and d.setOuterHTML(e,\"<ul><li>List Item</li></ul>\") replaces the DIV element itself.In latter case the parent of the list is the BODY element.The following table shows the example document and the results of various methods described above.Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Although the set of HTML tags is a closed set, we have left the set open so that people can add their own tag types to their custom parser and still communicate to the reader."},
{"description": "This class is the base interface for hostname verification.During handshaking, if the URL's hostname and the server's identification hostname mismatch, the verification mechanism can call back to implementers of this interface to determine if this connection should be allowed.The policies can be certificate-based or may depend on other authentication schemes.These callbacks are used when the default rules for URL hostname verification fail."},
{"description": "These are basically tag and attribute definitions."},
{"description": "The parameters include an optional output length which specifies the MAC truncation length in bits.The resulting HMAC will be truncated to the specified number of bits.If the parameter is not specified, then this implies that all the bits of the hash are to be output.The XML Schema Definition of the HMACOutputLength element is defined as: <element"},
{"description": "The Hijrah calendar system has only one era covering the proleptic years greater than zero."},
{"description": "The Hijrah calendar is a lunar calendar supporting Islamic calendars.The HijrahChronology follows the rules of the Hijrah calendar system.The Hijrah calendar has several variants based on differences in when the new moon is determined to have occurred and where the observation is made.In some variants the length of each month is computed algorithmically from the astronomical data for the moon and earth and in others the length of the month is determined by an authorized sighting of the new moon.For the algorithmically based calendars the calendar can project into the future.For sighting based calendars only historical data from past sightings is available.The length of each month is 29 or 30 days.Ordinary years have 354 days; leap years have 355 days.CLDR and LDML identify variants: Chronology ID Calendar Type Locale extension, see Locale Description Hijrah-umalqura islamic-umalqura ca-islamic-umalqura Islamic - Umm Al-Qura calendar of Saudi Arabia Additional variants may be available through Chronology.getAvailableChronologies().Example Selecting the chronology from the locale uses Chronology.ofLocale(java.util.Locale) to find the Chronology based on Locale supported BCP 47 extension mechanism to request a specific calendar (\"ca\")."},
{"description": "This date operates using one of several variants of the Hijrah calendar.The Hijrah calendar has a different total of days in a year than Gregorian calendar, and the length of each month is based on the period of a complete revolution of the moon around the earth (as between successive new moons).Each HijrahDate is created bound to a particular HijrahChronology, The same chronology is propagated to each HijrahDate computed from the date.To use a different Hijrah variant, its HijrahChronology can be used to create new HijrahDate instances.) method can be used to convert to a new HijrahChronology.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of HijrahDate may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "The listener interface for receiving hierarchy changed events.The class that is interested in processing a hierarchy changed event should implement this interface.The listener object created from that class is then registered with a Component using the Component's addHierarchyListener method.When the hierarchy to which the Component belongs changes, the hierarchyChanged method in the listener object is invoked, and the HierarchyEvent is passed to it.Hierarchy events are provided for notification purposes ONLY; The AWT will automatically handle changes to the hierarchy internally so that GUI layout, displayability, and visibility work properly regardless of whether a program registers a HierarchyListener or not."},
{"description": "An interface for an object that allows one to mark up the background with colored areas."},
{"description": "An event which indicates a change to the Component hierarchy to which Component belongs.Hierarchy Change Events (HierarchyListener) addition of an ancestor removal of an ancestor hierarchy made displayable hierarchy made undisplayable hierarchy shown on the screen (both visible and displayable) hierarchy hidden on the screen (either invisible or undisplayable)an ancestor was resized an ancestor was moved Hierarchy events are provided for notification purposes ONLY.The AWT will automatically handle changes to the hierarchy internally so that GUI layout and displayability works properly regardless of whether a program is receiving these events or not.This event is generated by a Container object (such as a Panel) when the Container is added, removed, moved, or resized, and passed down the hierarchy.It is also generated by a Component object when that object's addNotify, removeNotify, show, or hide method is called.The ANCESTOR_MOVED and ANCESTOR_RESIZED events are dispatched to every HierarchyBoundsListener or HierarchyBoundsAdapter object which registered to receive such events using the Component's addHierarchyBoundsListener method.(HierarchyBoundsAdapter objects implement the HierarchyBoundsListener interface.)The HIERARCHY_CHANGED events are dispatched to every HierarchyListener object which registered to receive such events using the Component's addHierarchyListener method.Each such listener object gets this HierarchyEvent when the event occurs.An unspecified behavior will be caused if the id parameter of any particular HierarchyEvent instance is not in the range from HIERARCHY_FIRST to HIERARCHY_LAST.The changeFlags parameter of any HierarchyEvent instance takes one of the following values: HierarchyEvent.Assigning the value different from listed above will cause unspecified behavior."},
{"description": "The listener interface for receiving ancestor moved and resized events.The class that is interested in processing these events either implements this interface (and all the methods it contains) or extends the abstract HierarchyBoundsAdapter class (overriding only the method of interest).The listener object created from that class is then registered with a Component using the Component's addHierarchyBoundsListener method.When the hierarchy to which the Component belongs changes by the resizing or movement of an ancestor, the relevant method in the listener object is invoked, and the HierarchyEvent is passed to it.Hierarchy events are provided for notification purposes ONLY; The AWT will automatically handle changes to the hierarchy internally so that GUI layout works properly regardless of whether a program registers an HierarchyBoundsListener or not."},
{"description": "This class implements the Set interface, backed by a hash table (actually a HashMap instance).It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time.This class permits the null element.This class offers constant time performance for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets.Iterating over this set requires time proportional to the sum of the HashSet instance's size (the number of elements) plus the \"capacity\" of the backing HashMap instance (the number of buckets).Thus, it's very important not to set the initial capacity too high (or the load factor too low)If multiple threads access a hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally.This is typically accomplished by synchronizing on some object that naturally encapsulates the set.If no such object exists, the set should be \"wrapped\" using the Collections.synchronizedSet method.This is best done at creation time, to prevent accidental unsynchronized access to the set:Set s = Collections.synchronizedSet(new HashSet(...)); The iterators returned by this class's iterator method are fail-fast:if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the Iterator throws a ConcurrentModificationException.Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast iterators throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.This class is a member of the Java Collections Framework."},
{"description": "This class implements a hash table, which maps keys to values.Any non-null object can be used as a key or as a value.To successfully store and retrieve objects from a hashtable, the objects used as keys must implement the hashCode method and the equals method.An instance of Hashtable has two parameters that affect its performance: initial capacity and load factor.The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created.Note that the hash table is open: in the case of a \"hash collision\", a single bucket stores multiple entries, which must be searched sequentially.The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased.The initial capacity and load factor parameters are merely hints to the implementation.Generally, the default load factor (.75) offers a good tradeoff between time and space costs.Higher values decrease the space overhead but increase the time cost to look up an entry (which is reflected in most Hashtable operations, including get and put).The initial capacity controls a tradeoff between wasted space and the need for rehash operations, which are time-consuming.No rehash operations will ever occur if the initial capacity is greater than the maximum number of entries the Hashtable will contain divided by its load factor.However, setting the initial capacity too high can waste space.If many entries are to be made into a Hashtable, creating it with a sufficiently large capacity may allow the entries to be inserted more efficiently than letting it perform automatic rehashing as needed to grow the table.This example creates a hashtable of numbers.It uses the names of the numbers as keys: Hashtable<String, Integer> numbers = new Hashtable<String, Integer>();+ n); } The iterators returned by the iterator method of the collections returned by all of this class's \"collection view methods\" are fail-fast: if the Hashtable is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException.Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.The Enumerations returned by Hashtable's keys and elements methods are not fail-fast.Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast iterators throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.As of the Java 2 platform v1.2, this class was retrofitted to implement the Map interface, making it a member of the Java Collections Framework.Unlike the new collection implementations, Hashtable is synchronized.If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable.If a thread-safe highly-concurrent implementation is desired, then it is recommended to use ConcurrentHashMap in place of Hashtable."},
{"description": "Class HashPrintServiceAttributeSet provides an attribute set which inherits its implementation from class HashAttributeSet and enforces the semantic restrictions of interface PrintServiceAttributeSet."},
{"description": "Class HashPrintRequestAttributeSet inherits its implementation from class HashAttributeSet and enforces the semantic restrictions of interface PrintRequestAttributeSet."},
{"description": "Thrown when code that is dependent on a keyboard, display, or mouse is called in an environment that does not support a keyboard, display, or mouse."},
{"description": "This XmlAdapter binds byte[] to the hexBinary representation in XML."},
{"description": "An abstract adapter class for receiving ancestor moved and resized events.The methods in this class are empty.This class exists as a convenience for creating listener objects.(If you implement the HierarchyBoundsListener interface, you have to define both methods in it.This abstract class defines null methods for them both, so you only have to define the method for the event you care about.)When the hierarchy to which the Component belongs changes by resize or movement of an ancestor, the relevant method in the listener object is invoked, and the HierarchyEvent is passed to it."},
{"description": "Class HashPrintJobAttributeSet provides an attribute set which inherits its implementation from class HashAttributeSet and enforces the semantic restrictions of interface PrintJobAttributeSet."},
{"description": "This implementation provides all of the optional map operations, and permits null values and the null key.(The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.)This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets.Iteration over collection views requires time proportional to the \"capacity\" of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings).Thus, it's very important not to set the initial capacity too high (or the load factor too low)An instance of HashMap has two parameters that affect its performance: initial capacity and load factor.The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created.The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased.When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt)so that the hash table has approximately twice the number of buckets.As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs.Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put).The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations.If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.If many mappings are to be stored in a HashMap instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table.Note that using many keys with the same hashCode() is a sure way to slow down performance of any hash table.To ameliorate impact, when keys are Comparable, this class may use comparison order among keys to help break ties.If multiple threads access a hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally.(A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with a key that an instance already contains is not a structural modification.)This is typically accomplished by synchronizing on some object that naturally encapsulates the map.If no such object exists, the map should be \"wrapped\" using the Collections.synchronizedMap method.This is best done at creation time, to prevent accidental unsynchronized access to the map: Map m = Collections.synchronizedMap(new HashMap(...)); The iterators returned by all of this class's \"collection view methods\" are fail-fast:if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException.Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast iterators throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.This class is a member of the Java Collections Framework."},
{"description": "Class HashAttributeSet provides an AttributeSet implementation with characteristics of a hash map."},
{"description": "This interface is for returning controls with objects returned in NamingEnumerations.For example, suppose a server sends back controls with the results of a search operation, the service provider would return a NamingEnumeration of objects that are both SearchResult and implement HasControls.while (elts.hasMore()) { Object entry = elts.next(); // Get search result SearchResult res =Get entry controls if (entry instanceof HasControls)"},
{"description": "Class HashDocAttributeSet provides an attribute set which inherits its implementation from class HashAttributeSet and enforces the semantic restrictions of interface DocAttributeSet."},
{"description": "This interface is implemented by any class which wants to receive notifications about the completion of an SSL protocol handshake on a given SSL connection.When an SSL handshake completes, new security parameters will have been established.Those parameters always include the security keys used to protect messages.They may also include parameters associated with a new session such as authenticated peer identity and a new SSL cipher suite."},
{"description": "This event indicates that an SSL handshake completed on a given SSL connection.All of the core information about that handshake's result is captured through an \"SSLSession\" object.As a convenience, this event class provides direct access to some important session attributes.The source of this event is the SSLSocket on which handshaking just completed."},
{"description": "HandlerResolver is an interface implemented by an application to get control over the handler chain set on proxy/dispatch objects at the time of their creation.A HandlerResolver may be set on a Service using the setHandlerResolver method.When the runtime invokes a HandlerResolver, it will pass it a PortInfo object containing information about the port that the proxy/dispatch object will be accessing."},
{"description": "This class works with the deprecated DocumentHandler interface.It has been replaced by the SAX2 DefaultHandler class."},
{"description": "The Handler interface is the base interface for JAX-WS handlers."},
{"description": "A Handler object takes log messages from a Logger and exports them.It might for example, write them to a console or write them to a file, or send them to a network logging service, or forward them to an OS log, or whatever.A Handler can be disabled by doing a setLevel(Level.Handler classes typically use LogManager properties to set default values for the Handler's Filter, Formatter, and Level."},
{"description": "This interface represents a guard, which is an object that is used to protect access to another object.This interface contains a single method, checkGuard, with a single object argument.checkGuard is invoked (by the GuardedObject getObject method) to determine whether or not to allow access to the object."},
{"description": "This class implements a stream filter for reading compressed data in the GZIP file format."},
{"description": "A GuardedObject is an object that is used to protect access to another object.A GuardedObject encapsulates a target object and a Guard object, such that access to the target object is possible only if the Guard object allows it.Once an object is encapsulated by a GuardedObject, access to that object is controlled by the getObject method, which invokes the checkGuard method on the Guard object that is guarding access."},
{"description": "This class implements a stream filter for writing compressed data in the GZIP file format."},
{"description": "This interface encapsulates a single GSS-API principal entity.The application obtains an implementation of this interface through one of the createName methods that exist in the GSSManager class.Conceptually a GSSName contains many representations of the entity or many primitive name elements, one for each supported underlying mechanism.In GSS terminology, a GSSName that contains an element from just one mechanism is called a Mechanism Name (MN)Since different authentication mechanisms may employ different namespaces for identifying their principals, GSS-API's naming support is necessarily complex in multi-mechanism environments (or even in some single-mechanism environments where the underlying mechanism supports multiple namespaces).Different name formats and their definitions are identified with Oid's and some standard types are defined in this interface.The format of the names can be derived based on the unique Oid of its name type.The code below creates a GSSName, converts it to an MN, performs a comparison, obtains a printable representation of the name, exports it to a byte array and then re-imports to obtain a new GSSName.Oid krb5 = new Oid(\"1.2.840.113554.1.2.2\"); GSSName mechName = name.canonicalize(krb5); // the above two steps are equivalent to the following GSSName mechName = manager.createName(\"service@host\", GSSName."},
{"description": "Enumeration of the possible ways ParallelGroup can align its children."},
{"description": "This interface encapsulates the GSS-API security context and provides the security services that are available over the context.Security contexts are established between peers using locally acquired credentials.Multiple contexts may exist simultaneously between a pair of peers, using the same or different set of credentials.GSS-API functions in a manner independent of the underlying transport protocol and depends on its calling application to transport the tokens that are generated by the security context between the peers.If the caller instantiates the context using the default GSSManager instance, then the Kerberos v5 GSS-API mechanism is guaranteed to be available for context establishment.This mechanism is identified by the Oid \"1.2.840.113554.1.2.2\" and is defined in RFC 1964.Before the context establishment phase is initiated, the context initiator may request specific characteristics desired of the established context.Not all underlying mechanisms support all characteristics that a caller might desire.After the context is established, the caller can check the actual characteristics and services offered by that context by means of various query methods.When using the Kerberos v5 GSS-API mechanism offered by the default GSSManager instance, all optional services will be available locally.They are mutual authentication, credential delegation, confidentiality and integrity protection, and per-message replay detection and sequencing.Note that in the GSS-API, message integrity is a prerequisite for message confidentiality.The context establishment occurs in a loop where the initiator calls initSecContext and the acceptor calls acceptSecContext until the context is established.While in this loop the initSecContext and acceptSecContext methods produce tokens that the application sends over to the peer.The peer passes any such token as input to its acceptSecContext or initSecContext as the case may be.During the context establishment phase, the isProtReady method may be called to determine if the context can be used for the per-message operations of wrap and getMIC.This allows applications to use per-message operations on contexts which aren't yet fully established.After the context has been established or the isProtReady method returns true, the query routines can be invoked to determine the actual characteristics and services of the established context.The application can also start using the per-message methods of wrap and getMIC to obtain cryptographic operations on application supplied data.When the context is no longer needed, the application should call dispose to release any system resources the context may be using.A security context typically maintains sequencing and replay detection information about the tokens it processes.Therefore, the sequence in which any tokens are presented to this context for processing can be important.Also note that none of the methods in this interface are synchronized.Therefore, it is not advisable to share a GSSContext among several threads unless some application level synchronization is in place.Finally, different mechanism providers might place different security restrictions on using GSS-API contexts.These will be documented by the mechanism provider.The application will need to ensure that it has the appropriate permissions if such checks are made in the mechanism layer.The example code presented below demonstrates the usage of the GSSContext interface for the initiating peer.Different operations on the GSSContext object are presented, including: object instantiation, setting of desired flags, context establishment, query of actual context flags, per-message operations on application data, and finally context deletion.INDEFINITE_LIFETIME); // set desired context options prior to context establishment context.requestConf(true); context.requestMutualAuth(true); context.requestReplayDet(true); context.requestSequenceDet(true); // establish a context between peers byte []inToken = new byte[0]; // Loop while there still is a token to be processed while (!context.isEstablished()) { byte[]"},
{"description": "A UserPrincipal representing a group identity, used to determine access rights to objects in a file system.The exact definition of a group is implementation specific, but typically, it represents an identity created for administrative purposes so as to determine the access rights for the members of the group.Whether an entity can be a member of multiple groups, and whether groups can be nested, are implementation specified and therefore not specified."},
{"description": "This exception is thrown whenever a GSS-API error occurs, including any mechanism specific error.It may contain both the major and the minor GSS-API status codes.Major error codes are those defined at the GSS-API level in this class.Minor error codes are mechanism specific error codes that can provide additional information.The underlying mechanism implementation is responsible for setting appropriate minor status codes when throwing this exception.Aside from delivering the numeric error codes to the caller, this class performs the mapping from their numeric values to textual representations."},
{"description": "This class serves as a factory for other important GSS-API classes and also provides information about the mechanisms that are supported.It can create instances of classes implementing the following three GSS-API interfaces: GSSName, GSSCredential, and GSSContext.It also has methods to query for the list of available mechanisms and the nametypes that each mechanism supports.An instance of the default GSSManager subclass may be obtained through the static method getInstance, but applications are free to instantiate other subclasses of GSSManager.The default GSSManager instance will support the Kerberos v5 GSS-API mechanism in addition to any others.This mechanism is identified by the Oid \"1.2.840.113554.1.2.2\" and is defined in RFC 1964.A subclass extending the GSSManager abstract class may be implemented as a modular provider based layer that utilizes some well known service provider specification.The GSSManager API allows the application to set provider preferences on such an implementation.These methods also allow the implementation to throw a well-defined exception in case provider based configuration is not supported.Applications that expect to be portable should be aware of this and recover cleanly by catching the exception.It is envisioned that there will be three most common ways in which providers will be used: The application does not care about what provider is used (the default case).The application wants a particular provider to be used preferentially, either for a particular mechanism or all the time, irrespective of mechanism.The application wants to use the locally configured providers as far as possible but if support is missing for one or more mechanisms then it wants to fall back on its own provider.The GSSManager class has two methods that enable these modes of usage: addProviderAtFront and addProviderAtEnd.These methods have the effect of creating an ordered list of <provider, oid> pairs where each pair indicates a preference of provider for a given oid.It is important to note that there are certain interactions between the different GSS-API objects that are created by a GSSManager, where the provider that is used for a particular mechanism might need to be consistent across all objects.For instance, if a GSSCredential contains elements from a provider p for a mechanism m, it should generally be passed in to a GSSContext that will use provider p for the mechanism m.A simple rule of thumb that will maximize portability is that objects created from different GSSManager's should not be mixed, and if possible, a different GSSManager instance should be created if the application wants to invoke the addProviderAtFront method on a GSSManager that has already created an object.(); Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\"); Oid krb5PrincipalNameType = new Oid(\"1.2.840.113554.1.2.2.1\"); // Identify who the client wishes to be GSSName userName = manager.createName(\"duke\", GSSName.This uses a Kerberos specific // name format.Instantiate and initialize a security context that will be // established with the server GSSContext context = manager.createContext(serverName, krb5Mechanism, userCreds, GSSContext.DEFAULT_LIFETIME); The server side might use the following variation of this source: //Instantiate and initialize a security context that will // wait for an establishment request token from the client GSSContext context ="},
{"description": "This interface encapsulates the GSS-API credentials for an entity.A credential contains all the necessary cryptographic information to enable the creation of a context on behalf of the entity that it represents.It may contain multiple, distinct, mechanism specific credential elements, each containing information for a specific security mechanism, but all referring to the same entity.A credential may be used to perform context initiation, acceptance, or both.Credentials are instantiated using one of the createCredential methods in the GSSManager class.GSS-API credential creation is not intended to provide a \"login to the network\" function, as such a function would involve the creation of new credentials rather than merely acquiring a handle to existing credentials.The section on credential acquisition in the package level description describes how existing credentials are acquired in the Java platform.GSS-API implementations must impose a local access-control policy on callers to prevent unauthorized callers from acquiring credentials to which they are not entitled.Applications will create a credential object passing the desired parameters.The application can then use the query methods to obtain specific information about the instantiated credential object.When the credential is no longer needed, the application should call the dispose method to release any resources held by the credential object and to destroy any cryptographically sensitive information.This example code demonstrates the creation of a GSSCredential implementation for a specific entity, querying of its fields, and its release when it is no longer needed: GSSManager manager = GSSManager.getInstance; // display credential information - name, remaining lifetime, // and the mechanisms it has been acquired over System.out.println(cred.getName().toString()); System.out.println(cred.getRemainingLifetime());"},
{"description": "GroupLayout is a LayoutManager that hierarchically groups components in order to position them in a Container.GroupLayout is intended for use by builders, but may be hand-coded as well.Grouping is done by instances of the Group class.GroupLayout supports two types of groups.A sequential group positions its child elements sequentially, one after another.A parallel group aligns its child elements in one of four ways.Each group may contain any number of elements, where an element is a Group, Component, or gap.A gap can be thought of as an invisible component with a minimum, preferred and maximum size.In addition GroupLayout supports a preferred gap, whose value comes from LayoutStyle.Elements are similar to a spring.Each element has a range as specified by a minimum, preferred and maximum.Gaps have either a developer-specified range, or a range determined by LayoutStyle.The range for Components is determined from the Component's getMinimumSize, getPreferredSize and getMaximumSize methods.In addition, when adding Components you may specify a particular range to use instead of that from the component.The range for a Group is determined by the type of group.A ParallelGroup's range is the maximum of the ranges of its elements.A SequentialGroup's range is the sum of the ranges of its elements.GroupLayout treats each axis independently.That is, there is a group representing the horizontal axis, and a group representing the vertical axis.The horizontal group is responsible for determining the minimum, preferred and maximum size along the horizontal axis as well as setting the x and width of the components contained in it.The vertical group is responsible for determining the minimum, preferred and maximum size along the vertical axis as well as setting the y and height of the components contained in it.Each Component must exist in both a horizontal and vertical group, otherwise an IllegalStateException is thrown during layout, or when the minimum, preferred or maximum size is requested.The following diagram shows a sequential group along the horizontal axis.The sequential group contains three components.A parallel group was used along the vertical axis.To reinforce that each axis is treated independently the diagram shows the range of each group and element along each axis.The range of each component has been projected onto the axes, and the groups are rendered in blue (horizontal) and red (vertical).For readability there is a gap between each of the elements in the sequential group.The sequential group along the horizontal axis is rendered as a solid blue line.Notice the sequential group is the sum of the children elements it contains.Along the vertical axis the parallel group is the maximum of the height of each of the components.As all three components have the same height, the parallel group has the same height.The following diagram shows the same three components, but with the parallel group along the horizontal axis and the sequential group along the vertical axis.As c1 is the largest of the three components, the parallel group is sized to c1.As c2 and c3 are smaller than c1 they are aligned based on the alignment specified for the component (if specified) or the default alignment of the parallel group.If the component orientation were right-to-left then c2 and c3 would be positioned on the opposite side.The following diagram shows a sequential group along both the horizontal and vertical axis.GroupLayout provides the ability to insert gaps between Components.The size of the gap is determined by an instance of LayoutStyle.This may be turned on using the setAutoCreateGaps method.Similarly, you may use the setAutoCreateContainerGaps method to insert gaps between components that touch the edge of the parent container and the container.The following builds a panel consisting of two labels in one column, followed by two textfields in the next column:// Turn on automatically adding gaps between components layout.setAutoCreateGaps(true); // Turn on automatically creating gaps between components that touch //// The sequential group in turn contains two parallel groups.One parallel group contains the labels, the other the text fields.Variable indentation is used to reinforce the level of grouping.// The sequential group contains two parallel groups that align //By using a sequential group // the labels and text fields are positioned vertically after one another.addComponent(label2).addComponent(tf2)); layout.setVerticalGroup(vGroup); When run the following is produced.This layout consists of the following.The horizontal axis consists of a sequential group containing two parallel groups.The first parallel group contains the labels, and the second parallel group contains the text fields.The vertical axis consists of a sequential group containing two parallel groups.The parallel groups are configured to align their components along the baseline.The first parallel group contains the first label and first text field, and the second group consists of the second label and second text field.There are a couple of things to notice in this code: You need not explicitly add the components to the container; this is indirectly done by using one of the add methods of Group.The various add methods return the caller.This allows for easy chaining of invocations.There are no public constructors for Groups; instead use the create methods of GroupLayout."},
{"description": "This interface is used to represent a group of principals.(A principal represents an entity such as an individual user or a company).Note that Group extends Principal.Thus, either a Principal or a Group can be passed as an argument to methods containing a Principal parameter.For example, you can add either a Principal or a Group to a Group object by calling the object's addMember method, passing it the Principal or Group."},
{"description": "The GridLayout class is a layout manager that lays out a container's components in a rectangular grid.The container is divided into equal-sized rectangles, and one component is placed in each rectangle.For example, the following is an applet that lays out six buttons into three rows and two columns: import java.awt.*; import java.applet.Applet; public class ButtonGrid extends Applet { public void init() { setLayout(newadd(new Button(\"6\")); } } If the container's ComponentOrientation property is horizontal and left-to-right, the above example produces the output shown in Figure 1.If the container's ComponentOrientation property is horizontal and right-to-left, the example produces the output shown in Figure 2.When both the number of rows and the number of columns have been set to non-zero values, either by a constructor or by the setRows and setColumns methods, the number of columns specified is ignored.Instead, the number of columns is determined from the specified number of rows and the total number of components in the layout.So, for example, if three rows and two columns have been specified and nine components are added to the layout, they will be displayed as three rows of three columns.Specifying the number of columns affects the layout only when the number of rows is set to zero."},
{"description": "The GridBagConstraints class specifies constraints for components that are laid out using the GridBagLayout class."},
{"description": "GregorianCalendar is a concrete subclass of Calendar and provides the standard calendar system used by most of the world.GregorianCalendar is a hybrid calendar that supports both the Julian and Gregorian calendar systems with the support of a single discontinuity, which corresponds by default to the Gregorian date when the Gregorian calendar was instituted (October 15, 1582 in some countries, later in others).The cutover date may be changed by the caller by calling setGregorianChange().Historically, in those countries which adopted the Gregorian calendar first, October 4, 1582(Julian) was thus followed by October 15, 1582 (Gregorian).This calendar models this correctly.Before the Gregorian cutover, GregorianCalendar implements the Julian calendar.The only difference between the Gregorian and the Julian calendar is the leap year rule.The Julian calendar specifies leap years every four years, whereas the Gregorian calendar omits century years which are not divisible by 400.GregorianCalendar implements proleptic Gregorian and Julian calendars.That is, dates are computed by extrapolating the current rules indefinitely far backward and forward in time.As a result, GregorianCalendar may be used for all years to generate meaningful and consistent results.However, dates obtained using GregorianCalendar are historically accurate only from March 1, 4 AD onward, when modern Julian calendar rules were adopted.Before this date, leap year rules were applied irregularly, and before 45 BC the Julian calendar did not even exist.Prior to the institution of the Gregorian calendar, New Year's Day was March 25.To avoid confusion, this calendar always uses January 1.A manual adjustment may be made if desired for dates that are prior to the Gregorian changeover and which fall between January 1 and March 24.The first week of a calendar year is the earliest seven day period starting on getFirstDayOfWeek() that contains at least getMinimalDaysInFirstWeek() days from that year.It thus depends on the values of getMinimalDaysInFirstWeek(), getFirstDayOfWeek(), and the day of the week of January 1.Weeks between week 1 of one year and week 1 of the following year (exclusive) are numbered sequentially from 2 to 52 or 53 (except for year(s) involved in the Julian-Gregorian transition).() and getMinimalDaysInFirstWeek() values are initialized using locale-dependent resources when constructing a GregorianCalendar.The week determination is compatible with the ISO 8601 standard when getFirstDayOfWeek() is MONDAY and getMinimalDaysInFirstWeek() is 4, which values are used in locales where the standard is preferred.A week year is in sync with a WEEK_OF_YEAR cycle.All weeks between the first and last weeks (inclusive) have the same week year value.Therefore, the first and last days of a week year may have different calendar year values.For example, January 1, 1998 is a Thursday.The week year is 1998 for the last three days of calendar year 1997.If, however, getFirstDayOfWeek() is SUNDAY, then week 1 of 1998 starts on January 4, 1998, and ends on January 10, 1998; the first three days of 1998 then are part of week 53 of 1997 and their week year is 1997.Week 1 of a month (the days with WEEK_OF_MONTH = 1) is the earliest set of at least getMinimalDaysInFirstWeek() contiguous days in that month, ending on the day before getFirstDayOfWeek().Unlike week 1 of a year, week 1 of a month may be shorter than 7 days, need not start on getFirstDayOfWeek(), and will not include days of the previous month.Days of a month before week 1 have a WEEK_OF_MONTH of 0.() is 4, then the first week of January 1998 is Sunday, January 4 through Saturday, January 10.These days have a WEEK_OF_MONTH of 1.Thursday, January 1 through Saturday, January 3 have a WEEK_OF_MONTH of 0.If getMinimalDaysInFirstWeek() is changed to 3, then January 1 through January 3 have a WEEK_OF_MONTH of 1.GregorianCalendar uses the following default value for each calendar field if its value is undefined.Default values are not applicable for the fields not listed above.Calendar calendar = new GregorianCalendar(pdt); Date trialTime = new Date(); calendar.setTime(trialTime); // print out a bunch of interesting things; System.out.println(\"DST_OFFSET: \" + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); System.out.println(\"Current Time, with hour reset to 3\"); calendar.clear(Calendar.HOUR_OF_DAY); //"},
{"description": "An image filter that \"disables\" an image by turning it into a grayscale image, and brightening the pixels in the image."},
{"description": "The GraphicsEnvironment class describes the collection of GraphicsDevice objects and Font objects available to a Java(tm) application on a particular platform.The resources in this GraphicsEnvironment might be local or on a remote machine.GraphicsDevice objects can be screens, printers or image buffers and are the destination of Graphics2D drawing methods.Each GraphicsDevice has a number of GraphicsConfiguration objects associated with it.These objects specify the different configurations in which the GraphicsDevice can be used."},
{"description": "The GridBagLayoutInfo is an utility class for GridBagLayout layout manager.It stores align, size and baseline parameters for every component within a container."},
{"description": "The GridBagLayout class is a flexible layout manager that aligns components vertically, horizontally or along their baseline without requiring that the components be of the same size.Each GridBagLayout object maintains a dynamic, rectangular grid of cells, with each component occupying one or more cells, called its display area.Each component managed by a GridBagLayout is associated with an instance of GridBagConstraints.The constraints object specifies where a component's display area should be located on the grid and how the component should be positioned within its display area.In addition to its constraints object, the GridBagLayout also considers each component's minimum and preferred sizes in order to determine a component's size.The overall orientation of the grid depends on the container's ComponentOrientation property.For horizontal left-to-right orientations, grid coordinate (0,0) is in the upper left corner of the container with x increasing to the right and y increasing downward.For horizontal right-to-left orientations, grid coordinate (0,0) is in the upper right corner of the container with x increasing to the left and y increasing downward.To use a grid bag layout effectively, you must customize one or more of the GridBagConstraints objects that are associated with its components.You customize a GridBagConstraints object by setting one or more of its instance variables: GridBagConstraints.gridx, GridBagConstraints.gridy Specifies the cell containing the leading corner of the component's display area, where the cell at the origin of the grid has address gridx\u00a0=\u00a00, gridy\u00a0=\u00a00.For horizontal left-to-right layout, a component's leading corner is its upper left.For horizontal right-to-left layout, a component's leading corner is its upper right.RELATIVE (the default value) to specify that the component be placed immediately following (along the x axis for gridx or the y axis for gridy) the component that was added to the container just before this component was added.The default value is 1.REMAINDER to specify that the component's display area will be from gridx to the last cell in the row (for gridwidth) or from gridy to the last cell in the column (for gridheight).RELATIVE to specify that the component's display area will be from gridx to the next to the last cell in its row (for gridwidth or from gridy to the next to the last cell in its column (for gridheight).GridBagConstraints.fill Used when the component's display area is larger than the component's requested size to determine whether (and how) to resize the component.Possible values are GridBagConstraints.HORIZONTAL (make the component wide enough to fill its display area horizontally, but don't change its height), GridBagConstraints.VERTICAL (make the component tall enough to fill its display area vertically, but don't change its width), and GridBagConstraints.BOTH (make the component fill its display area entirely).The width of the component will be at least its minimum width plus ipadx pixels.Similarly, the height of the component will be at least the minimum height plus ipady pixels.GridBagConstraints.anchor Specifies where the component should be positioned in its display area.There are three kinds of possible values: absolute, orientation-relative, and baseline-relative Orientation relative values are interpreted relative to the container's ComponentOrientation property while absolute values are not.Baseline relative values are calculated relative to the baseline.Valid values are: Absolute Values Orientation Relative Values Baseline Relative Values GridBagConstraints.GridBagConstraints.weighty Used to determine how to distribute space, which is important for specifying resizing behavior.Unless you specify a weight for at least one component in a row (weightx) and column (weighty), all the components clump together in the center of their container.This is because when the weight is zero (the default), the GridBagLayout object puts any extra space between its grid of cells and the edges of the container.Each row may have a baseline; the baseline is determined by the components in that row that have a valid baseline and are aligned along the baseline (the component's anchor value is one of BASELINE, BASELINE_LEADING or BASELINE_TRAILING).If none of the components in the row has a valid baseline, the row does not have a baseline.If a component spans rows it is aligned either to the baseline of the start row (if the baseline-resize behavior is CONSTANT_ASCENT) or the end row (if the baseline-resize behavior is CONSTANT_DESCENT).The following figure shows a baseline layout and includes a component that spans rows: This layout consists of three components: A panel that starts in row 0 and ends in row 1.The panel has a baseline-resize behavior of CONSTANT_DESCENT and has an anchor of BASELINE.As the baseline-resize behavior is CONSTANT_DESCENTthe prevailing row for the panel is row 1.Because the second button and the panel share the same prevailing row, they are both aligned along their baseline.Components positioned using one of the baseline-relative values resize differently than when positioned using an absolute or orientation-relative value.How components change is dictated by how the baseline of the prevailing row changes.The baseline is anchored to the bottom of the display area if any components with the same prevailing row have a baseline-resize behavior of CONSTANT_DESCENT, otherwise the baseline is anchored to the top of the display area.The following rules dictate the resize behavior: Resizable components positioned above the baseline can only grow as tall as the baseline.For example, if the baseline is at 100 and anchored at the top, a resizable component positioned above the baseline can never grow more than 100 units.Similarly, resizable components positioned below the baseline can only grow as high as the difference between the display height and the baseline.Resizable components positioned on the baseline with a baseline-resize behavior of OTHER are only resized if the baseline at the resized size fits within the display area.If the baseline is such that it does not fit within the display area the component is not resized.Components positioned on the baseline that do not have a baseline-resize behavior of OTHER can only grow as tall as display height - baseline + baseline of component.If you position a component along the baseline, but the component does not have a valid baseline, it will be vertically centered in its space.Similarly if you have positioned a component relative to the baseline and none of the components in the row have a valid baseline the component is vertically centered.The following figures show ten components (all buttons) managed by a grid bag layout.Figure 2 shows the layout for a horizontal, left-to-right container and Figure 3 shows the layout for a horizontal, right-to-left container.Horizontal, Right-to-Left Each of the ten components has the fill field of its associated GridBagConstraints object set to GridBagConstraints.In addition, the components have the following non-default constraints: Button1, Button2, Button3:REMAINDER Here is the code that implements the example shown above: import java.awt.*; import java.applet.Applet; public class GridBagEx1 extends Applet { protected void makebutton(String name, GridBagLayout gridbag, GridBagConstraints c) { Button button = new Button(name);//reset to the default makebutton(\"Button9\", gridbag, c); makebutton(\"Button10\", gridbag, c); setSize(300, 100); } public static void main(String args[]) { Frame f = new Frame(\"GridBag Layout Example\"); GridBagEx1 ex1 ="},
{"description": "The GraphicsDevice class describes the graphics devices that might be available in a particular graphics environment.These include screen and printer devices.Note that there can be many screens and many printers in an instance of GraphicsEnvironment.Each graphics device has one or more GraphicsConfiguration objects associated with it.These objects specify the different configurations in which the GraphicsDevice can be used.In a multi-screen environment, the GraphicsConfiguration objects can be used to render components on multiple screens.The following code sample demonstrates how to create a JFrame object for each GraphicsConfiguration on each screen device in the GraphicsEnvironment:(); for (int i=0; i < gc.length; i++) { JFrame f = new JFrame(gs[j].getDefaultConfiguration"},
{"description": "The GraphicsConfiguration class describes the characteristics of a graphics destination such as a printer or monitor.There can be many GraphicsConfiguration objects associated with a single graphics device, representing different drawing modes or capabilities.The corresponding native structure will vary from platform to platform.For example, on X11 windowing systems, each visual is a different GraphicsConfiguration.On Microsoft Windows, GraphicsConfigurations represent PixelFormats available in the current resolution and color depth.In a virtual device multi-screen environment in which the desktop area could span multiple physical screen devices, the bounds of the GraphicsConfiguration objects are relative to the virtual coordinate system.When setting the location of a component, use getBounds to get the bounds of the desired GraphicsConfiguration and offset the location with the coordinates of the GraphicsConfiguration, as the following code sample illustrates:; // where gc is a GraphicsConfiguration Rectangle bounds = gc.getBounds(); f.setLocation(10 + bounds.x, 10 + bounds.y); To determine if your environment is a virtual device environment, call getBounds on all of the GraphicsConfiguration objects in your system.If any of the origins of the returned bounds is not (0,\u00a00), your environment is a virtual device environment.You can also use getBounds to determine the bounds of the virtual device.The union is the bounds of the virtual device.The following code sample calculates the bounds of the virtual device.(); for (int i=0; i < gc.length; i++) { virtualBounds = virtualBounds.union(gc[i].getBounds()); } }"},
{"description": "The GraphicsConfigTemplate class is used to obtain a valid GraphicsConfiguration.A user instantiates one of these objects and then sets all non-default attributes as desired.The GraphicsDevice.getBestConfiguration(java.awt.GraphicsConfigTemplate) method found in the GraphicsDevice class is then called with thisA valid GraphicsConfiguration is returned that meets or exceeds what was requested in the GraphicsConfigTemplate."},
{"description": "This Graphics2D class extends the Graphics class to provide more sophisticated control over geometry, coordinate transformations, color management, and text layout.This is the fundamental class for rendering 2-dimensional shapes, text and images on the Java(tm) platform.All coordinates passed to a Graphics2D object are specified in a device-independent coordinate system called User Space, which is used by applications.The Graphics2D object contains an AffineTransform object as part of its rendering state that defines how to convert coordinates from user space to device-dependent coordinates in Device Space.Coordinates in device space usually refer to individual device pixels and are aligned on the infinitely thin gaps between these pixels.Some Graphics2D objects can be used to capture rendering operations for storage into a graphics metafile for playback on a concrete device of unknown physical resolution at a later time.Since the resolution might not be known when the rendering operations are captured, the Graphics2D Transform is set up to transform user coordinates to a virtual device space that approximates the expected resolution of the target device.Further transformations might need to be applied at playback time if the estimate is incorrect.Some of the operations performed by the rendering attribute objects occur in the device space, but all Graphics2D methods take user space coordinates.Every Graphics2D object is associated with a target that defines where rendering takes place.A GraphicsConfiguration object defines the characteristics of the rendering target, such as pixel format and resolution.The same rendering target is used throughout the life of a Graphics2D object.When creating a Graphics2D object, the GraphicsConfiguration specifies the default transform for the target of the Graphics2D (a Component or Image).This default transform maps the user space coordinate system to screen and printer device coordinates such that the origin maps to the upper left hand corner of the target region of the device with increasing X coordinates extending to the right and increasing Y coordinates extending downward.The scaling of the default transform is set to identity for those devices that are close to 72 dpi, such as screen devices.The scaling of the default transform is set to approximately 72 user space coordinates per square inch for high resolution devices, such as printers.For image buffers, the default transform is the Identity transform.The Rendering Process can be broken down into four phases that are controlled by the Graphics2D rendering attributes.The renderer can optimize many of these steps, either by caching the results for future calls, by collapsing multiple virtual steps into a single operation, or by recognizing various attributes as common simple cases that can be eliminated by modifying other parts of the operation.The steps in the rendering process are: Determine what to render.The Clip is specified by a Shape in user space and is controlled by the program using the various clip manipulation methods of Graphics and Graphics2D.This user clip is transformed into device space by the current Transform and combined with the device clip, which is defined by the visibility of windows and device extents.The combination of the user clip and device clip defines the composite clip, which determines the final clipping region.The user clip is not modified by the rendering system to reflect the resulting composite clip.The three types of rendering operations, along with details of each of their particular rendering processes are: Shape operationsIf the operation is a draw(Shape) operation, then the createStrokedShape method on the current Stroke attribute in the Graphics2D context is used to construct a new Shape object that contains the outline of the specified Shape.The Shape is transformed from user space to device space using the current Transform in the Graphics2D context.The outline of the Shape is extracted using the getPathIterator method of Shape, which returns a PathIterator object that iterates along the boundary of the Shape.If the Graphics2D object cannot handle the curved segments that the PathIterator object returns then it can call the alternate getPathIterator method of Shape, which flattens the Shape.The current Paint in the Graphics2D context is queried for a PaintContext, which specifies the colors to render in device space.The following steps are used to determine the set of glyphs required to render the indicated String: If the argument is a String, then the current Font in the Graphics2D context is asked to convert the Unicode characters in the String into a set of glyphs for presentation with whatever basic layout and shaping algorithms the font implements.If the argument is an AttributedCharacterIterator, the iterator is asked to convert itself to a TextLayout using its embedded font attributes.The TextLayout implements more sophisticated glyph layout algorithms that perform Unicode bi-directional layout adjustments automatically for multiple fonts of differing writing directions.If the argument is a GlyphVector, then the GlyphVector object already contains the appropriate font-specific glyph codes with explicit coordinates for the position of each glyph.The current Font is queried to obtain outlines for the indicated glyphs.These outlines are treated as shapes in user space relative to the position of each glyph that was determined in step 1.The character outlines are filled as indicated above under Shape operations.The current Paint is queried for a PaintContext, which specifies the colors to render in device space.The region of interest is defined by the bounding box of the source Image.This bounding box is specified in Image Space, which is the Image object's local coordinate system.If an AffineTransform is passed to drawImage(Image, AffineTransform, ImageObserver), the AffineTransform is used to transform the bounding box from image space to user space.If no AffineTransform is supplied, the bounding box is treated as if it is already in user space.The bounding box of the source Image is transformed from user space into device space using the current Transform.Note that the result of transforming the bounding box does not necessarily result in a rectangular region in device space.The Image object determines what colors to render, sampled according to the source to destination coordinate mapping specified by the current Transform and the optional image transform.The default values for the Graphics2D rendering attributes are: Paint The color of the Component.Clip No rendering Clip, the output is clipped to the Component.The JDK(tm) 1.1 rendering model is based on a pixelization model that specifies that coordinates are infinitely thin, lying between the pixels.Drawing operations are performed using a one-pixel wide pen that fills the pixel below and to the right of the anchor point on the path.The JDK 1.1 rendering model is consistent with the capabilities of most of the existing class of platform renderers that need to resolve integer coordinates to a discrete pen that must fall completely on a specified number of pixels.API supports antialiasing renderers.A pen with a width of one pixel does not need to fall completely on pixel N as opposed to pixel N+1.The pen can fall partially on both pixels.It is not necessary to choose a bias direction for a wide pen since the blending that occurs along the pen traversal edges makes the sub-pixel position of the pen visible to the user.On the other hand, when antialiasing is turned off by setting the KEY_ANTIALIASING hint key to the VALUE_ANTIALIAS_OFF hint value, the renderer might need to apply a bias to determine which pixel to modify when the pen is straddling a pixel boundary, such as when it is drawn along an integer coordinate in device space.While the capabilities of an antialiasing renderer make it no longer necessary for the rendering model to specify a bias for the pen, it is desirable for the antialiasing and non-antialiasing renderers to perform similarly for the common cases of drawing one-pixel wide horizontal and vertical lines on the screen.To ensure that turning on antialiasing by setting the KEY_ANTIALIASING hint key to VALUE_ANTIALIAS_ON does not cause such lines to suddenly become twice as wide and half as opaque, it is desirable to have the model specify a path for such lines so that they completely cover a particular set of pixels to help increase their crispness.Java 2D API maintains compatibility with JDK 1.1 rendering behavior, such that legacy operations and existing renderer behavior is unchanged under Java 2D API.Legacy methods that map onto general draw and fill methods are defined, which clearly indicates how Graphics2D extends Graphics based on settings of Stroke and Transform attributes and rendering hints.The definition performs identically under default attribute settings.For example, the default Stroke is a BasicStroke with a width of 1 and no dashing and the default Transform for screen drawing is an Identity transform.The following two rules provide predictable rendering behavior whether aliasing or antialiasing is being used.Device coordinates are defined to be between device pixels which avoids any inconsistent results between aliased and antialiased rendering.If coordinates were defined to be at a pixel's center, some of the pixels covered by a shape, such as a rectangle, would only be half covered.With aliased rendering, the half covered pixels would either be rendered inside the shape or outside the shape.With anti-aliased rendering, the pixels on the entire edge of the shape would be half covered.On the other hand, since coordinates are defined to be between pixels, a shape like a rectangle would have no half covered pixels, whether or not it is rendered using antialiasing.Lines and paths stroked using the BasicStroke object may be \"normalized\" to provide consistent rendering of the outlines when positioned at various points on the drawable and whether drawn with aliased or antialiased rendering.This normalization process is controlled by the KEY_STROKE_CONTROL hint.The exact normalization algorithm is not specified, but the goals of this normalization are to ensure that lines are rendered with consistent visual appearance regardless of how they fall on the pixel grid and to promote more solid horizontal and vertical lines in antialiased mode so that they resemble their non-antialiased counterparts more closely.A typical normalization step might promote antialiased line endpoints to pixel centers to reduce the amount of blending or adjust the subpixel positioning of non-antialiased lines so that the floating point line widths round to even or odd pixel counts with equal likelihood.This process can move endpoints by up to half a pixel (usually towards positive infinity along both axes) to promote these consistent results.The following definitions of general legacy methods perform identically to previously specified behavior under default attribute settings: For fill operations, including fillRect, fillRoundRect, fillOval, fillArc, fillPolygon, and clearRect, fill can now be called with the desired Shape.For example, when filling a rectangle: fill(new Rectangle(x, y, w, h)); is called.Similarly, for draw operations, including drawLine, drawRect, drawRoundRect, drawOval, drawArc, drawPolyline, and drawPolygon, draw can now be called with the desired Shape.The draw3DRect and fill3DRect methods were implemented in terms of the drawLine and fillRect methods in the Graphics class which would predicate their behavior upon the current Stroke and Paint objects in a Graphics2D context.This class overrides those implementations with versions that use the current Color exclusively, overriding the current Paint and which uses fillRect to describe the exact same behavior as the preexisting methods regardless of the setting of the current Stroke.The Graphics class defines only the setColor method to control the color to be painted.Since the Java 2D API extends the Color object to implement the new Paint interface, the existing setColor method is now a convenience method for setting the current Paint attribute to a Color object.setColor(c) is equivalent to setPaint(c).The Graphics class defines two methods for controlling how colors are applied to the destination.The setPaintMode method is implemented as a convenience method to set the default Composite, equivalent to setComposite(new AlphaComposite.method is implemented as a convenience method to set a special Composite object that ignores the Alpha components of source colors and sets the destination color to the value: dstpixel = (PixelOf(srccolor)"},
{"description": "The Graphics class is the abstract base class for all graphics contexts that allow an application to draw onto components that are realized on various devices, as well as onto off-screen images.A Graphics object encapsulates state information needed for the basic rendering operations that Java supports.This state information includes the following properties: The Component object on which to draw.Coordinates are infinitely thin and lie between the pixels of the output device.Operations that draw the outline of a figure operate by traversing an infinitely thin path between pixels with a pixel-sized pen that hangs down and to the right of the anchor point on the path.Operations that fill a figure operate by filling the interior of that infinitely thin path.Operations that render horizontal text render the ascending portion of character glyphs entirely above the baseline coordinate.The graphics pen hangs down and to the right from the path it traverses.This has the following implications: If you draw a figure that covers a given rectangle, that figure occupies one extra row of pixels on the right and bottom edges as compared to filling a figure that is bounded by that same rectangle.If you draw a horizontal line along the same y coordinate as the baseline of a line of text, that line is drawn entirely below the text, except for any descenders.All coordinates that appear as arguments to the methods of this Graphics object are considered relative to the translation origin of this Graphics object prior to the invocation of the method.All rendering operations modify only pixels which lie within the area bounded by the current clip, which is specified by a Shape in user space and is controlled by the program using the Graphics object.This user clip is transformed into device space and combined with the device clip, which is defined by the visibility of windows and device extents.The combination of the user clip and device clip defines the composite clip, which determines the final clipping region.The user clip cannot be modified by the rendering system to reflect the resulting composite clip.The user clip can only be changed through the setClip or clipRect methods.All drawing or writing is done in the current color, using the current paint mode, and in the current font."},
{"description": "This class is used with the CHAR_REPLACEMENT attribute.The GraphicAttribute class represents a graphic embedded in text.Clients subclass this class to implement their own char replacement graphics.Clients wishing to embed shapes and images in text need not subclass this class.Instead, clients can use the ShapeGraphicAttribute and ImageGraphicAttribute classes.Mutating a GraphicAttribute that is used in a TextLayout results in undefined behavior from the TextLayout."},
{"description": "The GradientPaint class provides a way to fill a Shape with a linear color gradient pattern.If Point P1 with Color C1 and Point P2 with Color C2 are specified in user space, the Color on the P1, P2 connecting line is proportionally changed from C1 to C2.Any point P not on the extended P1, P2 connecting line has the color of the pointP' that is the perpendicular projection of P on the extended P1, P2 connecting line.Points on the extended line outside of the P1, P2 segment can be colored in one of two ways.If the gradient is cyclic then the points on the extended P1, P2 connecting line cycle back and forth between the colors C1 and C2.If the gradient is acyclic then points on the P1 side of the segment have the constant Color C1 while points on the P2 side have the constant Color C2."},
{"description": "This can be implemented to be stateless, or to hold some information as a cache to facilitate faster rendering and model/view translation.At a minimum, the GlyphPainter allows a View implementation to perform its duties independant of a particular version of JVM and selection of capabilities (i.e. shaping for i18n, etc)."},
{"description": "A GlyphView is a styled chunk of text that represents a view mapped over an element in the text model.This view is generally responsible for displaying text glyphs using character level attributes in some way.An implementation of the GlyphPainter class is used to do the actual rendering and model/view translations.The view supports breaking for the purpose of formatting.The fragments produced by breaking share the view that has primary responsibility for the element (i.e. they are nested classes and carry only a small amount of state of their own)so they can share its resources.Since this view represents text that may have tabs embedded in it, it implements the TabableView interface.Tabs will only be expanded if this view is embedded in a container that does tab expansion.ParagraphView is an example of a container that does tab expansion."},
{"description": "A GlyphVector object is a collection of glyphs containing geometric information for the placement of each glyph in a transformed coordinate space which corresponds to the device on which the GlyphVector is ultimately displayed.The GlyphVector does not attempt any interpretation of the sequence of glyphs it contains.Relationships between adjacent glyphs in sequence are solely used to determine the placement of the glyphs in the visual coordinate space.Instances of GlyphVector are created by a Font.In a text processing application that can cache intermediate representations of text, creation and subsequent caching of a GlyphVector for use during rendering is the fastest method to present the visual representation of characters to a user.A GlyphVector is associated with exactly one Font, and can provide data useful only in relation to this Font.In addition, metrics obtained from a GlyphVector are not generally geometrically scaleable since the pixelization and spacing are dependent on grid-fitting algorithms within a Font.To facilitate accurate measurement of a GlyphVector and its component glyphs, you must specify a scaling transform, anti-alias mode, and fractional metrics mode when creating the GlyphVector.These characteristics can be derived from the destination device.For each glyph in the GlyphVector, you can obtain: the position of the glyph the transform associated with the glyph the metrics of the glyph in the context of the GlyphVector.The metrics of the glyph may be different under different transforms, application specified rendering hints, and the specific instance of the glyph within the GlyphVector.Altering the data used to create the GlyphVector does not alter the state of the GlyphVector.Methods are provided to adjust the positions of the glyphs within the GlyphVector.These methods are most appropriate for applications that are performing justification operations for the presentation of the glyphs.Methods are provided to transform individual glyphs within the GlyphVector.These methods are primarily useful for special effects.Methods are provided to return both the visual, logical, and pixel bounds of the entire GlyphVector or of individual glyphs within the GlyphVector.Methods are provided to return a Shape for the GlyphVector, and for individual glyphs within the GlyphVector."},
{"description": "The GlyphMetrics class represents information for a single glyph.A glyph is the visual representation of one or more characters.Many different glyphs can be used to represent a single character or combination of characters.GlyphMetrics instances are produced by Font and are applicable to a specific glyph in a particular Font.STANDARD glyphs are commonly used to represent single characters.LIGATURE glyphs are used to represent sequences of characters.COMPONENT glyphs in a GlyphVector do not correspond to a particular character in a text model.Instead, COMPONENT glyphs are added for typographical reasons, such as Arabic justification.COMBINING glyphs embellish STANDARD or LIGATURE glyphs, such as accent marks.Carets do not appear before COMBINING glyphs.Other metrics available through GlyphMetrics are the components of the advance, the visual bounds, and the left and right side bearings.Glyphs for a rotated font, or obtained from a GlyphVector which has applied a rotation to the glyph, can have advances that contain both X and Y components.Usually the advance only has one component.The advance of a glyph is the distance from the glyph's origin to the origin of the next glyph along the baseline, which is either vertical or horizontal.Note that, in a GlyphVector, the distance from a glyph to its following glyph might not be the glyph's advance, because of kerning or other positioning adjustments.The bounds is the smallest rectangle that completely contains the outline of the glyph.The bounds rectangle is relative to the glyph's origin.The left-side bearing is the distance from the glyph origin to the left of its bounds rectangle.If the left-side bearing is negative, part of the glyph is drawn to the left of its origin.The right-side bearing is the distance from the right side of the bounds rectangle to the next glyph origin (the origin plus the advance).If negative, part of the glyph is drawn to the right of the next glyph's origin.Note that the bounds does not necessarily enclose all the pixels affected when rendering the glyph, because of rasterization and pixel adjustment effects.Although instances of GlyphMetrics can be directly constructed, they are almost always obtained from a GlyphVector."},
{"description": "GenericArrayType represents an array type whose component type is either a parameterized type or a type variable."},
{"description": "The GlyphJustificationInfo class represents information about the justification properties of a glyph.A glyph is the visual representation of one or more characters.Many different glyphs can be used to represent a single character or combination of characters.The four justification properties represented by GlyphJustificationInfo are weight, priority, absorb and limit.Weight is the overall 'weight' of the glyph in the line.Generally it is proportional to the size of the font.Glyphs with larger weight are allocated a correspondingly larger amount of the change in space.Priority determines the justification phase in which this glyph is used.All glyphs of the same priority are examined before glyphs of the next priority.If all the change in space can be allocated to these glyphs without exceeding their limits, then glyphs of the next priority are not examined.There are four priorities, kashida, whitespace, interchar, and none.KASHIDA is the first priority examined.NONE is the last priority examined.Absorb determines whether a glyph absorbs all change in space.Within a given priority, some glyphs may absorb all the change in space.If any of these glyphs are present, no glyphs of later priority are examined.Limit determines the maximum or minimum amount by which the glyph can change.Left and right sides of the glyph can have different limits.Each GlyphJustificationInfo represents two sets of metrics, which are growing and shrinking.Growing metrics are used when the glyphs on a line are to be spread apart to fit a larger width.Shrinking metrics are used when the glyphs are to be moved together to fit a smaller width."},
{"description": "Thrown when a syntactically malformed signature attribute is encountered by a reflective method that needs to interpret the generic signature information for a type, method or constructor."},
{"description": "A common interface for all entities that declare type variables."},
{"description": "The Generated annotation is used to mark source code that has been generated.It can also be used to differentiate user written code from generated code in a single file.When used, the value element must have the name of the code generator.The recommended convention is to use the fully qualified name of the code generator in the value field .The date element is used to indicate the date the source was generated.The date element must follow the ISO 8601 standard.For example the date element would have the following value 2001-07-04T12:08:56.235-0700 which represents 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.The comment element is a place holder for any comments that the code generator may want to include in the generated code."},
{"description": "A gauge monitor observes an attribute that is continuously variable with time.A gauge monitor sends notifications as follows: if the attribute value is increasing and becomes equal to or greater than the high threshold value, a threshold high notification is sent.Subsequent crossings of the high threshold value do not cause further notifications unless the attribute value becomes equal to or less than the low threshold value.if the attribute value is decreasing and becomes equal to or less than the low threshold value, a threshold low notification is sent.Subsequent crossings of the low threshold value do not cause further notifications unless the attribute value becomes equal to or greater than the high threshold value.This provides a hysteresis mechanism to avoid repeated triggering of notifications when the attribute value makes small oscillations around the high or low threshold value.If the gauge difference mode is used, the value of the derived gauge is calculated as the difference between the observed gauge values for two successive observations.The derived gauge value (V[t]) is calculated using the following method: V[t] =This implementation of the gauge monitor requires the observed attribute to be of the type integer or floating-point"},
{"description": "A channel that can write bytes from a sequence of buffers.A gathering write operation writes, in a single invocation, a sequence of bytes from one or more of a given sequence of buffers.Gathering writes are often useful when implementing network protocols or file formats that, for example, group data into segments consisting of one or more fixed-length headers followed by a variable-length body.Similar scattering read operations are defined in the ScatteringByteChannel interface."},
{"description": "Simple block cipher modes (such as CBC) generally require only an initialization vector (such as IvParameterSpec), but GCM needs these parameters: IV: Initialization Vector (IV)In addition to the parameters described here, other GCM inputs/output (Additional Authenticated Data (AAD), Keys, block ciphers, plain/ciphertext and authentication tags) are handled in the Cipher class.\" The GCM specification states that tLen may only have the values {128, 120, 112, 104, 96}, or {64, 32} for certain applications.Other values can be specified for this class, but not all CSP implementations will support them."},
{"description": "The GeneralSecurityException class is a generic security exception class that provides type safety for all the security-related exception classes that extend from it."},
{"description": "The GeneralPath class represents a geometric path constructed from straight lines, and quadratic and cubic (B\u00e9zier) curves.It can contain multiple subpaths.GeneralPath is a legacy final class which exactly implements the behavior of its superclass Path2D.Float.Together with Path2D.Double, the Path2D classes provide full implementations of a general geometric path that support all of the functionality of the Shape and PathIterator interfaces with the ability to explicitly select different levels of internal coordinate precision.Use Path2D.Float (or this legacy GeneralPath subclass) when dealing with data that can be represented and used with floating point precision.Use Path2D.Double for data that requires the accuracy or range of double precision."},
{"description": "Garbage collection is the process that the Java virtual machine uses to find and reclaim unreachable objects to free up memory space.A garbage collector is one type of memory manager.A Java virtual machine may have one or more instances of the implementation class of this interface.An instance implementing this interface is an MXBean that can be obtained by calling the ManagementFactory.getGarbageCollectorMXBeans() method or from the platform MBeanServer method.The ObjectName for uniquely identifying the MXBean for a garbage collector within an MBeanServer is: java.lang:type=GarbageCollector,name=collector's name It can be obtained by calling the PlatformManagedObject.getObjectName() method.A platform usually includes additional platform-dependent information specific to a garbage collection algorithm for monitoring."},
{"description": "Content interface implemented using a gapped buffer similar to that used by emacs.The underlying storage is a array of unicode characters with a gap somewhere.The gap is moved to the location of changes to take advantage of common behavior where most changes are in the same location.Changes that occur at a gap boundary are generally cheap and moving the gap is generally cheaper than moving the array contents directly to accommodate the change.The Position implementations (marks) store the array index and can easily calculate the sequential position from the current gap location.Changes only require update to the the marks between the old and new gap boundaries when the gap is moved, so generally updating the marks is pretty cheap.The marks are stored sorted so they can be located quickly with a binary search.This increases the cost of adding a mark, and decreases the cost of keeping the mark updated."},
{"description": "This class provides a base implementation of Future, with methods to start and cancel a computation, query to see if the computation is complete, and retrieve the result of the computation.Once the computation has completed, the computation cannot be restarted or cancelled (unless the computation is invoked using runAndReset()).A FutureTask can be used to wrap a Callable or Runnable object.Because FutureTask implements Runnable, a FutureTask can be submitted to an Executor for execution.In addition to serving as a standalone class, this class provides protected functionality that may be useful when creating customized task classes."},
{"description": "An informative annotation type used to indicate that an interface type declaration is intended to be a functional interface as defined by the Java Language Specification.Conceptually, a functional interface has exactly one abstract method.Since default methods have an implementation, they are not abstract.If an interface declares an abstract method overriding one of the public methods of java.lang.Object, that also does not count toward the interface's abstract method count since any implementation of the interface will have an implementation from java.lang.Object or elsewhere.Note that instances of functional interfaces can be created with lambda expressions, method references, or constructor references.If a type is annotated with this annotation type, compilers are required to generate an error message unless: The type is an interface type and not an annotation type, enum, or class.The annotated type satisfies the requirements of a functional interface.However, the compiler will treat any interface meeting the definition of a functional interface as a functional interface regardless of whether or not a FunctionalInterface annotation is present on the interface declaration."},
{"description": "Represents a function that accepts one argument and produces a result.This is a functional interface whose functional method is apply(Object)."},
{"description": "A Future represents the result of an asynchronous computation.Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation.The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready.Cancellation is performed by the cancel method.If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future<?void showSearch(final String target) throws InterruptedException { Future<String> future = executor.submit(new// do other things while searching try { displayText(future.get()); // use future } catch (ExecutionException ex) { cleanup(); return; } } } The FutureTask class is an implementation of Future that implements Runnable, and so may be executed by an Executor.For example, the above construction with submit could be replaced by: FutureTask<String>future = new FutureTask<String>(new Callable<String>() { public String call() { return searcher.search(target); }});executor.execute(future); Memory consistency effects: Actions taken by the asynchronous computation happen-before actions following the corresponding Future.get() in another thread."},
{"description": "A Frame is a top-level window with a title and a border.The size of the frame includes any area designated for the border.The dimensions of the border area may be obtained using the getInsets method, however, since these dimensions are platform-dependent, a valid insets value cannot be obtained until the frame is made displayable by either calling pack or show.Since the border area is included in the overall size of the frame, the border effectively obscures a portion of the frame, constraining the area available for rendering and/or displaying subcomponents to the rectangle which has an upper-left corner location of (insets.left, insets.top), and has a size of width - (insets.left + insets.right) by height - (insets.top + insets.bottom).The default layout for a frame is BorderLayout.A frame may have its native decorations (i.e. Frame and Titlebar) turned off with setUndecorated.In a multi-screen environment, you can create a Frame on a different screen device by constructing the Frame with Frame(GraphicsConfiguration) or Frame(String title, GraphicsConfiguration).The GraphicsConfiguration object is one of the GraphicsConfiguration objects of the target screen device.In a virtual device multi-screen environment in which the desktop area could span multiple physical screen devices, the bounds of all configurations are relative to the virtual-coordinate system.The origin of the virtual-coordinate system is at the upper left-hand corner of the primary physical screen.Depending on the location of the primary screen in the virtual device, negative coordinates are possible, as shown in the following figure.In such an environment, when calling setLocation, you must pass a virtual coordinate to this method.The following code sets the location of the Frame at (10, 10) relative to the origin of the physical screen of the corresponding GraphicsConfiguration.If the bounds of the GraphicsConfiguration is not taken into account, the Frame location would be set at (10, 10) relative to the virtual-coordinate system and would appear on the primary physical screen, which might be different from the physical screen of the specified GraphicsConfiguration.; Frames are capable of generating the following types of WindowEvents:If the program doesn't explicitly hide or dispose the window while processing this event, the window close operation is canceled."},
{"description": "Exception thrown when the ORB failed in an attempt to free dynamic memory, for example because of heap corruption or memory segments being locked.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "Forwards calls to a given file object.Subclasses of this class might override some of these methods and might also provide additional fields and methods."},
{"description": "Component decorator that implements the view interface for form elements, <input>, <textarea>, and <select>.The model for the component is stored as an attribute of the the element (using StyleConstants.The type of the model is assumed to of the type that would be set by HTMLDocument.If there are multiple views mapped over the document, they will share the embedded component models.The following table shows what components get built by this view.Element Type Component built input, type button JButton input, type checkbox JCheckBox input, type image JButton input, type password JPasswordField input, type radio JRadioButton input, type reset JButton input, type submit JButton input, type text JTextField select, size > 1 or multiple attribute defined JList in a JScrollPane select, size unspecified or 1 JComboBox textarea JTextArea in a JScrollPane input, type file JTextField"},
{"description": "Forwards calls to a given file manager.Subclasses of this class might override some of these methods and might also provide additional fields and methods."},
{"description": "GET corresponds to the GET form method POST corresponds to the POST from method"},
{"description": "Forwards calls to a given file object.Subclasses of this class might override some of these methods and might also provide additional fields and methods."},
{"description": "FormSubmitEvent is used to notify interested parties that a form was submitted."},
{"description": "Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown."},
{"description": "A Formatter provides support for formatting LogRecords.Typically each logging Handler will have a Formatter associated with it.The Formatter takes a LogRecord and converts it to a string.Some formatters (such as the XMLFormatter) need to wrap head and tail strings around a set of formatted records.The getHeader and getTail methods can be used to obtain these strings."},
{"description": "This class provides support for layout justification and alignment, common formats for numeric, string, and date/time data, and locale-specific output.Common Java types such as byte, BigDecimal, and Calendar are supported.Limited formatting customization for arbitrary user types is provided through the Formattable interface.Formatters are not necessarily safe for multithreaded access.Thread safety is optional and is the responsibility of users of methods in this class.Formatted printing for the Java language is heavily inspired by C's printf.Although the format strings are similar to C, some customizations have been made to accommodate the Java language and exploit some of its features.Also, Java formatting is more strict than C's; for example, if a conversion is incompatible with a flag, an exception will be thrown.The format strings are thus intended to be recognizable to C programmers but not necessarily completely compatible with those in C. Examples of expected usage:US); // Explicit argument indices may be used to re-order output.// -> \" d c b a\" // Optional locale as the first argument can be used to get // locale-specific formatting of numbers.The precision and width can be // given to round and align the value.The '(' numeric flag may be used to format negative numbers with // parentheses rather than a minus sign.formatter.format(\"Amount gained or lost since last statement: $ %(,.2f\", balanceDelta); // -> \"Amount gained or lost since last statement: $ (6,217.58)\"Convenience methods for common formatting requests exist as illustrated by the following invocations: //// -> \"Local time: 13:34:18\" // Writes formatted output to System.err.No such file or directory\" Like C's sprintf(3), Strings may be formatted using the static method String.format:\" Organization This specification is divided into two sections.The first section, Summary, covers the basic formatting concepts.This section is intended for users who want to get started quickly and are familiar with formatted printing in other programming languages.The second section, Details, covers the specific implementation details.It is intended for users who want more precise specification of formatting behavior.This section is intended to provide a brief overview of formatting concepts.Every method which produces formatted output requires a format string and an argument list.The format string is a String which may contain fixed text and one or more embedded format specifiers.; This format string is the first argument to the format method.It contains three format specifiers \"%1$tm\", \"%1$te\", and \"%1$tY\" which indicate how the arguments should be processed and where they should be inserted in the text.The remaining portions of the format string are fixed text including \"Dukes Birthday: \" and any other spaces or punctuation.The argument list consists of all arguments passed to the method after the format string.In the above example, the argument list is of size one and consists of the Calendar object c.The format specifiers for general, character, and numeric types have the following syntax:[argument_index$][flags][width][.precision]conversion The optional argument_index is a decimal integer indicating the position of the argument in the argument list.The first argument is referenced by \"1$\", the second by \"2$\", etc.The optional flags is a set of characters that modify the output format.The set of valid flags depends on the conversion.The optional width is a positive decimal integer indicating the minimum number of characters to be written to the output.The optional precision is a non-negative decimal integer usually used to restrict the number of characters.The specific behavior depends on the conversion.The required conversion is a character indicating how the argument should be formatted.The set of valid conversions for a given argument depends on the argument's data type.The format specifiers for types which are used to represents dates and times have the following syntax:The required conversion is a two character sequence.The first character is 't' or 'T'.These characters are similar to but not completely identical to those defined by GNU date and POSIX strftime(3c).The format specifiers which do not correspond to arguments have the following syntax:The required conversion is a character indicating content to be inserted in the output.Conversions Conversions are divided into the following categories: General - may be applied to any argument type Character - may be applied to basic types which represent Unicode characters: char, Character, byte, Byte, short, and Short.This conversion may also be applied to the types int and Integer when Character.isValidCodePoint(int) returns true Numeric Integral - may be applied to Java integral types: byte, Byte, short, Short, int and Integer, long, Long, and BigInteger (but not char or Character)Floating Point - may be applied to Java floating-point types: float, Float, double, Double, and BigDecimal Date/Time - may be applied to Java types which are capable of encoding a date or time:long, Long, Calendar, Date and TemporalAccessor Percent - produces a literal '%' ('\\u0025')Line Separator - produces the platform-specific line separator The following table summarizes the supported conversions.Conversions denoted by an upper-case character (i.e. 'B', 'H', 'S', 'C', 'X', 'E', 'G', 'A', and 'T') are the same as those for the corresponding lower-case conversion characters except that the result is converted to upper case according to the rules of the prevailing Locale.The result is equivalent to the following invocation of String.toUpperCase() out.toUpperCase() Conversion Argument Category Description 'b', 'B' general If the argument arg is null, then the result is \"false\".If arg is a boolean or Boolean, then the result is the string returned by String.valueOf(arg).Otherwise, the result is obtained by invoking Integer.toHexString(arg.hashCode()). 's'If arg implements Formattable, then arg.formatTo is invoked.Otherwise, the result is obtained by invoking arg.toString(). 'c', 'The result is a Unicode character 'd' integral The result is formatted as a decimal integer 'o' integral The result is formatted as an octal integer 'x', 'X' integral The result is formatted as a hexadecimal integer 'e', 'E' floating point The result is formatted as a decimal number in computerized scientific notation 'f' floating point The result is formatted as a decimal number 'g', 'The result is formatted using computerized scientific notation or decimal format, depending on the precision and the value after rounding. 'The result is formatted as a hexadecimal floating-point number with a significand and an exponent.This conversion is not supported for the BigDecimal type despite the latter's being in the floating point argument category. 't', 'T' date/time Prefix for date and time conversion characters.The result is a literal '%' ('\\u0025') 'n' line separatorThe result is the platform-specific line separatorAny characters not explicitly defined as conversions are illegal and are reserved for future extensions.The following date and time conversion suffix characters are defined for the 't' and 'T' conversions.The types are similar to but not completely identical to those defined by GNU date and POSIX strftime(3c).Additional conversion types are provided to access Java-specific functionality (e.g. 'L' for milliseconds within the second).The following conversion characters are used for formatting times: 'H' Hour of the day for the 24-hour clock, formatted as two digits with a leading zero as necessary i.e. 00 - 23. 'M' Minute within the hour formatted as two digits with a leading zero as necessary, i.e. 00 - 59.Seconds within the minute, formatted as two digits with a leading zero as necessary, i.e. 00 - 60 (\"60\" is a special value required to support leap seconds). 'N' Nanosecond within the second, formatted as nine digits with leading zeros as necessary, i.e. 000000000 - 999999999. 'This value will be adjusted as necessary for Daylight Saving Time.For long, Long, and Date the time zone used is the default time zone for this instance of the Java virtual machine. 'This value will be adjusted as necessary for Daylight Saving Time.For long, Long, and Date the time zone used is the default time zone for this instance of the Java virtual machine.The Formatter's locale will supersede the locale of the argument (if any).The following conversion characters are used for formatting dates: 'B' Locale-specific full month name, e.g. \"January\", \"February\".\"Mon\" 'C' Four-digit year divided by 100, formatted as two digits with leading zero as necessary, i.e. 00 - 99 'Y' Year, formatted as at least four digits with leading zeros as necessary, e.g. 0092 equals 92 CE for the Gregorian calendar. 'j' Day of year, formatted as three digits with leading zeros as necessary, e.g. 001 - 366 for the Gregorian calendar. 'm' Month, formatted as two digits with leading zeros as necessary, i.e. 01 - 13.'d' Day of month, formatted as two digits with leading zeros as necessary, i.e. 01 - 31 'e' Day of month, formatted as two digits, i.e. 1 - 31.The following conversion characters are used for formatting common date/time compositions.R' Time formatted for the 24-hour clock as \"%tH:%tM\" 'T' Time formatted for the 24-hour clock as \"%tH:%tM:%tS\".'r' Time formatted for the 12-hour clock as \"%tI:%tM:%tS %Tp\".The location of the morning or afternoon marker ('%Tp') may be locale-dependent. 'D' Date formatted as \"%tm/%td/%ty\". 'F' ISO\u00a08601 complete date formatted as \"%tY-%tm-%td\". 'c' Date and time formatted as \"%ta %tb %td %tT %tZ %tY\", e.g. \"Sun Jul 20 16:17:00 EDT 1969\".Any characters not explicitly defined as date/time conversion suffixes are illegal and are reserved for future extensions.The following table summarizes the supported flags.y means the flag is supported for the indicated argument types.y1 - y3 y - The result should use a conversion-dependent alternate form '+' - - y4 y - The result will always include a sign '\u00a0\u00a0' - - y4 y - The result will include a leading space for positive values '0'- - y y - The result will be zero-padded ',' - - y2 y5 -The result will include locale-specific grouping separators '(' - - y4 y5 -The result will enclose negative numbers in parentheses 1 Depends on the definition of Formattable.For 'd', 'o', 'x', and 'X' conversions applied to BigInteger or 'd' applied to byte, Byte, short, Short, int and Integer, long, and Long. 5 For 'e', 'E', 'f', 'g', and 'G' conversions only.Any characters not explicitly defined as flags are illegal and are reserved for future extensions.The width is the minimum number of characters to be written to the output.For the line separator conversion, width is not applicable; if it is provided, an exception will be thrown.Precision For general argument types, the precision is the maximum number of characters to be written to the output.For the floating-point conversions 'a', 'A', 'e', 'E', and 'f' the precision is the number of digits after the radix point.If the conversion is 'g' or 'G', then the precision is the total number of digits in the resulting magnitude after rounding.For character, integral, and date/time argument types and the percent and line separator conversions, the precision is not applicable; if a precision is provided, an exception will be thrown.The argument index is a decimal integer indicating the position of the argument in the argument list.The first argument is referenced by \"1$\", the second by \"2$\", etc.Another way to reference arguments by position is to use the '<' ('\\u003c') flag, which causes the argument for the previous format specifier to be re-used.For example, the following two statements would produce identical strings: Calendar c = ...; String s1 =This section is intended to provide behavioral details for formatting, including conditions and exceptions, supported data types, localization, and interactions between flags, conversions, and data types.For an overview of formatting concepts, refer to the Summary Any characters not explicitly defined as conversions, date/time conversion suffixes, or flags are illegal and are reserved for future extensions.Use of such a character in a format string will cause an UnknownFormatConversionException or UnknownFormatFlagsException to be thrown.If the format specifier contains a width or precision with an invalid value or which is otherwise unsupported, then a IllegalFormatWidthException or IllegalFormatPrecisionException respectively will be thrown.If a format specifier contains a conversion character that is not applicable to the corresponding argument, then an IllegalFormatConversionException will be thrown.All specified exceptions may be thrown by any of the format methods of Formatter as well as by any format convenience methods such as String.format and PrintStream.printf.Conversions denoted by an upper-case character (i.e. 'B', 'H', 'S', 'C', 'X', 'E', 'G', 'A', and 'T') are the same as those for the corresponding lower-case conversion characters except that the result is converted to upper case according to the rules of the prevailing Locale.The result is equivalent to the following invocation of String.toUpperCase() out.toUpperCase()The following general conversions may be applied to any argument type: 'b' '\\u0062' Produces either \"true\" or \"false\" as returned by Boolean.toString(boolean).If the argument is a boolean or Boolean, then the result is the string returned by String.valueOf().h' '\\u0068' Produces a string representing the hash code value of the object.If the argument, arg is null, then the result is \"null\".Otherwise, the result is obtained by invoking Integer.toHexString(arg.hashCode()).If the argument implements Formattable, then its formatTo method is invoked.Otherwise, the result is obtained by invoking the argument's toString() method.If the '#' flag is given and the argument is not a Formattable , then a FormatFlagsConversionMismatchException will be thrown.The following flags apply to general conversions: '-' '\\u002d' Left justifies the output.Spaces ('\\u0020') will be added at the end of the converted value as required to fill the minimum width of the field.#' '\\u0023' Requires the output use an alternate form.The definition of the form is specified by the conversion.The width is the minimum number of characters to be written to the output.If the length of the converted value is less than the width then the output will be padded by '\u00a0\u00a0' ('\\u0020') until the total number of characters equals the width.The padding is on the left by default.If the '-' flag is given, then the padding will be on the right.If the width is not specified then there is no minimum.The precision is the maximum number of characters to be written to the output.The precision is applied before the width, thus the output will be truncated to precision characters even if the width is greater than the precision.If the precision is not specified then there is no explicit limit on the number of characters.Character This conversion may be applied to char and Character.It may also be applied to the types byte, Byte, short, and Short, int and Integer when Character.isValidCodePoint(int) returns true.This may be more than one 16-bit char in the case where the argument represents a supplementary character.The width is defined as for General conversions.Numeric Numeric conversions are divided into the following categories: Byte, Short, Integer, and Long BigInteger Float and Double BigDecimal Numeric types will be formatted according to the following algorithm: Number Localization Algorithm After digits are obtained for the integer part, fractional part, and exponent (as appropriate for the data type), the following transformation is applied: Each digit character d in the string is replaced by a locale-specific digit computed relative to the current locale's zero digit z; that is d\u00a0-\u00a0 '0' \u00a0+\u00a0z.If the ',' ('\\u002c') flag is given, then the locale-specific grouping separator is inserted by scanning the integer part of the string from least significant to most significant digits and inserting a separator at intervals defined by the locale's grouping size.If the '0' flag is given, then the locale-specific zero digits are inserted after the sign character, if any, and before the first non-zero digit, until the length of the string is equal to the requested field width.If the value is NaN or positive infinity the literal strings \"NaN\" or \"Infinity\" respectively, will be output.If the value is negative infinity, then the output will be \"(Infinity)\" if the '(' flag is given otherwise the output will be \"-Infinity\".Byte, Short, Integer, and Long The following conversions may be applied to byte, Byte, short, Short, int and Integer, long, and Long.If the '0' flag is given and the value is negative, then the zero padding will occur after the sign.If x is negative then the result will be an unsigned value generated by adding 2n to the value where n is the number of bits in the type as returned by the static SIZE field in the Byte, Short, Integer, or Long classes as appropriate.If the '#' flag is given then the output will always begin with the radix indicator '0'.If the '0' flag is given then the output will be padded with leading zeros to the field width following any indication of sign.If x is negative then the result will be an unsigned value generated by adding 2n to the value where n is the number of bits in the type as returned by the static SIZE field in the Byte, Short, Integer, or Long classes as appropriate.If the '#' flag is given then the output will always begin with the radix indicator \"0x\".If the '0' flag is given then the output will be padded to the field width with leading zeros after the radix indicator or sign (if present).The entire string representing the number will be converted to upper case including the 'x' (if any) and all hexadecimal digits 'a' - 'f' ('\\u0061' - '\\u0066').If the conversion is 'o', 'x', or 'X' and both the '#' and the '0' flags are given, then result will contain the radix indicator ('0' for octal and \"0x\" or \"0X\" for hexadecimal), some number of zeros (based on the width), and the value.If the '-' flag is not given, then the space padding will occur before the sign.The following flags apply to numeric integral conversions:If this flag is not given then only negative values will include a sign.\\u0020' Requires the output to include a single extra space ('\\u0020') for non-negative values.If both the '+' and '\u00a0\u00a0' flags are given then an IllegalFormatFlagsException will be thrown. '0' '\\u0030' Requires the output to be padded with leading zeros to the minimum field width following any sign or radix indicator except when converting NaN or infinity.If both the '-' and '0' flags are given then an IllegalFormatFlagsException will be thrown. ',' '\\u002c' Requires the output to include the locale-specific group separators as described in the \"group\" section of the localization algorithm. 'If no flags are given the default formatting is as follows: The output is right-justified within the width Negative numbers begin with a '-' ('\\u002d') Positive numbers and zero do not include a sign or extra leading spaceNo grouping separators are included The width is the minimum number of characters to be written to the output.This includes any signs, digits, grouping separators, radix indicator, and parentheses.If the length of the converted value is less than the width then the output will be padded by spaces ('\\u0020') until the total number of characters equals width.The padding is on the left by default.If '-' flag is given then the padding will be on the right.If width is not specified then there is no minimum.BigInteger The following conversions may be applied to BigInteger.If x is negative then the result will be a signed value beginning with '-' ('\\u002d').Signed output is allowed for this type because unlike the primitive types it is not possible to create an unsigned equivalent without assuming an explicit data-type size.If the '#' flag is given then the output will always begin with '0' prefix.If the '0' flag is given then the output will be padded with leading zeros to the field width following any indication of sign.If x is negative then the result will be a signed value beginning with '-' ('\\u002d').Signed output is allowed for this type because unlike the primitive types it is not possible to create an unsigned equivalent without assuming an explicit data-type size.If the '#' flag is given then the output will always begin with the radix indicator \"0x\".If the '0' flag is given then the output will be padded to the field width with leading zeros after the radix indicator or sign (if present).The entire string representing the number will be converted to upper case including the 'x' (if any) and all hexadecimal digits 'a' - 'f' ('\\u0061' - '\\u0066').If the conversion is 'o', 'x', or 'X' and both the '#' and the '0' flags are given, then result will contain the base indicator ('0' for octal and \"0x\" or \"0X\" for hexadecimal), some number of zeros (based on the width), and the value.If the '0' flag is given and the value is negative, then the zero padding will occur after the sign.If the '-' flag is not given, then the space padding will occur before the sign.All flags defined for Byte, Short, Integer, and Long apply.The default behavior when no flags are given is the same as for Byte, Short, Integer, and Long.The specification of width is the same as defined for Byte, Short, Integer, and Long.e' '\\u0065' Requires the output to be formatted using computerized scientific notation.The formatting of the magnitude m depends upon its value.If m is NaN or infinite, the literal strings \"NaN\" or \"Infinity\", respectively, will be output.If m is positive-zero or negative-zero, then the exponent will be \"+00\".Otherwise, the result is a string that represents the sign and magnitude (absolute value) of the argument.The formatting of the sign is described in the localization algorithm.The formatting of the magnitude m depends upon its value.Let n be the unique integer such that 10n<= m < 10n+1; then let a be the mathematically exact quotient of m and 10nThe magnitude is then represented as the integer part of a, as a single decimal digit, followed by the decimal separator followed by decimal digits representing the fractional part of a, followed by the exponent symbol 'e' ('\\u0065'), followed by the sign of the exponent, followed by a representation of n as a decimal integer, as produced by the method Long.toString(long, int), and zero-padded to include at least two digits.The number of digits in the result for the fractional part of m or a is equal to the precision.If the precision is not specified then the default value is 6.If the precision is less than the number of digits which would appear after the decimal point in the string returned by Float.toString(float) orDouble.toString(double) respectively, then the value will be rounded using the round half up algorithm.Otherwise, zeros may be appended to reach the precision.The exponent symbol will be 'E' ('\\u0045'). 'g' '\\u0067' Requires the output to be formatted in general scientific notation as described below.After rounding for the precision, the formatting of the resulting magnitude m depends on its value.If m is greater than or equal to 10-4 but less than 10precision then it is represented in decimal format.If m is less than 10-4 or greater than or equal to 10precision, then it is represented in computerized scientific notation.The total number of significant digits in m is equal to the precision.If the precision is not specified, then the default value is 6.If the precision is 0, then it is taken to be 1.The result is a string that represents the sign and magnitude (absolute value) of the argument.The formatting of the sign is described in the localization algorithm.The formatting of the magnitude m depends upon its value.If m NaN or infinite, the literal strings \"NaN\" or \"Infinity\", respectively, will be output.The magnitude is formatted as the integer part of m, with no leading zeroes, followed by the decimal separator followed by one or more decimal digits representing the fractional part of m.The number of digits in the result for the fractional part of m or a is equal to the precision.If the precision is not specified then the default value is 6.If the precision is less than the number of digits which would appear after the decimal point in the string returned by Float.toString(float) orDouble.toString(double) respectively, then the value will be rounded using the round half up algorithm.Otherwise, zeros may be appended to reach the precision.The result is a string that represents the sign and magnitude (absolute value) of the argument x.The formatting of the magnitude m depends upon its value.If the value is NaN or infinite, the literal strings \"NaN\" or \"Infinity\", respectively, will be output.If m is zero then it is represented by the string \"0x0.0p0\".If m is a double value with a normalized representation then substrings are used to represent the significand and exponent fields.The significand is represented by the characters \"0x1.\"The exponent is represented by 'p' ('\\u0070') followed by a decimal string of the unbiased exponent as if produced by invoking Integer.toString on the exponent value.If the precision is specified, the value is rounded to the given number of hexadecimal digits.If m is a double value with a subnormal representation then, unless the precision is specified to be in the range 1 through 12, inclusive, the significand is represented by the characters '0x0.'If the precision is in the interval [1,\u00a012], the subnormal value is normalized such that it begins with the characters '0x1.', rounded to the number of hexadecimal digits of precision, and the exponent adjusted accordingly.Note that there must be at least one nonzero digit in a subnormal significand.The entire string representing the number will be converted to upper case including the 'x' ('\\u0078') and 'p' ('\\u0070' and all hexadecimal digits 'a' - 'f' ('\\u0061' - '\\u0066').All flags defined for Byte, Short, Integer, and Long apply.If no flags are given the default formatting is as follows: The output is right-justified within the width Negative numbers begin with a '-' Positive numbers and positive zero do not include a sign or extra leading spaceNo grouping separators are included The decimal separator will only appear if a digit follows itThe width is the minimum number of characters to be written to the output.This includes any signs, digits, grouping separators, decimal separators, exponential symbol, radix indicator, parentheses, and strings representing infinity and NaN as applicable.If the length of the converted value is less than the width then the output will be padded by spaces ('\\u0020') until the total number of characters equals width.The padding is on the left by default.If the '-' flag is given then the padding will be on the right.If width is not specified then there is no minimum.If the conversion is 'e', 'E' or 'f', then the precision is the number of digits after the decimal separator.If the precision is not specified, then it is assumed to be 6.If the conversion is 'g' or 'G', then the precision is the total number of significant digits in the resulting magnitude after rounding.If the precision is not specified, then the default value is 6.If the precision is 0, then it is taken to be 1.If the conversion is 'a' or 'A', then the precision is the number of hexadecimal digits after the radix point.If the precision is not provided, then all of the digits as returned by Double.toHexString(double) will be output.e' '\\u0065' Requires the output to be formatted using computerized scientific notation.The formatting of the magnitude m depends upon its value.If m is positive-zero or negative-zero, then the exponent will be \"+00\".Otherwise, the result is a string that represents the sign and magnitude (absolute value) of the argument.The formatting of the sign is described in the localization algorithm.The formatting of the magnitude m depends upon its value.Let n be the unique integer such that 10n<= m < 10n+1; then let a be the mathematically exact quotient of m and 10nThe magnitude is then represented as the integer part of a, as a single decimal digit, followed by the decimal separator followed by decimal digits representing the fractional part of a, followed by the exponent symbol 'e' ('\\u0065'), followed by the sign of the exponent, followed by a representation of n as a decimal integer, as produced by the method Long.toString(long, int), and zero-padded to include at least two digits.The number of digits in the result for the fractional part of m or a is equal to the precision.If the precision is not specified then the default value is 6.If the precision is less than the number of digits to the right of the decimal point then the value will be rounded using the round half up algorithm.Otherwise, zeros may be appended to reach the precision.The exponent symbol will be 'E' ('\\u0045'). 'g' '\\u0067' Requires the output to be formatted in general scientific notation as described below.After rounding for the precision, the formatting of the resulting magnitude m depends on its value.If m is greater than or equal to 10-4 but less than 10precision then it is represented in decimal format.If m is less than 10-4 or greater than or equal to 10precision, then it is represented in computerized scientific notation.The total number of significant digits in m is equal to the precision.If the precision is not specified, then the default value is 6.If the precision is 0, then it is taken to be 1.The result is a string that represents the sign and magnitude (absolute value) of the argument.The formatting of the sign is described in the localization algorithm.The formatting of the magnitude m depends upon its value.The magnitude is formatted as the integer part of m, with no leading zeroes, followed by the decimal separator followed by one or more decimal digits representing the fractional part of m.The number of digits in the result for the fractional part of m or a is equal to the precision.If the precision is not specified then the default value is 6.If the precision is less than the number of digits to the right of the decimal point then the value will be rounded using the round half up algorithm.Otherwise, zeros may be appended to reach the precision.All flags defined for Byte, Short, Integer, and Long apply.The default behavior when no flags are given is the same as for Float and Double.The specification of width and precision is the same as defined for Float and Double.This conversion may be applied to long, Long, Calendar, Date and TemporalAccessor 't' '\\u0074' Prefix for date and time conversion characters.The following date and time conversion character suffixes are defined for the 't' and 'T' conversions.The types are similar to but not completely identical to those defined by GNU date and POSIX strftime(3c).Additional conversion types are provided to access Java-specific functionality (e.g. 'L' for milliseconds within the second).The following conversion characters are used for formatting times: 'H' '\\u0048' Hour of the day for the 24-hour clock, formatted as two digits with a leading zero as necessary i.e. 00 - 23. 00M' '\\u004d' Minute within the hour formatted as two digits with a leading zero as necessary, i.e. 00 - 59.' Seconds within the minute, formatted as two digits with a leading zero as necessary, i.e. 00 - 60 (\"60\" is a special value required to support leap seconds). 'N' '\\u004e' Nanosecond within the second, formatted as nine digits with leading zeros as necessary, i.e. 000000000 - 999999999.The precision of this value is limited by the resolution of the underlying operating system or hardware. '(Note that 'p' produces lower-case output.This is different from GNU date and POSIX strftime(3c) which produce upper-case output.)This value will be adjusted as necessary for Daylight Saving Time.For long, Long, and Date the time zone used is the default time zone for this instance of the Java virtual machine. 'This value will be adjusted as necessary for Daylight Saving Time.For long, Long, and Date the time zone used is the default time zone for this instance of the Java virtual machine.The Formatter's locale will supersede the locale of the argument (if any).'s' '\\u0073' Seconds since the beginning of the epoch starting at 1 January 1970 00:00:00 UTC, i.e. Long.The precision of this value is limited by the resolution of the underlying operating system or hardware.The following conversion characters are used for formatting dates: 'B' '\\u0042' Locale-specific full month name, e.g. \"January\", \"February\".'b' '\\u0062' Locale-specific abbreviated month name, e.g. \"Jan\", \"Feb\". ''Y' '\\u0059' Year, formatted to at least four digits with leading zeros as necessary, e.g. 0092 equals 92 CE for the Gregorian calendar. 'j' '\\u006a' Day of year, formatted as three digits with leading zeros as necessary, e.g. 001 - 366 for the Gregorian calendar.m' '\\u006d' Month, formatted as two digits with leading zeros as necessary, i.e. 01 - 13, where \"01\" is the first month of the year and (\"13\" is a special value required to support lunar calendars).'d' '\\u0064' Day of month, formatted as two digits with leading zeros as necessary, i.e. 01 - 31, where \"01\" is the first day of the month. 'e' '\\u0065' Day of month, formatted as two digits, i.e. 1 - 31where \"1\" is the first day of the month.The following conversion characters are used for formatting common date/time compositions.' Time formatted for the 24-hour clock as \"%tH:%tM\" 'T' '\\u0054'Time formatted for the 24-hour clock as \"%tH:%tM:%tS\". 'r' '\\u0072' Time formatted for the 12-hour clock as \"%tI:%tM:%tS %Tp\".The location of the morning or afternoon marker ('%Tp') may be locale-dependent. 'D' '\\u0044' Date formatted as \"%tm/%td/%ty\". 'F' '\\u0046' ISO\u00a08601 complete date formatted as \"%tY-%tm-%td\". 'c' '\\u0063' Date and time formatted as \"%ta %tb %td %tT %tZ %tY\", e.g.The width is the minimum number of characters to be written to the output.If the length of the converted value is less than the width then the output will be padded by spaces ('\\u0020') until the total number of characters equals width.The padding is on the left by default.If the '-' flag is given then the padding will be on the right.If width is not specified then there is no minimum.Percent The conversion does not correspond to any argument.%' The result is a literal '%' ('\\u0025')The width is the minimum number of characters to be written to the output including the '%'.If the length of the converted value is less than the width then the output will be padded by spaces ('\\u0020') until the total number of characters equals width.The padding is on the left.If width is not specified then just the '%' is output.The conversion does not correspond to any argument. 'If any are provided an IllegalFormatFlagsException, IllegalFormatWidthException, and IllegalFormatPrecisionException, respectively will be thrown.Argument Index Format specifiers can reference arguments in three ways:Explicit indexing is used when the format specifier contains an argument index.The argument index is a decimal integer indicating the position of the argument in the argument list.The first argument is referenced by \"1$\", the second by \"2$\", etc.For example: formatter.format(\"%4$s %3$s %2$s %1$s %4$s %3$s %2$s %1$s\", \"a\", \"b\", \"c\", \"d\") // -> \"d c b a d c b a\" Relative indexing is used when the format specifier contains a '<' ('\\u003c') flag which causes the argument for the previous format specifier to be re-used.If there is no previous argument, then a MissingFormatArgumentException is thrown.formatter.format(\"%s %s %<s %<s\", \"a\", \"b\", \"c\", \"d\") // -> \"a b b b\" // \"c\" and \"d\" are ignored because they are not referenced Ordinary indexing is used when the format specifier contains neither an argument index nor a '<' flag.Each format specifier which uses ordinary indexing is assigned a sequential implicit index into argument list which is independent of the indices used by explicit or relative indexing.\"a b c d\" It is possible to have a format string which uses all forms of indexing, for example: formatter.format(\"%2$s %s %<s %s\", \"a\", \"b\", \"c\", \"d\") // -> \"b a a b\" // \"c\" and \"d\" are ignored because they are not referenced The maximum number of arguments is limited by the maximum dimension of a Java array as defined by The Java\u2122 Virtual Machine Specification.If the argument index is does not correspond to an available argument, then a MissingFormatArgumentException is thrown.If there are more arguments than format specifiers, the extra arguments are ignored.Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown."},
{"description": "FomattableFlags are passed to the Formattable.formatTo() method and modify the output format for Formattables.Implementations of Formattable are responsible for interpreting and validating any flags."},
{"description": "The Formattable interface must be implemented by any class that needs to perform custom formatting using the 's' conversion specifier of Formatter.This interface allows basic control for formatting arbitrary objects.*; ... public class StockName implements Formattable { private String symbol, companyName, frenchCompanyName; public StockName(String symbol, String companyName, String frenchCompanyName) { ... } ...|| out.length() < precision) { // write it all sb.append(out); } else { sb.append(out.substring(0, precision - 1)).append('*'); } // apply width and justification int len = sb.length(); if (len < width) for (int i = 0; i < width - len; i++) if ((f & LEFT_JUSTIFY) == LEFT_JUSTIFY)(' '); else sb.insert(0, ' '); fmt.format(sb.toString()); } public String toString() { return String.format(\"%s - %s\", symbol, companyName); } } When used in conjunction with the Formatter, the above class produces the following output for various format strings.Formatter fmt = new Formatter(); StockName sn = new StockName(\"HUGE\", \"Huge Fruit,Inc.\" Formattables are not necessarily safe for multithreaded access.Thread safety is optional and may be enforced by classes that extend and implement this interface.Unless otherwise specified, passing a null argument to any method in this interface will cause a NullPointerException to be thrown."},
{"description": "Enumeration of the style of a localized date, time or date-time formatter.These styles are used when obtaining a date-time style from configuration."},
{"description": "Defines constants that are used as attribute keys in the AttributedCharacterIterator returned from Format.formatToCharacterIterator and as field identifiers in FieldPosition."},
{"description": "A thread managed by a ForkJoinPool, which executes ForkJoinTasks.This class is subclassable solely for the sake of adding functionality -- there are no overridable methods dealing with scheduling or execution.However, you can override initialization and termination methods surrounding the main task processing loop.If you do create such a subclass, you will also need to supply a custom ForkJoinPool."},
{"description": "Abstract base class for tasks that run within a ForkJoinPool.A ForkJoinTask is a thread-like entity that is much lighter weight than a normal thread.Huge numbers of tasks and subtasks may be hosted by a small number of actual threads in a ForkJoinPool, at the price of some usage limitations.A \"main\" ForkJoinTask begins execution when it is explicitly submitted to a ForkJoinPool, or, if not already engaged in a ForkJoin computation, commenced in the ForkJoinPool.commonPool() via fork(), invoke(), or related methods.Once started, it will usually in turn start other subtasks.As indicated by the name of this class, many programs using ForkJoinTask employ only methods fork() and join(), or derivatives such as invokeAll.However, this class also provides a number of other methods that can come into play in advanced usages, as well as extension mechanics that allow support of new forms of fork/join processing.A ForkJoinTask is a lightweight form of Future.The efficiency of ForkJoinTasks stems from a set of restrictions (that are only partially statically enforceable) reflecting their main use as computational tasks calculating pure functions or operating on purely isolated objects.The primary coordination mechanisms are fork(), that arranges asynchronous execution, and join(), that doesn't proceed until the task's result has been computed.Computations should ideally avoid synchronized methods or blocks, and should minimize other blocking synchronization apart from joining other tasks or using synchronizers such as Phasers that are advertised to cooperate with fork/join scheduling.Subdividable tasks should also not perform blocking I/O, and should ideally access variables that are completely independent of those accessed by other running tasks.These guidelines are loosely enforced by not permitting checked exceptions such as IOExceptions to be thrown.However, computations may still encounter unchecked exceptions, that are rethrown to callers attempting to join them.These exceptions may additionally include RejectedExecutionException stemming from internal resource exhaustion, such as failure to allocate internal task queues.Rethrown exceptions behave in the same way as regular exceptions, but, when possible, contain stack traces (as displayed for example using ex.printStackTrace()) of both the thread that initiated the computation as well as the thread actually encountering the exception; minimally only the latter.It is possible to define and use ForkJoinTasks that may block, but doing do requires three further considerations: (1) Completion of few if any other tasks should be dependent on a task that blocks on external synchronization or I/O. Event-style async tasks that are never joined (for example, those subclassing CountedCompleter) often fall into this category.(2) To minimize resource impact, tasks should be small; ideally performing only the (possibly) blocking action.ManagedBlocker API is used, or the number of possibly blocked tasks is known to be less than the pool's ForkJoinPool.getParallelism() level, the pool cannot guarantee that enough threads will be available to ensure progress or good performance.The primary method for awaiting completion and extracting results of a task is join(), but there are several variants:() methods support interruptible and/or timed waits for completion and report results using Future conventions.The \"quiet\" forms of these methods do not extract results or report exceptions.These may be useful when a set of tasks are being executed, and you need to delay processing of results or exceptions until all complete.Method invokeAll (available in multiple versions) performs the most common form of parallel invocation: forking a set of tasks and joining them all.As is the case with other forms of recursive calls, returns (joins) should be performed innermost-first.For example, a.fork(); b.fork(); b.join(); a.join(); is likely to be substantially more efficient than joining a before b.The execution status of tasks may be queried at several levels of detail:isDone() is true if a task completed in any way (including the case where a task was cancelled without executing); isCompletedNormally() is true if a task completed without cancellation or encountering an exception; isCancelled() is true if the task was cancelled (in which case getException() returns a CancellationException); and isCompletedAbnormally() is true if a task was either cancelled or encountered an exception, in which case getException() will return either the encountered exception or CancellationException.Instead, you subclass one of the abstract classes that support a particular style of fork/join processing, typically RecursiveAction for most computations that do not return results, RecursiveTask for those that do, and CountedCompleter for those in which completed actions trigger other actions.Normally, a concrete ForkJoinTask subclass declares fields comprising its parameters, established in a constructor, and then defines a compute method that somehow uses the control methods supplied by this base class.Method join() and its variants are appropriate for use only when completion dependencies are acyclic; that is, the parallel computation can be described as a directed acyclic graph (DAG).Otherwise, executions may encounter a form of deadlock as tasks cyclically wait for each other.However, this framework supports other methods and techniques (for example the use of Phaser, helpQuiesce(), and complete(V)) that may be of use in constructing custom subclasses for problems that are not statically structured as DAGs.To support such usages, a ForkJoinTask may be atomically tagged with a short value using setForkJoinTaskTag(short) or compareAndSetForkJoinTaskTag(short, short) and checked using getForkJoinTaskTag().The ForkJoinTask implementation does not use these protected methods or tags for any purpose, but they may be of use in the construction of specialized subclasses.For example, parallel graph traversals can use the supplied methods to avoid revisiting nodes/tasks that have already been processed.(Method names for tagging are bulky in part to encourage definition of methods that reflect their usage patterns.)Most base support methods are final, to prevent overriding of implementations that are intrinsically tied to the underlying lightweight task scheduling framework.Developers creating new basic styles of fork/join processing should minimally implement protected methods exec(), setRawResult(V), and getRawResult(), while also introducing an abstract computational method that can be implemented in its subclasses, possibly relying on other protected methods provided by this class.ForkJoinTasks should perform relatively small amounts of computation.Large tasks should be split into smaller subtasks, usually via recursive decomposition.As a very rough rule of thumb, a task should perform more than 100 and less than 10000 basic computational steps, and should avoid indefinite looping.If tasks are too big, then parallelism cannot improve throughput.If too small, then memory and internal task maintenance overhead may overwhelm processing.This class provides adapt methods for Runnable and Callable, that may be of use when mixing execution of ForkJoinTasks with other kinds of tasks.When all tasks are of this form, consider using a pool constructed in asyncMode.ForkJoinTasks are Serializable, which enables them to be used in extensions such as remote execution frameworks.It is sensible to serialize tasks only before or after, but not during, execution.Serialization is not relied on during execution itself."},
{"description": "Format is an abstract base class for formatting locale-sensitive information such as dates, messages, and numbers.Format defines the programming interface for formatting locale-sensitive objects into Strings (the format method) and for parsing Strings back into objects (the parseObject method).Generally, a format's parseObject method must be able to parse any string formatted by its format method.However, there may be exceptional cases where this is not possible.For example, a format method might create two adjacent integer numbers with no separator in between, and in this case the parseObject could not tell which digits belong to which number.Subclassing The Java Platform provides three specialized subclasses of Format-- DateFormat, MessageFormat, and NumberFormat--for formatting dates, messages, and numbers, respectively.Concrete subclasses must implement three methods: format(Object obj, StringBuffer toAppendTo, FieldPosition pos)These general methods allow polymorphic parsing and formatting of objects and are used, for example, by MessageFormat.Subclasses often also provide additional format methods for specific input types as well as parse methods for specific result types.Any parse method that does not take a ParsePosition argument should throw ParseException when no text in the required format is at the beginning of the input text.Most subclasses will also implement the following factory methods: getInstance for getting a useful format object appropriate for the current locale getInstance(Locale) for getting a useful format object appropriate for the specified localeIn addition, some subclasses may also implement other getXxxxInstance methods for more specialized control.For example, the NumberFormat class provides getPercentInstance and getCurrencyInstance methods for getting specialized number formatters.Subclasses of Format that allow programmers to create objects for locales (with getInstance(Locale) for example) must also implement the following class method: public static Locale[] getAvailableLocales()And finally subclasses may define a set of constants to identify the various fields in the formatted output.These constants are used to create a FieldPosition object which identifies what information is contained in the field and its position in the formatted result.These constants should be named item_FIELD where item identifies the field.It is recommended to create separate format instances for each thread.If multiple threads access a format concurrently, it must be synchronized externally."},
{"description": "A format conversion provider provides format conversion services from one or more input formats to one or more output formats.Converters include codecs, which encode and/or decode audio data, as well as transcoders, etc.Format converters provide methods for determining what conversions are supported and for obtaining an audio stream from which converted data can be read.The source format represents the format of the incoming audio data, which will be converted.The target format represents the format of the processed, converted audio data.This is the format of the data that can be read from the stream returned by one of the getAudioInputStream methods."},
{"description": "Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown."},
{"description": "A ManagedBlocker provides two methods.Method block() blocks the current thread if necessary (perhaps internally invoking isReleasable before actually blocking).These actions are performed by any thread invoking ForkJoinPool.managedBlock(ManagedBlocker).The unusual methods in this API accommodate synchronizers that may, but don't usually, block for long periods.Similarly, they allow more efficient internal handling of cases in which additional workers may be, but usually are not, needed to ensure sufficient parallelism.Toward this end, implementations of method isReleasable must be amenable to repeated invocation.For example, here is a ManagedBlocker based on a ReentrantLock: class ManagedLocker implements ManagedBlocker { final ReentrantLock lock; boolean hasLock = false; ManagedLocker(ReentrantLock lock) { this.lock = lock; } public boolean block() { if (!hasLock)Here is a class that possibly blocks waiting for an item on a given queue: class QueueTaker{ this.queue = q; } public boolean block() throws InterruptedException { if (item =={ // call after pool.managedBlock completes return item; } }"},
{"description": "A ForkJoinWorkerThreadFactory must be defined and used for ForkJoinWorkerThread subclasses that extend base functionality or initialize threads with different contexts."},
{"description": "A ForkJoinPool provides the entry point for submissions from non-ForkJoinTask clients, as well as management and monitoring operations.A ForkJoinPool differs from other kinds of ExecutorService mainly by virtue of employing work-stealing: all threads in the pool attempt to find and execute tasks submitted to the pool and/or created by other active tasks (eventually blocking waiting for work if none exist).This enables efficient processing when most tasks spawn other subtasks (as do most ForkJoinTasks), as well as when many small tasks are submitted to the pool from external clients.Especially when setting asyncMode to true in constructors, ForkJoinPools may also be appropriate for use with event-style tasks that are never joined.A static commonPool() is available and appropriate for most applications.The common pool is used by any ForkJoinTask that is not explicitly submitted to a specified pool.Using the common pool normally reduces resource usage (its threads are slowly reclaimed during periods of non-use, and reinstated upon subsequent use).For applications that require separate or custom pools, a ForkJoinPool may be constructed with a given target parallelism level; by default, equal to the number of available processors.The pool attempts to maintain enough active (or available) threads by dynamically adding, suspending, or resuming internal worker threads, even if some tasks are stalled waiting to join others.However, no such adjustments are guaranteed in the face of blocked I/O or other unmanaged synchronization.ManagedBlocker interface enables extension of the kinds of synchronization accommodated.In addition to execution and lifecycle control methods, this class provides status check methods (for example getStealCount()) that are intended to aid in developing, tuning, and monitoring fork/join applications.Also, method toString() returns indications of pool state in a convenient form for informal monitoring.As is the case with other ExecutorServices, there are three main task execution methods summarized in the following table.These are designed to be used primarily by clients not already engaged in fork/join computations in the current pool.The main forms of these methods accept instances of ForkJoinTask, but overloaded forms also allow mixed execution of plain Runnable- or Callable- based activities as well.However, tasks that are already executing in a pool should normally instead use the within-computation forms listed in the table unless using async event-style tasks that are not usually joined, in which case there is little difference among choice of methods.Summary of task execution methods Call from non-fork/join clients Call from within fork() (ForkJoinTasks are Futures)The common pool is by default constructed with default parameters, but these may be controlled by setting three system properties: java.util.concurrent.ForkJoinPool.common.parallelism -If a SecurityManager is present and no factory is specified, then the default pool uses a factory supplying threads that have no Permissions enabled.The system class loader is used to load these classes.Upon any error in establishing these settings, default parameters are used.It is possible to disable or limit the use of threads in the common pool by setting the parallelism property to zero, and/or using a factory that may return null.Implementation notes: This implementation restricts the maximum number of running threads to 32767.Attempts to create pools with greater than the maximum number result in IllegalArgumentException.This implementation rejects submitted tasks (that is, by throwing RejectedExecutionException) only when the pool is shut down or internal resources have been exhausted."},
{"description": "A subclass of java.awt.Font that implements UIResource.UI classes which set default font properties should use this class.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The FontRenderContext class is a container for the information needed to correctly measure text.The measurement of text can vary because of rules that map outlines to pixels, and rendering hints provided by an application.One such piece of information is a transform that scales typographical points to pixels.(A point is defined to be exactly 1/72 of an inch, which is slightly different than the traditional mechanical measurement of a point.)A character that is rendered at 12pt on a 600dpi device might have a different size than the same character rendered at 12pt on a 72dpi device because of such factors as rounding to pixel boundaries and hints that the font designer may have specified.Anti-aliasing and Fractional-metrics specified by an application can also affect the size of a character because of rounding to pixel boundaries.Typically, instances of FontRenderContext are obtained from a Graphics2D object.A FontRenderContext which is directly constructed will most likely not represent any actual graphics device, and may lead to unexpected or incorrect results."},
{"description": "The FontMetrics class defines a font metrics object, which encapsulates information about the rendering of a particular font on a particular screen.Note to subclassers: Since many of these methods form closed, mutually recursive loops, you must take care that you implement at least one of the methods in each such loop to prevent infinite recursion when your subclass is used.In particular, the following is the minimal suggested set of methods to override in order to ensure correctness and prevent infinite recursion (though other subsets are equally feasible):Note that the implementations of these methods are inefficient, so they are usually overridden with more efficient toolkit-specific implementations.When an application asks to place a character at the position (x,\u00a0y), the character is placed so that its reference point (shown as the dot in the accompanying image) is put at that position.The reference point specifies a horizontal line called the baseline of the character.In normal printing, the baselines of characters should align.In addition, every character in a font has an ascent, a descent, and an advance width.The ascent is the amount by which the character ascends above the baseline.The descent is the amount by which the character descends below the baseline.The advance width indicates the position at which AWT should place the next character.An array of characters or a string can also have an ascent, a descent, and an advance width.The ascent of the array is the maximum ascent of any character in the array.The descent is the maximum descent of any character in the array.The advance width is the sum of the advance widths of each of the characters in the character array.The advance of a String is the distance along the baseline of the String.This distance is the width that should be used for centering or right-aligning the String.Note that the advance of a String is not necessarily the sum of the advances of its characters measured in isolation because the width of a character can vary depending on its context.For example, in Arabic text, the shape of a character can change in order to connect to other characters.Also, in some scripts, certain character sequences can be represented by a single shape, called a ligature.Measuring characters individually does not account for these transformations.Font metrics are baseline-relative, meaning that they are generally independent of the rotation applied to the font (modulo possible grid hinting effects)."},
{"description": "The Font class represents fonts, which are used to render text in a visible way.A font provides the information needed to map sequences of characters to sequences of glyphs and to render sequences of glyphs on Graphics and Component objects.Characters and Glyphs A character is a symbol that represents an item such as a letter, a digit, or punctuation in an abstract way.For example, 'g', LATIN SMALL LETTER G, is a character.A glyph is a shape used to render a character or a sequence of characters.In general, however, characters and glyphs do not have one-to-one correspondence.For example, the character '\u00e1' LATIN SMALL LETTER A WITH ACUTE, can be represented by two glyphs: one for 'a' and one for '\u00b4'.On the other hand, the two-character string \"fi\" can be represented by a single glyph, an \"fi\" ligature.In complex writing systems, such as Arabic or the South and South-East Asian writing systems, the relationship between characters and glyphs can be more complicated and involve context-dependent selection of glyphs as well as glyph reordering.A font encapsulates the collection of glyphs needed to render a selected set of characters as well as the tables needed to map sequences of characters to corresponding sequences of glyphs.The Java Platform distinguishes between two kinds of fonts: physical fonts and logical fonts.Physical fonts are the actual font libraries containing glyph data and tables to map from character sequences to glyph sequences, using a font technology such as TrueType or PostScript Type 1.All implementations of the Java Platform must support TrueType fonts; support for other font technologies is implementation dependent.Physical fonts may use names such as Helvetica, Palatino, HonMincho, or any number of other font names.Typically, each physical font supports only a limited set of writing systems, for example, only Latin characters or only Japanese and Basic Latin.The set of available physical fonts varies between configurations.Applications that require specific fonts can bundle them and instantiate them using the createFont method.Logical fonts are the five font families defined by the Java platform which must be supported by any Java runtime environment: Serif, SansSerif, Monospaced, Dialog, and DialogInput.These logical fonts are not actual font libraries.Instead, the logical font names are mapped to physical fonts by the Java runtime environment.The mapping is implementation and usually locale dependent, so the look and the metrics provided by them vary.Typically, each logical font name maps to several physical fonts in order to cover a large range of characters.Peered AWT components, such as Label and TextField, can only use logical fonts.A Font can have many faces, such as heavy, medium, oblique, gothic and regular.All of these faces have similar typographic design.There are three different names that you can get from a Font object.The logical font name is simply the name that was used to construct the font.The font face name, or just font name for short, is the name of a particular font face, like Helvetica Bold.The family name is the name of the font family that determines the typographic design across several faces, like Helvetica.The Font class represents an instance of a font face from a collection of font faces that are present in the system resources of the host system.As examples, Arial Bold and Courier Bold Italic are font faces.There can be several Font objects associated with a font face, each differing in size, style, transform and font features.The getAllFonts method of the GraphicsEnvironment class returns an array of all font faces available in the system.These font faces are returned as Font objects with a size of 1, identity transform and default font features.These base fonts can then be used to derive new Font objects with varying sizes, styles, transforms and font features via the deriveFont methods in this class.Font and TextAttribute Font supports most TextAttributes.This makes some operations, such as rendering underlined text, convenient since it is not necessary to explicitly construct a TextLayout object.Attributes can be set on a Font by constructing or deriving it using a Map of TextAttribute values.The values of some TextAttributes are not serializable, and therefore attempting to serialize an instance of Font that has such values will not serialize them.This means a Font deserialized from such a stream will not compare equal to the original Font that contained the non-serializable attributes.This should very rarely pose a problem since these attributes are typically used only in special circumstances and are unlikely to be serialized.FOREGROUND and BACKGROUND use Paint values.CHAR_REPLACEMENT uses GraphicAttribute values.INPUT_METHOD_HIGHLIGHT uses InputMethodHighlight values, which are not serializable.Clients who create custom subclasses of Paint and GraphicAttribute can make them serializable and avoid this problem.Clients who use input method highlights can convert these to the platform-specific attributes for that highlight on the current platform and set them on the Font as a workaround.The Map-based constructor and deriveFont APIs ignore the FONT attribute, and it is not retained by the Font; the static getFont(java.util.Several attributes will cause additional rendering overhead and potentially invoke layout.If a Font has such attributes, the hasLayoutAttributes() method will return true.In order to account for this (rare) possibility, font APIs are specified to return metrics and take parameters 'in baseline-relative coordinates'.This maps the 'x' coordinate to the advance along the baseline, (positive x is forward along the baseline), and the 'y' coordinate to a distance along the perpendicular to the baseline at 'x' (positive y is 90 degrees clockwise from the baseline vector).APIs for which this is especially important are called out as having 'baseline-relative coordinates.'"},
{"description": "Thrown by method createFont in the Font class to indicate that the specified font is bad."},
{"description": "A FocusTraversalPolicy defines the order in which Components with a particular focus cycle root are traversed.Instances can apply the policy to arbitrary focus cycle roots, allowing themselves to be shared across Containers.They do not need to be reinitialized when the focus cycle roots of a Component hierarchy change.The core responsibility of a FocusTraversalPolicy is to provide algorithms determining the next and previous Components to focus when traversing forward or backward in a UI.Each FocusTraversalPolicy must also provide algorithms for determining the first, last, and default Components in a traversal cycle.First and last Components are used when normal forward and backward traversal, respectively, wraps.The default Component is the first to receive focus when traversing down into a new focus traversal cycle.A FocusTraversalPolicy can optionally provide an algorithm for determining a Window's initial Component.The initial Component is the first to receive focus when a Window is first made visible.FocusTraversalPolicy takes into account focus traversal policy providers.When searching for first/last/next/previous Component, if a focus traversal policy provider is encountered, its focus traversal policy is used to perform the search operation."},
{"description": "This class has been obsoleted by the 1.4 focus APIs.While client code may still use this class, developers are strongly encouraged to use java.awt.KeyboardFocusManager and java.awt.DefaultKeyboardFocusManager instead."},
{"description": "A low-level event which indicates that a Component has gained or lost the input focus.This low-level event is generated by a Component (such as a TextField).The event is passed to every FocusListener or FocusAdapter object which registered to receive such events using the Component's addFocusListener method.( FocusAdapter objects implement the FocusListener interface.)Each such listener object gets this FocusEvent when the event occurs.There are two levels of focus events: permanent and temporary.Permanent focus change events occur when focus is directly moved from one Component to another, such as through a call to requestFocus() or as the user uses the TAB key to traverse Components.Temporary focus change events occur when focus is temporarily lost for a Component as the indirect result of another operation, such as Window deactivation or a Scrollbar drag.In this case, the original focus state will automatically be restored once that operation is finished, or, for the case of Window deactivation, when the Window is reactivated.Both permanent and temporary focus events are delivered using the FOCUS_GAINED and FOCUS_LOST event ids; the level may be distinguished in the event using the isTemporary() method.An unspecified behavior will be caused if the id parameter of any particular FocusEvent instance is not in the range from FOCUS_FIRST to FOCUS_LAST."},
{"description": "The class that is interested in processing a focus event either implements this interface (and all the methods it contains) or extends the abstract FocusAdapter class (overriding only the methods of interest).The listener object created from that class is then registered with a component using the component's addFocusListener method.When the component gains or loses the keyboard focus, the relevant method in the listener object is invoked, and the FocusEvent is passed to it."},
{"description": "A View that tries to flow it's children into some partially constrained space.This can be used to build things like paragraphs, pages, etc.The flow is made up of the following pieces of functionality.A logical set of child views, which as used as a layout pool from which a physical view is formed.A physical structure, that represents the flow.The children of this view are where the pieces of of the logical views are placed to create the flow."},
{"description": "The methods in this class are empty.This class exists as convenience for creating listener objects.(If you implement the FocusListener interface, you have to define all of the methods in it.This abstract class defines null methods for them all, so you can only have to define methods for events you care about.)When the component gains or loses the keyboard focus, the relevant method in the listener object is invoked, and the FocusEvent is passed to it."},
{"description": "A Flushable is a destination of data that can be flushed.The flush method is invoked to write any buffered output to the underlying stream."},
{"description": "The default implementation is completely stateless, and recalculates the entire flow if the layout is invalid on the given FlowView.Alternative strategies can be implemented by subclassing, and might perform incremental repair to the layout or alternative breaking behavior."},
{"description": "A Holder class for a float that is used to store \"out\" and \"inout\" parameters in IDL methods.If an IDL method signature has an IDL float as an \"out\" or \"inout\" parameter, the programmer must pass an instance of FloatHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myFloatHolder is an instance of FloatHolder, the value stored in its value field can be accessed with myFloatHolder.value."},
{"description": "A FloatControl object provides control over a range of floating-point values.Float controls are often represented in graphical user interfaces by continuously adjustable objects such as sliders or rotary knobs.Concrete subclasses of FloatControl implement controls, such as gain and pan, that affect a line's audio signal in some way that an application can manipulate.Type inner class provides static instances of types that are used to identify some common kinds of float control.The FloatControl abstract class provides methods to set and get the control's current floating-point value.Other methods obtain the possible range of values and the control's resolution (the smallest increment between returned values).Some float controls allow ramping to a new value over a specified period of time.FloatControl also includes methods that return string labels for the minimum, maximum, and midpoint positions of the control."},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "A flow layout arranges components in a directional flow, much like lines of text in a paragraph.The flow direction is determined by the container's componentOrientation property and may be one of two values: ComponentOrientation.RIGHT_TO_LEFT Flow layouts are typically used to arrange buttons in a panel.It arranges buttons horizontally until no more buttons fit on the same line.The line alignment is determined by the align property.The possible values are: LEFT RIGHT CENTER LEADING TRAILINGFor example, the following picture shows an applet using the flow layout manager (its default layout manager) to position three buttons: Here is the code for this applet: import java.awt.*; import java.applet.Applet; public class myButtons extends Applet { Button button1, button2, button3; public void init() { button1 = new Button(\"Ok\"); button2 = new Button(\"Open\"); button3 = new Button(\"Close\"); add(button1); add(button2); add(button3); } } A flow layout lets each component assume its natural (preferred) size."},
{"description": "Type inner class identifies one kind of float control.Static instances are provided for the common types."},
{"description": "This class defines four categories of operations upon float buffers:Absolute and relative get and put methods that read and write single floats; Relative bulk get methods that transfer contiguous sequences of floats from this buffer into an array; and Relative bulk put methods that transfer contiguous sequences of floats from a float array or some other float buffer into this buffer; and Methods for compacting, duplicating, and slicing a float buffer.Float buffers can be created either by allocation, which allocates space for the buffer's content, by wrapping an existing float array into a buffer, or by creating a view of an existing byte buffer.Like a byte buffer, a float buffer is either direct or non-direct.A float buffer created via the wrap methods of this class will be non-direct.A float buffer created as a view of a byte buffer will be direct if, and only if, the byte buffer itself is direct.Whether or not a float buffer is direct may be determined by invoking the isDirect method.Methods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked."},
{"description": "The Float class wraps a value of primitive type float in an object.An object of type Float contains a single field whose type is float.In addition, this class provides several methods for converting a float to a String and a String to a float, as well as other constants and methods useful when dealing with a float."},
{"description": "A FlavorMap which relaxes the traditional 1-to-1 restriction of a Map.A flavor is permitted to map to any number of natives, and likewise a native is permitted to map to any number of flavors."},
{"description": "A two-way Map between \"natives\" (Strings), which correspond to platform- specific data formats, and \"flavors\" (DataFlavors), which correspond to platform-independent MIME types."},
{"description": "Interface FlavorException is a mixin interface which a subclass of PrintException can implement to report an error condition involving a doc flavor or flavors (class DocFlavor).The Print Service API does not define any print exception classes that implement interface FlavorException, that being left to the Print Service implementor's discretion."},
{"description": "Defines an object which listens for FlavorEvents."},
{"description": "FlavorEvent is used to notify interested parties that available DataFlavors have changed in the Clipboard (the event source)."},
{"description": "This will become more open in a future release.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "FixedHolder is a container class for values of IDL type \"fixed\", which is mapped to the Java class java.math.BigDecimal.If an IDL method signature has a fixed as an \"out\" or \"inout\" parameter, the programmer must pass an instance of FixedHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the contained value corresponding to the \"out\" value returned from the server."},
{"description": "The FlatteningPathIterator class returns a flattened view of another PathIterator object.Other Shape classes can use this class to provide flattening behavior for their paths without having to perform the interpolation calculations themselves."},
{"description": "The abstract class FilterWriter itself provides default methods that pass all requests to the contained stream.Subclasses of FilterWriter should override some of these methods and may also provide additional methods and fields."},
{"description": "A FilterInputStream contains some other input stream, which it uses as its basic source of data, possibly transforming the data along the way or providing additional functionality.The class FilterInputStream itself simply overrides all methods of InputStream with versions that pass all requests to the contained input stream.Subclasses of FilterInputStream may further override some of these methods and may also provide additional methods and fields."},
{"description": "This class is the superclass of all classes that filter output streams.These streams sit on top of an already existing output stream (the underlying output stream) which it uses as its basic sink of data, but possibly transforming the data along the way or providing additional functionality.The class FilterOutputStream itself simply overrides all methods of OutputStream with versions that pass all requests to the underlying output stream.Subclasses of FilterOutputStream may further override some of these methods as well as provide additional methods and fields."},
{"description": "The standard interface that all standard implementations of FilteredRowSet must implement.The FilteredRowSetImpl class provides the reference implementation which may be extended if required.Alternatively, a vendor is free to implement its own version by implementing this interface.1.0 Background There are occasions when a RowSet object has a need to provide a degree of filtering to its contents.One possible solution is to provide a query language for all standard RowSet implementations; however, this is an impractical approach for lightweight components such as disconnected RowSet objects.The FilteredRowSet interface seeks to address this need without supplying a heavyweight query language along with the processing that such a query language would require.The CachedRowSet class provides a set of protected cursor manipulation methods, which a FilteredRowSet implementation can override to supply filtering support.If a FilteredRowSet implementation is shared using the inherited createShared method in parent interfaces, the Predicate should be shared without modification by all FilteredRowSet instance clones.3.0 Usage By implementing a Predicate (see example in Predicate class JavaDoc), a FilteredRowSet could then be used as described below.only names from \"Alpha\" to \"Bravo\" will be returned In the example above, we initialize a Range object which implements the Predicate interface.This object expresses the following constraints: All rows outputted or modified from this FilteredRowSet object must fall between the values 'Alpha' and 'Bravo' both values inclusive, in the column 'If a filter is applied to a FilteredRowSet object that contains no data that falls within the range of the filter, no rows are returned.This framework allows multiple classes implementing predicates to be used in combination to achieved the required filtering result with out the need for query language processing.The predicate set on a FilteredRowSet object applies a criterion on all rows in a RowSet object to manage a subset of rows in a RowSet object.This criterion governs the subset of rows that are visible and also defines which rows can be modified, deleted or inserted.Therefore, the predicate set on a FilteredRowSet object must be considered as bi-directional and the set criterion as the gating mechanism for all views and updates to the FilteredRowSet object.Any attempt to update the FilteredRowSet that violates the criterion will result in a SQLException object being thrown.The FilteredRowSet range criterion can be modified by applying a new Predicate object to the FilteredRowSet instance at any time.This is possible if no additional references to the FilteredRowSet object are detected.A new filter has has an immediate effect on criterion enforcement within the FilteredRowSet object, and all subsequent views and updates will be subject to similar enforcement.5.0 Behavior of Rows Outside the Filter Rows that fall outside of the filter set on a FilteredRowSet object cannot be modified until the filter is removed or a new filter is applied.Furthermore, only rows that fall within the bounds of a filter will be synchronized with the data source."},
{"description": "This class is an implementation of the ImageProducer interface which takes an existing image and a filter object and uses them to produce image data for a new filtered version of the original image.Here is an example which filters an image by swapping the red and blue compents: Image src = getImage(\"doc:///demo/images/duke/T1.gif\"); ImageFilter colorfilter = new RedBlueSwapFilter(); Image img = createImage(new FilteredImageSource(src.getSource(), colorfilter));"},
{"description": "Class Finishings is a printing attribute class, an enumeration, that identifies whether the printer applies a finishing operation of some kind of binding to each copy of each printed document in the job.For multidoc print jobs (jobs with multiple documents), the MultipleDocumentHandling attribute determines what constitutes a \"copy\" for purposes of finishing.Standard Finishings values are: \u00a0 NONEThe following Finishings values are more specific; they indicate a corner or an edge as if the document were a portrait document: \u00a0 STAPLE_TOP_LEFT EDGE_STITCH_LEFT STAPLE_DUAL_LEFT \u00a0 \u00a0 STAPLE_BOTTOM_LEFT EDGE_STITCH_TOP STAPLE_DUAL_TOP \u00a0 \u00a0 STAPLE_TOP_RIGHT EDGE_STITCH_RIGHT STAPLE_DUAL_RIGHT \u00a0 \u00a0 STAPLE_BOTTOM_RIGHT EDGE_STITCH_BOTTOM STAPLE_DUAL_BOTTOM \u00a0 The STAPLE_XXX values are specified with respect to the document as if the document were a portrait document.If the document is actually a landscape or a reverse-landscape document, the client supplies the appropriate transformed value.For example, to position a staple in the upper left hand corner of a landscape document when held for reading, the client supplies the STAPLE_BOTTOM_LEFT value (since landscape is defined as a +90 degree rotation from portrait, i.e., anti-clockwise).On the other hand, to position a staple in the upper left hand corner of a reverse-landscape document when held for reading, the client supplies the STAPLE_TOP_RIGHT value (since reverse-landscape is defined as a -90 degree rotation from portrait, i.e., clockwise).The angle (vertical, horizontal, angled) of each staple with respect to the document depends on the implementation which may in turn depend on the value of the attribute.The effect of a Finishings attribute on a multidoc print job (a job with multiple documents) depends on whether all the docs have the same binding specified or whether different docs have different bindings specified, and on the (perhaps defaulted) value of the MultipleDocumentHandling attribute.If all the docs have the same binding specified, then any value of MultipleDocumentHandling makes sense, and the printer's processing depends on the MultipleDocumentHandling value:SINGLE_DOCUMENT -- All the input docs will be bound together as one output document with the specified binding.SINGLE_DOCUMENT_NEW_SHEET -- All the input docs will be bound together as one output document with the specified binding, and the first impression of each input doc will always start on a new media sheet.SEPARATE_DOCUMENTS_UNCOLLATED_COPIES -- Each input doc will be bound separately with the specified binding.SEPARATE_DOCUMENTS_COLLATED_COPIES -- Each input doc will be bound separately with the specified binding.If different docs have different bindings specified, then only two values of MultipleDocumentHandling make sense, and the printer reports an error when the job is submitted if any other value is specified: SEPARATE_DOCUMENTS_UNCOLLATED_COPIES -- Each input doc will be bound separately with its own specified binding.SEPARATE_DOCUMENTS_COLLATED_COPIES -- Each input doc will be bound separately with its own specified binding.IPP Compatibility: Class Finishings encapsulates some of the IPP enum values that can be included in an IPP \"finishings\" attribute, which is a set of enums.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value.In IPP Finishings is a multi-value attribute, this API currently allows only one binding to be specified."},
{"description": "The abstract class FilterReader itself provides default methods that pass all requests to the contained stream.Subclasses of FilterReader should override some of these methods and may also provide additional methods and fields."},
{"description": "A Filter can be used to provide fine grain control over what is logged, beyond the control provided by log levels.Each Logger and each Handler can have a filter associated with it.The Logger or Handler will call the isLoggable method to check if a given LogRecord should be published."},
{"description": "An implementation of this interface is provided to the Files.walkFileTree methods to visit each file in a file tree.Suppose we want to delete a file tree.In that case, each directory should be deleted after the entries in the directory are deleted.Files.walkFileTree(start, new SimpleFileVisitor<Path>() { @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.delete(file); return FileVisitResult.public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {{ // directory iteration failed throw e; } } }); Furthermore, suppose we want to copy a file tree to a target location.In that case, symbolic links should be followed and the target directory should be created before the entries in the directory are copied.public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException { Path targetdir = target.resolve(source.relativize(dir)); try { Files.copy(dir, targetdir); } catch (FileAlreadyExistsException e) { if (!Files.isDirectory(targetdir))public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.copy(file, target.resolve(source.relativize(file))); return CONTINUE; } });"},
{"description": "The constructors of this class assume that the default character encoding and the default byte-buffer size are acceptable.Whether or not a file is available or may be created depends upon the underlying platform.Some platforms, in particular, allow a file to be opened for writing by only one FileWriter (or other file-writing object) at a time.In such situations the constructors in this class will fail if the file involved is already open.FileWriter is meant for writing streams of characters."},
{"description": "FileView defines an abstract class that can be implemented to provide the filechooser with UI information for a File.Each L&F JFileChooserUI object implements this class to pass back the correct icons and type descriptions specific to thatL&F. For example, the Microsoft Windows L&F returns the generic Windows icons for directories and generic files.Additionally, you may want to provide your own FileView to JFileChooser to return different icons or additional information using JFileChooser.setFileView(javax.swing.filechooser.JFileChooser first looks to see if there is a user defined FileView, if there is, it gets type information from there first.If FileView returns null for any method, JFileChooser then uses the L&F specific view to get the information.So, for example, if you provide a FileView class that returns an Icon for JPG files, and returns null icons for all other files, the UI's FileView will provide default icons for all other files."},
{"description": "A file type detector is a concrete implementation of this class, has a zero-argument constructor, and implements the abstract methods specified below.The means by which a file type detector determines the file type is highly implementation specific.A simple implementation might examine the file extension (a convention used in some platforms) and map it to a file type.In other cases, the file type may be stored as a file attribute or the bytes in a file may be examined to guess its file type."},
{"description": "The FileTypeMap is an abstract class that provides a data typing interface for files.Implementations of this class will implement the getContentType methods which will derive a content type from a file name or a File object.FileTypeMaps could use any scheme to determine the data type, from examining the file extension of a file (like the MimetypesFileTypeMap) to opening the file and trying to derive its type from the contents of the file.The FileDataSource class uses the defaultFileTypeMap (a MimetypesFileTypeMap unless changed) to determine the content type of files."},
{"description": "For example, it may represent the time that the file was last modified, accessed, or created.Instances of this class are immutable."},
{"description": "This class defines the getDefault method to get the default file system and factory methods to construct other types of file systems.The first invocation of any of the methods defined by this class causes the default provider to be loaded.The default provider, identified by the URI scheme \"file\", creates the FileSystem that provides access to the file systems accessible to the Java virtual machine.If the process of loading or initializing the default provider fails then an unspecified error is thrown.Installed providers are loaded using the service-provider loading facility defined by the ServiceLoader class.Installed providers are loaded using the system class loader.If the system class loader cannot be found then the extension class loader is used; if there is no extension class loader then the bootstrap class loader is used.Providers are typically installed by placing them in a JAR file on the application class path or in the extension directory, the JAR file contains a provider-configuration file named java.nio.file.spi.FileSystemProvider in the resource directory META-INF/services, and the file lists one or more fully-qualified names of concrete subclass of FileSystemProvider that have a zero argument constructor.If a provider is instantiated and its getScheme returns the same URI scheme of a provider that was previously instantiated then the most recently instantiated duplicate is discarded.URI schemes are compared without regard to case.During construction a provider may safely access files associated with the default provider but care needs to be taken to avoid circular loading of other installed providers.If circular loading of installed providers is detected then an unspecified error is thrown.This class also defines factory methods that allow a ClassLoader to be specified when locating a provider.As with installed providers, the provider classes are identified by placing the provider configuration file in the resource directory META-INF/services.If a thread initiates the loading of the installed file system providers and another thread invokes a method that also attempts to load the providersthen the method will block until the loading completes."},
{"description": "FileSystemView is JFileChooser's gateway to the file system.Since the JDK1.1 File API doesn't allow access to such information as root partitions, file type information, or hidden file bits, this class is designed to intuit as much OS-specific file system information as possible.Java Licensees may want to provide a different implementation of FileSystemView to better handle a given operating system."},
{"description": "The methods defined by the Files class will typically delegate to an instance of this class.A file system provider is a concrete implementation of this class that implements the abstract methods defined by this class.A provider is identified by a URI scheme.The default provider is identified by the URI scheme \"file\".It creates the FileSystem that provides access to the file systems accessible to the Java virtual machine.The default provider is typically a system-default provider but may be overridden if the system property java.nio.file.spi.DefaultFileSystemProvider is set.In that case, the provider has a one argument constructor whose formal parameter type is FileSystemProvider.All other providers have a zero argument constructor that initializes the provider.A provider is a factory for one or more FileSystem instances.Each file system is identified by a URI where the URI's scheme matches the provider's scheme.The default file system, for example, is identified by the URI \"file:///\".A memory-based file system, for example, may be identified by a URI such as \"memory:///?name=logfs\".The newFileSystem method may be used to create a file system, and the getFileSystem method may be used to obtain a reference to an existing file system created by the provider.Where a provider is the factory for a single file system then it is provider dependent if the file system is created when the provider is initialized, or later when the newFileSystem method is invoked.In the case of the default provider, the FileSystem is created when the provider is initialized.All of the methods in this class are safe for use by multiple concurrent threads."},
{"description": "Thrown when a file system operation fails on one or two files.This class is the general class for file system exceptions."},
{"description": "Runtime exception thrown when an attempt is made to create a file system that already exists."},
{"description": "The default file system, obtained by invoking the FileSystems.getDefault method, provides access to the file system that is accessible to the Java virtual machine.The FileSystems class defines methods to create file systems that provide access to other types of (custom) file systems.A file system is the factory for several types of objects: The getPath method converts a system dependent path string, returning a Path object that may be used to locate and access a file.The getPathMatcher method is used to create a PathMatcher that performs match operations on paths.The getFileStores method returns an iterator over the underlying file-stores.The getUserPrincipalLookupService method returns the UserPrincipalLookupService to lookup users or groups by name.The newWatchService method creates a WatchService that may be used to watch objects for changes and events.In some cases the file system is a single hierarchy of files with one top-level root directory.In other cases it may have several distinct file hierarchies, each with its own top-level root directory.The getRootDirectories method may be used to iterate over the root directories in the file system.A file system is typically composed of one or more underlying file-stores that provide the storage for the files.Theses file stores can also vary in the features they support, and the file attributes or meta-data that they associate with files.A file system is open upon creation and can be closed by invoking its close method.Once closed, any further attempt to access objects in the file system cause ClosedFileSystemException to be thrown.File systems created by the default provider cannot be closed.A FileSystem can provide read-only or read-write access to the file system.Whether or not a file system provides read-only access is established when the FileSystem is created and can be tested by invoking its isReadOnly method.Attempts to write to file stores by means of an object associated with a read-only file system throws ReadOnlyFileSystemException.File systems are safe for use by multiple concurrent threads.The close method may be invoked at any time to close a file system but whether a file system is asynchronously closeable is provider specific and therefore unspecified.In other words, if a thread is accessing an object in a file system, and another thread invokes the close method then it may require to block until the first operation is complete.Closing a file system causes all open channels, watch services, and other closeable objects associated with the file system to be closed."},
{"description": "The constructors of this class assume that the default character encoding and the default byte-buffer size are appropriate.FileReader is meant for reading streams of characters."},
{"description": "An attribute view that is a read-only or updatable view of the attributes of a FileStore."},
{"description": "A FileStore represents a storage pool, device, partition, volume, concrete file system or other implementation specific means of file storage.The FileStore for where a file is stored is obtained by invoking the getFileStore method, or all file stores can be enumerated by invoking the getFileStores method.In addition to the methods defined by this class, a file store may support one or more FileStoreAttributeView classes that provide a read-only or updatable view of a set of file store attributes."},
{"description": "Indicates a Filer detected an attempt to open a file that would violate the guarantees provided by the Filer.Those guarantees include not creating the same file more than once, not creating multiple files corresponding to the same type, and not creating files for types with invalid names."},
{"description": "This class represents access to a file or directory.A FilePermission consists of a pathname and a set of actions valid for that pathname.Pathname is the pathname of the file or directory granted the specified actions.*\" (where \"/\" is the file separator character, File.separatorChar) indicates all the files and directories contained in that directory.A pathname consisting of the special token \"<<ALL FILES>>\" matches any file.A pathname consisting of a single \"*\" indicates all the files in the current directory, while a pathname consisting of a single \"-\" indicates all the files in the current directory and (recursively) all files and subdirectories contained in the current directory.The actions to be granted are passed to the constructor in a string containing a list of one or more comma-separated keywords.read read permission write write permission execute execute permission.The actions string is converted to lowercase before processing.The \"<<ALL FILES>>\" permission with write action is especially dangerous.One thing this effectively allows is replacement of the system binary, including the JVM runtime environment.Please note: Code can always read a file from the same directory it's in (or a subdirectory of that directory); it does not need explicit permission to do so."},
{"description": "This interface supports the creation of new files by an annotation processor.Files created in this way will be known to the annotation processing tool implementing this interface, better enabling the tool to manage them.Source and class files so created will be considered for processing by the tool in a subsequent round of processing after the close method has been called on the Writer or OutputStream used to write the contents of the file.Three kinds of files are distinguished: source files, class files, and auxiliary resource files.There are two distinguished supported locations (subtrees within the logical file system) where newly created files are placed: one for new source files, and one for new class files.(These might be specified on a tool's command line, for example, using flags such as -s and -d.)The actual locations for new source files and new class files may or may not be distinct on a particular run of the tool.Resource files may be created in either location.The methods for reading and writing resources take a relative name argument.A relative name is a non-null, non-empty sequence of path segments separated by '/'; '.'A valid relative name must match the \"path-rootless\" rule of RFC 3986, section 3.3.The file creation methods take a variable number of arguments to allow the originating elements to be provided as hints to the tool infrastructure to better manage dependencies.The originating elements are the types or packages (representing package-info files) which caused an annotation processor to attempt to create a new file.For example, if an annotation processor tries to create a source file, GeneratedFromUserSource, in response to processing @Generate public class UserSource {} the type element for UserSource should be passed as part of the creation method call as in: filer.createSourceFile(\"GeneratedFromUserSource\", eltUtils.getTypeElement(\"UserSource\")); If there are no originating elements, none need to be passed.This information may be used in an incremental environment to determine the need to rerun processors or remove generated files.Non-incremental environments may ignore the originating element information.During each run of an annotation processing tool, a file with a given pathname may be created only once.If that file already exists before the first attempt to create it, the old contents will be deleted.Any subsequent attempt to create the same file during a run will throw a FilerException, as will attempting to create both a class file and source file for the same type name or same package name.The initial inputs to the tool are considered to be created by the zeroth round; therefore, attempting to create a source or class file corresponding to one of those inputs will result in a FilerException.In general, processors must not knowingly attempt to overwrite existing files that were not generated by some processor.A Filer may reject attempts to open a file corresponding to an existing type, like java.lang.Object.Likewise, the invoker of the annotation processing tool must not knowingly configure the tool such that the discovered processors will attempt to overwrite existing files that were not generated.Processors can indicate a source or class file is generated by including an @Generated annotation.Note that some of the effect of overwriting a file can be achieved by using a decorator-style pattern.Instead of modifying a class directly, the class is designed so that either its superclass is generated by annotation processing or subclasses of the class are generated by annotation processing.If the subclasses are generated, the parent class may be designed to use factories instead of public constructors so that only subclass instances would be presented to clients of the parent class."},
{"description": "A file attribute view that supports reading or updating the owner of a file.This file attribute view is intended for file system implementations that support a file attribute that represents an identity that is the owner of the file.Often the owner of a file is the identity of the entity that created the file.The getOwner or setOwner methods may be used to read or update the owner of the file.The getAttribute and setAttribute methods may also be used to read or update the owner.In that case, the owner attribute is identified by the name \"owner\", and the value of the attribute is a UserPrincipal."},
{"description": "A simple interface which provides a mechanism to map between a file name and a MIME type string."},
{"description": "Signals that an attempt to open the file denoted by a specified pathname has failed.This exception will be thrown by the FileInputStream, FileOutputStream, andRandomAccessFile constructors when a file with the specified pathname does not exist.It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing."},
{"description": "In this context, file means an abstraction of regular files and other sources of data.For example, a file object can be used to represent regular files, memory cache, or data in databases.All methods in this interface might throw a SecurityException if a security exception occurs.Unless explicitly allowed, all methods in this interface might throw a NullPointerException if given a null argument."},
{"description": "A file output stream is an output stream for writing data to a File or to a FileDescriptor.Whether or not a file is available or may be created depends upon the underlying platform.Some platforms, in particular, allow a file to be opened for writing by only one FileOutputStream (or other file-writing object) at a time.In such situations the constructors in this class will fail if the file involved is already open.FileOutputStream is meant for writing streams of raw bytes such as image data."},
{"description": "Instances of classes that implement this interface are used to filter filenames.These instances are used to filter directory listings in the list method of class File, and by the Abstract Window Toolkit's file dialog component."},
{"description": "Checked exception received by a thread when another thread interrupts it while it is waiting to acquire a file lock.Before this exception is thrown the interrupt status of the previously-blocked thread will have been set."},
{"description": "An implementation of FileFilter that filters using a specified set of extensions.The extension for a file is the portion of the file name after the last \".\".Files whose name does not contain a \".\" have no file name extension.The following example creates a FileNameExtensionFilter that will show jpg files: FileFilter filter = new FileNameExtensionFilter(\"JPEG file\", \"jpg\", \"jpeg\"); JFileChooser fileChooser = ...; fileChooser.addChoosableFileFilter(filter);"},
{"description": "This class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations."},
{"description": "A FileInputStream obtains input bytes from a file in a file system.What files are available depends on the host environment.FileInputStream is meant for reading streams of raw bytes such as image data."},
{"description": "A file-lock object is created each time a lock is acquired on a file via one of the lock or tryLock methods of the FileChannel class, or the lock or tryLock methods of the AsynchronousFileChannel class.It remains valid until the lock is released by invoking the release method, by closing the channel that was used to acquire it, or by the termination of the Java virtual machine, whichever comes first.The validity of a lock may be tested by invoking its isValid method.A shared lock prevents other concurrently-running programs from acquiring an overlapping exclusive lock, but does allow them to acquire overlapping shared locks.An exclusive lock prevents other programs from acquiring an overlapping lock of either type.Once it is released, a lock has no further effect on the locks that may be acquired by other programs.Whether a lock is exclusive or shared may be determined by invoking its isShared method.Some platforms do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.The locks held on a particular file by a single Java virtual machine do not overlap.The overlaps method may be used to test whether a candidate lock range overlaps an existing lock.A file-lock object records the file channel upon whose file the lock is held, the type and validity of the lock, and the position and size of the locked region.Only the validity of a lock is subject to change over time; all other aspects of a lock's state are immutable.File locks are held on behalf of the entire Java virtual machine.They are not suitable for controlling access to a file by multiple threads within the same virtual machine.File-lock objects are safe for use by multiple concurrent threads.Platform dependencies This file-locking API is intended to map directly to the native locking facility of the underlying operating system.Thus the locks held on a file should be visible to all programs that have access to the file, regardless of the language in which those programs are written.Whether or not a lock actually prevents another program from accessing the content of the locked region is system-dependent and therefore unspecified.The native file-locking facilities of some systems are merely advisory, meaning that programs must cooperatively observe a known locking protocol in order to guarantee data integrity.On other systems native file locks are mandatory, meaning that if one program locks a region of a file then other programs are actually prevented from accessing that region in a way that would violate the lock.On yet other systems, whether native file locks are advisory or mandatory is configurable on a per-file basis.To ensure consistent and correct behavior across platforms, it is strongly recommended that the locks provided by this API be used as if they were advisory locks.Programs that combine locking and mapping should be prepared for this combination to fail.On some systems, closing a channel releases all locks held by the Java virtual machine on the underlying file regardless of whether the locks were acquired via that channel or via another channel open on the same file.It is strongly recommended that, within a program, a unique channel be used to acquire all locks on any given file.Some network filesystems permit file locking to be used with memory-mapped files only when the locked regions are page-aligned and a whole multiple of the underlying hardware's page size.Some network filesystems do not implement file locks on regions that extend past a certain position, often 230 or 231.In general, great care should be taken when locking files that reside on network filesystems."},
{"description": "ImageOutputStream that writes its output directly to a File or RandomAccessFile."},
{"description": "An implementation of ImageInputStream that gets its input from a File or RandomAccessFile.The file contents are assumed to be stable during the lifetime of the object."},
{"description": "FileFilter is an abstract class used by JFileChooser for filtering the set of files shown to the user.See FileNameExtensionFilter for an implementation that filters using the file name extension.A FileFilter can be set on a JFileChooser to keep unwanted files from appearing in the directory listing."},
{"description": "Instances of this interface may be passed to the listFiles(FileFilter) method of the File class."},
{"description": "The FileHandler can either write to a specified file, or it can write to a rotating set of files.For a rotating set of files, as each file reaches a given size limit, it is closed, rotated out, and a new file opened.Successively older files are named by adding \"0\", \"1\", \"2\", etc.By default buffering is enabled in the IO libraries but each log record is flushed out when it is complete.By default the XMLFormatter class is used for formatting.By default each FileHandler is initialized using the following LogManager configuration properties where <handler-name> refers to the fully-qualified class name of the handler.If properties are not defined (or have invalid values) then the specified default values are used.<handler-name>.filter specifies the name of a Filter class to use (defaults to no Filter).<handler-name>.encoding the name of the character set encoding to use (defaults to the default platform encoding).If this is zero, then there is no limit.<handler-name>.pattern specifies a pattern for generating the output file name.<handler-name>.append specifies whether the FileHandler should append onto any existing files (defaults to false).For example, the properties for FileHandler would be: java.util.logging.FileHandler.level=INFO java.util.logging.FileHandler.formatter=java.util.logging.SimpleFormatterFor a custom handler, e.g. com.foo.MyHandler, the properties would be: com.foo.MyHandler.level=INFO com.foo.MyHandler.formatter=java.util.logging.SimpleFormatterA pattern consists of a string that includes the following special components that will be replaced at runtime: \"/\" the local pathname separator \"%t\" the system temporary directory \"%h\" the value of the \"user.home\" system property \"%g\" the generation number to distinguish rotated logs \"%u\" a unique number to resolve conflicts \"%%\" translates to a single percent sign \"%\" If no \"%g\" field has been specified and the file count is greater than one, then the generation number will be added to the end of the generated filename, after a dot.Thus for example a pattern of \"%t/java%g.log\" with a count of 2 would typically cause log files to be written on Solaris to /var/whereas on Windows 95 they would be typically written to C:\\TEMP\\java0.log and C:\\TEMP\\java1.log Generation numbersNormally the \"%u\" unique field is set to 0.However, if the FileHandler tries to open the filename and finds the file is currently in use by another process it will increment the unique number field and try again.This will be repeated until FileHandler finds a file name that is not currently in use.If there is a conflict and no \"%u\" field has been specified, it will be added at the end of the filename after a dot.(This will be after any automatically added generation number.)Thus if three processes were all trying to log to fred%u.%g.txt then they might end up using fred0.0.txt, fred1.0.txt, fred2.0.txt as the first file in their rotating sequences.Note that the use of unique ids to avoid conflicts is only guaranteed to work reliably when using a local disk file system."},
{"description": "Instances of the file descriptor class serve as an opaque handle to the underlying machine-specific structure representing an open file, an open socket, or another source or sink of bytes.The main practical use for a file descriptor is to create a FileInputStream or FileOutputStream to contain it.Applications should not create their own file descriptors."},
{"description": "The FileDataSource class implements a simple DataSource object that encapsulates a file.It provides data typing services via a FileTypeMap object.The setFileTypeMap method can be used to explicitly set the FileTypeMap for an instance of FileDataSource.If no FileTypeMap is set, the FileDataSource will call the FileTypeMap's getDefaultFileTypeMap method to get the System's default FileTypeMap."},
{"description": "An implementation of ImageInputStream that gets its input from a regular InputStream.A file is used to cache previously read data."},
{"description": "ImageOutputStream that writes its output to a regular OutputStream.A file is used to cache data until it is flushed to the output stream."},
{"description": "A file channel is a SeekableByteChannel that is connected to a file.It has a current position within its file which can be both queried and modified.The file itself contains a variable-length sequence of bytes that can be read and written and whose current size can be queried.The size of the file increases when bytes are written beyond its current size; the size of the file decreases when it is truncated.The file may also have some associated metadata such as access permissions, content type, and last-modification time; this class does not define methods for metadata access.In addition to the familiar read, write, and close operations of byte channels, this class defines the following file-specific operations: Bytes may be read or written at an absolute position in a file in a way that does not affect the channel's current position.A region of a file may be mapped directly into memory; for large files this is often much more efficient than invoking the usual read or write methods.Updates made to a file may be forced out to the underlying storage device, ensuring that data are not lost in the event of a system crash.Bytes can be transferred from a file to some other channel, and vice versa, in a way that can be optimized by many operating systems into a very fast transfer directly to or from the filesystem cache.A region of a file may be locked against access by other programs.File channels are safe for use by multiple concurrent threads.The close method may be invoked at any time, as specified by the Channel interface.Only one operation that involves the channel's position or can change its file's size may be in progress at any given time; attempts to initiate a second such operation while the first is still in progress will block until the first operation completes.Other operations, in particular those that take an explicit position, may proceed concurrently; whether they in fact do so is dependent upon the underlying implementation and is therefore unspecified.The view of a file provided by an instance of this class is guaranteed to be consistent with other views of the same file provided by other instances in the same program.The view provided by an instance of this class may or may not, however, be consistent with the views seen by other concurrently-running programs due to caching performed by the underlying operating system and delays induced by network-filesystem protocols.This is true regardless of the language in which these other programs are written, and whether they are running on the same machine or on some other machine.The exact nature of any such inconsistencies are system-dependent and are therefore unspecified.A file channel is created by invoking one of the open methods defined by this class.A file channel can also be obtained from an existing FileInputStream, FileOutputStream, or RandomAccessFile object by invoking that object's getChannel method, which returns a file channel that is connected to the same underlying file.Where the file channel is obtained from an existing stream or random access file then the state of the file channel is intimately connected to that of the object whose getChannel method returned the channel.Changing the file's length via the file channel will change the length seen via the originating object, and vice versa.Changing the file's content by writing bytes will change the content seen by the originating object, and vice versa.At various points this class specifies that an instance that is \"open for reading,\" \"open for writing,\" or \"open for reading and writing\" is required.A channel obtained via the getChannel method of a FileInputStream instance will be open for reading.A channel obtained via the getChannel method of a FileOutputStream instance will be open for writing.Finally, a channel obtained via the getChannel method of a RandomAccessFile instance will be open for reading if the instance was created with mode \"r\" and will be open for reading and writing if the instance was created with mode \"rw\".A file channel that is open for writing may be in append mode, for example if it was obtained from a file-output stream that was created by invoking the FileOutputStream(File,boolean) constructor and passing true for the second parameter.In this mode each invocation of a relative write operation first advances the position to the end of the file and then writes the requested data.Whether the advancement of the position and the writing of the data are done in a single atomic operation is system-dependent and therefore unspecified."},
{"description": "An attribute view that is a read-only or updatable view of non-opaque values associated with a file in a filesystem.This interface is extended or implemented by specific file attribute views that define methods to read and/or update the attributes of a file."},
{"description": "Checked exception thrown when an attempt is made to create a file or directory and a file of that name already exists."},
{"description": "An object that encapsulates the value of a file attribute that can be set atomically when creating a new file or directory by invoking the createFile or createDirectory methods."},
{"description": "User interfaces and operating systems use system-dependent pathname strings to name files and directories.This class presents an abstract, system-independent view of hierarchical pathnames.An abstract pathname has two components: An optional system-dependent prefix string, such as a disk-drive specifier, \"/The first name in an abstract pathname may be a directory name or, in the case of Microsoft Windows UNC pathnames, a hostname.Each subsequent name in an abstract pathname denotes a directory; the last name may denote either a directory or a file.The empty abstract pathname has no prefix and an empty name sequence.The conversion of a pathname string to or from an abstract pathname is inherently system-dependent.When an abstract pathname is converted into a pathname string, each name is separated from the next by a single copy of the default separator character.The default name-separator character is defined by the system property file.separator, and is made available in the public static fields separator and separatorChar of this class.When a pathname string is converted into an abstract pathname, the names within it may be separated by the default name-separator character or by any other name-separator character that is supported by the underlying system.An absolute pathname is complete in that no other information is required in order to locate the file that it denotes.A relative pathname, in contrast, must be interpreted in terms of information taken from some other pathname.By default the classes in the java.io package always resolve relative pathnames against the current user directory.This directory is named by the system property user.dir, and is typically the directory in which the Java virtual machine was invoked.The parent of an abstract pathname may be obtained by invoking the getParent() method of this class and consists of the pathname's prefix and each name in the pathname's name sequence except for the last.Each directory's absolute pathname is an ancestor of any File object with an absolute abstract pathname which begins with the directory's absolute pathname.For example, the directory denoted by the abstract pathname \"/usr\" is an ancestor of the directory denoted by the pathname \"/usr/local/bin\".The prefix concept is used to handle root directories on UNIX platforms, and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms, as follows: For UNIX platforms, the prefix of an absolute pathname is always \"/\".Relative pathnames have no prefix.The abstract pathname denoting the root directory has the prefix \"/\" and an empty name sequence.For Microsoft Windows platforms, the prefix of a pathname that contains a drive specifier consists of the drive letter followed by \":\" and possibly followed by \"\\\\\" if the pathname is absolute.The prefix of a UNC pathname is \"\\\\\\\\\"; the hostname and the share name are the first two names in the name sequence.A relative pathname that does not specify a drive has no prefix.Instances of this class may or may not denote an actual file-system object such as a file or a directory.If it does denote such an object then that object resides in a partition.A partition is an operating system-specific portion of storage for a file system.A single storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may contain multiple partitions.The object, if any, will reside on the partition named by some ancestor of the absolute form of this pathname.A file system may implement restrictions to certain operations on the actual file-system object, such as reading, writing, and executing.These restrictions are collectively known as access permissions.The file system may have multiple sets of access permissions on a single object.For example, one set may apply to the object's owner, and another may apply to all other users.The access permissions on an object may cause some methods in this class to fail.Instances of the File class are immutable; that is, once created, the abstract pathname represented by a File object will never change.The java.nio.file package defines interfaces and classes for the Java virtual machine to access files, file attributes, and file systems.This API may be used to overcome many of the limitations of the java.io.File class.The toPath method may be used to obtain a Path that uses the abstract path represented by a File object to locate a file.The resulting Path may be used with the Files class to provide more efficient and extensive access to additional file operations, file attributes, and I/O exceptions to help diagnose errors when an operation on a file fails."},
{"description": "If the view is allocated extra space, the field must adjust for it.If the hosting component is a JTextField, this view will manage the ranges of the associated BoundedRangeModel and will adjust the horizontal allocation to match the current visibility settings of the JTextField."},
{"description": "FieldPosition is a simple class used by Format and its subclasses to identify fields in formatted output.Fields can be identified in two ways:By an integer constant, whose names typically end with _FIELD.The constants are defined in the various subclasses of Format.FieldPosition keeps track of the position of the field within the formatted output with two indices: the index of the first character of the field and the index of the last character of the field.One version of the format method in the various Format classes requires a FieldPosition object as an argument.You use this format method to perform partial formatting or to get information about the formatted output (such as the position of a field).If you are interested in the positions of all attributes in the formatted string use the Format method formatToCharacterIterator."},
{"description": "The FileDialog class displays a dialog window from which the user can select a file.Since it is a modal dialog, when the application calls its show method to display the dialog, it blocks the rest of the application until the user has chosen a file."},
{"description": "A Field provides information about, and dynamic access to, a single field of a class or an interface.The reflected field may be a class (static) field or an instance field.A Field permits widening conversions to occur during a get or set access operation, but throws an IllegalArgumentException if a narrowing conversion would occur."},
{"description": "The FeatureDescriptor class is the common baseclass for PropertyDescriptor, EventSetDescriptor, and MethodDescriptor, etc.It supports some common information that can be set and retrieved for any of the introspection descriptors.In addition it provides an extension mechanism so that arbitrary attribute/value pairs can be associated with a design feature."},
{"description": "Class Fidelity is a printing attribute class, an enumeration, that indicates whether total fidelity to client supplied print request attributes is required.If FIDELITY_TRUE is specified and a service cannot print the job exactly as specifiedit must reject the job.If FIDELITY_FALSE is specified a reasonable attempt to print the job is acceptable.IPP Compatibility: The IPP boolean value is \"true\" for FIDELITY_TRUE and \"false\" for FIDELITY_FALSE.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "Signals that user authentication failed.This exception is thrown by LoginModules if authentication failed.For example, a LoginModule throws this exception if the user entered an incorrect password."},
{"description": "The FaultAction annotation is used inside an Action annotation to allow an explicit association of a WS-Addressing Action message addressing property with the fault messages of the WSDL operation mapped from the exception class.The wsam:Action attribute value in the fault message in the generated WSDL operation mapped for className class is equal to the corresponding value in the FaultAction.For the exact computation of wsam:Action values for the fault messages, refer to the algorithm in the JAX-WS specification.Example 1: Specify explicit values for Action message addressing property for the input, output and fault message if the Java method throws only one service specific exception.: Here is an example that shows if the explicit value for Action message addressing property for the service specific exception is not present.: Here is an example that shows how to specify explicit values for Action message addressing property if the Java method throws more than one service specific exception.AddNumbersException, TooBigNumbersException { return number1 + number2; } } The generated WSDL looks like: <definitions targetNamespace=\"http://example.com/numbers\" ..."},
{"description": "Thrown when a problem with configuration with the Parser Factories exists.This error will typically be thrown when the class of a parser factory specified in the system properties cannot be found or instantiated."},
{"description": "Only the identity of the class of an Externalizable instance is written in the serialization stream and it is the responsibility of the class to save and restore the contents of its instances.The writeExternal and readExternal methods of the Externalizable interface are implemented by a class to give the class complete control over the format and contents of the stream for an object and its supertypes.These methods must explicitly coordinate with the supertype to save its state.These methods supersede customized implementations of writeObject and readObject methods.Object Serialization uses the Serializable and Externalizable interfaces.Object persistence mechanisms can use them as well.Each object to be stored is tested for the Externalizable interface.If the object supports Externalizable, the writeExternal method is called.If the object does not support Externalizable and does implement Serializable, the object is saved using ObjectOutputStream.When an Externalizable object is reconstructed, an instance is created using the public no-arg constructor, then the readExternal method called.Serializable objects are restored by reading them from an ObjectInputStream.An Externalizable instance can designate a substitution object via the writeReplace and readResolve methods documented in the Serializable interface."},
{"description": "This interface represents an X.509 extension.Extensions provide a means of associating additional attributes with users or public keys and for managing a certification hierarchy.The extension format also allows communities to define private extensions to carry information unique to those communities.Each extension contains an object identifier, a criticality setting indicating whether it is a critical or a non-critical extension, and and an ASN.1 DER-encoded value.Its ASN.1 definition is: Extension ::=SEQUENCE { extnId OBJECT IDENTIFIER, critical BOOLEAN DEFAULT FALSE, extnValue OCTET STRING -- contains a DER encoding of a value -- of the type registered for use with -- the extnId object identifier value }This interface is designed to provide access to a single extension, unlike X509Extension which is more suitable for accessing a set of extensions."},
{"description": "This interface represents an LDAP extended operation response as defined in RFC 2251.It comprises an optional object identifier and an optional ASN.1 BER encoded value.The methods in this class can be used by the application to get low level information about the extended operation response.However, typically, the application will be using methods specific to the class that implements this interface.Such a class should have decoded the BER buffer in the response and should provide methods that allow the user to access that data in the response in a type-safe and friendly manner.For example, suppose the LDAP server supported a 'get time' extended operation.It would supply GetTimeRequest and GetTimeResponse classes.The GetTimeResponse class might look like: public class GetTimeResponse implements ExtendedResponse { public java.util.Date getDate() {...}; public long getTime() {...}; .... } A program would use then these classes as follows:(GetTimeResponse) ectx.extendedOperation(new GetTimeRequest());"},
{"description": "An ExportException is a RemoteException thrown if an attempt to export a remote object fails.A remote object is exported via the constructors and exportObject methods of java.rmi.server.UnicastRemoteObject and java.rmi.activation.Activatable."},
{"description": "Exception used to stop and expand/collapse from happening."},
{"description": "This interface represents an LDAPv3 extended operation request as defined in RFC 2251.It comprises an object identifier string and an optional ASN.1 BER encoded value.The methods in this class are used by the service provider to construct the bits to send to the LDAP server.Applications typically only deal with the classes that implement this interface, supplying them with any information required for a particular extended operation request.It would then pass such a class as an argument to the LdapContext.extendedOperation() method for performing the LDAPv3 extended operation.For example, suppose the LDAP server supported a 'get time' extended operation.It would supply GetTimeRequest and GetTimeResponse classes: public class GetTimeRequest implements ExtendedRequest { public GetTimeRequest() {... }; public ExtendedResponse createExtendedResponse(String id, byte[]throws NamingException { return new GetTimeResponse(id, berValue, offset, length); } ...} public class GetTimeResponse implements ExtendedResponse { long time;() { return new java.util.Date(time) }; public long getTime() { return time }; ... } A program would use then these classes as follows:(GetTimeResponse) ectx.extendedOperation(new GetTimeRequest()); long time = resp.getTime"},
{"description": "An Expression object represents a primitive expression in which a single method is applied to a target and a set of arguments to return a result - as in \"a.getFoo()\".In addition to the properties of the super class, the Expression object provides a value which is the object returned when this expression is evaluated.The return value is typically not provided by the caller and is instead computed by dynamically finding the method and invoking it when the first call to getValue is made."},
{"description": "This class defines the Service Provider Interface (SPI) for the ExemptionMechanism class.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular exemption mechanism."},
{"description": "This is the generic ExemptionMechanism exception."},
{"description": "This class provides the functionality of an exemption mechanism, examples of which are key recovery, key weakening, and key escrow.Applications or applets that use an exemption mechanism may be granted stronger encryption capabilities than those which don't."},
{"description": "An Executor that provides methods to manage termination and methods that can produce a Future for tracking progress of one or more asynchronous tasks.An ExecutorService can be shut down, which will cause it to reject new tasks.Two different methods are provided for shutting down an ExecutorService.The shutdown() method will allow previously submitted tasks to execute before terminating, while the shutdownNow() method prevents waiting tasks from starting and attempts to stop currently executing tasks.Upon termination, an executor has no tasks actively executing, no tasks awaiting execution, and no new tasks can be submitted.An unused ExecutorService should be shut down to allow reclamation of its resources.Method submit extends base method Executor.execute(Runnable) by creating and returning a Future that can be used to cancel execution and/or wait for completion.Methods invokeAny and invokeAll perform the most commonly useful forms of bulk execution, executing a collection of tasks and then waiting for at least one, or all, to complete.(Class ExecutorCompletionService can be used to write customized variants of these methods.)The Executors class provides factory methods for the executor services provided in this package.Usage Examples Here is a sketch of a network service in which threads in a thread pool service incoming requests.It uses the preconfigured Executors.newFixedThreadPool(int) factory method: class NetworkService implementsRunnable { private final ServerSocket serverSocket; private final ExecutorService pool; public NetworkService(int port, int poolSize) throws IOException { serverSocket = new ServerSocket(port);pool = Executors.newFixedThreadPool(poolSize); } public void run() { // run the service try { for (;;) { pool.execute(new Handler(serverSocket.accept())); } } catch (IOException ex) { pool.shutdown(); } } } class Handler implements Runnable { private final Socket socket; Handler(Socket socket) { this.socket = socket; } public void run() { // read and service request on socket } }The following method shuts down an ExecutorService in two phases, first by calling shutdown to reject incoming tasks, and then calling shutdownNow, if necessary, to cancel any lingering tasks: void shutdownAndAwaitTermination(ExecutorService pool) { pool.shutdown(); //Disable new tasks from being submitted try { // Wait a while for existing tasks to terminatepool.shutdownNow(); // Preserve interrupt status Thread.currentThread().interrupt(); } } Memory consistency effects: Actions in a thread prior to the submission of a Runnable or Callable task to an ExecutorService happen-before any actions taken by that task, which in turn happen-before the result is retrieved via Future.get()."},
{"description": "Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception.This exception can be inspected using the Throwable.getCause() method."},
{"description": "An object that executes submitted Runnable tasks.This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc.An Executor is normally used instead of explicitly creating threads.For example, rather than invoking new Thread(new(RunnableTask())).start() for each of a set of tasks, you might use: Executor executor = anExecutor; executor.execute(new RunnableTask1()); executor.execute(new RunnableTask2()); ... However, the Executor interface does not strictly require that execution be asynchronous.In the simplest case, an executor can run the submitted task immediately in the caller's thread: class DirectExecutor implements Executor { public void execute(Runnable r) { r.run(); } } More typically, tasks are executed in some thread other than the caller's thread.The executor below spawns a new thread for each task.class ThreadPerTaskExecutor implements Executor { public void execute(Runnable r) { new Thread(r).start(); } } Many Executor implementations impose some sort of limitation on how and when tasks are scheduled.The executor below serializes the submission of tasks to a second executor, illustrating a composite executor.final Executor executor; Runnable active; SerialExecutor(Executor executor) { this.executor = executor; } public synchronized void execute(final Runnable r) { tasks.offer(newRunnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (active == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((active = tasks.poll()) != null) { executor.execute(active); } } } The Executor implementations provided in this package implement ExecutorService, which is a more extensive interface.The ThreadPoolExecutor class provides an extensible thread pool implementation.The Executors class provides convenient factory methods for these Executors.Actions in a thread prior to submitting a Runnable object to an Executor happen-before its execution begins, perhaps in another thread."},
{"description": "This class supports the following kinds of methods: Methods that create and return an ExecutorService set up with commonly useful configuration settings.Methods that create and return a ScheduledExecutorService set up with commonly useful configuration settings.Methods that create and return a \"wrapped\" ExecutorService, that disables reconfiguration by making implementation-specific methods inaccessible.Methods that create and return a ThreadFactory that sets newly created threads to a known state.Methods that create and return a Callable out of other closure-like forms, so they can be used in execution methods requiring Callable."},
{"description": "A CompletionService that uses a supplied Executor to execute tasks.This class arranges that submitted tasks are, upon completion, placed on a queue accessible using take.The class is lightweight enough to be suitable for transient use when processing groups of tasks.Suppose you have a set of solvers for a certain problem, each returning a value of some type Result, and would like to run them concurrently, processing the results of each of them that return a non-null value, in some method use(Result r).You could write this as: void solve(Executor e, Collection<Callable<Result>> solvers) throws InterruptedException, ExecutionException { CompletionService<Result> ecs = new ExecutorCompletionService<Result>(e); for (Callable<Result> s : solvers) ecs.submit(s); int n = solvers.size(); for (int i = 0; i < n; ++i) { Result r = ecs.take().get(); if (r != null)use(r); } } Suppose instead that you would like to use the first non-null result of the set of tasks, ignoring any that encounter exceptions, and cancelling all other tasks when the first one is ready:Collection<Callable<Result>> solvers) throws InterruptedException { CompletionService<Result> ecs = new ExecutorCompletionService<Result>(e); int n = solvers.size();List<Future<Result>> futures =try { for (Callable<Result> s : solvers) futures.add(ecs.submit(s)); for (int i = 0; i < n; ++i) { try { Result r = ecs.take().get(); if (r != null) { result = r; break; } } catch (ExecutionException ignore) {} } } finally { for (Future<Result>"},
{"description": "An executable is a method, constructor, or initializer.The executable is represented as when viewed as a method (or constructor or initializer) of some reference type.If that reference type is parameterized, then its actual type arguments are substituted into any types returned by the methods of this interface."},
{"description": "A synchronization point at which threads can pair and swap elements within pairs.Each thread presents some object on entry to the exchange method, matches with a partner thread, and receives its partner's object on return.An Exchanger may be viewed as a bidirectional form of a SynchronousQueue.Exchangers may be useful in applications such as genetic algorithms and pipeline designs.Sample Usage: Here are the highlights of a class that uses an Exchanger to swap buffers between threads so that the thread filling the buffer gets a freshly emptied one when it needs it, handing off the filled one to the thread emptying the buffer.} } catch (InterruptedException ex) { ... handle ...} } } void start() { new Thread(new FillingLoop()).start();new Thread(new EmptyingLoop()).start(); } } Memory consistency effects: For each pair of threads that successfully exchange objects via an Exchanger, actions prior to the exchange() in each thread happen-before those subsequent to a return from the corresponding exchange() in the other thread."},
{"description": "Signals that an unexpected exception has occurred in a static initializer.An ExceptionInInitializerError is thrown to indicate that an exception occurred during evaluation of a static initializer or the initializer for a static variable.As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.The \"saved throwable object\" that may be provided at construction time and accessed via the getException() method is now known as the cause, and may be accessed via the Throwable.getCause() method, as well as the aforementioned \"legacy method.\""},
{"description": "An object used in Request operations to describe the exceptions that can be thrown by a method.It maintains a modifiable list of TypeCodes of the exceptions.(); The variable excList represents an ExceptionList object with no TypeCode objects in it.To add items to the list, you first create a TypeCode object for the exception you want to include, using the ORB method create_exception_tc.Then you use the ExceptionList method add to add it to the list.The class ExceptionList has a method for getting the number of TypeCode objects in the list, and after items have been added, it is possible to call methods for accessing or deleting an item at a designated index."},
{"description": "An ExceptionListener is notified of internal exceptions."},
{"description": "The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to catch.The class Exception and any subclasses that are not also subclasses of RuntimeException are checked exceptions.Checked exceptions need to be declared in a method or constructor's throws clause if they can be thrown by the execution of the method or constructor and propagate outside the method or constructor boundary."},
{"description": "The parameters include an optional inclusive namespace prefix list.The XML Schema Definition of the Exclusive XML Canonicalization parameters is defined as: <schema xmlns=\"http://www.w3.org/2001/XMLSchema\" xmlns:ec=\"http://www.w3.org/2001/10/xml-exc"},
{"description": "An EventSetDescriptor describes a group of events that a given Java bean fires.The given group of events are all delivered as method calls on a single event listener interface, and an event listener object can be registered via a call on a registration method supplied by the event source."},
{"description": "The EventTarget interface is implemented by all Nodes in an implementation which supports the DOM Event Model.Therefore, this interface can be obtained by using binding-specific casting methods on an instance of the Node interface.The interface allows registration and removal of EventListeners on an EventTarget and dispatch of events to that EventTarget."},
{"description": "EventQueue is a platform-independent class that queues events, both from the underlying peer classes and from trusted application classes.It encapsulates asynchronous event dispatch machinery which extracts events from the queue and dispatches them by calling dispatchEvent(AWTEvent) method on this EventQueue with the event to be dispatched as an argument.The particular behavior of this machinery is implementation-dependent.The only requirements are that events which were actually enqueued to this queue (note that events being posted to the EventQueue can be coalesced) are dispatched: Sequentially.That is, it is not permitted that several events from this queue are dispatched simultaneously.In the same order as they are enqueued.That is, if AWTEvent\u00a0A is enqueued to the EventQueue before AWTEvent\u00a0B then event B will not be dispatched before event A.In such a scenario, there will be one EventQueue per context.Other browsers place all applets into the same context, implying that there will be only a single, global EventQueue for all applets.For information on the threading issues of the event dispatch machinery, see AWT Threading Issues."},
{"description": "An abstract wrapper class for an EventListener class which associates a set of additional parameters with the listener.Subclasses must provide the storage and accessor methods for the additional arguments or parameters.For example, a bean which supports named properties would have a two argument method signature for adding a PropertyChangeListener for a property: public voidIf the bean also implemented the zero argument get listener method: public PropertyChangeListenergetPropertyChangeListeners() then the array may contain inner PropertyChangeListeners which are also PropertyChangeListenerProxy objects.If the calling method is interested in retrieving the named property then it would have to test the element to see if it is a proxy class."},
{"description": "The root class from which all event state objects shall be derived.All Events are constructed with a reference to the object, the \"source\", that is logically deemed to be the object upon which the Event in question initially occurred upon."},
{"description": "This is the base class for deriving an XMLEventReader filter.This class is designed to sit between an XMLEventReader and an application's XMLEventReader.By default each method does nothing but call the corresponding method on the parent interface."},
{"description": "A class that holds a list of EventListeners.A single instance can be used to hold all listeners (of all types) for the instance using the list.It is the responsiblity of the class using the EventListenerList to provide type-safe API (preferably conforming to the JavaBeans spec) and methods which dispatch event notification methods to appropriate Event Listeners on the list.The main benefits that this class provides are that it is relatively cheap in the case of no listeners, and it provides serialization for event-listener lists in a single place, as well as a degree of MT safety (when used correctly).Usage example: Say one is defining a class that sends out FooEvents, and one wants to allow users of the class to register FooListeners and receive notification when FooEvents occur.The following should be added to the class definition:FooEvent fooEvent = null; public void addFooListener(FooListener l) { listenerList.add(FooListener.class, l); } public void removeFooListener(FooListener l) { listenerList.remove(FooListener.class, l); } // Notify all listeners that have registered interest for // notification on this event type.The event instance // is lazily created using the parameters passed into // the fire method.// Process the listeners last to first, notifying // those that are interested in this event for (int i = listeners.length-2; i>=0; i-=2) { if (listeners[i]==FooListener.class) { //; ((FooListener)listeners[i+1]).fooXXX(fooEvent); } } } foo should be changed to the appropriate name, and fireFooXxx to the appropriate method name.One fire method should exist for each notification method in the FooListener interface.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The EventHandler class provides support for dynamically generating event listeners whose methods execute a simple statement involving an incoming event object and a target object.The EventHandler class is intended to be used by interactive tools, such as application builders, that allow developers to make connections between beans.Typically connections are made from a user interface bean (the event source) to an application logic bean (the target).The most effective connections of this kind isolate the application logic from the user interface.For example, the EventHandler for a connection from a JCheckBox to a method that accepts a boolean value can deal with extracting the state of the check box and passing it directly to the method so that the method is isolated from the user interface layer.Inner classes are another, more general way to handle events from user interfaces.The EventHandler class handles only a subset of what is possible using inner classes.However, EventHandler works better with the long-term persistence scheme than inner classes.Also, using EventHandler in large applications in which the same interface is implemented many times can reduce the disk and memory footprint of the application.The reason that listeners created with EventHandler have such a small footprint is that the Proxy class, on which the EventHandler relies, shares implementations of identical interfaces.For example, if you use the EventHandler create methods to make all the ActionListeners in an application, all the action listeners will be instances of a single class (one created by the Proxy class).In general, listeners based on the Proxy class require one listener class to be created per listener type (interface), whereas the inner class approach requires one class to be created per listener (object that implements the interface).You don't generally deal directly with EventHandler instances.Instead, you use one of the EventHandler create methods to create an object that implements a given listener interface.This listener object uses an EventHandler object behind the scenes to encapsulate information about the event, the object to be sent a message when the event occurs, the message (method) to be sent, and any argument to the method.The following section gives examples of how to create listener objects using the create methods.Examples of Using EventHandler The simplest use of EventHandler is to install a listener that calls a method on the target object with no arguments.In the following example we create an ActionListener that invokes the toFront method on an instance of javax.swing.JFrame.One could get the same effect, with some additional compile-time type safety, by defining a new implementation of the ActionListener interface and adding an instance of it to the button: //Equivalent(); }}); The next simplest use of EventHandler is to extract a property value from the first argument of the method in the listener interface (typically an event object) and use it to set the value of a property in the target object.In the following example we create an ActionListener that sets the nextFocusableComponent property of the target (myButton) object to the value of the \"source\" property of the event.This would correspond to the following inner class implementation: //Equivalent; }} It's also possible to create an EventHandler that just passes the incoming event object to the target's action.If the fourth EventHandler.create argument is an empty string, then the event is just passed along:This would correspond to the following inner class implementation: //Equivalentcode using an inner class instead of EventHandler.new ActionListener() { public void actionPerformed(ActionEvent e) { target.doActionEvent(e); }} Probably the most common use of EventHandler is to extract a property value from the source of the event object and set this value as the value of a property of the target object.In the following example we create an ActionListener that sets the \"label\" property of the target object to the value of the \"text\" property of the source (the value of the \"source\" property) of the event.This would correspond to the following inner class implementation: //Equivalent{ myButton.setLabel(((JTextField)e.getSource()).getText()); }} The event property may be \"qualified\" with an arbitrary number of property prefixes delimited with the \".\" character.The \"qualifying\" names that appear before the \".\" characters are taken as the names of properties that should be applied, left-most first, to the event object.For example, the following action listener EventHandler.create(ActionListener.class, target, \"a\", \"b.c.d\") might be written as the following inner class (assuming all the properties had canonical getter methods and returned the appropriate types): //Equivalent; }} The target property may also be \"qualified\" with an arbitrary number of property prefixs delimited with the \".\" character.For example, the following action listener: EventHandler.create(ActionListener.class, target, \"a.b\", \"c.d\") might be written as the following inner class (assuming all the properties had canonical getter methods and returned the appropriate types): //Equivalent} As EventHandler ultimately relies on reflection to invoke a method we recommend against targeting an overloaded method.For example, if the target is an instance of the class MyTarget which is defined as: public class MyTarget { public void doIt(String); public void doIt(Object); } Then the method doIt is overloaded.EventHandler will invoke the method that is appropriate based on the source.For that reason we recommend against targeting overloaded methods."},
{"description": "A tagging interface that all event listener interfaces must extend."},
{"description": "The EventListener interface is the primary method for handling events.Users implement the EventListener interface and register their listener on an EventTarget using the AddEventListener method.The users should also remove their EventListener from its EventTarget after they have completed using the listener.When a Node is copied using the cloneNode method the EventListeners attached to the source Node are not attached to the copied Node.If the user wishes the same EventListeners to be added to the newly created copy the user must add them manually."},
{"description": "Event operations may throw an EventException as specified in their method descriptions."},
{"description": "Target The name parameter in the addNamingListener() methods is referred to as the target.The target, along with the scope, identify the object(s) that the listener is interested in.It is possible to register interest in a target that does not exist, but there might be limitations in the extent to which this can be supported by the service provider and underlying protocol/service.If a service only supports registration for existing targets, an attempt to register for a nonexistent target results in a NameNotFoundException being thrown as early as possible, preferably at the time addNamingListener() is called, or if that is not possible, the listener will receive the exception through the NamingExceptionEvent.Also, for service providers that only support registration for existing targets, when the target that a listener has registered for is subsequently removed from the namespace, the listener is notified via a NamingExceptionEvent (containing aNameNotFoundException).An application can use the method targetMustExist() to check whether a EventContext supports registration of nonexistent targets.The EventContext instance on which you invoke the registration methods is the event source of the events that are (potentially) generated.The source is not necessarily the object named by the target.Only when the target is the empty name is the object named by the target the source.In other words, the target, along with the scope parameter, are used to identify the object(s) that the listener is interested in, but the event source is the EventContext instance with which the listener has registered.For example, suppose a listener makes the following registration: NamespaceChangeListener listener = ...; src.addNamingListener(\"x\", SUBTREE_SCOPE, listener); When an object named \"x/y\" is subsequently deleted, the corresponding NamingEvent (evt) must contain: evt.getEventContext() ==Furthermore, listener registration/deregistration is with the EventContext instance, and not with the corresponding object in the namespace.If the program intends at some point to remove a listener, then it needs to keep a reference to the EventContext instance on which it invoked() (just as it needs to keep a reference to the listener in order to remove it later).It cannot expect to do a lookup() and get another instance of a EventContext on which to perform the deregistration.Lifetime of Registration A registered listener becomes deregistered when:It is removed using removeNamingListener().An exception is thrown while collecting information about the events.That is, when the listener receives a NamingExceptionEvent.Context.close() is invoked on the EventContext instance with which it has registered.Until that point, a EventContext instance that has outstanding listeners will continue to exist and be maintained by the service provider.The registration/deregistration methods accept an instance of NamingListener.There are subinterfaces of NamingListener for different of event types of NamingEvent.For example, the ObjectChangeListener interface is for the NamingEvent.To register interest in multiple event types, the listener implementation should implement multiple NamingListener subinterfaces and use a single invocation of addNamingListener().In addition to reducing the number of method calls and possibly the code size of the listeners, this allows some service providers to optimize the registration.Threading Issues Like Context instances in general, instances of EventContext are not guaranteed to be thread-safe.Care must be taken when multiple threads are accessing the same EventContext concurrently."},
{"description": "This interface declares a simple filter interface that one can create to filter XMLEventReaders"},
{"description": "Using the search filter, it is possible to register interest in objects that do not exist at the time of registration but later come into existence and satisfy the filter.However, there might be limitations in the extent to which this can be supported by the service provider and underlying protocol/service.If the caller submits a filter that cannot be supported in this way, addNamingListener() throws an InvalidSearchFilterException.See EventContext for a description of event source and target, and information about listener registration/deregistration that are also applicable to methods in this interface.A SearchControls or array object passed as a parameter to any method is owned by the caller.The service provider will not modify the object or keep a reference to it."},
{"description": "The Event interface is used to provide contextual information about an event to the handler processing the event.An object which implements the Event interface is generally passed as the first parameter to an event handler.More specific context information is passed to event handlers by deriving additional interfaces from Event which contain information directly relating to the type of event they accompany.These derived interfaces are also implemented by the object passed to the event listener."},
{"description": "The Event class is obsolete and is available only for backwards compatibility.It has been replaced by the AWTEvent class and its subclasses.Event is a platform-independent class that encapsulates events from the platform's Graphical User Interface in the Java\u00a01.0 event model.In Java\u00a01.1 and later versions, the Event class is maintained only for backwards compatibility.The information in this class description is provided to assist programmers in converting Java\u00a01.0 programs to the new event model.In the Java\u00a01.0 event model, an event contains an id field that indicates what type of event it is and which other Event variables are relevant for the event.For keyboard events, key contains a value indicating which key was activated, and modifiers contains the modifiers for that event.For the KEY_PRESS and KEY_RELEASE event ids, the value of key is the unicode character code for the key.For KEY_ACTION and KEY_ACTION_RELEASE, the value of key is one of the defined action-key identifiers in the Event class (PGUP, PGDN, F1, F2, etc)."},
{"description": "Represents a class or interface type that cannot be properly modeled.This may be the result of a processing error, such as a missing class file or erroneous source code.Most queries for information derived from such a type (such as its members or its supertype) will not, in general, return meaningful results."},
{"description": "A class which implements a simple etched border which can either be etched-in or etched-out.If no highlight/shadow colors are initialized when the border is created, then these colors will be dynamically derived from the background color of the component argument passed into the paintBorder() method.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "ErrorManager objects can be attached to Handlers to process any error that occurs on a Handler during Logging.When processing logging output, if a Handler encounters problems then rather than throwing an Exception back to the issuer of the logging call (who is unlikely to be interested) the Handler should call its associated ErrorManager."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.If a SAX application needs to implement customized error handling, it must implement this interface and then register an instance with the XML reader using the setErrorHandler method.The parser will then report all errors and warnings through this interface.If an application does not register an ErrorHandler, XML parsing errors will go unreported, except that SAXParseExceptions will be thrown for fatal errors.In order to detect validity errors, an ErrorHandler that does something with error() calls must be registered.For XML processing errors, a SAX driver must use this interface in preference to throwing an exception: it is up to the application to decide whether to throw an exception for different types of errors and warnings.Note, however, that there is no requirement that the parser continue to report additional errors after a call to fatalError.In other words, a SAX driver class may throw an exception after reporting any fatalError.Also parsers may throw appropriate exceptions for non-XML errors.For example, XMLReader.parse() would throw an IOException for errors accessing entities or the document."},
{"description": "An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.Most such errors are abnormal conditions.The ThreadDeath error, though a \"normal\" condition, is also a subclass of Error because most applications should not try to catch it.A method is not required to declare in its throws clause any subclasses of Error that might be thrown during the execution of the method but not caught, since these errors are abnormal conditions that should never occur.That is, Error and its subclasses are regarded as unchecked exceptions for the purposes of compile-time checking of exceptions."},
{"description": "The Transformer then reports all errors and warnings through this interface.If an application does not register its own custom ErrorListener, the default ErrorListener is used which reports all warnings and errors to System.err and does not throw any Exceptions.Applications are strongly encouraged to register and use ErrorListeners that insure proper behavior for warnings and errors.For transformation errors, a Transformer must use this interface instead of throwing an Exception: it is up to the application to decide whether to throw an Exception for different types of errors and warnings.Note however that the Transformer is not required to continue with the transformation after a call to fatalError(TransformerException exception).Transformers may use this mechanism to report XML parsing errors as well as transformation errors."},
{"description": "Most calendar systems have a single epoch dividing the time-line into two eras.However, some calendar systems, have multiple eras, such as one for the reign of each leader.In all cases, the era is conceptually the largest division of the time-line.Each chronology defines the Era's that are known Eras and a Chronology.eras to get the valid eras.For example, the Thai Buddhist calendar system divides time into two eras, before and after a single date.By contrast, the Japanese calendar system has one era for the reign of each Emperor.Instances of Era may be compared using the == operator."},
{"description": "A container (holder) for an exception that is used in Request operations to make exceptions available to the client.An Environment object is created with the ORB method create_environment."},
{"description": "Signals that an end of file or end of stream has been reached unexpectedly during input.This exception is mainly used by data input streams to signal end of stream.Note that many other input operations return a special value on end of stream rather than throwing an exception."},
{"description": "Class EnumSyntax is an abstract base class providing the common implementation of all \"type safe enumeration\" objects.An enumeration class (which extends class EnumSyntax) provides a group of enumeration values (objects) that are singleton instances of the enumeration class; for example: public class Bach extends EnumSyntax { public static final Bach JOHANN_SEBASTIAN =new Bach(3); public static final Bach P_D_Q = new Bach(4); private static final String[] stringTable = { \"Johann Sebastian Bach\", \"Wilhelm Friedemann Bach\", \"Carl Philip Emmanuel Bach\", \"Johann Christian Bach\", \"P.D.Q. Bach\" }; protected String[] getStringTable() { return stringTable; } private static final Bach[] enumValueTable = { JOHANN_SEBASTIAN, WILHELM_FRIEDEMANN, CARL_PHILIP_EMMANUEL, JOHANN_CHRISTIAN, P_D_Q }; protected EnumSyntax[]getEnumValueTable() { return enumValueTable; } } You can then write code that uses the == and !; } The equals() method for an enumeration class just does a test for identical objects (=You can convert an enumeration value to a string by calling toString().The string is obtained from a table supplied by the enumeration class.Under the hood, an enumeration value is just an integer, a different integer for each enumeration value within an enumeration class.You can get an enumeration value's integer value by calling getValue().An enumeration value's integer value is established when it is constructed (see EnumSyntax(int)).Since the constructor is protected, the only possible enumeration values are the singleton objects declared in the enumeration class; additional enumeration values cannot be created at run time.You can define a subclass of an enumeration class that extends it with additional enumeration values.The subclass's enumeration values' integer values need not be distinct from the superclass's enumeration values' integer values;the ==, !=, equals(), and toString() methods will still work properly even if the subclass uses some of the same integer values as the superclass.However, the application in which the enumeration class and subclass are used may need to have distinct integer values in the superclass and subclass."},
{"description": "All of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created.Enum maps are represented internally as arrays.Enum maps are maintained in the natural order of their keys (the order in which the enum constants are declared).This is reflected in the iterators returned by the collections views (keySet(), entrySet(), and values()).Iterators returned by the collection views are weakly consistent: they will never throw ConcurrentModificationException and they may or may not show the effects of any modifications to the map that occur while the iteration is in progress.Attempts to insert a null key will throw NullPointerException.Attempts to test for the presence of a null key or to remove one will, however, function properly.Like most collection implementations EnumMap is not synchronized.If multiple threads access an enum map concurrently, and at least one of the threads modifies the map, it should be synchronized externally.This is typically accomplished by synchronizing on some object that naturally encapsulates the enum map.If no such object exists, the map should be \"wrapped\" using the Collections.synchronizedMap(java.util.This is best done at creation time, to prevent accidental unsynchronized access:(...)); Implementation note: All basic operations execute in constant time.They are likely (though not guaranteed) to be faster than their HashMap counterparts.This class is a member of the Java Collections Framework."},
{"description": "An object that implements the Enumeration interface generates a series of elements, one at a time.the nextElement method return successive elements of the series.For example, to print all elements of a Vector<E> v: for (Enumeration<E> e = v.elements(); e.hasMoreElements();) System.out.println(e.nextElement()); Methods are provided to enumerate through the elements of a vector, the keys of a hashtable, and the values in a hashtable.Enumerations are also used to specify the input streams to a SequenceInputStream.The functionality of this interface is duplicated by the Iterator interface.In addition, Iterator adds an optional remove operation, and has shorter method names.New implementations should consider using Iterator in preference to Enumeration."},
{"description": "Type inner class identifies one kind of enumerated control.Static instances are provided for the common types."},
{"description": "All of the elements in an enum set must come from a single enum type that is specified, explicitly or implicitly, when the set is created.Enum sets are represented internally as bit vectors.The space and time performance of this class should be good enough to allow its use as a high-quality, typesafe alternative to traditional int-based \"bit flags.Even bulk operations (such as containsAll and retainAll) should run very quickly if their argument is also an enum set.The iterator returned by the iterator method traverses the elements in their natural order (the order in which the enum constants are declared).The returned iterator is weakly consistent: it will never throw ConcurrentModificationException and it may or may not show the effects of any modifications to the set that occur while the iteration is in progress.Attempts to insert a null element will throw NullPointerException.Attempts to test for the presence of a null element or to remove one will, however, function properly.Like most collection implementations, EnumSet is not synchronized.If multiple threads access an enum set concurrently, and at least one of the threads modifies the set, it should be synchronized externally.This is typically accomplished by synchronizing on some object that naturally encapsulates the enum set.If no such object exists, the set should be \"wrapped\" using the Collections.synchronizedSet(java.util.This is best done at creation time, to prevent accidental unsynchronized access:; Implementation note: All basic operations execute in constant time.They are likely (though not guaranteed) to be much faster than their HashSet counterparts.Even bulk operations execute in constant time if their argument is also an enum set.This class is a member of the Java Collections Framework."},
{"description": "A EnumControl provides control over a set of discrete possible values, each represented by an object.In a graphical user interface, such a control might be represented by a set of buttons, each of which chooses one value or setting.For example, a reverb control might provide several preset reverberation settings, instead of providing continuously adjustable parameters of the sort that would be represented by FloatControl objects.Controls that provide a choice between only two settings can often be implemented instead as a BooleanControl, and controls that provide a set of values along some quantifiable dimension might be implemented instead as a FloatControl with a coarse resolution.However, a key feature of EnumControl is that the returned values are arbitrary objects, rather than numerical or boolean values.This means that each returned object can provide further information.As an example, the settings of a REVERB control are instances of ReverbType that can be queried for the parameter values used for each setting."},
{"description": "Thrown when an application tries to access an enum constant by name and the enum type contains no constant with the specified name.This exception can be thrown by the API used to read annotations reflectively."},
{"description": "This is the common base class of all Java language enumeration types.More information about enums, including descriptions of the implicitly declared methods synthesized by the compiler, can be found in section 8.9 of The Java\u2122 Language Specification.Note that when using an enumeration type as the type of a set or as the type of the keys in a map, specialized and efficient set and map implementations are available."},
{"description": "The XMLReader.setEntityResolver() method is used to provide implementations of this interface to parsers.When a parser uses the methods in this interface, the EntityResolver2.resolveEntity() method (in this interface) is used instead of the older (SAX 1.0) EntityResolver.resolveEntity() method.This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.If a SAX application requires the customized handling which this interface defines for external entities, it must ensure that it uses an XMLReader with the http://xml.org/sax/features/use-entity-resolver2 feature flag set to true (which is its default value when the feature is recognized).If that flag is unrecognized, or its value is false, or the resolver does not implement this interface, then only the EntityResolver method will be used.That supports three categories of application that modify entity resolution.Old Style applications won't know about this interface; they will provide an EntityResolver.Transitional Mode provide an EntityResolver2 and automatically get the benefit of its methods in any systems (parsers or other tools) supporting it, due to polymorphism.Both Old Style and Transitional Mode applications will work with any SAX2 parser.New style applications will fail to run except on SAX2 parsers that support this particular feature.They will insist that feature flag have a value of \"true\", and the EntityResolver2 implementation they provide might throw an exception if the original SAX 1.0 style entity resolution method is invoked."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.If a SAX application needs to implement customized handling for external entities, it must implement this interface and register an instance with the SAX driver using the setEntityResolver method.The XML reader will then allow the application to intercept any external entities (including the external DTD subset and external parameter entities, if any) before including them.Many SAX applications will not need to implement this interface, but it will be especially useful for applications that build XML documents from databases or other specialised input sources, or for applications that use URI types other than URLs.The following resolver would provide the application with a special character stream for the entity with the system identifier \"http://www.myhost.com/today\": import org.xml.sax.EntityResolver; import org.xml.sax.InputSource; public class MyResolver implementsnew MyReader(); return new InputSource(reader); } else { // use the default behaviour return null; } } } The application can also use this interface to redirect system identifiers to local URIs or to look up replacements in a catalog (possibly by using the public identifier)."},
{"description": "This event reports entities that have not been resolved and reports their replacement text unprocessed (if available).If javax.xml.stream.isReplacingEntityReferences is set to true entity references will be resolved transparently.Entities are handled in two possible ways: (1) If javax.xml.stream.isReplacingEntityReferences is set to true all entity references are resolved and reported as markup transparently.If javax.xml.stream.isReplacingEntityReferences is set to false Entity references are reported as an EntityReference Event."},
{"description": "This interface is used to record and report unparsed entity declarations."},
{"description": "EntityReference nodes may be used to represent an entity reference in the tree.Note that character references and references to predefined entities are considered to be expanded by the HTML or XML processor so that characters are represented by their Unicode equivalent rather than by an entity reference.Moreover, the XML processor may completely expand references to entities while building the Document, instead of providing EntityReference nodes.If it does provide such nodes, then for an EntityReference node that represents a reference to a known entity an Entity exists, and the subtree of the EntityReference node is a copy of the Entity node subtree.However, the latter may not be true when an entity contains an unbound namespace prefix.In such a case, because the namespace prefix resolution depends on where the entity reference is, the descendants of the EntityReference node may be bound to different namespace URIs.When an EntityReference node represents a reference to an unknown entity, the node has no children and its replacement value, when used by Attr.value for example, is empty.Note: EntityReference nodes may cause element content and attribute value normalization problems when, such as in XML 1.0 and XML Schema, the normalization is performed after entity reference are expanded."},
{"description": "An entity is described in a DTD using the ENTITY construct.It defines the type and value of the the entity."},
{"description": "This interface represents a known entity, either parsed or unparsed, in an XML document.The nodeName attribute that is inherited from Node contains the name of the entity.An XML processor may choose to completely expand entities before the structure model is passed to the DOM; in this case there will be no EntityReference nodes in the document tree.XML does not mandate that a non-validating XML processor read and process entity declarations made in the external subset or declared in parameter entities.This means that parsed entities declared in the external subset need not be expanded by some classes of applications, and that the replacement text of the entity may not be available.When the replacement text is available, the corresponding Entity node's child list represents the structure of that replacement value.DOM Level 3 does not support editing Entity nodes; if a user wants to make changes to the contents of an Entity, every related EntityReference node has to be replaced in the structure model by a clone of the Entity's contents, and then the desired changes must be made to each of those clones instead.An Entity node does not have any parent.Note: If the entity contains an unbound namespace prefix, the namespaceURI of the corresponding node in the Entity node subtree is null.The same is true for EntityReference nodes that refer to this entity, when they are created using the createEntityReference method of the Document interface."},
{"description": "EndpointContext allows multiple endpoints in an application to share any information.For example, servlet application's war may contain multiple endpoints and these endpoints can get addresses of each other by sharing this context.If multiple endpoints share different ports of a WSDL, then the multiple port addresses can be patched when the WSDL is accessed.It also allows all endpoints to share any other runtime information.This needs to be set by using Endpoint.setEndpointContext(javax.xml.ws."},
{"description": "This class represents an WS-Addressing EndpointReference which is a remote reference to a web service endpoint.See Web Services Addressing 1.0 - Core for more information on WS-Addressing EndpointReferences.This class is immutable as the typical web service developer need not be concerned with its contents.The web service developer should use this class strictly as a mechanism to reference a remote web service endpoint.See the Service APIs that clients can use to that utilize an EndpointReference.See the Endpoint, and BindingProvider APIs on how EndpointReferences can be created for published endpoints.Concrete implementations of this class will represent an EndpointReference for a particular version of Addressing.For example the W3CEndpointReference is for use with W3C Web Services Addressing 1.0 - Core Recommendation.If JAX-WS implementors need to support different versions of addressing, they should write their own EndpointReference subclass for that version.This will allow a JAX-WS implementation to create a vendor specific EndpointReferences that the vendor can use to flag a different version of addressing.Web service developers that wish to pass or return EndpointReference in Java methods in an SEI should use concrete instances of an EndpointReference such as the W3CEndpointReference.This way the schema mapped from the SEI will be more descriptive of the type of endpoint reference being passed.JAX-WS implementors are expected to extract the XML infoset from an EndpointReferece using the writeTo(javax.xml.transform.JAXB will bind this class to xs:anyType.If a better binding is desired, web services developers should use a concrete subclass such as W3CEndpointReference."},
{"description": "Endpoints are created using the static methods defined in this class.An endpoint is always tied to one Binding and one implementor, both set at endpoint creation time.An endpoint is either in a published or an unpublished state.The publish methods can be used to start publishing an endpoint, at which point it starts accepting incoming requests.Conversely, the stop method can be used to stop accepting incoming requests and take the endpoint down.An Executor may be set on the endpoint in order to gain better control over the threads used to dispatch incoming requests.For instance, thread pooling with certain parameters can be enabled by creating a ThreadPoolExecutor and registering it with the endpoint.Handler chains can be set using the contained Binding.An endpoint may have a list of metadata documents, such as WSDL and XMLSchema documents, bound to it.At publishing time, the JAX-WS implementation will try to reuse as much of that metadata as possible instead of generating new ones based on the annotations present on the implementor."},
{"description": "An EndElement is reported for each End Tag in the document."},
{"description": "This class implements the EncryptedPrivateKeyInfo type as defined in PKCS #8.algorithm OBJECT IDENTIFIER, parameters ANY DEFINED"},
{"description": "An Encoder is a class which can be used to create files or streams that encode the state of a collection of JavaBeans in terms of their public APIs.The Encoder, in conjunction with its persistence delegates, is responsible for breaking the object graph down into a series of Statementss and Expressions which can be used to create it.A subclass typically provides a syntax for these expressions using some human readable form - like Java source code or XML."},
{"description": "This class represents a public or private key in encoded format."},
{"description": "Thrown by methods in the Stack class to indicate that the stack is empty."},
{"description": "The Float class defines an ellipse specified in float precision."},
{"description": "This immutable class holds the necessary values needed to represent an elliptic curve."},
{"description": "A class which provides an empty, transparent border which takes up space but does no drawing.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The Double class defines an ellipse specified in double precision."},
{"description": "The Ellipse2D class describes an ellipse that is defined by a framing rectangle.This class is only the abstract superclass for all objects which store a 2D ellipse.The actual storage representation of the coordinates is left to the subclass."},
{"description": "The constants of this enumerated type provide a simple classification of the syntactic locations where annotations may appear in a Java program.These constants are used in java.lang.annotation.Target meta-annotations to specify where it is legal to write annotations of a given type.The syntactic locations where annotations may appear are split into declaration contexts , where annotations apply to declarations, and type contexts , where annotations apply to types used in declarations and expressions.For example, an annotation whose type is meta-annotated with @Target(ElementType.FIELD) may only be written as a modifier for a field declaration.For example, an annotation whose type is meta-annotated with @Target(ElementType.TYPE_USE) may be written on the type of a field (or within the type of the field, if it is a nested, parameterized, or array type), and may also appear as a modifier for, say, a class declaration.The TYPE_USE constant includes type declarations and type parameter declarations as a convenience for designers of type checkers which give semantics to annotation types.For example, if the annotation type NonNull is meta-annotated with @Target(ElementType.TYPE_USE), then @NonNull class C {...} could be treated by a type checker as indicating that all variables of class C are non-null, while still allowing variables of other classes to be non-null or not non-null based on whether @NonNull appears at the variable's declaration."},
{"description": "Classes implementing this interface are used to operate on an element when the kind of element is unknown at compile time.When a visitor is passed to an element's accept method, the visitXYZ method most applicable to that element is invoked.Classes implementing this interface may or may not throw a NullPointerException if the additional parameter p is null; see documentation of the implementing class for details.It is possible that methods will be added to this interface to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, visitor classes directly implementing this interface may be source incompatible with future versions of the platform.To avoid this source incompatibility, visitor implementations are encouraged to instead extend the appropriate abstract visitor class that implements this interface.However, an API should generally use this visitor interface as the type for parameters, return type, etc.Note that methods to accommodate new language constructs could be added in a source compatible way if they were added as default methods.However, default methods are only available on Java SE 8 and higher releases and the javax.lang.model.* packages bundled in Java SE 8 are required to also be runnable on Java SE 7.Therefore, default methods cannot be used when extending javax.lang.model.However, default methods may be used in subsequent revisions of the javax.lang.model.* packages that are only required to run on Java SE 8 and higher platform versions."},
{"description": "The visitXYZ methods in this class scan their component elements by calling scan on their enclosed elements, parameters, etc., as indicated in the individual method specifications.A subclass can control the order elements are visited by overriding the visitXYZ methods.Note that clients of a scanner may get the desired behavior be invoking v.scan(e, p) rather than v.visit(e, p) on the root objects of interest.When a subclass overrides a visitXYZ method, the new method can cause the enclosed elements to be scanned in the default way by calling super.visitXYZ.In this fashion, the concrete visitor can control the ordering of traversal over the component elements with respect to the additional processing; for example, consistently calling super.visitXYZ at the start of the overridden methods will yield a preorder traversal, etc.If the component elements should be traversed in some other order, instead of calling super.visitXYZ, an overriding visit method should call scan with the elements in the desired order.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The ElementVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new element scanner visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated."},
{"description": "Compatibility Note: Methods may be added to this interface in future releases of the platform."},
{"description": "The visitXYZ methods in this class scan their component elements by calling scan on their enclosed elements, parameters, etc., as indicated in the individual method specifications.A subclass can control the order elements are visited by overriding the visitXYZ methods.Note that clients of a scanner may get the desired behavior be invoking v.scan(e, p) rather than v.visit(e, p) on the root objects of interest.When a subclass overrides a visitXYZ method, the new method can cause the enclosed elements to be scanned in the default way by calling super.visitXYZ.In this fashion, the concrete visitor can control the ordering of traversal over the component elements with respect to the additional processing; for example, consistently calling super.visitXYZ at the start of the overridden methods will yield a preorder traversal, etc.If the component elements should be traversed in some other order, instead of calling super.visitXYZ, an overriding visit method should call scan with the elements in the desired order.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The ElementVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new element scanner visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated."},
{"description": "The visitXYZ methods in this class scan their component elements by calling scan on their enclosed elements, parameters, etc., as indicated in the individual method specifications.A subclass can control the order elements are visited by overriding the visitXYZ methods.Note that clients of a scanner may get the desired behavior be invoking v.scan(e, p) rather than v.visit(e, p) on the root objects of interest.When a subclass overrides a visitXYZ method, the new method can cause the enclosed elements to be scanned in the default way by calling super.visitXYZ.In this fashion, the concrete visitor can control the ordering of traversal over the component elements with respect to the additional processing; for example, consistently calling super.visitXYZ at the start of the overridden methods will yield a preorder traversal, etc.If the component elements should be traversed in some other order, instead of calling super.visitXYZ, an overriding visit method should call scan with the elements in the desired order.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The ElementVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new element scanner visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated."},
{"description": "ElementIterator, as the name suggests, iterates over the Element tree.The constructor can be invoked with either Document or an Element as an argument.If the constructor is invoked with a Document as an argument then the root of the iteration is the return value of document.getDefaultRootElement().The iteration happens in a depth-first manner.In terms of how boundary conditions are handled: a) if next() is called before first() or current(), the root will be returned.next() returns null to indicate the end of the list.c) previous() returns null when the current element is the root or next() has returned null.The ElementIterator does no locking of the Element tree.This means that it does not track any changes.It is the responsibility of the user of this class, to ensure that no changes happen during element iteration."},
{"description": "The returned sets and lists are new collections and do use the argument as a backing store.The methods in this class do not make any attempts to guard against concurrent modifications of the arguments.The returned sets and lists are mutable but unsafe for concurrent access.A returned set has the same iteration order as the argument set to a method.If iterables and sets containing null are passed as arguments to methods in this class, a NullPointerException will be thrown.Note that a static import statement can make the text of calls to the methods in this class more concise; for example: import static javax.lang.model.util.ElementFilter."},
{"description": "For elements XYZ that may have more than one kind, the visitXYZ methods in this class delegate to the visitXYZKind method corresponding to the first argument's kind.The visitXYZKind methods call defaultAction, passing their arguments to defaultAction's corresponding parameters.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The ElementVisitor interface implemented by this class may have methods added to it or the ElementKind enum used in this case may have constants added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new abstract element kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "This is an element marker interface.Under certain circumstances, it is necessary for the binding compiler to generate derived java content classes that implement this interface.In those cases, client applications must supply element instances rather than types of elements."},
{"description": "For elements XYZ that may have more than one kind, the visitXYZ methods in this class delegate to the visitXYZKind method corresponding to the first argument's kind.The visitXYZKind methods call defaultAction, passing their arguments to defaultAction's corresponding parameters.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The ElementVisitor interface implemented by this class may have methods added to it or the ElementKind enum used in this case may have constants added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new abstract element kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "For elements XYZ that may have more than one kind, the visitXYZ methods in this class delegate to the visitXYZKind method corresponding to the first argument's kind.The visitXYZKind methods call defaultAction, passing their arguments to defaultAction's corresponding parameters.Methods in this class may be overridden subject to their general contract.Note that annotating methods in concrete subclasses with @Override will help ensure that methods are overridden as intended.The ElementVisitor interface implemented by this class may have methods added to it or the ElementKind enum used in this case may have constants added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new abstract element kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "Note that it is possible additional element kinds will be added to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language."},
{"description": "The EditorKit acts as a factory for some kind of policy.For example, an implementation of html and rtf can be provided that is replaceable with other implementations.A kit can safely store editing state as an instance of the kit will be dedicated to a text component.New kits will normally be created by cloning a prototype kit.The kit will have it's setComponent method called to establish it's relationship with a JTextComponent."},
{"description": "This immutable class specifies an elliptic curve public key with its associated parameters."},
{"description": "This immutable class specifies an elliptic curve private key with its associated parameters."},
{"description": "This is essential the description of a tag.It describes the type, content model, attributes, attribute types etc.It is used to correctly parse a document by the Parser."},
{"description": "The Element interface represents an element in an HTML or XML document.Elements may have attributes associated with them; since the Element interface inherits from Node, the generic Node interface attribute attributes may be used to retrieve the set of all attributes for an element.There are methods on the Element interface to retrieve either an Attr object by name or an attribute value by name.In XML, where an attribute value may contain entity references, an Attr object should be retrieved to examine the possibly fairly complex sub-tree representing the attribute value.On the other hand, in HTML, where all attributes have simple string values, methods to directly access an attribute value can safely be used as a convenience.In DOM Level 2, the method normalize is inherited from the Node interface where it was moved."},
{"description": "Each element represents a static, language-level construct (and not, for example, a runtime construct of the virtual machine).Elements should be compared using the equals(Object) method.There is no guarantee that any particular element will always be represented by the same object.Using instanceof is not necessarily a reliable idiom for determining the effective class of an object in this modeling hierarchy since an implementation may choose to have a single object implement multiple Element subinterfaces."},
{"description": "It is intended to capture the spirit of an SGML element."},
{"description": "This immutable class represents a point on an elliptic curve (EC) in affine coordinates.Other coordinate systems can extend this class to represent this point in other coordinates."},
{"description": "This immutable class defines an elliptic curve (EC) prime finite field."},
{"description": "This immutable class defines an elliptic curve (EC) characteristic 2 finite field."},
{"description": "This interface represents an elliptic curve (EC) finite field.All specialized EC fields must implements this interface."},
{"description": "DynValueCommon provides operations supported by both the DynValue and DynValueBox interfaces."},
{"description": "DynValue objects support the manipulation of IDL non-boxed value types.The DynValue interface can represent both null and non-null value types.For a DynValue representing a non-null value type, the DynValue's components comprise the public and private members of the value type, including those inherited from concrete base value types, in the order of definition.A DynValue representing a null value type has no components and a current position of -1.Indiscriminantly changing the contents of private value type members can cause the value type implementation to break by violating internal constraints.Access to private members is provided to support such activities as ORB bridging and debugging and should not be used to arbitrarily violate the encapsulation of the value type."},
{"description": "DynValueCommon provides operations supported by both the DynValue and DynValueBox interfaces."},
{"description": "DynValueBox objects support the manipulation of IDL boxed value types.The DynValueBox interface can represent both null and non-null value types.For a DynValueBox representing a non-null value type, the DynValueBox has a single component of the boxed type.A DynValueBox representing a null value type has no components and a current position of -1."},
{"description": "DynValueBox objects support the manipulation of IDL boxed value types.The DynValueBox interface can represent both null and non-null value types.For a DynValueBox representing a non-null value type, the DynValueBox has a single component of the boxed type.A DynValueBox representing a null value type has no components and a current position of -1."},
{"description": "DynValue objects support the manipulation of IDL non-boxed value types.The DynValue interface can represent both null and non-null value types.For a DynValue representing a non-null value type, the DynValue's components comprise the public and private members of the value type, including those inherited from concrete base value types, in the order of definition.A DynValue representing a null value type has no components and a current position of -1.Indiscriminantly changing the contents of private value type members can cause the value type implementation to break by violating internal constraints.Access to private members is provided to support such activities as ORB bridging and debugging and should not be used to arbitrarily violate the encapsulation of the value type."},
{"description": "DynValue objects support the manipulation of IDL non-boxed value types.The DynValue interface can represent both null and non-null value types.For a DynValue representing a non-null value type, the DynValue's components comprise the public and private members of the value type, including those inherited from concrete base value types, in the order of definition.A DynValue representing a null value type has no components and a current position of -1.Indiscriminantly changing the contents of private value type members can cause the value type implementation to break by violating internal constraints.Access to private members is provided to support such activities as ORB bridging and debugging and should not be used to arbitrarily violate the encapsulation of the value type."},
{"description": "DynUnion objects support the manipulation of IDL unions.A union can have only two valid current positions: zero, which denotes the discriminator one, which denotes the active member The component_count value for a union depends on the current discriminator: it is 2 for a union whose discriminator indicates a named member, and 1 otherwise."},
{"description": "DynUnion objects support the manipulation of IDL unions.A union can have only two valid current positions: zero, which denotes the discriminator one, which denotes the active member The component_count value for a union depends on the current discriminator: it is 2 for a union whose discriminator indicates a named member, and 1 otherwise."},
{"description": "DynUnion objects support the manipulation of IDL unions.A union can have only two valid current positions: zero, which denotes the discriminator one, which denotes the active member The component_count value for a union depends on the current discriminator: it is 2 for a union whose discriminator indicates a named member, and 1 otherwise."},
{"description": "DynStruct objects support the manipulation of IDL struct and exception values.Members of the exceptions are handled in the same way as members of a struct."},
{"description": "DynStruct objects support the manipulation of IDL struct and exception values.Members of the exceptions are handled in the same way as members of a struct."},
{"description": "DynStruct objects support the manipulation of IDL struct and exception values.Members of the exceptions are handled in the same way as members of a struct."},
{"description": "Because IDL does not have a generic type that can represent fixed types with arbitrary number of digits and arbitrary scale, the operations use the IDL string type."},
{"description": "Because IDL does not have a generic type that can represent fixed types with arbitrary number of digits and arbitrary scale, the operations use the IDL string type."},
{"description": "Because IDL does not have a generic type that can represent fixed types with arbitrary number of digits and arbitrary scale, the operations use the IDL string type."},
{"description": "DynEnum objects support the manipulation of IDL enumerated values.The current position of a DynEnum is always -1."},
{"description": "DynEnum objects support the manipulation of IDL enumerated values.The current position of a DynEnum is always -1."},
{"description": "DynEnum objects support the manipulation of IDL enumerated values.The current position of a DynEnum is always -1."},
{"description": "Note that the dimension of the array is contained in the TypeCode which is accessible through the type attribute.It can also be obtained by calling the component_count operation."},
{"description": "Note that the dimension of the array is contained in the TypeCode which is accessible through the type attribute.It can also be obtained by calling the component_count operation."},
{"description": "Note that the dimension of the array is contained in the TypeCode which is accessible through the type attribute.It can also be obtained by calling the component_count operation."},
{"description": "Any values can be dynamically interpreted (traversed) and constructed through DynAny objects.A DynAny object is associated with a data value which corresponds to a copy of the value inserted into an any.A DynAny object may be viewed as an ordered collection of component DynAnys.For DynAnys representing a basic type, such as long, or a type without components, such as an empty exception, the ordered collection of components is empty.Each DynAny object maintains the notion of a current position into its collection of component DynAnys.The current position is identified by an index value that runs from 0 to n-1, where n is the number of components.The special index value -1 indicates a current position that points nowhere.For values that cannot have a current position (such as an empty exception), the index value is fixed at -1.If a DynAny is initialized with a value that has components, the index is initialized to 0.After creation of an uninitialized DynAny (that is, a DynAny that has no value but a TypeCode that permits components), the current position depends on the type of value represented by the DynAny.(The current position is set to 0 or -1, depending on whether the new DynAny gets default values for its components.)The iteration operations rewind, seek, and next can be used to change the current position and the current_component operation returns the component at the current position.The component_count operation returns the number of components of a DynAny.Collectively, these operations enable iteration over the components of a DynAny, for example, to (recursively) examine its contents.A constructed DynAny object is a DynAny object associated with a constructed type.There is a different interface, inheriting from the DynAny interface, associated with each kind of constructed type in IDL (fixed, enum, struct, sequence, union, array, exception, and value type).A constructed DynAny object exports operations that enable the creation of new DynAny objects, each of them associated with a component of the constructed data value.As an example, a DynStruct is associated with a struct value.This means that the DynStruct may be seen as owning an ordered collection of components, one for each structure member.The DynStruct object exports operations that enable the creation of new DynAny objects, each of them associated with a member of the struct.If a DynAny object has been obtained from another (constructed)DynAny object, such as a DynAny representing a structure member that was created from a DynStruct, the member DynAny is logically contained in the DynStruct.Calling an insert or get operation leaves the current position unchanged.Destroying a top-level DynAny object (one that was not obtained as a component of another DynAny) also destroys any component DynAny objects obtained from it.DynAny object does nothing.Invoking operations on a destroyed top-level DynAny or any of its descendants raises OBJECT_NOT_EXIST.If the programmer wants to destroy a DynAny object but still wants to manipulate some component of the data value associated with it, then he or she should first create a DynAny for the component and, after that, make a copy of the created DynAny object.The behavior of DynAny objects has been defined in order to enable efficient implementations in terms of allocated memory space and speed of access.DynAny objects are intended to be used for traversing values extracted from anys or constructing values of anys at runtime.Their use for other purposes is not recommended.Insert and get operations are necessary to handle basic DynAny objects but are also helpful to handle constructed DynAny objects.Inserting a basic data type value into a constructed DynAny object implies initializing the current component of the constructed data value associated with the DynAny object.For example, invoking insert_boolean on a DynStruct implies inserting a boolean data value at the current position of the associated struct data value.A type is consistent for inserting or extracting a value if its TypeCode is equivalent to the TypeCode contained in the DynAny or, if the DynAny has components, is equivalent to the TypeCode of the DynAny at the current position.DynAny and DynAnyFactory objects are intended to be local to the process in which they are created and used.This means that references to DynAny and DynAnyFactory objects cannot be exported to other processes, or externalized with ORB.object_to_string().If any attempt is made to do so, the offending operation will raise a MARSHAL system exception.Since their interfaces are specified in IDL, DynAny objects export operations defined in the standard org.omg.CORBA.Object interface.However, any attempt to invoke operations exported through the Object interface may raise the standard NO_IMPLEMENT exception.An attempt to use a DynAny object with the DII may raise the NO_IMPLEMENT exception."},
{"description": "DynAny objects can be created by invoking operations on the DynAnyFactory object.Generally there are only two ways to create a DynAny object: invoking an operation on an existing DynAny object invoking an operation on a DynAnyFactory objectA constructed DynAny object supports operations that enable the creation of new DynAny objects encapsulating access to the value of some constituent.DynAny objects also support the copy operation for creating new DynAny objects.A reference to the DynAnyFactory object is obtained by calling ORB.resolve_initial_references() with the identifier parameter set to the string constant \"DynAnyFactory\".Dynamic interpretation of an any usually involves creating a DynAny object using create_dyn_any() as the first step.Depending on the type of the any, the resulting DynAny object reference can be narrowed to a DynFixed, DynStruct, DynSequence, DynArray, DynUnion, DynEnum, or DynValue object reference.(), passing the TypeCode associated with the value to be created.The returned reference is narrowed to one of the complex types, such as DynStruct, if appropriate.Then, the value can be initialized by means of invoking operations on the resulting object.Finally, the to_any operation can be invoked to create an any value from the constructed DynAny."},
{"description": "DynAny objects can be created by invoking operations on the DynAnyFactory object.Generally there are only two ways to create a DynAny object: invoking an operation on an existing DynAny object invoking an operation on a DynAnyFactory objectA constructed DynAny object supports operations that enable the creation of new DynAny objects encapsulating access to the value of some constituent.DynAny objects also support the copy operation for creating new DynAny objects.A reference to the DynAnyFactory object is obtained by calling ORB.resolve_initial_references() with the identifier parameter set to the string constant \"DynAnyFactory\".Dynamic interpretation of an any usually involves creating a DynAny object using create_dyn_any() as the first step.Depending on the type of the any, the resulting DynAny object reference can be narrowed to a DynFixed, DynStruct, DynSequence, DynArray, DynUnion, DynEnum, or DynValue object reference.(), passing the TypeCode associated with the value to be created.The returned reference is narrowed to one of the complex types, such as DynStruct, if appropriate.Then, the value can be initialized by means of invoking operations on the resulting object.Finally, the to_any operation can be invoked to create an any value from the constructed DynAny."},
{"description": "DynAny objects can be created by invoking operations on the DynAnyFactory object.Generally there are only two ways to create a DynAny object: invoking an operation on an existing DynAny object invoking an operation on a DynAnyFactory objectA constructed DynAny object supports operations that enable the creation of new DynAny objects encapsulating access to the value of some constituent.DynAny objects also support the copy operation for creating new DynAny objects.A reference to the DynAnyFactory object is obtained by calling ORB.resolve_initial_references() with the identifier parameter set to the string constant \"DynAnyFactory\".Dynamic interpretation of an any usually involves creating a DynAny object using create_dyn_any() as the first step.Depending on the type of the any, the resulting DynAny object reference can be narrowed to a DynFixed, DynStruct, DynSequence, DynArray, DynUnion, DynEnum, or DynValue object reference.(), passing the TypeCode associated with the value to be created.The returned reference is narrowed to one of the complex types, such as DynStruct, if appropriate.Then, the value can be initialized by means of invoking operations on the resulting object.Finally, the to_any operation can be invoked to create an any value from the constructed DynAny."},
{"description": "Any values can be dynamically interpreted (traversed) and constructed through DynAny objects.A DynAny object is associated with a data value which corresponds to a copy of the value inserted into an any.A DynAny object may be viewed as an ordered collection of component DynAnys.For DynAnys representing a basic type, such as long, or a type without components, such as an empty exception, the ordered collection of components is empty.Each DynAny object maintains the notion of a current position into its collection of component DynAnys.The current position is identified by an index value that runs from 0 to n-1, where n is the number of components.The special index value -1 indicates a current position that points nowhere.For values that cannot have a current position (such as an empty exception), the index value is fixed at -1.If a DynAny is initialized with a value that has components, the index is initialized to 0.After creation of an uninitialized DynAny (that is, a DynAny that has no value but a TypeCode that permits components), the current position depends on the type of value represented by the DynAny.(The current position is set to 0 or -1, depending on whether the new DynAny gets default values for its components.)The iteration operations rewind, seek, and next can be used to change the current position and the current_component operation returns the component at the current position.The component_count operation returns the number of components of a DynAny.Collectively, these operations enable iteration over the components of a DynAny, for example, to (recursively) examine its contents.A constructed DynAny object is a DynAny object associated with a constructed type.There is a different interface, inheriting from the DynAny interface, associated with each kind of constructed type in IDL (fixed, enum, struct, sequence, union, array, exception, and value type).A constructed DynAny object exports operations that enable the creation of new DynAny objects, each of them associated with a component of the constructed data value.As an example, a DynStruct is associated with a struct value.This means that the DynStruct may be seen as owning an ordered collection of components, one for each structure member.The DynStruct object exports operations that enable the creation of new DynAny objects, each of them associated with a member of the struct.If a DynAny object has been obtained from another (constructed)DynAny object, such as a DynAny representing a structure member that was created from a DynStruct, the member DynAny is logically contained in the DynStruct.Calling an insert or get operation leaves the current position unchanged.Destroying a top-level DynAny object (one that was not obtained as a component of another DynAny) also destroys any component DynAny objects obtained from it.DynAny object does nothing.Invoking operations on a destroyed top-level DynAny or any of its descendants raises OBJECT_NOT_EXIST.If the programmer wants to destroy a DynAny object but still wants to manipulate some component of the data value associated with it, then he or she should first create a DynAny for the component and, after that, make a copy of the created DynAny object.The behavior of DynAny objects has been defined in order to enable efficient implementations in terms of allocated memory space and speed of access.DynAny objects are intended to be used for traversing values extracted from anys or constructing values of anys at runtime.Their use for other purposes is not recommended.Insert and get operations are necessary to handle basic DynAny objects but are also helpful to handle constructed DynAny objects.Inserting a basic data type value into a constructed DynAny object implies initializing the current component of the constructed data value associated with the DynAny object.For example, invoking insert_boolean on a DynStruct implies inserting a boolean data value at the current position of the associated struct data value.A type is consistent for inserting or extracting a value if its TypeCode is equivalent to the TypeCode contained in the DynAny or, if the DynAny has components, is equivalent to the TypeCode of the DynAny at the current position.DynAny and DynAnyFactory objects are intended to be local to the process in which they are created and used.This means that references to DynAny and DynAnyFactory objects cannot be exported to other processes, or externalized with ORB.object_to_string().If any attempt is made to do so, the offending operation will raise a MARSHAL system exception.Since their interfaces are specified in IDL, DynAny objects export operations defined in the standard org.omg.CORBA.Object interface.However, any attempt to invoke operations exported through the Object interface may raise the standard NO_IMPLEMENT exception.An attempt to use a DynAny object with the DII may raise the NO_IMPLEMENT exception."},
{"description": "A Duration object represents a period of Gregorian time, which consists of six fields (years, months, days, hours, minutes, and seconds) plus a sign (+/-) field.The first five fields have non-negative (>=0) integers or null (which represents that the field is not set), and the seconds field has a non-negative decimal or null.A negative sign indicates a negative duration.This class provides a number of methods that make it easy to use for the duration datatype of XML Schema 1.0 with the errata.Order relationship Duration objects only have partial order, where two values A and B maybe either:A<B (A is shorter than B)A>B (A is longer than B)A==B (A and B are of the same duration)(Comparison between A and B is indeterminate)For example, 30 days cannot be meaningfully compared to one month.method implements this relationship.This class provides a set of basic arithmetic operations, such as addition, subtraction and multiplication.Because durations don't have total order, an operation could fail for some combinations of operations.For example, you cannot subtract 15 days from 1 month.See the javadoc of those methods for detailed conditions where this could happen.Also, division of a duration by a number is not provided because the Duration class can only deal with finite precision decimal numbers.For example, one cannot represent 1 sec divided by 3.However, you could substitute a division by 3 with multiplying by numbers such as 0.3 or 0.333.Range of allowed values Because some operations of Duration rely on Calendar even though Duration can hold very large or very small values, some of the methods may not work correctly on such Durations.The impacted methods document their dependency on Calendar."},
{"description": "This class models a quantity or amount of time in terms of seconds and nanoseconds.It can be accessed using other duration-based units, such as minutes and hours.In addition, the DAYS unit can be used and is treated as exactly equal to 24 hours, thus ignoring daylight savings effects.A physical duration could be of infinite length.For practicality, the duration is stored with constraints similar to Instant.The duration uses nanosecond resolution with a maximum value of the seconds that can be held in a long.This is greater than the current estimated age of the universe.The range of a duration requires the storage of a number larger than a long.To achieve this, the class stores a long representing seconds and an int representing nanosecond-of-second, which will always be between 0 and 999,999,999.The model is of a directed duration, meaning that the duration may be negative.The duration is measured in \"seconds\", but these are not necessarily identical to the scientific \"SI second\" definition based on atomic clocks.This difference only impacts durations measured near a leap-second and should not affect most applications.This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of Duration may have unpredictable results and should be avoided.The equals method should be used for comparisons."},
{"description": "Defines the methods that should be implemented by a Dynamic MBean (MBean that exposes a dynamic management interface)."},
{"description": "POA-based DSI servants inherit from the standard DynamicImplementation class, this class inherits from the Servant class."},
{"description": "Any values can be dynamically interpreted (traversed) and constructed through DynAny objects.A DynAny object is associated with a data value which corresponds to a copy of the value inserted into an any.A DynAny object may be viewed as an ordered collection of component DynAnys.For DynAnys representing a basic type, such as long, or a type without components, such as an empty exception, the ordered collection of components is empty.Each DynAny object maintains the notion of a current position into its collection of component DynAnys.The current position is identified by an index value that runs from 0 to n-1, where n is the number of components.The special index value -1 indicates a current position that points nowhere.For values that cannot have a current position (such as an empty exception), the index value is fixed at -1.If a DynAny is initialized with a value that has components, the index is initialized to 0.After creation of an uninitialized DynAny (that is, a DynAny that has no value but a TypeCode that permits components), the current position depends on the type of value represented by the DynAny.(The current position is set to 0 or -1, depending on whether the new DynAny gets default values for its components.)The iteration operations rewind, seek, and next can be used to change the current position and the current_component operation returns the component at the current position.The component_count operation returns the number of components of a DynAny.Collectively, these operations enable iteration over the components of a DynAny, for example, to (recursively) examine its contents.A constructed DynAny object is a DynAny object associated with a constructed type.There is a different interface, inheriting from the DynAny interface, associated with each kind of constructed type in IDL (fixed, enum, struct, sequence, union, array, exception, and value type).A constructed DynAny object exports operations that enable the creation of new DynAny objects, each of them associated with a component of the constructed data value.As an example, a DynStruct is associated with a struct value.This means that the DynStruct may be seen as owning an ordered collection of components, one for each structure member.The DynStruct object exports operations that enable the creation of new DynAny objects, each of them associated with a member of the struct.If a DynAny object has been obtained from another (constructed)DynAny object, such as a DynAny representing a structure member that was created from a DynStruct, the member DynAny is logically contained in the DynStruct.Calling an insert or get operation leaves the current position unchanged.Destroying a top-level DynAny object (one that was not obtained as a component of another DynAny) also destroys any component DynAny objects obtained from it.DynAny object does nothing.Invoking operations on a destroyed top-level DynAny or any of its descendants raises OBJECT_NOT_EXIST.If the programmer wants to destroy a DynAny object but still wants to manipulate some component of the data value associated with it, then he or she should first create a DynAny for the component and, after that, make a copy of the created DynAny object.The behavior of DynAny objects has been defined in order to enable efficient implementations in terms of allocated memory space and speed of access.DynAny objects are intended to be used for traversing values extracted from anys or constructing values of anys at runtime.Their use for other purposes is not recommended.Insert and get operations are necessary to handle basic DynAny objects but are also helpful to handle constructed DynAny objects.Inserting a basic data type value into a constructed DynAny object implies initializing the current component of the constructed data value associated with the DynAny object.For example, invoking insert_boolean on a DynStruct implies inserting a boolean data value at the current position of the associated struct data value.A type is consistent for inserting or extracting a value if its TypeCode is equivalent to the TypeCode contained in the DynAny or, if the DynAny has components, is equivalent to the TypeCode of the DynAny at the current position.DynAny and DynAnyFactory objects are intended to be local to the process in which they are created and used.This means that references to DynAny and DynAnyFactory objects cannot be exported to other processes, or externalized with ORB.object_to_string().If any attempt is made to do so, the offending operation will raise a MARSHAL system exception.Since their interfaces are specified in IDL, DynAny objects export operations defined in the standard org.omg.CORBA.Object interface.However, any attempt to invoke operations exported through the Object interface may raise the standard NO_IMPLEMENT exception.An attempt to use a DynAny object with the DII may raise the NO_IMPLEMENT exception."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.If a SAX application needs information about notations and unparsed entities, then the application implements this interface and registers an instance with the SAX parser using the parser's setDTDHandler method.The parser uses the instance to report notation and unparsed entity declarations to the application.Note that this interface includes only those DTD events that the XML recommendation requires processors to report: notation and unparsed entity declarations.The SAX parser may report these events in any order, regardless of the order in which the notations and unparsed entities were declared; however, all DTD events must be reported after the document handler's startDocument event, and before the first startElement event.(If the LexicalHandler is used, these events must also be reported before the endDTD event.)It is up to the application to store the information for future use (perhaps in a hash table or object tree).If the application encounters attributes of type \"NOTATION\", \"ENTITY\", or \"ENTITIES\", it can use the information that it obtained through this interface to find the entity and/or notation corresponding with the attribute value."},
{"description": "Unchecked exception thrown when duplicate flags are provided in the format specifier.Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown."},
{"description": "The names of the constants correspond the the equivalent SGML constructs as described in \"The SGML Handbook\" by Charles F. Goldfarb."},
{"description": "This is the top level interface for events dealing with DTDs"},
{"description": "DTD describes a document syntax and is used in parsing of HTML documents.It contains a list of elements and their attributes as well as a list of entities defined in the DTD."},
{"description": "This class specifies a DSA public key with its associated parameters."},
{"description": "DSA (Digital Signature Algorithm) is defined in NIST's FIPS-186."},
{"description": "This class specifies a DSA private key with its associated parameters."},
{"description": "DSA (Digital Signature Algorithm) is defined in NIST's FIPS-186."},
{"description": "Interface to a DSA-specific set of key parameters, which defines a DSA key family.DSA (Digital Signature Algorithm) is defined in NIST's FIPS-186."},
{"description": "This class specifies the set of parameters used with the DSA algorithm."},
{"description": "DSA (Digital Signature Algorithm) is defined in NIST's FIPS-186."},
{"description": "The initialize methods may each be called any number of times.If no initialize method is called on a DSAKeyPairGenerator, the default is to generate 1024-bit keys, using precomputed p, q and g parameters and an instance of SecureRandom as the random bit source.Users wishing to indicate DSA-specific parameters, and to generate a key pair suitable for use with the DSA algorithm typically Get a key pair generator for the DSA algorithm by calling the KeyPairGenerator getInstance method with \"DSA\" as its argument.Note: it is not always necessary to do do algorithm-specific initialization for a DSA key pair generator.That is, it is not always necessary to call an initialize method in this interface.Algorithm-independent initialization using the initialize method in the KeyPairGenerator interface is all that is needed when you accept defaults for algorithm-specific parameters.Note: Some earlier implementations of this interface may not support larger sizes of DSA parameters such as 2048 and 3072-bit."},
{"description": "The DropTargetListener interface is the callback interface used by the DropTarget class to provide notification of DnD operations that involve the subject DropTarget.Methods of this interface may be implemented to provide \"drag under\" visual feedback to the user throughout the Drag and Drop operation.When the drag enters, moves over, or exits the operable part of the drop site for that DropTarget, when the drop action changes, and when the drop occurs, the relevant method in the listener object is invoked, and the DropTargetEvent is passed to it.The operable part of the drop site for the DropTarget is the part of the associated Component's geometry that is not obscured by an overlapping top-level window or by another Component higher in the Z-order that has an associated active DropTarget.During the drag, the data associated with the current drag operation can be retrieved by calling getTransferable() on DropTargetDragEvent instances passed to the listener's methods."},
{"description": "The DropTargetEvent is the base class for both the DropTargetDragEvent and the DropTargetDropEvent.It encapsulates the current state of the Drag and Drop operations, in particular the current DropTargetContext."},
{"description": "The DropTargetDropEvent is delivered via the DropTargetListener drop() method.The DropTargetDropEvent reports the source drop actions and the user drop action that reflect the current state of the drag-and-drop operation.Source drop actions is a bitwise mask of DnDConstants that represents the set of drop actions supported by the drag source for this drag-and-drop operation.User drop action depends on the drop actions supported by the drag source and the drop action selected by the user.The user can select a drop action by pressing modifier keys during the drag operation:ACTION_LINK Ctrl -> ACTION_COPY Shift -> ACTION_MOVE If the user selects a drop action, the user drop action is one of DnDConstants that represents the selected drop action if this drop action is supported by the drag source or DnDConstants.ACTION_NONE if this drop action is not supported by the drag source.If the user doesn't select a drop action, the set of DnDConstants that represents the set of drop actions supported by the drag source is searched for DnDConstants.and the user drop actionIf no constant is found the user drop action is DnDConstants."},
{"description": "Driver properties for making a connection.The DriverPropertyInfo class is of interest only to advanced programmers who need to interact with a Driver via the method getDriverProperties to discover and supply properties for connections."},
{"description": "The DropTargetDragEvent is delivered to a DropTargetListener via its dragEnter() and dragOver() methods.The DropTargetDragEvent reports the source drop actions and the user drop action that reflect the current state of the drag operation.Source drop actions is a bitwise mask of DnDConstants that represents the set of drop actions supported by the drag source for this drag operation.User drop action depends on the drop actions supported by the drag source and the drop action selected by the user.The user can select a drop action by pressing modifier keys during the drag operation:ACTION_LINK Ctrl -> ACTION_COPY Shift -> ACTION_MOVE If the user selects a drop action, the user drop action is one of DnDConstants that represents the selected drop action if this drop action is supported by the drag source or DnDConstants.ACTION_NONE if this drop action is not supported by the drag source.If the user doesn't select a drop action, the set of DnDConstants that represents the set of drop actions supported by the drag source is searched for DnDConstants.and the user drop actionIf no constant is found the user drop action is DnDConstants."},
{"description": "The methods in this class are empty.This class exists only as a convenience for creating listener objects.(If you implement the DropTargetListener interface, you have to define all of the methods in it.This abstract class defines a null implementation for every method except drop(DropTargetDropEvent), so you only have to define methods for events you care about.)You must provide an implementation for at least drop(DropTargetDropEvent).This method cannot have a null implementation because its specification requires that you either accept or reject the drop, and, if accepted, indicate whether the drop was successful.When the drag enters, moves over, or exits the operable part of the drop site for that DropTarget, when the drop action changes, and when the drop occurs, the relevant method in the listener object is invoked, and the DropTargetEvent is passed to it.The operable part of the drop site for the DropTarget is the part of the associated Component's geometry that is not obscured by an overlapping top-level window or by another Component higher in the Z-order that has an associated active DropTarget.During the drag, the data associated with the current drag operation can be retrieved by calling getTransferable() on DropTargetDragEvent instances passed to the listener's methods."},
{"description": "this protected nested class implements autoscrolling"},
{"description": "A DropTargetContext is created whenever the logical cursor associated with a Drag and Drop operation coincides with the visible geometry of a Component associated with a DropTarget.The DropTargetContext provides the mechanism for a potential receiver of a drop operation to both provide the end user with the appropriate drag under feedback, but also to effect the subsequent data transfer if appropriate."},
{"description": "The DropTarget is associated with a Component when that Component wishes to accept drops during Drag and Drop operations.Each DropTarget is associated with a FlavorMap.The default FlavorMap hereafter designates the FlavorMap returned by SystemFlavorMap.getDefaultFlavorMap()."},
{"description": "The DataSource interface, new in the JDBC 2.0 API, provides another way to connect to a data source.The use of a DataSource object is the preferred means of connecting to a data source.As part of its initialization, the DriverManager class will attempt to load the driver classes referenced in the \"jdbc.drivers\" system property.This allows a user to customize the JDBC Drivers used by their applications.For example in your ~/.hotjava/properties file you might specify: jdbc.drivers=foo.bah.Driver:wombat.sql.Driver:bad.taste.ourDriverThe DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition Service Provider mechanism.JDBC 4.0 Drivers must include the file META-INF/services/java.sql.This file contains the name of the JDBC drivers implementation of java.sql.Driver.Driver file would contain the entry: my.sql.DriverApplications no longer need to explicitly load JDBC drivers using Class.forName().Existing programs which currently load JDBC drivers using Class.forName() will continue to work without modification.When the method getConnection is called, the DriverManager will attempt to locate a suitable driver from amongst those loaded at initialization and those loaded explicitly using the same classloader as the current applet or application.Starting with the Java 2 SDK, Standard Edition, version 1.3, a logging stream can be set only if the proper permission has been granted.Normally this will be done with the tool PolicyTool, which can be used to grant permission java.sql.SQLPermission"},
{"description": "The class that is interested in processing mouse motion events during a drag operation either implements this interface or extends the abstract DragSourceAdapter class (overriding only the methods of interest).Whenever the mouse moves during a drag operation initiated with this DragSource, that object's dragMouseMoved method is invoked, and the DragSourceDragEvent is passed to it."},
{"description": "The DragSourceDragEvent is delivered from the DragSourceContextPeer, via the DragSourceContext, to the DragSourceListener registered with that DragSourceContext and with its associated DragSource.The DragSourceDragEvent reports the target drop action and the user drop action that reflect the current state of the drag operation.Target drop action is one of DnDConstants that represents the drop action selected by the current drop target if this drop action is supported by the drag source or DnDConstants.ACTION_NONE if this drop action is not supported by the drag source.User drop action depends on the drop actions supported by the drag source and the drop action selected by the user.The user can select a drop action by pressing modifier keys during the drag operation:ACTION_LINK Ctrl -> ACTION_COPY Shift -> ACTION_MOVE If the user selects a drop action, the user drop action is one of DnDConstants that represents the selected drop action if this drop action is supported by the drag source or DnDConstants.ACTION_NONE if this drop action is not supported by the drag source.If the user doesn't select a drop action, the set of DnDConstants that represents the set of drop actions supported by the drag source is searched for DnDConstants.and the user drop actionIf no constant is found the user drop action is DnDConstants."},
{"description": "This class is the base class for DragSourceDragEvent and DragSourceDropEvent.DragSourceEvents are generated whenever the drag enters, moves over, or exits a drop site, when the drop action changes, and when the drag ends.The location for the generated DragSourceEvent specifies the mouse cursor location in screen coordinates at the moment this event occurred.In a multi-screen environment without a virtual device, the cursor location is specified in the coordinate system of the initiator GraphicsConfiguration.The initiator GraphicsConfiguration is the GraphicsConfiguration of the Component on which the drag gesture for the current drag operation was recognized.If the cursor location is outside the bounds of the initiator GraphicsConfiguration, the reported coordinates are clipped to fit within the bounds of that GraphicsConfiguration.In a multi-screen environment with a virtual device, the location is specified in the corresponding virtual coordinate system.If the cursor location is outside the bounds of the virtual device the reported coordinates are clipped to fit within the bounds of the virtual device."},
{"description": "An interface that must be implemented when a Driver wants to be notified by DriverManager.A DriverAction implementation is not intended to be used directly by applications.A JDBC Driver may choose to create its DriverAction implementation in a private class to avoid it being called directly.Driver, java.sql.DriverAction) in order to inform DriverManager which DriverAction implementation to call when the JDBC driver is de-registered."},
{"description": "The interface that every driver class must implement.The Java SQL framework allows for multiple database drivers.Each driver should supply a class that implements the Driver interface.The DriverManager will try to load as many drivers as it can find and then for any given connection request, it will ask each driver in turn to try to connect to the target URL.It is strongly recommended that each Driver class should be small and standalone so that the Driver class can be loaded and queried without bringing in vast quantities of supporting code.When a Driver class is loaded, it should create an instance of itself and register it with the DriverManager.This means that a user can load and register a driver by calling: Class.forName(\"foo.bah.A JDBC driver may create a DriverAction implementation in order to receive notifications when DriverManager.deregisterDriver(java.sql."},
{"description": "The DragSourceListener defines the event interface for originators of Drag and Drop operations to track the state of the user's gesture, and to provide appropriate \"drag over\" feedback to the user throughout the Drag and Drop operation.The drop site is associated with the previous dragEnter() invocation if the latest invocation of dragEnter() on this listener: corresponds to that drop site and is not followed by a dragExit() invocation on this listener."},
{"description": "The DragSourceDropEvent is delivered from the DragSourceContextPeer, via the DragSourceContext, to the dragDropEnd method of DragSourceListeners registered with that DragSourceContext and with its associated DragSource.It contains sufficient information for the originator of the operation to provide appropriate feedback to the end user when the operation completes."},
{"description": "The DragSourceContext class is responsible for managing the initiator side of the Drag and Drop protocol.In particular, it is responsible for managing drag event notifications to the DragSourceListeners and DragSourceMotionListeners, and providing the Transferable representing the source data for the drag operation.Note that the DragSourceContext itself implements the DragSourceListener and DragSourceMotionListener interfaces.This is to allow the platform peer (the DragSourceContextPeer instance) created by the DragSource to notify the DragSourceContext of state changes in the ongoing operation.This allows the DragSourceContext object to interpose itself between the platform and the listeners provided by the initiator of the drag operation.By default, DragSourceContext sets the cursor as appropriate for the current state of the drag and drop operation.For example, if the user has chosen the move action, and the pointer is over a target that accepts the move action, the default move cursor is shown.When the pointer is over an area that does not accept the transfer, the default \"no drop\" cursor is shown.This default handling mechanism is disabled when a custom cursor is set by the setCursor(java.awt.Cursor) method.When the default handling is disabled, it becomes the responsibility of the developer to keep the cursor up to date, by listening to the DragSource events and calling the setCursor() method.Alternatively, you can provide custom cursor behavior by providing custom implementations of the DragSource and the DragSourceContext classes."},
{"description": "The methods in this class are empty.This class exists only as a convenience for creating listener objects.(If you implement the DragSourceListener interface, you have to define all of the methods in it.This abstract class defines null methods for them all, so you only have to define methods for events you care about.)When the drag enters, moves over, or exits a drop site, when the drop action changes, and when the drag ends, the relevant method in the listener object is invoked, and the DragSourceEvent is passed to it.The drop site is associated with the previous dragEnter() invocation if the latest invocation of dragEnter() on this adapter corresponds to that drop site and is not followed by a dragExit() invocation on this adapter."},
{"description": "The DragGestureRecognizer is an abstract base class for the specification of a platform-dependent listener that can be associated with a particular Component in order to identify platform-dependent drag initiating gestures.The appropriate DragGestureRecognizer subclass instance is obtained from the DragSource associated with a particular Component, or from the Toolkit object via its createDragGestureRecognizer() method.Once the DragGestureRecognizer is associated with a particular Component it will register the appropriate listener interfaces on that Component in order to track the input events delivered to the Component.Once the DragGestureRecognizer identifies a sequence of events on the Component as a drag initiating gesture, it will notify its unicast DragGestureListener by invoking its gestureRecognized() method.When a concrete DragGestureRecognizer instance detects a drag initiating gesture on the Component it is associated with, it fires a DragGestureEvent to the DragGestureListener registered on its unicast event source for DragGestureListener events.This DragGestureListener is responsible for causing the associated DragSource to start the Drag and Drop operation (if appropriate)."},
{"description": "The DragSource is the entity responsible for the initiation of the Drag and Drop operation, and may be used in a number of scenarios: 1 default instance per JVM for the lifetime of that JVM.[implementation dependent] Once the DragSource is obtained, a DragGestureRecognizer should also be obtained to associate the DragSource with a particular Component.The initial interpretation of the user's gesture, and the subsequent starting of the drag operation are the responsibility of the implementing Component, which is usually implemented by a DragGestureRecognizer.When a drag gesture occurs, the DragSource's startDrag() method shall be invoked in order to cause processing of the user's navigational gestures and delivery of Drag and Drop protocol notifications.A DragSource shall only permit a single Drag and Drop operation to be current at any one time, and shall reject any further startDrag() requests by throwing an IllegalDnDOperationException until such time as the extant operation is complete.The startDrag() method invokes the createDragSourceContext() method to instantiate an appropriate DragSourceContext and associate the DragSourceContextPeer with that.If the Drag and Drop System is unable to initiate a drag operation for some reason, the startDrag() method throws a java.awt.dnd.InvalidDnDOperationException to signal such a condition.Typically this exception is thrown when the underlying platform system is either not in a state to initiate a drag, or the parameters specified are invalid.Note that during the drag, the set of operations exposed by the source at the start of the drag operation may not change until the operation is complete.The operation(s) are constant for the duration of the operation with respect to the DragSource."},
{"description": "A DragGestureEvent is passed to DragGestureListener's dragGestureRecognized() method when a particular DragGestureRecognizer detects that a platform dependent drag initiating gesture has occurred on the Component that it is tracking.The action field of any DragGestureEvent instance should take one of the following values: DnDConstants.Assigning the value different from listed above will cause an unspecified behavior."},
{"description": "This interface is intended for a drag gesture recognition implementation.Upon recognition of a drag gesture the DragGestureRecognizer calls this interface's dragGestureRecognized() method and passes a DragGestureEvent."},
{"description": "Represents a function that accepts a double-valued argument and produces a long-valued result.This is the double-to-long primitive specialization for Function.This is a functional interface whose functional method is applyAsLong(double)."},
{"description": "Represents an operation on a single double-valued operand that produces a double-valued result.This is the primitive type specialization of UnaryOperator for double.This is a functional interface whose functional method is applyAsDouble(double)."},
{"description": "This is the double-producing primitive specialization of Supplier.There is no requirement that a distinct result be returned each time the supplier is invoked.This is a functional interface whose functional method is getAsDouble()."},
{"description": "A state object for collecting statistics such as count, min, max, sum, and average.This class is designed to work with (though does not require) streams.For example, you can compute summary statistics on a stream of doubles with: DoubleSummaryStatistics stats = doubleStream.collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept, DoubleSummaryStatistics::combine); DoubleSummaryStatistics can be used as a reduction target for a stream."},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "This is the double primitive specialization of Stream.The following example illustrates an aggregate operation using Stream and DoubleStream, computing the sum of the weights of the red widgets: double sum"},
{"description": "This is the double-consuming primitive type specialization of Predicate.This is a functional interface whose functional method is test(double)."},
{"description": "Represents a function that accepts a double-valued argument and produces an int-valued result.This is the double-to-int primitive specialization for Function.This is a functional interface whose functional method is applyAsInt(double)."},
{"description": "A stream builder has a lifecycle, which starts in a building phase, during which elements can be added, and then transitions to a built phase, after which elements may not be added.The built phase begins when the build() method is called, which creates an ordered stream whose elements are the elements that were added to the stream builder, in the order they were added."},
{"description": "Represents a function that accepts a double-valued argument and produces a result.This is the double-consuming primitive specialization for Function.This is a functional interface whose functional method is apply(double)."},
{"description": "This class defines four categories of operations upon double buffers: Absolute and relative get and put methods that read and write single doubles; Relative bulk get methods that transfer contiguous sequences of doubles from this buffer into an array; and Relative bulk put methods that transfer contiguous sequences of doubles from a double array or some other double buffer into this buffer; and Methods for compacting, duplicating, and slicing a double buffer.Double buffers can be created either by allocation, which allocates space for the buffer's content, by wrapping an existing double array into a buffer, or by creating a view of an existing byte buffer.Like a byte buffer, a double buffer is either direct or non-direct.A double buffer created via the wrap methods of this class will be non-direct.A double buffer created as a view of a byte buffer will be direct if, and only if, the byte buffer itself is direct.Whether or not a double buffer is direct may be determined by invoking the isDirect method.Methods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked."},
{"description": "This is the primitive type specialization of BinaryOperator for double.This is a functional interface whose functional method is applyAsDouble(double, double)."},
{"description": "One or more variables that together maintain an initially zero double sum.When updates (method add(double)) are contended across threads, the set of variables may grow dynamically to reduce contention.Method sum() (or, equivalently doubleValue()) returns the current total combined across the variables maintaining the sum.The order of accumulation within or across threads is not guaranteed.Thus, this class may not be applicable if numerical stability is required, especially when combining values of substantially different orders of magnitude.This class is usually preferable to alternatives when multiple threads update a common value that is used for purposes such as summary statistics that are frequently updated but less frequently read.This class extends Number, but does not define methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are not useful as collection keys."},
{"description": "One or more variables that together maintain a running double value updated using a supplied function.When updates (method accumulate(double)) are contended across threads, the set of variables may grow dynamically to reduce contention.Method get() (or, equivalently, doubleValue()) returns the current value across the variables maintaining updates.This class is usually preferable to alternatives when multiple threads update a common value that is used for purposes such as summary statistics that are frequently updated but less frequently read.The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.The function is applied with the current value as its first argument, and the given update as the second argument.For example, to maintain a running maximum value, you could supply Double::max along with Double.The order of accumulation within or across threads is not guaranteed.Thus, this class may not be applicable if numerical stability is required, especially when combining values of substantially different orders of magnitude.Class DoubleAdder provides analogs of the functionality of this class for the common special case of maintaining sums.The call new DoubleAdder() is equivalent to new DoubleAccumulator((x, yThis class extends Number, but does not define methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are not useful as collection keys."},
{"description": "Represents an operation that accepts a single double-valued argument and returns no result.This is the primitive type specialization of Consumer for double.Unlike most other functional interfaces, DoubleConsumer is expected to operate via side-effects.This is a functional interface whose functional method is accept(double)."},
{"description": "A Holder class for a double that is used to store \"out\" and \"inout\" parameters in IDL methods.If an IDL method signature has an IDL double as an \"out\" or \"inout\" parameter, the programmer must pass an instance of DoubleHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myDoubleHolder is an instance of DoubleHolder, the value stored in its value field can be accessed with myDoubleHolder.value."},
{"description": "The Double class wraps a value of the primitive type double in an object.An object of type Double contains a single field whose type is double.In addition, this class provides several methods for converting a double to a String and a String to a double, as well as other constants and methods useful when dealing with a double."},
{"description": "A file attribute view that provides a view of the legacy \"DOS\" file attributes.These attributes are supported by file systems such as the File Allocation Table (FAT) format commonly used in consumer devices.A DosFileAttributeView is a BasicFileAttributeView that additionally supports access to the set of DOS attribute flags that are used to indicate if the file is read-only, hidden, a system file, or archived.Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by BasicFileAttributeView, and in addition, the following attributes are supported: Name Type readonly Boolean hidden Boolean systemBoolean The getAttribute method may be used to read any of these attributes, or any of the attributes defined by BasicFileAttributeView as if by invoking the readAttributes() method.The setAttribute method may be used to update the file's last modified time, last access time or create time attributes as defined by BasicFileAttributeView.It may also be used to update the DOS attributes as if by invoking the setReadOnly, setHidden, setSystem, and setArchive methods respectively."},
{"description": "This class contains additional methods to specify the location in a DOM tree where an XMLSignature is to be unmarshalled and validated from.Note that the behavior of an unmarshalled XMLSignature is undefined if the contents of the underlying DOM tree are modified by the caller after the XMLSignature is created.Also, note that DOMValidateContext instances can contain information and state specific to the XML signature structure it is used with.The results are unpredictable if a DOMValidateContext is used with different signature structures (for example, you should not use the same DOMValidateContext instance to validate two different XMLSignature objects)."},
{"description": "This class contains additional methods to specify the location in a DOM tree where an XMLSignature object is to be marshalled when generating the signature.Note that DOMSignContext instances can contain information and state specific to the XML signature structure it is used with.The results are unpredictable if a DOMSignContext is used with different signature structures (for example, you should not use the same DOMSignContext instance to sign two different XMLSignature objects)."},
{"description": "The purpose of this class is to allow a DOM node to be used to represent extensible content (any elements or mixed content) in XML Signature structures.If a sequence of nodes is needed, the node contained in the DOMStructure is the first node of the sequence and successive nodes can be accessed by invoking Node.getNextSibling().If the owner document of the DOMStructure is different than the target document of an XMLSignature, the XMLSignature.sign(XMLSignContext) method imports the node into the target document before generating the signature."},
{"description": "The DOMStringList interface provides the abstraction of an ordered collection of DOMString values, without defining or constraining how this collection is implemented.The items in the DOMStringList are accessible via an integral index, starting from 0."},
{"description": "Note that XSLT requires namespace support.Attempting to transform a DOM that was not contructed with a namespace-aware parser may result in errors.Parsers can be made namespace aware by calling DocumentBuilderFactory.setNamespaceAware(boolean awareness)."},
{"description": "File attributes associated with a file in a file system that supports legacy \"DOS\" attributes."},
{"description": "The purpose of this class is to provide additional context necessary for resolving XPointer URIs or same-document references."},
{"description": "If no output DOM source is set, the transformation will create a Document node as the holder for the result of the transformation, which may be retrieved with getNode()."},
{"description": "DOMLocator is an interface that describes a location (e.g. where an error occurred)."},
{"description": "To use a DOMLocator, the receiver of an error must downcast the SourceLocator object returned by an exception.A Transformer may use this object for purposes other than error reporting, for instance, to indicate the source node that originated a result node."},
{"description": "This interface permits a DOM implementer to supply one or more implementations, based upon requested features and versions, as specified in DOM Features.Each implemented DOMImplementationSource object is listed in the binding-specific list of available sources so that its DOMImplementation objects are made available."},
{"description": "A factory that enables applications to obtain instances of DOMImplementation.; This provides an application with an implementation-independent starting point.DOM implementations may modify this class to meet new security standards or to provide *additional* fallbacks for the list of DOMImplementationSources."},
{"description": "DOMImplementationLS contains the factory methods for creating Load and Save objects.The expectation is that an instance of the DOMImplementationLS interface can be obtained by using binding-specific casting methods on an instance of the DOMImplementation interface or, if the Document supports the feature \"Core\" version \"3.0\" defined in [DOM Level 3 Core] , by using the method DOMImplementation.getFeature with parameter values \"LS\" (or \"LS-Async\") and \"3.0\" (respectively)."},
{"description": "The DOMImplementationList interface provides the abstraction of an ordered collection of DOM implementations, without defining or constraining how this collection is implemented.The items in the DOMImplementationList are accessible via an integral index, starting from 0."},
{"description": "The DOMImplementation interface provides a number of methods for performing operations that are independent of any particular instance of the document object model."},
{"description": "Implementations of this interface will be used in conjunction with XmlAnyElement annotation to map an element of XML into a representation of infoset such as W3C DOM.Implementations hide how a portion of XML is converted into/from such DOM-like representation, allowing JAXB providers to work with arbitrary such library.This interface is intended to be implemented by library writers and consumed by JAXB providers.None of those methods are intended to be called from applications."},
{"description": "DOM operations only raise exceptions in \"exceptional\" circumstances, i.e., when an operation is impossible to perform (either for logical reasons, because data is lost, or because the implementation has become unstable).In general, DOM methods return specific error values in ordinary processing situations, such as out-of-bound errors when using NodeList.Implementations should raise other exceptions under other circumstances.For example, implementations should raise an implementation-dependent exception if a null argument is passed when null was not expected.Some languages and object systems do not support the concept of exceptions.For such systems, error conditions may be indicated using native error reporting mechanisms.For some bindings, for example, methods may return error codes similar to those listed in the corresponding method descriptions."},
{"description": "DOMErrorHandler is a callback interface that the DOM implementation can call when reporting errors that happens while processing XML data, or when doing some other processing (e.g. validating a document).A DOMErrorHandler object can be attached to a Document using the \"error-handler\" on the DOMConfiguration interface.If more than one error needs to be reported during an operation, the sequence and numbers of the errors passed to the error handler are implementation dependent.The application that is using the DOM implementation is expected to implement this interface."},
{"description": "DOMError is an interface that describes an error."},
{"description": "The DOMConfiguration interface represents the configuration of a document and maintains a table of recognized parameters.Using the configuration, it is possible to change Document.normalizeDocument() behavior, such as replacing the CDATASection nodes with Text nodes or specifying the type of the schema that must be used when the validation of the Document is requested.DOMConfiguration objects are also used in [DOM Level 3 Load and Save] in the DOMParser and DOMSerializer interfaces.The parameter names used by the DOMConfiguration object are defined throughout the DOM Level 3 specifications.To avoid possible conflicts, as a convention, names referring to parameters defined outside the DOM specification should be made unique.Because parameters are exposed as properties in names are recommended to follow the section 5.16 Identifiers of [Unicode] with the addition of the character '-' (HYPHEN-MINUS) but it is not enforced by the DOM implementation.DOM Level 3 Core Implementations are required to recognize all parameters defined in this specification.Some parameter values may also be required to be supported by the implementation.Refer to the definition of the parameter to know if a value must be supported or not.Note: Parameters are similar to features and properties used in SAX2 [SAX].The following list of parameters defined in the DOM: \"canonical-form\" true [optional] Canonicalize the document according to the rules specified in [Canonical XML], such as removing the DocumentType node (if any) from the tree, or removing superfluous namespace declarations from each element.Note that this is limited to what can be represented in the DOM; in particular, there is no way to specify the order of the attributes in the DOM.In addition, Setting this parameter to true will also set the state of the parameters listed below.Later changes to the state of one of those parameters will revert \"canonical-form\" back to false.Other parameters are not changed unless explicitly specified in the description of the parameters.(default)Do not canonicalize the document. \"cdata-sections\" true [required] (default)Keep CDATASection nodes in the document.The new Text node is then combined with any adjacent Text node.\"check-character-normalization\" true [optional] Check if the characters in the document are fully normalized, as defined in appendix B of [XML 1.1].When a sequence of characters is encountered that fails normalization checking, an error with the DOMError.type equals to \"check-character-normalization-failure\" is issued.Since this parameter requires to have schema information, the \"validate\" parameter will also be set to true.Having this parameter activated when \"validate\" is false has no effect and no schema-normalization will happen.Note: Since the document contains the result of the XML 1.0 processing, this parameter does not apply to attribute value normalization as defined in section 3.3.3 of [XML 1.0] and is only meant for schema languages other than Document Type Definition (DTD).false [required] (default) Do not perform schema normalization on the tree.\"element-content-whitespace\" true [required] (default)Keep all whitespaces in the document.false [optional] Discard all Text nodes that contain whitespaces in element content, as described in [element content whitespace].The implementation is expected to use the attribute Text.isElementContentWhitespace to determine if a Text node should be discarded or not.Text nodes are normalized, as defined in Node.normalize.Only unexpanded entity references are kept in the document.Note: This parameter does not affect Entity nodes. \"If an error is encountered in the document, the implementation will call back the DOMErrorHandler registered using this parameter.The implementation may provide a default DOMErrorHandler object.When called, DOMError.relatedData will contain the closest node to where the error occurred.If the implementation is unable to determine the node where the error occurs, DOMError.relatedData will contain the Document node.Mutations to the document from within an error handler will result in implementation dependent behavior. \"Other parameters are not changed unless explicitly specified in the description of the parameters.Note that querying this parameter with getParameter returns true only if the individual parameters specified above are appropriately set.false Setting infoset to false has no effect.namespaces\" true [required] (default) Perform the namespace processing as defined in .This parameter has no effect if the parameter \"namespaces\" is set to false.normalize-characters\" true [optional] Fully normalized the characters in the document as defined in appendix B of [XML 1.1].(default)Do not perform character normalization.\"schema-location\" [optional] Represent a DOMString object containing a list of URIs, separated by whitespaces (characters matching the nonterminal production S defined in section 2.3 [XML 1.0]), that represents the schemas against which validation should occur, i.e. the current schema.The types of schemas referenced in this list must match the type specified with schema-type, otherwise the behavior of an implementation is undefined.The schemas specified using this property take precedence to the schema information specified in the document itself.For namespace aware schema, if a schema specified using this property and a schema specified in the document instance (i.e. using the schemaLocation attribute) in a schema document (i.e. using schema import mechanisms) share the same targetNamespace, the schema specified by the user using this property will be used.If two schemas specified using this property share the same targetNamespace or have no namespace, the behavior is implementation dependent.It is strongly recommended that Document.documentURI will be set so that an implementation can successfully resolve any external entities referenced. \"schema-type\" [optional]Note that no lexical checking is done on the absolute URI.If this parameter is not set, a default value may be provided by the implementation, based on the schema languages supported and on the schema language used at load time.Note: For XML Schema [XML Schema Part 1] , applications must use the value \"http://www.w3.org/2001/XMLSchema\".For XML DTD [XML 1.0], applications must use the value \"http://www.w3.org/TR/REC-xml\".Other schema languages are outside the scope of the W3C and therefore should recommend an absolute URI in order to use this method.When a CDATA section is split a warning is issued with a DOMError.type equals to \"cdata-sections-splitted\" and DOMError.relatedData equals to the first CDATASection node in document order resulting from the split.false [required]Signal an error if a CDATASection contains an unrepresentable character.\"validate\" true [optional] Require the validation against a schema (i.e. XML schema, DTD, any other type or representation of schema) of the document as it is being normalized as defined by [XML 1.0].Schema-normalized values will not be exposed according to the schema in used unless the parameter \"datatype-normalization\" is true.This parameter will reevaluate: Attribute nodes with Attr.specified equals to false, as specified in the description of the Attr interface; The value of the attribute Text.isElementContentWhitespace for all Text nodes; The value of the attribute Attr.isId for all Attr nodes; The attributes Element.schemaTypeInfo and Attr.schemaTypeInfo.Note: \"validate-if-schema\" and \"validate\" are mutually exclusive, setting one of them to true will set the other one to false.Applications should also consider setting the parameter \"well-formed\" to true, which is the default for that option, when validating the document.validate-if-schema\" true [optional]Enable validation only if a declaration for the document element can be found in a schema (independently of where it is found, i.e. XML schema, DTD, or any other type or representation of schema).If validation is enabled, this parameter has the same behavior as the parameter \"validate\" set to true.Note: \"validate-if-schema\" and \"validate\" are mutually exclusive, setting one of them to true will set the other one to false.No schema processing should be performed if the document has a schema, including internal subset processing.Check if all nodes are XML well formed according to the XML version in use in Document.xmlVersion: check if the attribute Node.nodeName contains invalid characters according to its node type and generate a DOMError of type \"wf-invalid-character-in-node-name\", with a DOMError.SEVERITY_ERROR severity, if necessary; check if the data inside ProcessingInstruction nodes for invalid characters and generate a DOMError of type \"wf-invalid-character\", with a DOMError.The resolution of the system identifiers associated with entities is done using Document.documentURI.However, when the feature \"LS\" defined in [DOM Level 3 Load and Save] is supported by the DOM implementation, the parameter \"resource-resolver\" can also be used on DOMConfiguration objects attached to Document nodes.If this parameter is set, Document.normalizeDocument() will invoke the resource resolver instead of using Document.documentURI."},
{"description": "This class provides a DOM-specific implementation of the XMLCryptoContext interface.It also includes additional methods that are specific to a DOM-based implementation for registering and retrieving elements that contain attributes of type ID."},
{"description": "The DomainManager has associated with it the policy objects for a particular domain.The domain manager also records the membership of the domain and provides the means to add and remove members.The domain manager is itself a member of a domain, possibly the domain it manages.The domain manager provides mechanisms for establishing and navigating relationships to superior and subordinate domains and creating and accessing policies."},
{"description": "The DomainManager has associated with it the policy objects for a particular domain.The domain manager also records the membership of the domain and provides the means to add and remove members.The domain manager is itself a member of a domain, possibly the domain it manages.The domain manager provides mechanisms for establishing and navigating relationships to superior and subordinate domains and creating and accessing policies."},
{"description": "A DomainCombiner provides a means to dynamically update the ProtectionDomains associated with the current AccessControlContext.A DomainCombiner is passed as a parameter to the appropriate constructor for AccessControlContext.The newly constructed context is then passed to the AccessController.doPrivileged(..., context) method to bind the provided context (and associated DomainCombiner) with the current execution Thread.The combine method takes two arguments.The first argument represents an array of ProtectionDomains from the current execution Thread, since the most recent call to AccessController.doPrivileged.If no call to doPrivileged was made, then the first argument will contain all the ProtectionDomains from the current execution Thread.The second argument represents an array of inherited ProtectionDomains, which may be null.ProtectionDomains may be inherited from a parent Thread, or from a privileged context.If no call to doPrivileged was made, then the second argument will contain the ProtectionDomains inherited from the parent Thread.If one or more calls to doPrivileged were made, and the most recent call was to doPrivileged(action, context), then the second argument will contain the ProtectionDomains from the privileged context.If the most recent call was to doPrivileged(action), then there is no privileged context, and the second argument will be null.The combine method investigates the two input arrays of ProtectionDomains and returns a single array containing the updated ProtectionDomains.In the simplest case, the combine method merges the two stacks into one.In more complex cases, the combine method returns a modified stack of ProtectionDomains.The modification may have added new ProtectionDomains, removed certain ProtectionDomains, or simply updated existing ProtectionDomains.Re-ordering and other optimizations to the ProtectionDomains are also permitted.Typically the combine method bases its updates on the information encapsulated in the DomainCombiner.After the AccessController.getContext method receives the combined stack of ProtectionDomains back from the DomainCombiner, it returns a new AccessControlContext that has both the combined ProtectionDomains as well as the DomainCombiner."},
{"description": "A Parser for HTML Documents (actually, you can specify a DTD, but you should really only use this class with the html dtd in swing).This is the default parser used by HTMLEditorKit to parse HTML url's.This will message the callback for all valid tags, as well as tags that are implied but not explicitly specified.For example, the html string (<p>blah) only has a p tag defined.The callback will see the following methods: handleStartTag(html, ...)The items in italic are implied, that is, although they were not explicitly specified, to be correct html they should have been present (head isn't necessary, but it is still generated).For tags that are implied, the AttributeSet argument will have a value of Boolean.HTML.Attributes defines a type safe enumeration of html attributes.If an attribute key of a tag is defined in HTML.Attribute, the HTML.Attribute will be used as the key, otherwise a String will be used.For example <p foo=bar class=neat> has two attributes.foo is not defined in HTML.Attribute, where as class is, therefore the AttributeSet will have two values in it, HTML.Attribute.CLASS with a String value of 'neat' and the String key 'foo' with a String value of 'bar'.The position argument will indicate the start of the tag, comment or text.Similar to arrays, the first character in the stream has a position of 0.For tags that are implied the position will indicate the location of the next encountered tag.In the first example, the implied start body and html tags will have the same position as the p tag, and the implied end p, html and body tags will all have the same position.As html skips whitespace the position for text will be the position of the first valid character, eg in the string'\\n\\n\\nblah' the text 'blah' will have a position of 3, the newlines are skipped.For attributes that do not have a value, eg in the html string <foo blah>the attribute blah does not have a value, there are two possible values that will be placed in the AttributeSet's value: If the DTD does not contain an definition for the element, or the definition does not have an explicit value then the value in the AttributeSet will be HTML.NULL_ATTRIBUTE_VALUE.If the DTD contains an explicit value, as in: <!ATTLIST OPTION selected (selected) #IMPLIED>this value from the dtd (in this case selected) will be used.Once the stream has been parsed, the callback is notified of the most likely end of line string.The end of line string will be one of \\n, \\r or \\r\\n, which ever is encountered the most in parsing the stream."},
{"description": "Each Document has a doctype attribute whose value is either null or a DocumentType object.The DocumentType interface in the DOM Core provides an interface to the list of entities that are defined for the document, and little else because the effect of namespaces and the various XML schema efforts on DTD representation are not clearly understood as of this writing.DOM Level 3 doesn't support editing DocumentType nodes."},
{"description": "Class DocumentName is a printing attribute class, a text attribute, that specifies the name of a document.DocumentName is an attribute of the print data (the doc), not of the Print Job.A document's name is an arbitrary string defined by the client.However if a JobName is not specified, the DocumentName should be used instead, which implies that supporting specification of DocumentName requires reporting of JobName and vice versa.IPP Compatibility: The string value gives the IPP name value.The locale gives the IPP natural language.The category name returned by getName() gives the IPP attribute name."},
{"description": "The default implementation of the Document interface (AbstractDocument) supports asynchronous mutations.If this feature is used (i.e. mutations are made from a thread other than the Swing event thread), the listeners will be notified via the mutating thread.This means that if asynchronous updates are made, the implementation of this interface must be threadsafe!The DocumentEvent notification is based upon the JavaBeans event model.There is no guarantee about the order of delivery to listeners, and all listeners must be notified prior to making further mutations to the Document.This means implementations of the DocumentListener may not mutate the source of the event (i.e. the associated Document)."},
{"description": "The DocumentView interface is implemented by Document objects in DOM implementations supporting DOM Views.It provides an attribute to retrieve the default view of a document."},
{"description": "Configuration data that specifies the keystores in a keystore domain.A keystore domain is a collection of keystores that are presented as a single logical keystore.The configuration data is used during KeyStore load and store operations.The following syntax is supported for configuration data:; ... }; ... where domainName and keystoreName are identifiers and property is a key/value pairing.The key and value are separated by an 'equals' symbol and the value is enclosed in double quotes.A property value may be either a printable string or a binary string of colon-separated pairs of hexadecimal digits.Multi-valued properties are represented as a comma-separated list of values, enclosed in square brackets.To ensure that keystore entries are uniquely identified, each entry's alias is prefixed by its keystoreName followed by the entry name separator and each keystoreName must be unique within its domain.Entry name prefixes are omitted when storing a keystore.Properties are context-sensitive: properties that apply to all the keystores in a domain are located in the domain clause, and properties that apply only to a specific keystore are located in that keystore's clause.Unless otherwise specified, a property in a keystore clause overrides a property of the same name in the domain clause.\" The environment variable that stores a keystore password.Alternatively, passwords may be supplied to the constructor method in a Map<String, ProtectionParameter>.When specified, it applies to all the entries in a domain.Its default value is a space.For example, configuration data for a simple keystore domain comprising three keystores is shown below: domain app1 { keystore app1-truststore keystoreURI=\"file:///app1/etc/truststore.jks\"; keystore system-truststore keystoreURI=\"${java.home}/lib/security/cacerts\"; keystore app1-keystore"},
{"description": "This interface has been replaced by the SAX2 ContentHandler interface, which includes Namespace support."},
{"description": "This provides detailed information to Document observers about how the Document changed.It provides high level information such as type of change and where it occurred, as well as the more detailed structural changes (What Elements were inserted and removed)."},
{"description": "DocumentFragment is a \"lightweight\" or \"minimal\" Document object.It is very common to want to be able to extract a portion of a document's tree or to create a new fragment of a document.It is desirable to have an object which can hold such fragments and it is quite natural to use a Node for this purpose.While it is true that a Document object could fulfill this role, a Document object can potentially be a heavyweight object, depending on the underlying implementation.What is really needed for this is a very lightweight object.DocumentFragment is such an object.Furthermore, various operations -- such as inserting nodes as children of another Node -- may take DocumentFragment objects as arguments; this results in all the child nodes of the DocumentFragment being moved to the child list of this node.The children of a DocumentFragment node are zero or more nodes representing the tops of any sub-trees defining the structure of the document.DocumentFragment nodes do not need to be well-formed XML documents (although they do need to follow the rules imposed upon well-formed XML parsed entities, which can have multiple top nodes).For example, a DocumentFragment might have only one child and that child node could be a Text node.Such a structure model represents neither an HTML document nor a well-formed XML document.When a DocumentFragment is inserted into a Document (or indeed any other Node that may take children) the children of the DocumentFragment and not the DocumentFragment itself are inserted into the Node.This makes the DocumentFragment very useful when the user wishes to create nodes that are siblings; the DocumentFragment acts as the parent of these nodes so that the user can use the standard methods from the Node interface, such as Node.insertBefore and Node.appendChild."},
{"description": "DocumentFilter, as the name implies, is a filter for the Document mutation methods.When a Document containing a DocumentFilter is modified (either through insert or remove), it forwards the appropriate method invocation to the DocumentFilter.Subclasses can filter the modifications by conditionally invoking methods on the superclass, or invoking the necessary methods on the passed in FilterBypass.Subclasses should NOT call back into the Document for the modification instead call into the superclass or the FilterBypass.When remove or insertString is invoked on the DocumentFilter, the DocumentFilter may callback into the FilterBypass multiple times, or for different regions, but it should not callback into the FilterBypass after returning from the remove or insertString method.By default, text related document mutation methods such as insertString, replace and remove in AbstractDocument use DocumentFilter when available, and Element related mutation methods such as create, insert and removeElement in DefaultStyledDocument do not use DocumentFilter.If a method doesn't follow these defaults, this must be explicitly stated in the method documentation."},
{"description": "Document implementations that wish to support a DocumentFilter must provide an implementation that will not callback into the DocumentFilter when the following methods are invoked from the DocumentFilter."},
{"description": "Indicates that annotations with a type are to be documented by javadoc and similar tools by default.This type should be used to annotate the declarations of types whose annotations affect the use of annotated elements by their clients.If a type declaration is annotated with Documented, its annotations become part of the public API of the annotated elements."},
{"description": "The DocumentEvent interface provides a mechanism by which the user can create an Event of a type supported by the implementation.It is expected that the DocumentEvent interface will be implemented on the same object which implements the Document interface in an implementation which supports the Event model."},
{"description": "Defines a factory API that enables applications to obtain a parser that produces DOM object trees from XML documents."},
{"description": "The Document interface represents the entire HTML or XML document.Conceptually, it is the root of the document tree, and provides the primary access to the document's data.Since elements, text nodes, comments, processing instructions, etc. cannot exist outside the context of a Document, the Document interface also contains the factory methods needed to create these objects.The Node objects created have a ownerDocument attribute which associates them with the Document within whose context they were created."},
{"description": "The Document is a container for text that serves as the model for swing text components.The goal for this interface is to scale from very simple needs (a plain text textfield) to complex needs (an HTML or XML document, for example).Content At the simplest level, text can be modeled as a linear sequence of characters.To support internationalization, the Swing text model uses unicode characters.The sequence of characters displayed in a text component is generally referred to as the component's content.To refer to locations within the sequence, the coordinates used are the location between two characters.As the diagram below shows, a location in a text document can be referred to as a position, or an offset.In the example, if the content of a document is the sequence \"The quick brown fox,\" as shown in the preceding diagram, the location just before the word \"The\" is 0, and the location after the word\"The\" and before the whitespace that follows it is 3.The entire sequence of characters in the sequence \"The\" is called a range.The following methods give access to the character data that makes up the content.Structure Text is rarely represented simply as featureless content.Rather, text typically has some sort of structure associated with it.Exactly what structure is modeled is up to a particular Document implementation.It might be as simple as no structure (i.e. a simple text field), or it might be something like diagram below.The unit of structure (i.e. a node of the tree) is referred to by the Element interface.Each Element can be tagged with a set of attributes.These attributes (name/value pairs) are defined by the AttributeSet interface.The following methods give access to the document structure.getDefaultRootElement() getRootElements() Mutations All documents need to be able to add and remove simple text.Typically, text is inserted and removed via gestures from a keyboard or a mouse.What effect the insertion or removal has upon the document structure is entirely up to the implementation of the document.The following methods are related to mutation of the document content: insertString(int, java.lang.String, javax.swing.text.AttributeSet) remove(int, int) createPosition(int)Notification Mutations to the Document must be communicated to interested observers.The notification of change follows the event model guidelines that are specified for JavaBeans.In the JavaBeans event model, once an event notification is dispatched, all listeners must be notified before any further mutations occur to the source of the event.Further, order of delivery is not guaranteed.Notification is provided as two separate events, DocumentEvent, and UndoableEditEvent.If a mutation is made to a Document through its api, a DocumentEvent will be sent to all of the registered DocumentListeners.If the Document implementation supports undo/redo capabilities, an UndoableEditEvent will be sent to all of the registered UndoableEditListeners.If an undoable edit is undone, a DocumentEvent should be fired from the Document to indicate it has changed again.In this case however, there should be no UndoableEditEvent generated since that edit is actually the source of the change rather than a mutation to the Document made through its api.The document responds by dispatching a DocumentEvent to both component views and sends an UndoableEditEvent to the listening logic, which maintains a history buffer.Now suppose that the component shown on the right mutates the same document.Again, the document dispatches a DocumentEvent to both component views and sends an UndoableEditEvent to the listening logic that is maintaining the history buffer.If the history buffer is then rolled back (i.e. the last UndoableEdit undone), a DocumentEvent is sent to both views, causing both of them to reflect the undone mutation to the document (that is, the removal of the right component's mutation).If the history buffer again rolls back another change, another DocumentEvent is sent to both views, causing them to reflect the undone mutation to the document -- that is, the removal of the left component's mutation.The methods related to observing mutations to the document are: addDocumentListener(DocumentListener) removeDocumentListener(DocumentListener) addUndoableEditListener(UndoableEditListener) removeUndoableEditListener(UndoableEditListener) Properties Document implementations will generally have some set of properties associated with them at runtime.Two well known properties are the StreamDescriptionProperty, which can be used to describe where the Document came from, and the TitleProperty, which can be used to name the Document.The methods related to the properties are: getProperty(java.lang."},
{"description": "This interface represents a print job that can print a specified document with a set of job attributes.An object implementing this interface is obtained from a print service."},
{"description": "Using this class, an application programmer can obtain a Document from XML.An instance of this class can be obtained from the DocumentBuilderFactory.newDocumentBuilder() method.Once an instance of this class is obtained, XML can be parsed from a variety of input sources.These input sources are InputStreams, Files, URLs, and SAX InputSources.Note that this class reuses several classes from the SAX API.This does not require that the implementor of the underlying DOM implementation use a SAX parser to parse XML document into a Document.It merely requires that the implementation communicate with the application using these existing APIs."},
{"description": "Before calling the call method, additional aspects of the task can be configured, for example, by calling the setLocale method."},
{"description": "STRING provides predefined static constant DocFlavor objects for example"},
{"description": "READER provides predefined static constant DocFlavor objects for example"},
{"description": "INPUT_STREAM provides predefined static constant DocFlavor objects for example"},
{"description": "CHAR_ARRAY provides predefined static constant DocFlavor objects for example doc flavors using a character array (char[])"},
{"description": "URL provides predefined static constant DocFlavor objects."},
{"description": "SERVICE_FORMATTED provides predefined static constant DocFlavor objects for example doc flavors for service formatted print data."},
{"description": "BYTE_ARRAY provides predefined static constant DocFlavor objects for example"},
{"description": "Interface Doc specifies the interface for an object that supplies one piece of print data for a Print Job.\"Doc\" is a short, easy-to-pronounce term that means \"a piece of print data.\" The client passes to the Print Job an object that implements interface Doc, and the Print Job calls methods on that object to obtain the print data.The Doc interface lets a Print Job: Determine the format, or \"doc flavor\" (class DocFlavor), in which the print data is available.A doc flavor designates the print data format (a MIME type) and the representation class of the object from which the print data comes.Obtain the print data representation object, which is an instance of the doc flavor's representation class.The Print Job can then obtain the actual print data from the representation object.Obtain the printing attributes that specify additional characteristics of the doc or that specify processing instructions to be applied to the doc.Printing attributes are defined in package javax.print.attribute.The doc returns its printing attributes stored in an javax.print.attribute.DocAttributeSet.Each method in an implementation of interface Doc is permitted always to return the same object each time the method is called.This has implications for a Print Job or other caller of a doc object whose print data representation object \"consumes\" the print data as the caller obtains the print data, such as a print data representation object which is a stream.Once the Print Job has called getPrintData() and obtained the stream, any further calls to getPrintData() will return the same stream object upon which reading may already be in progress, not a new stream object that will re-read the print data from the beginning.Specifying a doc object to behave this way simplifies the implementation of doc objects, and is justified on the grounds that a particular doc is intended to convey print data only to one Print Job, not to several different Print Jobs.(To convey the same print data to several different Print Jobs, you have to create several different doc objects on top of the same print data source.)Interface Doc affords considerable implementation flexibility.The print data might already be in existence when the doc object is constructed.In this case the objects returned by the doc's methods can be supplied to the doc's constructor, be stored in the doc ahead of time, and simply be returned when called for.In this case the doc object might provide a \"lazy\" implementation that generates the print data representation object (and/or the print data) only when the Print Job calls for it (when the Print Job calls the getPrintData() method).There is no restriction on the number of client threads that may be simultaneously accessing the same doc.Therefore, all implementations of interface Doc must be designed to be multiple thread safe.However there can only be one consumer of the print data obtained from a Doc.If print data is obtained from the client as a stream, by calling Doc's getReaderForText() or getStreamForBytes() methods, or because the print data source is already an InputStream or Reader, then the print service should always close these streams for the client on all job completion conditions.If the print data is itself a stream, the service will always close it.If the print data is otherwise something that can be requested as a stream, the service will only close the stream if it has obtained the stream before terminating.That is, just because a print service might request data as a stream does not mean that it will, with the implications that Doc implementors which rely on the service to close them should create such streams only in response to a request from the service."},
{"description": "The DisplayMode class encapsulates the bit depth, height, width, and refresh rate of a GraphicsDevice.The ability to change graphics device's display mode is platform- and configuration-dependent and may not always be available (see GraphicsDevice.isDisplayChangeSupported())."},
{"description": "This class contains constant values representing the type of action(s) to be performed by a Drag and Drop operation."},
{"description": "The Dispatch interface provides support for the dynamic invocation of a service endpoint operations.The javax.xml.ws.Service class acts as a factory for the creation of Dispatch instances."},
{"description": "Interface DocAttribute is a tagging interface which a printing attribute class implements to indicate the attribute denotes a setting for a doc.(\"Doc\" is a short, easy-to-pronounce term that means \"a piece of print data.\")The client may include a DocAttribute in a Doc's attribute set to specify a characteristic of that doc.If an attribute implements PrintRequestAttribute as well as DocAttribute, the client may include the attribute in a attribute set which specifies a print job to specify a characteristic for all the docs in that job."},
{"description": "Interface DocAttributeSet specifies the interface for a set of doc attributes, i.e. printing attributes that implement interface DocAttribute.In the Print Service API, the client uses a DocAttributeSet to specify the characteristics of an individual doc and the print job settings to be applied to an individual doc.A DocAttributeSet is just an AttributeSet whose constructors and mutating operations guarantee an additional invariant, namely that all attribute values in the DocAttributeSet must be instances of interface DocAttribute.The add(Attribute), and addAll(AttributeSet) operations are respecified below to guarantee this additional invariant."},
{"description": "Class DocFlavor encapsulates an object that specifies the format in which print data is supplied to a DocPrintJob.\"Doc\" is a short, easy-to-pronounce term that means \"a piece of print data.The print data format, or \"doc flavor\", consists of two things: MIME type.This is a Multipurpose Internet Mail Extensions (MIME) media type (as defined in RFC 2045 and RFC 2046) that specifies how the print data is to be interpreted.The charset of text data should be the IANA MIME-preferred name, or its canonical name if no preferred name is specified.Additionally a few historical names supported by earlier versions of the Java platform may be recognized.This specifies the fully-qualified name of the class of the object from which the actual print data comes, as returned by the Class.getName() method.(Thus the class name for byte[] is \"[B\", for char[]it is \"[C\".)A Doc object lets the DocPrintJob determine the doc flavor the client can supply.A Doc object also lets the DocPrintJob obtain an instance of the doc flavor's representation class, from which the DocPrintJob then obtains the actual print data.There are two broad categories of print data, client formatted print data and service formatted print data.For client formatted print data, the client determines or knows the print data format.For example the client may have a JPEG encoded image, a URL for HTML code, or a disk file containing plain text in some encoding, possibly obtained from an external source, and requires a way to describe the data format to the print service.The doc flavor's representation class is a conduit for the JPS DocPrintJob to obtain a sequence of characters or bytes from the client.The doc flavor's MIME type is one of the standard media types telling how to interpret the sequence of characters or bytes.Interface Doc provides two utility operations, getReaderForText andgetStreamForBytes(), to help a Doc object's client extract client formatted print data.For client formatted print data, the print data representation class is typically one of the following (although other representation classes are permitted):Character array (char[]) -- The print data consists of the Unicode characters in the array.The print data consists of the Unicode characters in the string.The print data consists of the Unicode characters read from the stream up to the end-of-stream.The print data consists of the bytes in the array.The bytes are encoded in the character set specified by the doc flavor's MIME type.If the MIME type does not specify a character set, the default character set is US-ASCII.The print data consists of the bytes read from the stream up to the end-of-stream.The bytes are encoded in the character set specified by the doc flavor's MIME type.If the MIME type does not specify a character set, the default character set is US-ASCII.The print data consists of the bytes read from the URL location.The bytes are encoded in the character set specified by the doc flavor's MIME type.If the MIME type does not specify a character set, the default character set is US-ASCII.When the representation class is a URL, the print service itself accesses and downloads the document directly from its URL address, without involving the client.The service may be some form of network print service which is executing in a different environment.This means you should not use a URL print data flavor to print a document at a restricted URL that the client can see but the printer cannot see.This also means you should not use a URL print data flavor to print a document stored in a local file that is not available at a URL accessible independently of the client.For example, a file that is not served up by an HTTP server or FTP server.To print such documents, let the client open an input stream on the URL or file and use an input stream data flavor.Default and Platform Encodings For byte print data where the doc flavor's MIME type does not include a charset parameter, the Java Print Service instance assumes the US-ASCII character set by default.This is in accordance with RFC 2046, which says the default character set is US-ASCII.Note that US-ASCII is a subset of UTF-8, so in the future this may be widened if a future RFC endorses UTF-8 as the default in a compatible manner.Also note that this is different than the behaviour of the Java runtime when interpreting a stream of bytes as text data.That assumes the default encoding for the user's locale.Thus, when spooling a file in local encoding to a Java Print Service it is important to correctly specify the encoding.Developers working in the English locales should be particularly conscious of this, as their platform encoding corresponds to the default mime charset.By this coincidence that particular case may work without specifying the encoding of platform data.Every instance of the Java virtual machine has a default character encoding determined during virtual-machine startup and typically depends upon the locale and charset being used by the underlying operating system.In a distributed environment there is no guarantee that two VM share the same default encoding.Thus clients which want to stream platform encoded text data from the host platform to a Java Print Service instanceThe preferred form is the official IANA primary name for an encoding.Applications which stream text data should always specify the charset in the mime type, which necessitates obtaining the encoding of the host platform for data (eg files) stored in that platform's encoding.A CharSet which corresponds to this and is suitable for use in a mime-type for a DocFlavor can be obtained from DocFlavor.hostEncodingThis may not always be the primary IANA name but is guaranteed to be understood by this VM.For common flavors, the pre-defined *HOST DocFlavors may be used.Recommended DocFlavors The Java Print Service API does not define any mandatorily supported DocFlavors.However, here are some examples of MIME types that a Java Print Service instance might support for client formatted print data.Nested classes inside class DocFlavor declare predefined static constant DocFlavor objects for these example doc flavors; class DocFlavor's constructor can be used to create an arbitrary doc flavor.Preformatted text MIME-TypeDescription \"text/plain\" Plain text in the default character set (US-ASCII)text/plain; charset=xxx\" Plain text in character set xxx \"text/html\" HyperText Markup Language in the default character set (US-ASCII)\"text/html; charset=xxx\" HyperText Markup Language in character set xxxIn general, preformatted text print data is provided either in a character oriented representation class (character array, String, Reader) or in a byte oriented representation class (byte array, InputStream, URL).Preformatted page description language (PDL) documents MIME-TypeDescription \"application/pdf\" Portable Document Format document \"application/postscript\" PostScript document \"application/vnd.hp-PCL\" Printer Control Language document In general, preformatted PDL print data is provided in a byte oriented representation class (byte array, InputStream, URL).In general, preformatted image print data is provided in a byte oriented representation class (byte array, InputStream, URL).The print data format is unspecified (just an octet stream)The printer decides how to interpret the print data; the way this \"autosensing\" works is implementation dependent.In general, preformatted autosense print data is provided in a byte oriented representation class (byte array, InputStream, URL).Service Formatted Print Data For service formatted print data, the Java Print Service instance determines the print data format.The doc flavor's representation class denotes an interface whose methods the DocPrintJob invokes to determine the content to be printed -- such as a renderable image interface or a Java printable interface.The doc flavor's MIME type is the special value \"application/x-java-jvm-local-objectref\" indicating the client will supply a reference to a Java object that implements the interface named as the representation class.This MIME type is just a placeholder; what's important is the print data representation class.For service formatted print data, the print data representation class is typically one of the following (although other representation classes are permitted).Nested classes inside class DocFlavor declare predefined static constant DocFlavor objects for these example doc flavors; class DocFlavor's constructor can be used to create an arbitrary doc flavor.Renderable image object -- The client supplies an object that implements interface RenderableImage.The printer calls methods in that interface to obtain the image to be printed.Printable object -- The client supplies an object that implements interface Printable.The printer calls methods in that interface to obtain the pages to be printed, one by one.For each page, the printer supplies a graphics context, and whatever the client draws in that graphics context gets printed.Pageable object -- The client supplies an object that implements interface Pageable.The printer calls methods in that interface to obtain the pages to be printed, one by one.For each page, the printer supplies a graphics context, and whatever the client draws in that graphics context gets printed.Pre-defined Doc Flavors A Java Print Service instance is not required to support the following print data formats and print data representation classes.In fact, a developer using this class should never assume that a particular print service supports the document types corresponding to these pre-defined doc flavors.Always query the print service to determine what doc flavors it supports.However, developers who have print services that support these doc flavors are encouraged to refer to the predefined singleton instances created here.Specifically, the following doc flavor is recommended to be supported: \u00b7\u00a0\u00a0 (\"application/x-java-jvm-local-objectref\", \"java.awt.image.renderable.RenderableImage\")A Java Print Service instance is allowed to support any other doc flavors (or none) in addition to the above mandatory ones, at the implementation's choice.Support for the above doc flavors is desirable so a printing client can rely on being able to print on any JPS printer, regardless of which doc flavors the printer supports.If the printer doesn't support the client's preferred doc flavor, the client can at least print plain text, or the client can convert its data to a renderable image and print the image.Furthermore, every Java Print Service instance must fulfill these requirements for processing plain text print data: The character pair carriage return-line feed (CR-LF) means \"go to column 1 of the next line.\"A carriage return (CR) character standing by itself means \"go to column 1 of the next line.\"A line feed (LF) character standing by itself means \"go to column 1 of the next line.\" The client must itself perform all plain text print data formatting not addressed by the above requirements.Design Rationale Class DocFlavor in package javax.print.data is similar to class DataFlavor.Class DataFlavor is not used in the Java Print Service (JPS) API for three reasons which are all rooted in allowing the JPS API to be shared by other print services APIs which may need to run on Java profiles which do not include all of the Java Platform, Standard Edition.The JPS API is designed to be used in Java profiles which do not support AWT.The implementation of class java.awt.datatransfer.DataFlavor does not guarantee that equivalent data flavors will have the same serialized representation.DocFlavor does, and can be used in services which need this.The implementation of class java.awt.datatransfer.DataFlavor includes a human presentable name as part of the serialized representation.This is not appropriate as part of a service matching constraint.Class DocFlavor's serialized representation uses the following canonical form of a MIME type string.Thus, two doc flavors with MIME types that are not identical but that are equivalent (that have the same canonical form) may be considered equal.The parameter values retain their original case, except a charset parameter value for a text media type is converted to lowercase.Quote characters surrounding parameter values are removed.Quoting backslash characters inside parameter values are removed.The parameters are arranged in ascending order of parameter name.Class DocFlavor's serialized representation also contains the fully-qualified class name of the representation class (a String object), rather than the representation class itself (a Class object).This allows a client to examine the doc flavors a Java Print Service instance supports without having to load the representation classes, which may be problematic for limited-resource clients."},
{"description": "This interface represents a factory for obtaining the state of an object and corresponding attributes for binding.The JNDI framework allows for object implementations to be loaded in dynamically via object factories.A DirStateFactory extends StateFactory by allowing an Attributes instance to be supplied to and be returned by the getStateToBind() method.DirStateFactory implementations are intended to be used by DirContext service providers.When a caller binds an object using DirContext.bind(), he might also specify a set of attributes to be bound with the object.The object and attributes to be bound are passed to the getStateToBind() method of a factory.If the factory processes the object and attributes, it returns a corresponding pair of object and attributes to be bound.If the factory does not process the object, it must return null.For example, a caller might bind a printer object with some printer-related attributes.ctx.rebind(\"inky\", printer, printerAttrs); An LDAP service provider for ctx uses a DirStateFactory (indirectly via DirectoryManager.getStateToBind()) and gives it printer and printerAttrs.A factory for an LDAP directory might turn printer into a set of attributes and merge that with printerAttrs.The service provider then uses the resulting attributes to create an LDAP entry and updates the directory.Since DirStateFactory extends StateFactory, it has two getStateToBind() methods, where one differs from the other by the attributes argument.DirectoryManager.getStateToBind() will only use the form that accepts the attributes argument, while NamingManager.getStateToBind() will only use the form that does not accept the attributes argument.Either form of the getStateToBind() method of a DirStateFactory may be invoked multiple times, possibly using different parameters."},
{"description": "This interface represents a factory for creating an object given an object and attributes about the object.The JNDI framework allows for object implementations to be loaded in dynamically via object factories.A DirObjectFactory extends ObjectFactory by allowing an Attributes instance to be supplied to the getObjectInstance() method.DirObjectFactory implementations are intended to be used by DirContext service providers.The service provider, in addition reading an object from the directory, might already have attributes that are useful for the object factory to check to see whether the factory is supposed to process the object.For instance, an LDAP-style service provider might have read the \"objectclass\" of the object.A CORBA object factory might be interested only in LDAP entries with \"objectclass=corbaObject\".By using the attributes supplied by the LDAP service provider, the CORBA object factory can quickly eliminate objects that it need not worry about, and non-CORBA object factories can quickly eliminate CORBA-related LDAP entries."},
{"description": "An interface that is implemented by objects that decide if a directory entry should be accepted or filtered.A Filter is passed as the parameter to the Files.newDirectoryStream(Path,DirectoryStream."},
{"description": "A directory stream allows for the convenient use of the for-each construct to iterate over a directory.While DirectoryStream extends Iterable, it is not a general-purpose Iterable as it supports only a single Iterator; invoking the iterator method to obtain a second or subsequent iterator throws IllegalStateException.An important property of the directory stream's Iterator is that its hasNext method is guaranteed to read-ahead by at least one element.If hasNext method returns true, and is followed by a call to the next method, it is guaranteed that the next method will not throw an exception due to an I/O error, or because the stream has been closed.The Iterator does not support the remove operation.A DirectoryStream is opened upon creation and is closed by invoking the close method.Closing a directory stream releases any resources associated with the stream.Failure to close the stream may result in a resource leak.The try-with-resources statement provides a useful construct to ensure that the stream is closed: Path dir = ...try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) { for (Path entry: stream) { ... } } Once a directory stream is closed, then further access to the directory, using the Iterator, behaves as if the end of stream has been reached.Due to read-ahead, the Iterator may return one or more elements after the directory stream has been closed.Once these buffered elements have been read, then subsequent calls to the hasNext method returns false, and subsequent calls to the next method will throw NoSuchElementException.If a thread is blocked on the directory stream's iterator reading from the directory, and another thread invokes the close method, then the second thread may block until the read operation is complete.If an I/O error is encountered when accessing the directory then it causes the Iterator's hasNext or next methods to throw DirectoryIteratorException with the IOException as the cause.As stated above, the hasNext method is guaranteed to read-ahead by at least one element.This means that if hasNext method returns true, and is followed by a call to the next method, then it is guaranteed that the next method will not fail with a DirectoryIteratorException.The elements returned by the iterator are in no specific order.Some file systems maintain special links to the directory itself and the directory's parent directory.Entries representing these links are not returned by the iterator.It is thread safe but does not freeze the directory while iterating, so it may (or may not) reflect updates to the directory that occur after the DirectoryStream is created.Suppose we want a list of the source files in a directory.This example uses both the for-each and try-with-resources constructs.List<Path> listSourceFiles(Path dir) throws IOException { List<Path> result =I/O error encounted during the iteration, the cause is an IOException throw ex.getCause"},
{"description": "This class contains methods for supporting DirContext implementations.This class is an extension of NamingManager.It contains methods for use by service providers for accessing object factories and state factories, and for getting continuation contexts for supporting federation.DirectoryManager is safe for concurrent access by multiple threads.Except as otherwise noted, a Name, Attributes, or environment parameter passed to any method is owned by the caller.The implementation will not modify the object or keep a reference to it, although it may keep a reference to a clone or copy."},
{"description": "Runtime exception thrown if an I/O error is encountered when iterating over the entries in a directory.The I/O error is retrieved as an IOException using the getCause() method."},
{"description": "The DirectColorModel class is a ColorModel class that works with pixel values that represent RGB color and alpha information as separate samples and that pack all samples for a single pixel into a single int, short, or byte quantity.This class can be used only with ColorSpaces of type ColorSpace.In addition, for each component of the ColorSpace, the minimum normalized component value obtained via the getMinValue() method of ColorSpace must be 0.0, and the maximum value obtained via the getMaxValue() method must be 1.0 (these min/max values are typical for RGB spaces).There must be three color samples in the pixel values and there can be a single alpha sample.For those methods that use a primitive array pixel representation of type transferType, the array length is always one.The transfer types supported are DataBuffer.Color and alpha samples are stored in the single element of the array in bits indicated by bit masks.The same masks apply to the single int pixel representation used by other methods.The correspondence of masks and color/alpha samples is as follows: Masks are identified by indices running from 0 through 2 if no alpha is present, or 3 if an alpha is present.The first three indices refer to color samples; index 0 corresponds to red, index 1 to green, and index 2 to blue.Index 3 corresponds to the alpha sample, if present.The translation from pixel values to color/alpha components for display or processing purposes is a one-to-one correspondence of samples to components.A DirectColorModel is typically used with image data which uses masks to define packed samples.For example, a DirectColorModel can be used in conjunction with a SinglePixelPackedSampleModel to construct a BufferedImage.Normally the masks used by the SampleModel and the ColorModel would be the same.However, if they are different, the color interpretation of pixel data will be done according to the masks of the ColorModel.A single int pixel representation is valid for all objects of this class, since it is always possible to represent pixel values used with this class in a single int.Therefore, methods which use this representation will not throw an IllegalArgumentException due to an invalid pixel value.This color model is similar to an X11 TrueColor visual.The default RGB ColorModel specified by the getRGBdefault method is a DirectColorModel with the following parameters:TYPE_INT Many of the methods in this class are final.This is because the underlying native graphics code makes assumptions about the layout and operation of this class and those assumptions are reflected in the implementations of the methods here that are marked final.You can subclass this class for other reasons, but you cannot override or modify the behavior of those methods."},
{"description": "Each name passed as an argument to a DirContext method is relative to that context.The empty name is used to name the context itself.Most of the methods have overloaded versions with one taking a Name parameter and one taking a String.These overloaded versions are equivalent in that if the Name and String parameters are just different representations of the same name, then the overloaded versions of the same methods behave the same.In the method descriptions below, only one version is documented.The second version instead has a link to the first: the same documentation applies to both.These same rules apply to the name argument to the DirContext methods.Attribute Models There are two basic models of what attributes should be associated with.First, attributes may be directly associated with a DirContext object.In this model, an attribute operation on the named object is roughly equivalent to a lookup on the name (which returns the DirContext object), followed by the attribute operation invoked on the DirContext object in which the caller supplies an empty name.The attributes can be viewed as being stored along with the object (note that this does not imply that the implementation must do so).The second model is that attributes are associated with a name (typically an atomic name) in a DirContext.In this model, an attribute operation on the named object is roughly equivalent to a lookup on the name of the parent DirContext of the named object, followed by the attribute operation invoked on the parent in which the caller supplies the terminal atomic name.The attributes can be viewed as being stored in the parent DirContext (again, this does not imply that the implementation must do so).Objects that are not DirContexts can have attributes, as long as their parents are DirContexts.JNDI support both of these models.It is up to the individual service providers to decide where to \"store\" attributes.JNDI clients are safest when they do not make assumptions about whether an object's attributes are stored as part of the object, or stored within the parent object and associated with the object's name.In the getAttributes() and search() methods, you can supply the attributes to return by supplying a list of attribute names (strings).The attributes that you get back might not have the same names as the attribute names you have specified.This is because some directories support features that cause them to return other attributes.Such features include attribute subclassing, attribute name synonyms, and attribute language codes.In attribute subclassing, attributes are defined in a class hierarchy.In some directories, for example, the \"name\" attribute might be the superclass of all name-related attributes, including \"commonName\" and \"surName\".Asking for the \"name\" attribute might return both the \"commonName\" and \"surName\" attributes.With attribute type synonyms, a directory can assign multiple names to the same attribute.For example, \"cn\" and \"commonName\" might both refer to the same attribute.Asking for \"cn\" might return the \"commonName\" attribute.Some directories support the language codes for attributes.Some directories have the notion of \"operational attributes\" which are attributes associated with a directory object for administrative purposes.An example of operational attributes is the access control list for an object.In the getAttributes() and search() methods, you can specify that all attributes associated with the requested objects be returned by supply null as the list of attributes to return.The attributes returned do not include operational attributes.In order to retrieve operational attributes, you must name them explicitly.There are certain methods in which the name must resolve to a context (for example, when searching a single level context).The documentation of such methods use the term named context to describe their name parameter.For these methods, if the named object is not a DirContext, NotContextException is thrown.Aside from these methods, there is no requirement that the named object be a DirContext.Parameters An Attributes, SearchControls, or array object passed as a parameter to any method will not be modified by the service provider.The service provider may keep a reference to it for the duration of the operation, including any enumeration of the method's results and the processing of any referrals generated.The caller should not modify the object during this time.An Attributes object returned by any method is owned by the caller.The caller may subsequently modify it; the service provider will not.Exceptions All the methods in this interface can throw a NamingException or any of its subclasses."},
{"description": "The Dimension2D class is to encapsulate a width and a height dimension.This class is only the abstract superclass for all objects that store a 2D dimension.The actual storage representation of the sizes is left to the subclass."},
{"description": "The Dimension class encapsulates the width and height of a component (in integer precision) in a single object.The class is associated with certain properties of components.Several methods defined by the Component class and the LayoutManager interface return a Dimension object.Normally the values of width and height are non-negative integers.The constructors that allow you to create a dimension do not prevent you from setting a negative value for these properties.If the value of width or height is negative, the behavior of some methods defined by other objects is undefined."},
{"description": "A transparent stream that updates the associated message digest using the bits going through the stream.It is possible to turn this stream on or off (see on).When it is on, a call to one of the write methods results in an update on the message digest."},
{"description": "The XML Schema Definition is defined as: <element name=\"DigestMethod> A DigestMethod instance may be created by invoking the newDigestMethod method of the XMLSignatureFactory class."},
{"description": "The purpose of this interface is to group (and provide type safety for) all digest method parameter specifications.All digest method parameter specifications must implement this interface."},
{"description": "A transparent stream that updates the associated message digest using the bits going through the stream.It is possible to turn this stream on or off (see on).When it is on, a call to one of the read methods results in an update on the message digest.Note that digest objects can compute only one digest (see MessageDigest), so that in order to compute intermediate digests, a caller should retain a handle onto the digest object, and clone it for each digest to be computed, leaving the orginal digest untouched."},
{"description": "Any top-level window can be marked not to be blocked by modal dialogs.This enum specifies the possible modal exclusion types."},
{"description": "Modal dialogs block all input to some top-level windows.Whether a particular window is blocked depends on dialog's type of modality; this is called the \"scope of blocking\".The ModalityType enum specifies modal types and their associated scopes."},
{"description": "A Dialog is a top-level window with a title and a border that is typically used to take some form of input from the user.The size of the dialog includes any area designated for the border.The dimensions of the border area can be obtained using the getInsets method, however, since these dimensions are platform-dependent, a valid insets value cannot be obtained until the dialog is made displayable by either calling pack or show.Since the border area is included in the overall size of the dialog, the border effectively obscures a portion of the dialog, constraining the area available for rendering and/or displaying subcomponents to the rectangle which has an upper-left corner location of (insets.left, insets.top), and has a size of width - (insets.left + insets.right) by height - (insets.top + insets.bottom).The default layout for a dialog is BorderLayout.A dialog may have its native decorations (i.e. Frame & Titlebar) turned off with setUndecorated.A dialog may have another window as its owner when it's constructed.When the owner window of a visible dialog is minimized, the dialog will automatically be hidden from the user.When the owner window is subsequently restored, the dialog is made visible to the user again.In a multi-screen environment, you can create a Dialog on a different screen device than its owner.A modal dialog is one which blocks input to some other top-level windows in the application, except for any windows created with the dialog as their owner.Dialogs are capable of generating the following WindowEvents: WindowOpened, WindowClosing, WindowClosed, WindowActivated, WindowDeactivated, WindowGainedFocus, WindowLostFocus."},
{"description": "This is the generic Message Digest exception."},
{"description": "The Dictionary class is the abstract parent of any class, such as Hashtable, which maps keys to values.Every key and every value is an object.In any one Dictionary object, every key is associated with at most one value.Given a Dictionary and a key, the associated element can be looked up.Any non-null object can be used as a key and as a value.As a rule, the equals method should be used by implementations of this class to decide if two keys are the same.New implementations should implement the Map interface, rather than extending this class."},
{"description": "Class DialogTypeSelection is a printing attribute class, an enumeration, that indicates the user dialog type to be used for specifying printing options.This option to specify a native dialog for use with an IPP attribute set provides a standard way to reflect back of the setting and option changes made by a user to the calling application, and integrates the native dialog into the Java printing APIs.But note that some options and settings in a native dialog may not necessarily map to IPP attributes as they may be non-standard platform, or even printer specific options.IPP Compatibility: This is not an IPP attribute."},
{"description": "A diagnostic usually reports a problem at a specific position in a source file.However, not all diagnostics are associated with a position or a file.A position is a zero-based character offset from the beginning of a file.Negative values (except NOPOS) are not valid positions.Line and column numbers begin at 1.Negative values (except NOPOS) and 0 are not valid line or column numbers."},
{"description": "This class specifies a Diffie-Hellman public key with its associated parameters.Note that this class does not perform any validation on specified parameters."},
{"description": "This class specifies a Diffie-Hellman private key with its associated parameters.Note that this class does not perform any validation on specified parameters."},
{"description": "This class specifies the set of parameters used with the Diffie-Hellman algorithm, as specified in PKCS #3:A central authority generates parameters and gives them to the two entities seeking to generate a secret key.The parameters are a prime p, a base g, and optionally the length in bits of the private value,l. It is possible that more than one instance of parameters may be generated by a given central authority, and that there may be more than one central authority.Indeed, each individual may be its own central authority, with different entities having different parameters.Note that this class does not perform any validation on specified parameters."},
{"description": "A DetailEntry object, which carries information about errors related to the SOAPBody object that contains it, is application-specific."},
{"description": "The DGC abstraction is used for the server side of the distributed garbage collection algorithm.This interface contains the two methods: dirty and clean.A dirty call is made when a remote reference is unmarshaled in a client (the client is indicated by its VMID).A corresponding clean call is made when no more references to the remote reference exist in the client.A failed dirty call must schedule a strong clean call so that the call's sequence number can be retained in order to detect future calls received out of order by the distributed garbage collector.A reference to a remote object is leased for a period of time by the client holding the reference.It is the client's responsibility to renew the leases, by making additional dirty calls, on the remote references it holds before such leases expire.If the client does not renew the lease before it expires, the distributed garbage collector assumes that the remote object is no longer referenced by that client."},
{"description": "This class specifies the set of parameters used for generating Diffie-Hellman (system) parameters for use in Diffie-Hellman key agreement.This is typically done by a central authority.The central authority, after computing the parameters, must send this information to the parties looking to agree on a secret key."},
{"description": "DetailEntry objects give detailed error information that is application-specific and related to the SOAPBody object that contains it.A Detail object, which is part of a SOAPFault object, can be retrieved using the method SOAPFault.getDetail.The Detail interface provides two methods.One creates a new DetailEntry object and also automatically adds it to the Detail object.The second method gets a list of the DetailEntry objects contained in a Detail object.The following code fragment, in which sf is a SOAPFault object, gets its Detail object (d), adds a new DetailEntry object to d, and then gets a list of all the DetailEntry objects in d.The code also creates a Name object to pass toThe variable se, used to create the Name object, is a SOAPEnvelope object."},
{"description": "This exception is thrown by credentials implementing the Destroyable interface when the destroy method fails."},
{"description": "Class Destination is a printing attribute class, a URI, that is used to indicate an alternate destination for the spooled printer formatted data.Many PrintServices will not support the notion of a destination other than the printer device, and so will not support this attribute.A common use for this attribute will be applications which want to redirect output to a local disk file :Note that proper construction of \"file:\" scheme URI instances should be performed using the toURI() method of class File.If a destination URI is specified in a PrintRequest and it is not accessible for output by the PrintService, a PrintException will be thrown.The PrintException may implement URIException to provide a more specific cause.IPP Compatibility: Destination is not an IPP attribute."},
{"description": "DesktopManager objects are owned by a JDesktopPane object.They are responsible for implementing L&F specific behaviors for the JDesktopPane.JInternalFrame implementations should delegate specific behaviors to the DesktopManager.For instance, if a JInternalFrame was asked to iconify, it should try: getDesktopPane().getDesktopManager().iconifyFrame(frame); This delegation allows each L&F to provide custom behaviors for desktop-specific actions.(For example, how and where the internal frame's icon would appear.)This class provides a policy for the various JInternalFrame methods, it is not meant to be called directly rather the various JInternalFrame methods will call into the DesktopManager."},
{"description": "The Desktop class allows a Java application to launch associated applications registered on the native desktop to handle a URI or a file.Supported operations include: launching the user-default browser to show a specified URI; launching the user-default mail client with an optional mailto URI; launching a registered application to open, edit or print a specified file.This class provides methods corresponding to these operations.The methods look for the associated application registered on the current platform, and launch it to handle a URI or file.If there is no associated application or the associated application fails to be launched, an exception is thrown.An application is registered to a URI or file type; for example, the \"sxi\" file extension is typically registered to StarOffice.The mechanism of registering, accessing, and launching the associated application is platform-dependent.Each operation is an action type represented by the Desktop.Note: when some action is invoked and the associated application is executed, it will be executed on the same system as the one on which the Java application was launched."},
{"description": "Each platform supports a different set of actions.You may use the Desktop.isSupported(java.awt.Action) method to determine if the given action is supported by the current platform."},
{"description": "Meta-annotation that describes how an annotation element relates to a field in a Descriptor.This can be the Descriptor for an MBean, or for an attribute, operation, or constructor in an MBean, or for a parameter of an operation or constructor.public long getCacheSize(); } When a Standard MBean is made from the CacheControlMBean, the usual rules mean that it will have an attribute called CacheSize of type long.The @Units annotation, given the above definition, will ensure that the MBeanAttributeInfo for this attribute will have a Descriptor that has a field called units with corresponding value bytes.Similarly, if the annotation looks like this: @Documented @Target(ElementType.String resourceBundleBaseName() default \"\"; } and it is used like this: public interface CacheControlMBean { @Units(\"bytespublic long getCacheSize(); } then the resulting Descriptor will contain the following fields: NameValue units\"bytes\" descriptionResourceKey\"bytes.key\" descriptionResourceBundleBaseName \"com.example.foo.MBeanResources\" An annotation such as @Units can be applied to: a Standard MBean or MXBean interface; a method in such an interface; a parameter of a method in a Standard MBean or MXBean interface when that method is an operation (not a getter or setter for an attribute); a public constructor in the class that implements a Standard MBean or MXBean; a parameter in such a constructor.Other uses of the annotation are ignored.Interface annotations are checked only on the exact interface that defines the management interface of a Standard MBean or an MXBean, not on its parent interfaces.Method annotations are checked only in the most specific interface in which the method appears; in other words, if a child interface overrides a method from a parent interface, only @DescriptorKey annotations in the method in the child interface are considered.The Descriptor fields contributed in this way by different annotations on the same program element must be consistent.That is, two different annotations, or two members of the same annotation, must not define a different value for the same Descriptor field.Fields from annotations on a getter method must also be consistent with fields from annotations on the corresponding setter method.The Descriptor resulting from these annotations will be merged with any Descriptor fields provided by the implementation, such as the immutableInfo field for an MBean.The fields from the annotations must be consistent with these fields provided by the implementation.An annotation element to be converted into a descriptor field can be of any type allowed by the Java language, except an annotation or an array of annotations.The value of the field is derived from the value of the annotation element as follows:"},
{"description": "This class specifies a DES-EDE (\"triple-DES\") key."},
{"description": "This class represents the metadata set for a ModelMBean element.A descriptor is part of the ModelMBeanInfo, ModelMBeanNotificationInfo, ModelMBeanAttributeInfo, ModelMBeanConstructorInfo, and ModelMBeanParameterInfo.A descriptor consists of a collection of fields.Each field is in fieldname=fieldvalue format.Field names are not case sensitive, case will be preserved on field values.New fields can be defined and added by any program.Some fields have been predefined for consistency of implementation and support by the ModelMBeanInfo, ModelMBeanAttributeInfo, ModelMBeanConstructorInfo, ModelMBeanNotificationInfo, ModelMBeanOperationInfo and ModelMBean classes.The serialVersionUID of this class is -6292969195866300415L."},
{"description": "The kind of a diagnostic can be used to determine how the diagnostic should be presented to the user.For example, errors might be colored red or prefixed with the word \"Error\", while warnings might be colored yellow or prefixed with the word \"Warning\".There is no requirement that the Kind should imply any inherent semantic meaning to the message of the diagnostic: for example, a tool might provide an option to report all warnings as errors."},
{"description": "This class specifies a DES key."},
{"description": "This interface is intended to be implemented by, or delegated from, instances of java.beans.beancontext.BeanContext, in order to propagate to its nested hierarchy of java.beans.beancontext.BeanContextChild instances, the current \"designTime\" property.The JavaBeans\u2122 specification defines the notion of design time as is a mode in which JavaBeans instances should function during their composition and customization in a interactive design, composition or construction tool, as opposed to runtime when the JavaBean is part of an applet, application, or other live Java executable abstraction."},
{"description": "This interface is used to gain access to descriptors of the Descriptor class which are associated with a JMX component, i.e. MBean, MBeanInfo, MBeanAttributeInfo, MBeanNotificationInfo, MBeanOperationInfo, MBeanParameterInfo.ModelMBeans make extensive use of this interface in ModelMBeanInfo classes."},
{"description": "A Descriptor is associated with a MBeanInfo, MBeanAttributeInfo, etc.It consists of a collection of fields.A field is a name and an associated value.However, the case that was used when the field was first set is preserved in the result of the getFields() and getFieldNames() methods.New fields can be defined and added by any program.The Descriptor methods that could modify the contents of the descriptor will throw an exception for an immutable descriptor.Immutable descriptors are usually instances of ImmutableDescriptor or a subclass.Mutable descriptors are usually instances of DescriptorSupport or a subclass.Certain fields are used by the JMX implementation.This means either that the presence of the field may change the behavior of the JMX API or that the field may be set in descriptors returned by the JMX API.These fields appear in italics in the table below, and each one has a corresponding constant in the JMX class.For example, the field defaultValue is represented by the constant JMX.DEFAULT_VALUE_FIELD.Certain other fields have conventional meanings described in the table below but they are not required to be understood or set by the JMX implementation.Field names defined by the JMX specification in this and all future versions will never contain a period (.).Users can safely create their own fields by including a period in the name and be sure that these names will not collide with any future version of the JMX API.It is recommended to follow the Java package naming convention to avoid collisions between field names from different origins.For example, a field created by example.com might have the name com.example.interestLevel.Note that the values in the defaultValue, legalValues, maxValue, and minValue fields should be consistent with the type returned by the getType() method for the associated MBeanAttributeInfo or MBeanParameterInfo.For MXBeans, this means that they should be of the mapped Java type, called opendata(J) in the MXBean type mapping rules.An indication that this element of the information model is no longer recommended for use.A set of MBeans defined by an application is collectively called an information model.The convention is for the value of this field to contain a string that is the version of the model in which the element was first deprecated, followed by a space, followed by an explanation of the deprecation, for example \"1.3 Replaced by the Capacity attribute\".The base name for the ResourceBundle in which the key given in the descriptionResourceKey field can be found, for example \"com.example.myapp.MBeanResources\".The meaning of this field is defined by this specification but the field is not set or used by the JMX API itself.In conjunction with the descriptionResourceBundleBaseName, this can be used to find a localized version of the description.The meaning of this field is defined by this specification but the field is not set or used by the JMX API itself.A user interface might present it as a greyed-out item.For example, an attribute might only be meaningful after the start() method of an MBean has been called, and is otherwise disabled.Likewise, a notification might be disabled if it cannot currently be emitted but could be in other circumstances.exceptionsString[] MBeanAttributeInfo, MBeanConstructorInfo, MBeanOperationInfo The class names of the exceptions that can be thrown when invoking a constructor or operation, or getting an attribute.The meaning of this field is defined by this specification but the field is not set or used by the JMX API itself.Exceptions thrown when setting an attribute are specified by the field setExceptions.When this field is true, the MBeanInfo for the given MBean is guaranteed not to change over the lifetime of the MBean.Hence, a client can read it once and cache the read value.When this field is false or absent, there is no such guarantee, although that does not mean that the MBeanInfo will necessarily change.The time in milli-seconds that the MBeanInfo can reasonably be expected to be unchanged.The value can be a Long or a decimal string.This provides a hint from a DynamicMBean or any MBean that does not define immutableInfo as true that the MBeanInfo is not likely to change within this period and therefore can be cached.When this field is missing or has the value zero, it is not recommended to cache the MBeanInfo unless it has the immutableInfo set to true or it has \"jmx.mbean.info.changed\" in its MBeanNotificationInfo array.A Standard MBean or MXBean registered directly in the MBean Server or created using the StandardMBean class will have this field in its MBeanInfo Descriptor.A metric is a measurement exported by an MBean, usually an attribute but sometimes the result of an operation.A metric that is a counter has a value that never decreases except by being reset to a starting value.Counter metrics are almost always non-negative integers.An example might be the number of requests received.A metric that is a gauge has a numeric value that can increase or decrease.Examples might be the number of open connections or a cache hit rate or a temperature reading.MBeanInfo The string \"true\" or \"false\" according as this MBean is an MXBean.A Standard MBean or MXBean registered directly with the MBean Server or created using the StandardMBean class will have this field in its MBeanInfo Descriptor.In the case of MBeanAttributeInfo and MBeanParameterInfo, this is the Open Type of the attribute or parameter.In the case of MBeanOperationInfo, it is the Open Type of the return value.This field is set in the Descriptor for all instances of OpenMBeanAttributeInfoSupport, OpenMBeanOperationInfoSupport, and OpenMBeanParameterInfoSupport.It is also set for attributes, operations, and parameters of MXBeans.This field can be set for an MBeanNotificationInfo, in which case it indicates the Open Type that the user data will have.The original Java type of this element as it appeared in the MXBean interface method that produced this MBeanAttributeInfo (etc).For example, a method public MemoryUsage getHeapMemoryUsage(); in an MXBean interface defines an attribute called HeapMemoryUsage of type CompositeData.The originalType field in the Descriptor for this attribute will have the value \"java.lang.management.MemoryUsage\".The format of this string is described in the section Type Names of the MXBean specification.[] MBeanAttributeInfo The class names of the exceptions that can be thrown when setting an attribute.The meaning of this field is defined by this specification but the field is not set or used by the JMX API itself.Exceptions thrown when getting an attribute are specified by the field exceptions.It can be 0 to mean unknown severity or a value from 1 to 6 representing decreasing levels of severity.It can be represented as a decimal string or an Integer.The version of the information model in which this element was introduced.A set of MBeans defined by an application is collectively called an information model.The application may also define versions of this model, and use the \"since\" field to record the version in which an element first appeared.MBeanAttributeInfoMBeanParameterInfoMBeanOperationInfo The units in which an attribute, parameter, or operation return value is measured, for example \"bytes\" or \"seconds\".Some additional fields are defined by Model MBeans.The following table summarizes these fields.Note that when the Type in this table is Number, a String that is the decimal representation of a Long can also be used.Nothing prevents the use of these fields in MBeans that are not Model MBeans.The displayName, severity, and visibility fields are of interest outside Model MBeans, for example.But only Model MBeans have a predefined behavior for these fields.exportStringModelMBeanInfo Name to be used to export/expose this MBean so that it is findable by other JMX Agents.persistFileStringModelMBeanInfo File name into which the MBean should be persisted.persistLocationStringModelMBeanInfo The fully qualified directory name where the MBean should be persisted (if appropriate).Used when persistPolicy is \"OnTimer\" or \"NoMoreOftenThan\".XML formatted string to allow presentation of data.protocolMapDescriptorModelMBeanAttributeInfo See the section \"Protocol Map Support\" in the JMX specification document.Mappings must be appropriate for the attribute and entries can be updated or augmented at runtime.Can be: ObjectReference | Handle | EJBHandle | IOR"},
{"description": "A linear collection that supports element insertion and removal at both ends.The name deque is short for \"double ended queue\" and is usually pronounced \"deck\".Most Deque implementations place no fixed limits on the number of elements they may contain, but this interface supports capacity-restricted deques as well as those with no fixed size limit.This interface defines methods to access the elements at both ends of the deque.Methods are provided to insert, remove, and examine the element.Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation).The latter form of the insert operation is designed specifically for use with capacity-restricted Deque implementations; in most implementations, insert operations cannot fail.The twelve methods described above are summarized in the following table: Summary of Deque methods First Element (Head)This interface extends the Queue interface.When a deque is used as a queue, FIFO (First-In-First-Out) behavior results.Elements are added at the end of the deque and removed from the beginning.The methods inherited from the Queue interface are precisely equivalent to Deque methods as indicated in the following table: Comparison of Queue and Deque methods Queue Method Equivalent Deque Method add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst()peekFirst() Deques can also be used as LIFO (Last-In-First-Out) stacks.This interface should be used in preference to the legacy Stack class.When a deque is used as a stack, elements are pushed and popped from the beginning of the deque.Stack methods are precisely equivalent to Deque methods as indicated in the table below: Comparison of Stack and Deque methods Stack Method Equivalent Deque Method() Note that the peek method works equally well when a deque is used as a queue or a stack; in either case, elements are drawn from the beginning of the deque.This interface provides two methods to remove interior elements, removeFirstOccurrence and removeLastOccurrence.Unlike the List interface, this interface does not provide support for indexed access to elements.While Deque implementations are not strictly required to prohibit the insertion of null elements, they are strongly encouraged to do so.Users of any Deque implementations that do allow null elements are strongly encouraged not to take advantage of the ability to insert nulls.This is so because null is used as a special return value by various methods to indicated that the deque is empty.Deque implementations generally do not define element-based versions of the equals and hashCode methods, but instead inherit the identity-based versions from class Object.This interface is a member of the Java Collections Framework."},
{"description": "The portability package contains interfaces and classes that are designed for and intended to be used by ORB implementor.It exposes the publicly defined APIs that are used to connect stubs and skeletons to the ORB.The Delegate interface provides the ORB vendor specific implementation of PortableServer::Servant."},
{"description": "Delegate class provides the ORB vendor specific implementation of CORBA object.It extends org.omg.CORBA.portable.Delegate and provides new methods that were defined by CORBA 2.3."},
{"description": "A program element annotated @Deprecated is one that programmers are discouraged from using, typically because it is dangerous, or because a better alternative exists.Compilers warn when a deprecated program element is used or overridden in non-deprecated code."},
{"description": "This class is used to restrict the usage of the Kerberos delegation model, ie: forwardable and proxiable tickets.The first is the subordinate service principal being entrusted to use the TGT.The second service principal designates the target service the subordinate service principal is to interact with on behalf of the initiating KerberosPrincipal.This latter service principal is specified to restrict the use of a proxiable ticket.For example, to specify the \"host\" service use of a forwardable TGT the target permission is specified as follows: DelegationPermission(\"\\\"host/foo.example.com@EXAMPLE.COM\\\" \\\"krbtgt/EXAMPLE.COM@EXAMPLE.COM\\\"\"); To give the \"backup\" service a proxiable nfs service ticket the target permission might be specified: DelegationPermission(\"\\\"backup/bar.example.com@EXAMPLE.COM\\\" \\\"nfs/home."},
{"description": "Objects such as credentials may optionally implement this interface to provide the capability to destroy its contents."},
{"description": "Each stub (proxy) contains a delegate object, to which all org.omg.CORBA.Object methods are forwarded.This allows a stub generated by one vendor's ORB to work with the delegate from another vendor's ORB."},
{"description": "An unbounded blocking queue of Delayed elements, in which an element can only be taken when its delay has expired.The head of the queue is that Delayed element whose delay expired furthest in the past.If no delay has expired there is no head and poll will return null.method returns a value less than or equal to zero.Even though unexpired elements cannot be removed using take or poll, they are otherwise treated as normal elements.For example, the size method returns the count of both expired and unexpired elements.This queue does not permit null elements.This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces.The Iterator provided in method iterator() is not guaranteed to traverse the elements of the DelayQueue in any particular order.This class is a member of the Java Collections Framework."},
{"description": "A mix-in style interface for marking objects that should be acted upon after a given delay.An implementation of this interface must define a compareTo method that provides an ordering consistent with its getDelay method."},
{"description": "This class implements an output stream filter for compressing data in the \"deflate\" compression format.It is also used as the basis for other types of compression filters, such as GZIPOutputStream."},
{"description": "This class provides support for general purpose compression using the popular ZLIB compression library.The ZLIB compression library was initially developed as part of the PNG graphics standard and is not protected by patents.It is fully described in the specifications at the java.util.zip package description.The following code fragment demonstrates a trivial compression and decompression of a string using Deflater and Inflater.\"blahblahblah\"; byte[] input = inputString.getBytes(\"UTF-8\"); // Compress the bytes byte[] output = new byte[100]; Deflater compresser = new Deflater()"},
{"description": "The class that provides the constants used to identify the type of an Interface Repository object.This class contains two kinds of constants, those that are an int and those that are an instance of the class DefinitionKind.This class provides the method from_int, which given one of the int constants, creates the corresponding DefinitionKind instance.It also provides the method value, which returns the int constant that is the value for a DefinitionKind instance."},
{"description": "This is the default handler for all objects created from a JAXBContext that is managing schema-derived code generated by a JAXB 1.0 binding compiler.This handler causes the unmarshal and validate operations to fail on the first error or fatal error.This handler is not the default handler for JAXB mapped classes following JAXB 2.0 or later versions.Default validation event handling has changed and is specified in Unmarshaller and Marshaller."},
{"description": "Listeners are notified whenever the paths in the selection change, not the rows.In order to be able to track row changes you may wish to become a listener for expansion events on the tree and test for changes from there.resetRowSelection is called from any of the methods that update the selected paths.If you subclass any of these methods to filter what is allowed to be selected, be sure and message resetRowSelection if you do not message super.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A simple tree data model that uses TreeNodes.For further information and examples that use DefaultTreeModel, see How to Use Trees in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "You need to supply an instance of DefaultTreeCellRenderer so that the icons can be obtained.You can optionally supply a TreeCellEditor that will be layed out according to the icon in the DefaultTreeCellRenderer.If you do not supply a TreeCellEditor, a TextField will be used.Editing is started on a triple mouse click, or after a click, pause, click and a delay of 1200 milliseconds.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "DefaultTreeCellRenderer is not opaque and unless you subclass paint you should not change this.The set of icons and colors used by DefaultTreeCellRenderer can be configured using the various setter methods.The value for each property is initialized from the defaults table.When the look and feel changes (updateUI is invoked), any properties that have a value of type UIResource are refreshed from the defaults table.The following table lists the mapping between DefaultTreeCellRenderer property and defaults table key:This class overrides invalidate, validate, revalidate, repaint, and firePropertyChange solely to improve performance.If not overridden, these frequently called methods would execute code paths that are unnecessary for the default tree cell renderer.If you write your own renderer, take care to weigh the benefits and drawbacks of overriding these methods.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This is an implementation of TableModel that uses a Vector of Vectors to store the cell value objects.When DefaultTableModel is used with a TableRowSorter this will result in extensive use of toString, which for non-String data types is expensive.If you use DefaultTableModel with a TableRowSorter you are strongly encouraged to override getColumnClass to return the appropriate type.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A subclass of DefaultTableCellRenderer that implements UIResource.DefaultTableCellRenderer doesn't implement UIResource directly so that applications can safely override the cellRenderer property with DefaultTableCellRenderer subclasses.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "An UndoableEdit used to remember AttributeSet changes to an Element."},
{"description": "An implementation of RowSorter that provides sorting and filtering around a grid-based data model.Beyond creating and installing a RowSorter, you very rarely need to interact with one directly.Sorting is done based on the current SortKeys, in order.If two objects are equal (the Comparator for the column returns 0)If no SortKeys remain or the order is UNSORTED, then the order of the rows in the model is used.Sorting of each column is done by way of a Comparator that you can specify using the setComparator method.If a Comparator has not been specified, the Comparator returned by Collator.getInstance() is used on the results of calling toString on the underlying objects.The Comparator is never passed null.A null value is treated as occurring before a non-null value, and two null values are considered equal.If you specify a Comparator that casts its argument to a type other than that provided by the model, a ClassCastException will be thrown when the data is sorted.In addition to sorting, DefaultRowSorter provides the ability to filter rows.Filtering is done by way of a RowFilter that is specified using the setRowFilter method.By default, rows are in unsorted order (the same as the model) and every column is sortable.The default Comparators are documented in the subclasses (for example, TableRowSorter).If the underlying model structure changes (the modelStructureChanged method is invoked) the following are reset to their default values:Comparators by column, current sort order, and whether each column is sortable.The default sort order is unsorted (the same as the model), and columns are sortable by default.If the underlying model structure changes (the modelStructureChanged method is invoked) the following are reset to their default values:DefaultRowSorter is an abstract class.Concrete subclasses must provide access to the underlying data by invoking setModelWrapper.The setModelWrapper method must be invoked soon after the constructor is called, ideally from within the subclass's constructor.Undefined behavior will result if you use a DefaultRowSorter without specifying a ModelWrapper.DefaultRowSorter has two formal type parameters.The first type parameter corresponds to the class of the model, for exampleThe second type parameter corresponds to the class of the identifier passed to the RowFilter."},
{"description": "Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "ModelWrapper is responsible for providing the data that gets sorted by DefaultRowSorter.You normally do not interact directly with ModelWrapper.Subclasses of DefaultRowSorter provide an implementation of ModelWrapper wrapping another model.For example, TableRowSorter provides a ModelWrapper that wraps a TableModel.ModelWrapper makes a distinction between values as Objects and Strings.This allows implementations to provide a custom string converter to be used instead of invoking toString on the object."},
{"description": "This class inherits from JLabel, a standard component class.However JTable employs a unique mechanism for rendering its cells and therefore requires some slightly modified behavior from its cell renderer.The table class defines a single cell renderer and uses it as a as a rubber-stamp for rendering all cells in the table; it renders the first cell, changes the contents of that cell renderer, shifts the origin to the new location, re-draws it, and so on.The standard JLabel component was not designed to be used this way and we want to avoid triggering a revalidate each time the cell is drawn.This would greatly decrease performance because the revalidate message would be passed up the hierarchy of the container to determine whether any other components would be affected.As the renderer is only parented for the lifetime of a painting operation we similarly want to avoid the overhead associated with walking the hierarchy for painting operations.So this class overrides the validate, invalidate, revalidate, repaint, and firePropertyChange methods to be no-ops and override the isOpaque method solely to improve performance.If you write your own renderer, please keep this performance consideration in mind.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A document that can be marked up with character and paragraph styles in a manner similar to the Rich Text Format.The element structure for this document represents style crossings for style runs.These style runs are mapped into a paragraph element structure (which may reside in some other structure).The style runs break at paragraph boundaries since logical styles are assigned to paragraph boundaries.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The DefaultPersistenceDelegate is a concrete implementation of the abstract PersistenceDelegate class and is the delegate used by default for classes about which no information is available.The DefaultPersistenceDelegate provides, version resilient, public API-based persistence for classes that follow the JavaBeans\u2122 conventions without any class specific configuration.The key assumptions are that the class has a nullary constructor and that its state is accurately represented by matching pairs of \"setter\" and \"getter\" methods in the order they are returned by the Introspector.In addition to providing code-free persistence for JavaBeans, the DefaultPersistenceDelegate provides a convenient means to effect persistent storage for classes that have a constructor that, while not nullary, simply requires some property values as arguments."},
{"description": "A DefaultMutableTreeNode is a general-purpose node in a tree data structure.A tree node may have at most one parent and 0 or more children.DefaultMutableTreeNode provides operations for examining and modifying a node's parent and children and also operations for examining the tree that the node is a part of.A node's tree is the set of all nodes that can be reached by starting at the node and following all the possible links to parents and children.A node with no parent is the root of its tree; a node with no children is a leaf.A tree may consist of many subtrees, each node acting as the root for its own subtree.This class provides enumerations for efficiently traversing a tree or subtree in various orders or for following the path between two nodes.A DefaultMutableTreeNode may also hold a reference to a user object, the use of which is left to the user.Asking a DefaultMutableTreeNode for its string representation with toString() returns the string representation of its user object.This is not a thread safe class.If you intend to use a DefaultMutableTreeNode (or a tree of TreeNodes) in more than one thread, you need to do your own synchronizing.A good convention to adopt is synchronizing on the root node of a tree.While DefaultMutableTreeNode implements the MutableTreeNode interface and will allow you to add in any implementation of MutableTreeNode not all of the methods in DefaultMutableTreeNode will be applicable to all MutableTreeNodes implementations.Especially with some of the enumerations that are provided, using some of these methods assumes the DefaultMutableTreeNode contains only DefaultMutableNode instances.All of the TreeNode/MutableTreeNode methods will behave as defined no matter what implementations are added.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class is an extension of BoxLayout which adds the UIResource tag so that pluggable L&Fs can distinguish it from user-installed layout managers on menus."},
{"description": "All colors returned by DefaultMetalTheme are completely opaque.Font Style DefaultMetalTheme uses bold fonts for many controls.To make all controls (with the exception of the internal frame title bars and client decorated frame title bars) use plain fonts you can do either of the following:After setting this defaults property you need to re-install MetalLookAndFeel, as well as update the UI of any previously created widgets.The following illustrates how to do this: // turn off bold fonts UIManager.put(\"swing.boldMetal\", Boolean.This // needs to be invoked for all windows.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class loosely implements the java.util.Vector API, in that it implements the 1.1.x version of java.util.Vector, has no collection class support, and notifies the ListDataListeners when changes occur.Presently it delegates to a Vector, in a future release it will be a real Collection implementation.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Simple highlight painter that fills a highlighted area with a solid color."},
{"description": "DefaultFormatter formats arbitrary objects.Formatting is done by invoking the toString method.In order to convert the value back to a String, your class must provide a constructor that takes a String argument.If no single argument constructor that takes a String is found, the returned value will be the String passed into stringToValue.Instances of DefaultFormatter can not be used in multiple instances of JFormattedTextField.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class extends the SAX2 base handler class to support the SAX2 LexicalHandler, DeclHandler, and EntityResolver2 extensions.Except for overriding the original SAX1 resolveEntity() method the added handler methods just return.Subclassers may override everything on a method-by-method basis.This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.Note: this class might yet learn that the ContentHandler.setDocumentLocator() call might be passed a Locator2 object, and that the ContentHandler.startElement() call might be passed a Attributes2 object."},
{"description": "Implements a simple highlight painter that renders in a solid color."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This class is available as a convenience base class for SAX2 applications: it provides default implementations for all of the callbacks in the four core SAX2 handler classes: EntityResolver DTDHandler ContentHandler ErrorHandler Application writers can extend this class when they need to implement only part of an interface; parser writers can instantiate this class to provide default handlers when the application has not supplied its own.This class replaces the deprecated SAX1 HandlerBase class."},
{"description": "A subclass of DefaultListCellRenderer that implements UIResource.DefaultListCellRenderer doesn't implement UIResource directly so that applications can safely override the cellRenderer property with DefaultListCellRenderer subclasses.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class overrides invalidate, validate, revalidate, repaint, isOpaque, and firePropertyChange solely to improve performance.If not overridden, these frequently called methods would execute code paths that are unnecessary for the default list cell renderer.If you write your own renderer, take care to weigh the benefits and drawbacks of overriding these methods.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "DefaultFormatterFactory allows specifying a number of different JFormattedTextField.The most important one is the default one (setDefaultFormatter).The following process is used to determine the appropriate formatter to use.Is the passed in value null?If a non-null AbstractFormatter has not been found, use the default formatter.The following code shows how to configure a JFormattedTextField with two JFormattedTextField.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A FocusTraversalPolicy that determines traversal order based on the order of child Components in a Container.From a particular focus cycle root, the policy makes a pre-order traversal of the Component hierarchy, and traverses a Container's children according to the ordering of the array returned by Container.getComponents().Portions of the hierarchy that are not visible and displayable will not be searched.If client code has explicitly set the focusability of a Component by either overriding Component.isFocusTraversable() or Component.isFocusable(), or by calling Component.setFocusable(), then a DefaultFocusTraversalPolicy behaves exactly like a ContainerOrderFocusTraversalPolicy.If, however, the Component is relying on default focusability, then a DefaultFocusTraversalPolicy will reject all Components with non-focusable peers.This is the default FocusTraversalPolicy for all AWT Containers.The focusability of a peer is implementation-dependent.Sun recommends that all implementations for a particular native platform construct peers with the same focusability.The recommendations for Windows and Unix are that Canvases, Labels, Panels, Scrollbars, ScrollPanes, Windows, and lightweight Components have non-focusable peers, and all other Components have focusable peers.These recommendations are used in the Sun AWT implementations.Note that the focusability of a Component's peer is different from, and does not impact, the focusability of the Component itself."},
{"description": "Places content into the associated document.If there is a selection, it is removed before the new content is added.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The action that is executed by default if a key typed event is received and there is no keymap entry.There is a variation across different VM's in what gets sent as a key typed event, and this action tries to filter out the undesired events.This filters the control characters and those with the ALT modifier.It allows Control-Alt sequences through as these form legitimate unicode characters on some PC keyboards.If the event doesn't get filtered, it will try to insert content into the text editor.The content is fetched from the command string of the ActionEvent.The text entry is done through the replaceSelection method on the target text component.This is the action that will be fired for most text entry tasks.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class has been obsoleted by the 1.4 focus APIs.While client code may still use this class, developers are strongly encouraged to use java.awt.KeyboardFocusManager and java.awt.DefaultKeyboardFocusManager instead."},
{"description": "Pastes the contents of the system clipboard into the selected region, or before the caret if nothing is selected.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "If there is a selection, it is removed before the break is added.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "If there is a selection, it is removed before the tab is added.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This is an implementation of the DesktopManager.It currently implements the basic behaviors for managing JInternalFrames in an arbitrary parent.JInternalFrames that are not children of a JDesktop will use this component to handle their desktop-like actions.This class provides a policy for the various JInternalFrame methods, it is not meant to be called directly rather the various JInternalFrame methods will call into the DesktopManager."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This is the set of things needed by a text component to be a reasonably functioning editor for some type of text document.This implementation provides a default implementation which treats text as plain text and provides a minimal set of actions for a simple editor.There are two properties which deal with newlines.There is also a property defined in DefaultEditorKit, called EndOfLineStringProperty, which is defined automatically when a document is loaded, to be the first occurrence of any of the newline characters.But while the document is in memory, the \"\\n\" character is used to define a newline, regardless of how the newline is defined when the document is on disk.When a new document is created, and the EndOfLineStringProperty has not been defined, it will use the System property when writing out the document.Note that EndOfLineStringProperty is set on the Document using the get/putProperty methods.Subclasses may override this behavior."},
{"description": "The caret is rendered as a vertical line in the color specified by the CaretColor property of the associated JTextComponent.It can blink at the rate specified by the BlinkRate property.This implementation expects two sources of asynchronous notification.The timer thread fires asynchronously, and causes the caret to simply repaint the most recent bounding box.The caret also tracks change as the document is modified.Typically this will happen on the event dispatch thread as a result of some mouse or keyboard event.The caret behavior on both synchronous and asynchronous documents updates is controlled by UpdatePolicy property.The repaint of the new caret location will occur on the event thread in any case, as calls to modelToView are only safe on the event thread.The caret acts as a mouse and focus listener on the text component it has been installed in, and defines the caret semantics based upon those events.The listener methods can be reimplemented to change the semantics.By default, the first mouse button will be used to set focus and caret position.Dragging the mouse pointer with the first mouse button will sweep out a selection that is contiguous in the model.The Highlighter bound to the associated text component is used to render the selection by default.Selection appearance can be customized by supplying a painter to use for the highlights.By default a painter is used that will render a solid color as specified in the associated text component in the SelectionColor property.This can easily be changed by reimplementing the getSelectionPainter method.A customized caret appearance can be achieved by reimplementing the paint method.If the paint method is changed, the damage method should also be reimplemented to cause a repaint for the area needed to render the caret.The caret extends the Rectangle class which is used to hold the bounding box for where the caret was last rendered.This enables the caret to repaint in a thread-safe manner when the caret moves without making a call to modelToView which is unstable between model updates and view repair (i.e. the order of delivery to DocumentListeners is not guaranteed).The magic caret position is set to null when the caret position changes.A timer is used to determine the new location (after the caret change).When the timer fires, if the magic caret position is still null it is reset to the current caret position.Any actions that change the caret position and want the magic caret position to remain the same, must remember the magic caret position, change the cursor, and then set the magic caret position to its original value.This has the benefit that only actions that want the magic caret position to persist (such as open/down) need to know about it.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This is an optional extension handler for SAX2 to provide more complete information about DTD declarations in an XML document.XML readers are not required to recognize this handler, and it is not part of core-only SAX2 distributions.Note that data-related DTD declarations (unparsed entities and notations) are already reported through the DTDHandler interface.If you are using the declaration handler together with a lexical handler, all of the events will occur between the startDTD and the endDTD events.If the reader does not report declaration events, it will throw a SAXNotRecognizedException when you attempt to register the handler."},
{"description": "This includes parameterized types such as java.util.Set<String> as well as raw types.While a TypeElement represents a class or interface element, a DeclaredType represents a class or interface type, the latter being a use (or invocation) of the former.The supertypes (both class and interface types) of a declared type may be found using the Types.directSupertypes(TypeMirror) method.This returns the supertypes with any type arguments substituted in."},
{"description": "A significant part of dealing with dates and times is the localization.This class acts as a central point for accessing the information."},
{"description": "This class represents the set of symbols (such as the decimal separator, the grouping separator, and so on) needed by DecimalFormat to format numbers.DecimalFormat creates for itself an instance of DecimalFormatSymbols from its locale data.If you need to change any of these symbols, you can get the DecimalFormatSymbols object from your DecimalFormat and modify it."},
{"description": "An abstract class for service providers that provide instances of the DecimalFormatSymbols class.The requested Locale may contain an extension for specifying the desired numbering system."},
{"description": "DecimalFormat is a concrete subclass of NumberFormat that formats decimal numbers.It has a variety of features designed to make it possible to parse and format numbers in any locale, including support for Western, Arabic, and Indic digits.It also supports different kinds of numbers, including integers (123), fixed-point numbers (123.4), scientific notation (1.23E4), percentages (12%), and currency amounts ($123).All of these can be localized.In general, do not call the DecimalFormat constructors directly, since the NumberFormat factory methods may return subclasses other than DecimalFormat.If you need to customize the format object, do something like this: NumberFormat f = NumberFormat.getInstance(loc); if (f instanceof DecimalFormat) { ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true); } A DecimalFormat comprises a pattern and a set of symbols.The pattern may be set directly using applyPattern(), or indirectly using the API methods.The symbols are stored in a DecimalFormatSymbols object.When using the NumberFormat factory methods, the pattern and symbols are read from localized ResourceBundles.Patterns DecimalFormat patterns have the following syntax: Pattern: PositivePattern PositivePattern ;MinimumExponentopt A DecimalFormat pattern contains a positive and negative subpattern, for example, \"#,##0.00;(#,##0.00)\".Each subpattern has a prefix, numeric part, and suffix.The negative subpattern is optional; if absent, then the positive subpattern prefixed with the localized minus sign ('-' in most locales) is used as the negative subpattern.That is, \"0.00\" alone is equivalent to \"0.00;-0.00\".If there is an explicit negative subpattern, it serves only to specify the negative prefix and suffix; the number of digits, minimal digits, and other characteristics are all the same as the positive pattern.That means that \"#,##0.0#;(#)\" produces precisely the same behavior as \"#,##0.0#;(#,##0.0#)\".may be set to arbitrary values, and they will appear properly during formatting.For example, either the positive and negative prefixes or the suffixes must be distinct for DecimalFormat.parse() to be able to distinguish positive from negative values.Another example is that the decimal separator and thousands separator should be distinct characters, or parsing will be impossible.The grouping separator is commonly used for thousands, but in some countries it separates ten-thousands.The grouping size is a constant number of digits between the grouping characters, such as 3 for 100,000,000 or 4 for 1,0000,0000.If you supply a pattern with multiple grouping characters, the interval between the last one and the end of the integer is the one that is used.Many characters in a pattern are taken literally; they are matched during parsing and output unchanged during formatting.Special characters, on the other hand, stand for other characters, strings, or classes of characters.They must be quoted, unless noted otherwise, if they are to appear in the prefix or suffix as literals.The characters listed here are used in non-localized patterns.Localized patterns use the corresponding characters taken from this formatter's DecimalFormatSymbols object instead, and these characters lose their special status.Two exceptions are the currency sign and quote, which are not localized.If present in a pattern, the monetary decimal separator is used instead of the decimal separator. 'Scientific Notation Numbers in scientific notation are expressed as the product of a mantissa and a power of ten, for example, 1234 can be expressed as 1.234 x 10^3.The mantissa is often in the range 1.0 \u2264 x < 10.0, but it need not be.DecimalFormat can be instructed to format and parse scientific notation only via a pattern; there is currently no factory method that creates a scientific notation format.In a pattern, the exponent character immediately followed by one or more digit characters indicates scientific notation.Example: \"0.###E0\" formats the number 1234 as \"1.234E3\".The number of digit characters after the exponent character gives the minimum exponent digit count.There is no maximum.Negative exponents are formatted using the localized minus sign, not the prefix and suffix from the pattern.This allows patterns such as \"0.###E0 m/s\".The minimum and maximum number of integer digits are interpreted together: If the maximum number of integer digits is greater than their minimum number and greater than 1, it forces the exponent to be a multiple of the maximum number of integer digits, and the minimum number of integer digits to be interpreted as 1.The most common use of this is to generate engineering notation, in which the exponent is a multiple of three, e.g., \"##0.#####E0\".Otherwise, the minimum number of integer digits is achieved by adjusting the exponent.The number of significant digits in the mantissa is the sum of the minimum integer and maximum fraction digits, and is unaffected by the maximum integer digits.For example, 12345 formatted with \"##0.##E0\" is \"12.3E3\".To show all digits, set the significant digits count to zero.The number of significant digits does not affect parsing.Exponential patterns may not contain grouping separators.Rounding DecimalFormat provides rounding modes defined in RoundingMode for formatting.By default, it uses RoundingMode.For formatting, DecimalFormat uses the ten consecutive characters starting with the localized zero digit defined in the DecimalFormatSymbols object as digits.For parsing, these digits as well as all Unicode decimal digits, as defined by Character.digit, are recognized.Special Values NaN is formatted as a string, which typically has a single character \\uFFFD.This string is determined by the DecimalFormatSymbols object.This is the only value for which the prefixes and suffixes are not used.Infinity is formatted as a string, which typically has a single character \\u221E, with the positive or negative prefixes and suffixes applied.The infinity string is determined by the DecimalFormatSymbols object.It is recommended to create separate format instances for each thread.If multiple threads access a format concurrently, it must be synchronized externally.NumberFormat form; for (int j = 0; j < 4; ++j) { System.out.println(\"FORMAT\"); for (int i = 0; i < locales.length; ++i) { if (locales[i].getCountry().length() == 0) { continue; //; break; case 1: form = NumberFormat.getIntegerInstance(locales[i]); break; case 2: form = NumberFormat.getCurrencyInstance(locales[i]); break; default: form = NumberFormat.getPercentInstance(locales[i]); break; } if (form instanceof DecimalFormat) { System.out.print(\": \" + ((DecimalFormat)"},
{"description": "Graphics subclass supporting graphics debugging.DebugGraphics objects are rarely created by hand.They are most frequently created automatically when a JComponent's debugGraphicsOptions are changed using the setDebugGraphicsOptions() method.You must turn off double buffering to use DebugGraphics: RepaintManager repaintManager = RepaintManager.currentManager(component); repaintManager.setDoubleBufferingEnabled(false);"},
{"description": "Class DateTimeSyntax is an abstract base class providing the common implementation of all attributes whose value is a date and time.Under the hood, a date-time attribute is stored as a value of class java.util.Date.You can get a date-time attribute's Date value by calling getValue().A date-time attribute's Date value is established when it is constructed (see DateTimeSyntax(Date)).Class DateTimeSyntax stores its value in the form of a java.util.Date rather than a java.util.Calendar because it typically takes less memory to store and less time to compare a java.util.Date than a java.util.Calendar."},
{"description": "DayOfWeek is an enum representing the 7 days of the week - Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday.In addition to the textual enum name, each day-of-week has an int value.The int value follows the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).It is recommended that applications use the enum rather than the int value to ensure code clarity.This enum provides access to the localized textual form of the day-of-week.Some locales also assign different numeric values to the days, declaring Sunday to have the value 1, however this class provides no support for this.This enum represents a common concept that is found in many calendar systems.As such, this enum may be used by any calendar system that has the day-of-week concept defined exactly equivalent to the ISO calendar system."},
{"description": "An exception thrown when an error occurs during parsing.This exception includes the text being parsed and the error index."},
{"description": "This class provides the main application entry point for printing and parsing and provides common implementations of DateTimeFormatter: Using predefined constants, such as ISO_LOCAL_DATEUsing localized styles, such as long or medium More complex formatters are provided by DateTimeFormatterBuilder.The main date-time classes provide two methods - one for formatting, format(DateTimeFormatter formatter), and one for parsing, parse(CharSequence text, DateTimeFormatter formatter).(); String text = date.format(formatter); LocalDate parsedDate = LocalDate.parse(text, formatter); In addition to the format, formatters can be created with desired Locale, Chronology, ZoneId, and DecimalStyle.The withLocale method returns a new formatter that overrides the locale.The locale affects some aspects of formatting and parsing.For example, the ofLocalizedDate provides a formatter that uses the locale specific date format.The withChronology method returns a new formatter that overrides the chronology.If overridden, the date-time value is converted to the chronology before formatting.During parsing the date-time value is converted to the chronology before it is returned.The withZone method returns a new formatter that overrides the zone.If overridden, the date-time value is converted to a ZonedDateTime with the requested ZoneId before formatting.During parsing the ZoneId is applied before the value is returned.The withDecimalStyle method returns a new formatter that overrides the DecimalStyle.The DecimalStyle symbols are used for formatting and parsing.Some applications may need to use the older java.text.Format class for formatting.The toFormat() method returns an implementation of java.text.Format.Tue, 3 Jun 2008 11:05:30 GMT' Patterns for Formatting and Parsing Patterns are based on a simple sequence of letters and symbols.A pattern is used to create a Formatter using the ofPattern(String) and ofPattern(String, Locale) methods.For example, \"d MMM uuuu\" will format 2011-12-03 as '3\u00a0Dec\u00a02011'.A formatter created from a pattern can be used as many times as necessary, it is immutable and is thread-safe.For example: LocalDate date = LocalDate.now(); DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy MM dd\"); String text = date.format(formatter); LocalDate parsedDate = LocalDate.parse(text, formatter); All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.The following pattern letters are defined: Symbol Meaning Presentation Examples -------08:30 z time-zone name zone-name Pacific Standard Time; PST O localized zone-offset offset-O GMT+8; GMT+08:00; UTC-08:00;'' single quote literal ' [ optional section start ] optional section end # reserved for future use { reserved for future use } reserved for future use The count of pattern letters determines the format.The text style is determined based on the number of pattern letters used.Less than 4 pattern letters will use the short form.Exactly 4 pattern letters will use the full form.Exactly 5 pattern letters will use the narrow form.Pattern letters 'L', 'c', and 'q' specify the stand-alone form of the text styles.If the count of letters is one, then the value is output using the minimum number of digits and without padding.Otherwise, the count of digits is used as the width of the output field, with the value zero-padded as necessary.The following pattern letters have constraints on the count of letters.Only one letter of 'c' and 'F' can be specified.Up to two letters of 'd', 'H', 'h', 'K', 'k', 'm', and 's' can be specified.Up to three letters of 'D' can be specified.If the count of pattern letters is 3 or greater, use the Text rules above.The nano-of-second value has nine digits, thus the count of pattern letters is from 1 to 9.If it is less than 9, then the nano-of-second value is truncated, with only the most significant digits being output.Year: The count of letters determines the minimum field width below which padding is used.If the count of letters is two, then a reduced two digit form is used.For printing, this outputs the rightmost two digits.For parsing, this will parse using the base value of 2000, resulting in a year within the range 2000 to 2099 inclusive.If the count of letters is less than four (but not two), then the sign is only output for negative years as per SignStyle.Otherwise, the sign is output if the pad width is exceeded, as per SignStyle.: This outputs the time-zone ID, such as 'Europe/Paris'.If the count of letters is two, then the time-zone ID is output.Any other count of letters throwsThis outputs the display name of the time-zone ID.If the count of letters is one, two or three, then the short name is output.If the count of letters is four, then the full name is output.One letter outputs just the hour, such as '+01', unless the minute is non-zero in which case the minute is also output, such as '+0130'.Two letters outputs the hour and minute, without a colon, such as '+0130'.Three letters outputs the hour and minute, with a colon, such as '+01:30'.Four letters outputs the hour and minute and optional second, without a colon, such as '+013015'.Five letters outputs the hour and minute and optional second, with a colon, such as '+01:30:15'.IllegalArgumentException. Pattern letter 'X' (upper case) will output 'Z' when the offset to be output would be zero, whereas pattern letter 'x' (lower case) will output '+00', '+0000', or '+00:00'.One letter outputs the short form of the localized offset, which is localized offset text, such as 'GMT', with hour without leading zero, optional 2-digit minute and second if non-zero, and colon, for example 'GMT+8'.Four letters outputs the full form, which is localized offset text, such as 'GMT, with 2-digit hour and minute field, optional second field if non-zero, and colon, for example 'GMT+08:00'.Any other count of letters throws IllegalArgumentException.One, two or three letters outputs the hour and minute, without a colon, such as '+0130'.The output will be '+0000' when the offset is zero.Four letters outputs the full form of localized offset, equivalent to four letters of Offset-O.The output will be the corresponding localized offset text if the offset is zero.Five letters outputs the hour, minute, with optional second if non-zero, with colon.It outputs 'Z' if the offset is zero.Optional section: The optional section markers work exactly like calling DateTimeFormatterBuilder.optionalStart() and DateTimeFormatterBuilder.optionalEndModifies the pattern that immediately follows to be padded with spaces.The pad width is determined by the number of pattern letters.This is the same as calling DateTimeFormatterBuilder.padNext(int).For example, 'ppH' outputs the hour-of-day padded on the left with spaces to a width of 2.Any unrecognized letter is an error.Any non-letter character, other than '[', ']', '{', '}', '#' and the single quote will be output directly.Despite this, it is recommended to use single quotes around all characters that you want to output directly to ensure that future changes do not break your application.Resolving Parsing is implemented as a two-phase operation.First, the text is parsed using the layout defined by the formatter, producing a Map of field to value, a ZoneId and a Chronology.Second, the parsed data is resolved, by validating, combining and simplifying the various fields into more useful ones.Five parsing methods are supplied by this class.Four of these perform both the parse and resolve phases.The fifth method, parseUnresolved(CharSequence, ParsePosition), only performs the first phase, leaving the result unresolved.As such, it is essentially a low-level operation.The resolve phase is controlled by two parameters, set on this class.The ResolverStyle is an enum that offers three different approaches, strict, smart and lenient.The smart option is the default.It can be set using withResolverStyle(ResolverStyle).The withResolverFields(TemporalField...) parameter allows the set of fields that will be resolved to be filtered before resolving starts.For example, if the formatter has parsed a year, month, day-of-month and day-of-year, then there are two approaches to resolve a date:The resolver fields allows one of the two approaches to be selected.If no resolver fields are set then both approaches must result in the same date.Resolving separate fields to form a complete date and time is a complex process with behaviour distributed across a number of classes.It follows these steps: The chronology is determined.The chronology of the result is either the chronology that was parsed, or if no chronology was parsed, it is the chronology set on this class, or if that is null, it is IsoChronology.This is achieved using Chronology.resolveDate(Map, ResolverStyle).Documentation about field resolution is located in the implementation of Chronology.This is documented on ChronoField and is the same for all chronologies.Any fields that are not ChronoField are processed.This is achieved using TemporalField.resolve(Map, TemporalAccessor, ResolverStyle).Documentation about field resolution is located in the implementation of TemporalField.This allows fields in step four to produce ChronoField values and have them be processed into dates and times.A LocalTime is formed if there is at least an hour-of-day available.This involves providing default values for minute, second and fraction of second.Any remaining unresolved fields are cross-checked against any date and/or time that was resolved.Thus, an earlier stage would resolve (year + month + day-of-month) to a date, and this stage would check that day-of-week was valid for the date.If an excess number of days was parsed then it is added to the date if a date is available."},
{"description": "Class DateTimeAtProcessing is a printing attribute class, a date-time attribute, that indicates the date and time at which the Print Job first began processing.To construct a DateTimeAtProcessing attribute from separate values of the year, month, day, hour, minute, and so on, use a Calendar object to construct a Date object, then use the Date object to construct the DateTimeAtProcessing attribute.The information needed to construct an IPP \"date-time-at-processing\" attribute can be obtained as described above.The category name returned by getName() gives the IPP attribute name."},
{"description": "All date-time formatters are created ultimately using this builder.The basic elements of date-time can all be added: Value - a numeric value Fraction - a fractional value including the decimal place.Always use this when outputting fractions to ensure that the fraction is parsed correctly Text - the textual equivalent for the value OffsetId/Offset - the zone offset ZoneId -the time-zone id ZoneText - the name of the time-zone ChronologyId - the chronology id ChronologyText - the name of the chronology Literal - a text literal Nested and Optional - formats can be nested or made optional In addition, any of the elements may be decorated by padding, either with spaces or any other character.Finally, a shorthand pattern, mostly compatible with java.text.SimpleDateFormat SimpleDateFormat can be used, see appendPattern(String).In practice, this simply parses the pattern and calls other methods on the builder."},
{"description": "Exception used to indicate a problem while calculating a date-time.This exception is used to indicate problems with creating, querying and manipulating date-time objects."},
{"description": "DateFormatSymbols is a public class for encapsulating localizable date-time formatting data, such as the names of the months, the names of the days of the week, and the time zone data.SimpleDateFormat uses DateFormatSymbols to encapsulate this information.Typically you shouldn't use DateFormatSymbols directly.Rather, you are encouraged to create a date-time formatter with the DateFormat class's factory methods:These methods automatically create a DateFormatSymbols for the formatter so that you don't have to.After the formatter is created, you may modify its format pattern using the setPattern method.If you decide to create a date-time formatter with a specific format pattern for a specific locale, you can do so with: new SimpleDateFormat(aPattern, DateFormatSymbols.getInstance(aLocale)).When you obtain a DateFormatSymbols object, feel free to modify the date-time formatting data.For instance, you can replace the localized date-time format pattern characters with the ones that you feel easy to remember.Or you can change the representative cities to your favorite ones.New DateFormatSymbols subclasses may be added to support SimpleDateFormat for date-time formatting for additional locales."},
{"description": "DateFormat is an abstract class for date/time formatting subclasses which formats and parses dates or time in a language-independent manner.The date/time formatting subclass, such as SimpleDateFormat, allows for formatting (i.e., date \u2192 text), parsing (text \u2192 date), and normalization.The date is represented as a Date object or as the milliseconds since January 1, 1970, 00:00:00 GMT.DateFormat provides many class methods for obtaining default date/time formatters based on the default or a given locale and a number of formatting styles.The formatting styles include FULL, LONG, MEDIUM, and SHORT.More detail and examples of using these styles are provided in the method descriptions.DateFormat helps you to format and parse dates for any locale.Your code can be completely independent of the locale conventions for months, days of the week, or even the calendar format: lunar vs. solar.To format a date for the current Locale, use one of the static factory methods: myString = DateFormat.getDateInstance().format(myDate); If you are formatting multiple dates, it is more efficient to get the format and use it multiple times so that the system doesn't have to fetch the information about the local language and country conventions multiple times.FRANCE); You can use a DateFormat to parse also.There are other static factory methods available.You can pass in different options to these factory methods to control the length of the result; from SHORT to MEDIUM to LONG to FULL.The exact result depends on the locale, but generally: SHORT is completely numeric, such as 12.13.52 or 3:30pm MEDIUM is longer, such as Jan 12, 1952 LONG is longer, such as January 12, 1952 or 3:30:32pm FULL is pretty completely specified, such as Tuesday, April 12, 1952 AD or 3:30:42pm PST.You can also set the time zone on the format if you wish.If you want even more control over the format or parsing, (or want to give your users more control), you can try casting the DateFormat you get from the factory methods to a SimpleDateFormat.This will work for the majority of countries; just remember to put it in a try block in case you encounter an unusual one.You can also use forms of the parse and format methods with ParsePosition and FieldPosition to allow you to progressively parse through pieces of a string.align any particular field, or find out where it is for selection on the screen.It is recommended to create separate format instances for each thread.If multiple threads access a format concurrently, it must be synchronized externally."},
{"description": "An abstract class for service providers that provide instances of the DateFormatSymbols class."},
{"description": "An abstract class for service providers that provide concrete implementations of the DateFormat class."},
{"description": "Defines constants that are used as attribute keys in the AttributedCharacterIterator returned from DateFormat.formatToCharacterIterator and as field identifiers in FieldPosition.The class also provides two methods to map between its constants and the corresponding Calendar constants."},
{"description": "Class DateTimeAtCompleted is a printing attribute class, a date-time attribute, that indicates the date and time at which the Print Job completed (or was canceled or aborted).To construct a DateTimeAtCompleted attribute from separate values of the year, month, day, hour, minute, and so on, use a Calendar object to construct a Date object, then use the Date object to construct the DateTimeAtCompleted attribute.The information needed to construct an IPP \"date-time-at-completed\" attribute can be obtained as described above.The category name returned by getName() gives the IPP attribute name."},
{"description": "DateFormatter is an InternationalFormatter that does its formatting by way of an instance of java.text.DateFormat.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Class DateTimeAtCreation is a printing attribute class, a date-time attribute, that indicates the date and time at which the Print Job was created.To construct a DateTimeAtCreation attribute from separate values of the year, month, day, hour, minute, and so on, use a Calendar object to construct a Date object, then use the Date object to construct the DateTimeAtCreation attribute.The information needed to construct an IPP \"date-time-at-creation\" attribute can be obtained as described above.The category name returned by getName() gives the IPP attribute name."},
{"description": "The class Date represents a specific instant in time, with millisecond precision.Prior to JDK\u00a01.1, the class Date had two additional functions.It allowed the interpretation of dates as year, month, day, hour, minute, and second values.It also allowed the formatting and parsing of date strings.Unfortunately, the API for these functions was not amenable to internationalization.As of JDK\u00a01.1, the Calendar class should be used to convert between dates and time fields and the DateFormat class should be used to format and parse date strings.The corresponding methods in Date are deprecated.Although the Date class is intended to reflect coordinated universal time (UTC), it may not do so exactly, depending on the host environment of the Java Virtual Machine.Nearly all modern operating systems assume that 1\u00a0day\u00a0= 24\u00a0\u00d7\u00a060\u00a0\u00d7\u00a060\u00a0= 86400 seconds in all cases.In UTC, however, about once every year or two there is an extra second, called a \"leap second.\" The leap second is always added as the last second of the day, and always on December 31 or June 30.For example, the last minute of the year 1995 was 61 seconds long, thanks to an added leap second.Most computer clocks are not accurate enough to be able to reflect the leap-second distinction.Some computer standards are defined in terms of Greenwich mean time (GMT), which is equivalent to universal time (UT).GMT is the \"civil\" name for the standard; UT is the \"scientific\" name for the same standard.The distinction between UTC and UT is that UTC is based on an atomic clock and UT is based on astronomical observations, which for all practical purposes is an invisibly fine hair to split.Because the earth's rotation is not uniform (it slows down and speeds up in complicated ways), UT does not always flow uniformly.Leap seconds are introduced as needed into UTC so as to keep UTC within 0.9 seconds of UT1, which is a version of UT with certain corrections applied.There are other time and date systems as well; for example, the time scale used by the satellite-based global positioning system (GPS) is synchronized to UTC but is not adjusted for leap seconds.An interesting source of further information is the U.S. Naval Observatory, particularly the Directorate of Time at: http://tycho.usno.navy.mil and their definitions of \"Systems of Time\" at: http://tycho.usno.navy.mil/systime.htmlIn all methods of class Date that accept or return year, month, date, hours, minutes, and seconds values, the following representations are used: A year y is represented by the integer y\u00a0-\u00a01900.A month is represented by an integer from 0 to 11; 0 is January, 1 is February, and so forth; thus 11 is December.A date (day of month) is represented by an integer from 1 to 31 in the usual manner.An hour is represented by an integer from 0 to 23.Thus, the hour from midnight to 1 a.m. is hour 0, and the hour from noon to 1 p.m. is hour 12.A minute is represented by an integer from 0 to 59 in the usual manner.A second is represented by an integer from 0 to 61; the values 60 and 61 occur only for leap seconds and even then only in Java implementations that actually track leap seconds correctly.Because of the manner in which leap seconds are currently introduced, it is extremely unlikely that two leap seconds will occur in the same minute, but this specification follows the date and time conventions for ISO C.In all cases, arguments given to methods for these purposes need not fall within the indicated ranges; for example, a date may be specified as January 32 and is interpreted as meaning February 1."},
{"description": "A thin wrapper around a millisecond value that allows JDBC to identify this as an SQL DATE value.A milliseconds value represents the number of milliseconds that have passed since January 1, 1970 00:00:00.000 GMT.To conform with the definition of SQL DATE, the millisecond values wrapped by a java.sql.Date instance must be 'normalized' by setting the hours, minutes, seconds, and milliseconds to zero in the particular time zone with which the instance is associated."},
{"description": "A JAXB provider must supply a class that implements this interface.JAXB Providers are required to call the DatatypeConverter.setDatatypeConverter api at some point before the first marshal or unmarshal operation (perhaps during the call to JAXBContext.newInstance).This step is necessary to configure the converter that should be used to perform the print and parse functionality.Calling this api repeatedly will have no effect - the DatatypeConverter instance passed into the first invocation is the one that will be used from then on.This interface defines the parse and print methods.There is one parse and print method for each XML schema datatype specified in the the default binding Table 5-1 in the JAXB specification.The parse and print methods defined here are invoked by the static parse and print methods defined in the DatatypeConverter class.A parse method for a XML schema datatype must be capable of converting any lexical representation of the XML schema datatype ( specified by the XML Schema Part2:If an error is encountered during conversion, then an IllegalArgumentException or a subclass of IllegalArgumentException must be thrown by the method.A print method for a XML schema datatype can output any lexical representation that is valid with respect to the XML schema datatype.If an error is encountered during conversion, then an IllegalArgumentException, or a subclass of IllegalArgumentException must be thrown by the method.The prefix xsd: is used to refer to XML schema datatypes XML Schema Part2: Datatypes specification."},
{"description": "Factory that creates new javax.xml.datatype Objects that map XML to/from Java Objects.A new instance of the DatatypeFactory is created through the newInstance() method that uses the following implementation resolution mechanisms to determine an implementation: If the system property specified by DATATYPEFACTORY_PROPERTY, \"javax.xml.datatype.DatatypeFactory\", exists, a class with the name of the property value is instantiated.Any Exception thrown during the instantiation process is wrapped as a DatatypeConfigurationException.If the file ${JAVA_HOME}/lib/jaxp.properties exists, it is loaded in a Properties Object.The Properties Object is then queried for the property as documented in the prior step and processed as documented in the prior step.Uses the service-provider loading facilities, defined by the ServiceLoader class, to attempt to locate and load an implementation of the service using the default loading mechanism: the service-provider loading facility will use the current thread's context class loader to attempt to load the service.In case of service configuration error a DatatypeConfigurationException will be thrown.The final mechanism is to attempt to instantiate the Class specified by DATATYPEFACTORY_IMPLEMENTATION_CLASS.Any Exception thrown during the instantiation process is wrapped as a DatatypeConfigurationException."},
{"description": "Type-safe enum class that represents six fields of the Duration class."},
{"description": "The javaType binding declaration can be used to customize the binding of an XML schema datatype to a Java datatype.Customizations can involve writing a parse and print method for parsing and printing lexical representations of a XML schema datatype respectively.However, writing parse and print methods requires knowledge of the lexical representations ( XML Schema Part2: Datatypes specification ) and hence may be difficult to write.This class makes it easier to write parse and print methods.It defines static parse and print methods that provide access to a JAXB provider's implementation of parse and print methods.These methods are invoked by custom parse and print methods.For example, the binding of xsd:dateTime to a long can be customized using parse and print methods as follows: //There is a static parse and print method corresponding to each parse and print method respectively in the DatatypeConverterInterface.The static methods defined in the class can also be used to specify a parse or a print method in a javaType binding declaration.JAXB Providers are required to call the setDatatypeConverter api at some point before the first marshal or unmarshal operation (perhaps during the call to JAXBContext.newInstance).This step is necessary to configure the converter that should be used to perform the print and parse functionality.A print method for a XML schema datatype can output any lexical representation that is valid with respect to the XML schema datatype.If an error is encountered during conversion, then an IllegalArgumentException, or a subclass of IllegalArgumentException must be thrown by the method."},
{"description": "This interface is used by user written custom marshalling code for custom value types."},
{"description": "A data output stream lets an application write primitive Java data types to an output stream in a portable way.An application can then use a data input stream to read the data back in."},
{"description": "Besides the class information inherited from its superclass, DataLine.Info provides additional information specific to data lines.This information includes: the audio formats supported by the data line the minimum and maximum sizes of its internal buffer Because a Line.Info knows the class of the line its describes, a DataLine.Info object can describe DataLine subinterfaces such as SourceDataLine, TargetDataLine, and Clip.You can query a mixer for lines of any of these types, passing an appropriate instance of DataLine."},
{"description": "The DataOutput interface provides for converting data from any of the Java primitive types to a series of bytes and writing these bytes to a binary stream.There is also a facility for converting a String into modified UTF-8 format and writing the resulting series of bytes.For all the methods in this interface that write bytes, it is generally true that if a byte cannot be written for any reason, an IOException is thrown."},
{"description": "A factory for connections to the physical data source that this DataSource object represents.An alternative to the DriverManager facility, a DataSource object is the preferred means of getting a connection.An object that implements the DataSource interface will typically be registered with a naming service based on the Java\u2122 Naming and Directory (JNDI) API.The DataSource interface is implemented by a driver vendor.There are three types of implementations: Basic implementation -- produces a standard Connection object Connection pooling implementation -- produces a Connection object that will automatically participate in connection pooling.This implementation works with a middle-tier connection pooling manager.Distributed transaction implementation -- produces a Connection object that may be used for distributed transactions and almost always participates in connection pooling.This implementation works with a middle-tier transaction manager and almost always with a connection pooling manager.A DataSource object has properties that can be modified when necessary.For example, if the data source is moved to a different server, the property for the server can be changed.The benefit is that because the data source's properties can be changed, any code accessing that data source does not need to be changed.A driver that is accessed via a DataSource object does not register itself with the DriverManager.Rather, a DataSource object is retrieved though a lookup operation and then used to create a Connection object.With a basic implementation, the connection obtained through a DataSource object is identical to a connection obtained through the DriverManager facility.An implementation of DataSource must include a public no-arg constructor."},
{"description": "The DataSource interface provides the JavaBeans Activation Framework with an abstraction of an arbitrary collection of data.It provides a type for that data as well as access to it in the form of InputStreams and OutputStreams where appropriate."},
{"description": "DataLine adds media-related functionality to its superinterface, Line.This functionality includes transport-control methods that start, stop, drain, and flush the audio data that passes through the line.A data line can also report the current position, volume, and audio format of the media.Data lines are used for output of audio by means of the subinterfaces SourceDataLine or Clip, which allow an application program to write data.Similarly, audio input is handled by the subinterface TargetDataLine, which allows data to be read.A data line has an internal buffer in which the incoming or outgoing audio data is queued.The flush() method discards any available queued data from the internal buffer.A data line produces START and STOP events whenever it begins or ceases active presentation or capture of data.These events can be generated in response to specific requests, or as a result of less direct state changes.For example, if start() is called on an inactive data line, and data is available for capture or playback, a START event will be generated shortly, when data playback or capture actually begins.Or, if the flow of data to an active data line is constricted so that a gap occurs in the presentation of data, a STOP event is generated.Mixers often support synchronized control of multiple data lines.Synchronization can be established through the Mixer interface's synchronize method."},
{"description": "The DataInput interface provides for reading bytes from a binary stream and reconstructing from them data in any of the Java primitive types.There is also a facility for reconstructing a String from data in modified UTF-8 format.It is generally true of all the reading routines in this interface that if end of file is reached before the desired number of bytes has been read, an EOFException (which is a kind of IOException) is thrown.If any byte cannot be read for any reason other than end of file, an IOException other than EOFException is thrown.Modified UTF-8 Implementations of the DataInput and DataOutput interfaces represent Unicode strings in a format that is a slight modification of UTF-8.Note that in the following table, the most significant bit appears in the far left-hand column.All characters in the range '\\u0001' to '\\u007F' are represented by a single byte: Bit Values Byte 1 0 bits 6-0The null character '\\u0000' and characters in the range '\\u0080' to '\\u07FF' are represented by a pair of bytes:Byte 2 1 0 bits 5-0 char values in the range '\\u0800' to '\\uFFFF' are represented by three bytes:The differences between this format and the standard UTF-8 format are the following:The null byte '\\u0000' is encoded in 2-byte format rather than 1-byte, so that the encoded strings never have embedded nulls.Supplementary characters are represented in the form of surrogate pairs."},
{"description": "This interface defines a factory for datagram socket implementations.It is used by the classes DatagramSocket to create actual socket implementations."},
{"description": "This class represents a socket for sending and receiving datagram packets.A datagram socket is the sending or receiving point for a packet delivery service.Each packet sent or received on a datagram socket is individually addressed and routed.Multiple packets sent from one machine to another may be routed differently, and may arrive in any order.Where possible, a newly constructed DatagramSocket has the SO_BROADCAST socket option enabled so as to allow the transmission of broadcast datagrams.In order to receive broadcast packets a DatagramSocket should be bound to the wildcard address.In some implementations, broadcast packets may also be received when a DatagramSocket is bound to a more specific address.Example: DatagramSocket s = new DatagramSocket(null); s.bind(new InetSocketAddress(8888)); Which is equivalent to: DatagramSocket s = new DatagramSocket(8888); Both cases will create a DatagramSocket able to receive broadcasts on UDP port 8888."},
{"description": "This interface is used by user written custom unmarshaling code for custom value types."},
{"description": "A data input stream lets an application read primitive Java data types from an underlying input stream in a machine-independent way.An application uses a data output stream to write data that can later be read by a data input stream.DataInputStream is not necessarily safe for multithreaded access.Thread safety is optional and is the responsibility of users of methods in this class."},
{"description": "The DataHandler class provides a consistent interface to data available in many different sources and formats.It manages simple stream to string conversions and related operations using DataContentHandlers.It provides access to commands that can operate on the data.The commands are found using a CommandMap.DataHandler and the Transferable Interface DataHandler implements the Transferable interface so that data can be used in AWT data transfer operations, such as cut and paste and drag and drop.The implementation of the Transferable interface relies on the availability of an installed DataContentHandler object corresponding to the MIME type of the data represented in the specific instance of the DataHandler.The DataHandler keeps track of the current CommandMap that it uses to service requests for commands (getCommand, getAllCommands, getPreferredCommands).Each instance of a DataHandler may have a CommandMap associated with it using the setCommandMap method.If a CommandMap was not set, DataHandler calls the getDefaultCommandMap method in CommandMap and uses the value it returns.The current DataHandler implementation creates a private instance of URLDataSource when it is constructed with a URL."},
{"description": "An exception thrown as a DataTruncation exception (on writes) or reported as a DataTruncation warning (on reads) when a data values is unexpectedly truncated for reasons other than its having exceeded MaxFieldSize.The SQLstate for a DataTruncation during read is 01004.The SQLstate for a DataTruncation during write is 22001."},
{"description": "A datagram channel is created by invoking one of the open methods of this class.It is not possible to create a channel for an arbitrary, pre-existing datagram socket.A datagram channel need not be connected in order for the send and receive methods to be used.A datagram channel may be connected, by invoking its connect method, in order to avoid the overhead of the security checks are otherwise performed as part of every send and receive operation.A datagram channel must be connected in order to use the read and write methods, since those methods do not accept or return socket addresses.Whether or not a datagram channel is connected may be determined by invoking its isConnected method.Socket options are configured using the setOption method.A datagram channel to an Internet Protocol socket supports the following options: Option Name Description SO_SNDBUFThe size of the socket send buffer SO_RCVBUFThe size of the socket receive buffer SO_REUSEADDR Re-use address SO_BROADCAST Allow transmission of broadcast datagrams IP_TOS The Type of Service (ToS) octet in the Internet Protocol (IP) headerThe time-to-live for Internet Protocol (IP) multicast datagrams IP_MULTICAST_LOOP Loopback forDatagram channels are safe for use by multiple concurrent threads.They support concurrent reading and writing, though at most one thread may be reading and at most one thread may be writing at any given time."},
{"description": "A DataFlavor provides meta information about data.DataFlavor is typically used to access data on the clipboard, or during a drag and drop operation.An instance of DataFlavor encapsulates a content type as defined in RFC 2045 and RFC 2046.A content type is typically referred to as a MIME type.A content type consists of a media type (referred to as the primary type), a subtype, and optional parameters.The JRE data transfer implementation interprets the parameter \"class\" of a MIME type as a representation class.The representation class reflects the class of the object being transferred.In other words, the representation class is the type of object returned by Transferable.getTransferData(java.awt.datatransfer.For example, the MIME type of imageFlavor is \"image/x-java-image;class=java.awt.Image\", the primary type is image, the subtype is x-java-image, and the representation class is java.awt.Image.When getTransferData is invoked with a DataFlavor of imageFlavor, an instance of java.awt.Image is returned.It's important to note that DataFlavor does no error checking against the representation class.It is up to consumers of DataFlavor, such as Transferable, to honor the representation class.Note, if you do not specify a representation class when creating a DataFlavor, the default representation class is used.Also, DataFlavor instances with the \"text\" primary MIME type may have a \"charset\" parameter.Equality of DataFlavors is determined by the primary type, subtype, and representation class.When determining equality, any optional parameters are ignored.For example, the following produces two DataFlavors that are considered identical: DataFlavor flavor1 = new DataFlavor(Object.class, \"X-test/test; class=<java.lang.As such, asking a Transferable for either DataFlavor returns the same results."},
{"description": "This interface defines a factory for DataContentHandlers.An implementation of this interface should map a MIME type into an instance of DataContentHandler.The design pattern for classes implementing this interface is the same as for the ContentHandler mechanism used in java.net.URL."},
{"description": "The DataContentHandler interface is implemented by objects that can be used to extend the capabilities of the DataHandler's implementation of the Transferable interface.Through DataContentHandlers the framework can be extended to convert streams in to objects, and to write objects to streams.Applications don't generally call the methods in DataContentHandlers directly.Instead, an application calls the equivalent methods in DataHandler.The DataHandler will attempt to find an appropriate DataContentHandler that corresponds to its MIME type using the current DataContentHandlerFactory.The DataHandler then calls through to the methods in the DataContentHandler."},
{"description": "This class extends DataBuffer and stores data internally as shorts.Values stored in the short array(s) of this DataBuffer are treated as unsigned values.Note that some implementations may function more efficiently if they can maintain control over how the data for an image is stored.For example, optimizations such as caching an image in video memory require that the implementation track all modifications to that data.Other implementations may operate better if they can store the data in locations other than a Java array.To maintain optimum compatibility with various optimizations it is best to avoid constructors and methods which expose the underlying storage as a Java array as noted below in the documentation for those methods."},
{"description": "This class represents a datagram packet.Datagram packets are used to implement a connectionless packet delivery service.Each message is routed from one machine to another based solely on information contained within that packet.Multiple packets sent from one machine to another might be routed differently, and might arrive in any order."},
{"description": "This class extends DataBuffer and stores data internally as shorts.Note that some implementations may function more efficiently if they can maintain control over how the data for an image is stored.For example, optimizations such as caching an image in video memory require that the implementation track all modifications to that data.Other implementations may operate better if they can store the data in locations other than a Java array.To maintain optimum compatibility with various optimizations it is best to avoid constructors and methods which expose the underlying storage as a Java array as noted below in the documentation for those methods."},
{"description": "This class extends DataBuffer and stores data internally as integers.Note that some implementations may function more efficiently if they can maintain control over how the data for an image is stored.For example, optimizations such as caching an image in video memory require that the implementation track all modifications to that data.Other implementations may operate better if they can store the data in locations other than a Java array.To maintain optimum compatibility with various optimizations it is best to avoid constructors and methods which expose the underlying storage as a Java array as noted below in the documentation for those methods."},
{"description": "This class extends DataBuffer and stores data internally in float form.Note that some implementations may function more efficiently if they can maintain control over how the data for an image is stored.For example, optimizations such as caching an image in video memory require that the implementation track all modifications to that data.Other implementations may operate better if they can store the data in locations other than a Java array.To maintain optimum compatibility with various optimizations it is best to avoid constructors and methods which expose the underlying storage as a Java array as noted below in the documentation for those methods."},
{"description": "This class extends DataBuffer and stores data internally in double form.Note that some implementations may function more efficiently if they can maintain control over how the data for an image is stored.For example, optimizations such as caching an image in video memory require that the implementation track all modifications to that data.Other implementations may operate better if they can store the data in locations other than a Java array.To maintain optimum compatibility with various optimizations it is best to avoid constructors and methods which expose the underlying storage as a Java array as noted below in the documentation for those methods."},
{"description": "This class extends DataBuffer and stores data internally as bytes.Values stored in the byte array(s) of this DataBuffer are treated as unsigned values.Note that some implementations may function more efficiently if they can maintain control over how the data for an image is stored.For example, optimizations such as caching an image in video memory require that the implementation track all modifications to that data.Other implementations may operate better if they can store the data in locations other than a Java array.To maintain optimum compatibility with various optimizations it is best to avoid constructors and methods which expose the underlying storage as a Java array, as noted below in the documentation for those methods."},
{"description": "This class exists to wrap one or more data arrays.Each data array in the DataBuffer is referred to as a bank.Accessor methods for getting and setting elements of the DataBuffer's banks exist with and without a bank specifier.The methods without a bank specifier use the default 0th bank.The DataBuffer can optionally take an offset per bank, so that data in an existing array can be used even if the interesting data doesn't start at array location zero.The size field specifies how much of the data array is available for use.+ offset for a given bank should never be greater than the length of the associated data array.The data type of a data buffer indicates the type of the data array(s) and may also indicate additional semantics, e.g. storing unsigned 8-bit data in elements of a byte array.The data type may be TYPE_UNDEFINED or one of the types defined below.Other types may be added in the future.Generally, an object of class DataBuffer will be cast down to one of its data type specific subclasses to access data type specific methods for improved performance.API image classes use TYPE_BYTE, TYPE_USHORT, TYPE_INT, TYPE_SHORT, TYPE_FLOAT, and TYPE_DOUBLE DataBuffers to store image data."},
{"description": "Exception that represents a failure in a JAXB operation.This exception differs from JAXBException in that this is an unchecked exception, while JAXBException is a checked exception."},
{"description": "This interface is implemented by driver vendors to let users know the capabilities of a Database Management System (DBMS) in combination with the driver based on JDBC\u2122 technology (\"JDBC driver\") that is used with it.Different relational DBMSs often support different features, implement features in different ways, and use different data types.In addition, a driver may implement a feature on top of what the DBMS offers.Information returned by methods in this interface applies to the capabilities of a particular driver and a particular DBMS working together.Note that as used in this documentation, the term \"database\" is used generically to refer to both the driver and DBMS.A user for this interface is commonly a tool that needs to discover how to deal with the underlying DBMS.This is especially true for applications that are intended to be used with more than one DBMS.For example, a tool might use the method getTypeInfo to find out what data types can be used in a CREATE TABLE statement.Or a user might call the method supportsCorrelatedSubqueries to see if it is possible to use a correlated subquery or supportsBatchUpdates to see if it is possible to use batch updates.Regular ResultSet methods, such as getString and getInt, can be used to retrieve the data from these ResultSet objects.If a given form of metadata is not available, an empty ResultSet will be returned.Additional columns beyond the columns defined to be returned by the ResultSet object for a given method can be defined by the JDBC driver vendor and must be accessed by their column label.Some DatabaseMetaData methods take arguments that are String patterns.These arguments all have names such as fooPattern.Within a pattern String, \"%\" means match any substring of 0 or more characters, and \"_\" means match any one character.Only metadata entries matching the search pattern are returned.If a search pattern argument is set to null, that argument's criterion will be dropped from the search."},
{"description": "This exception is raised if an ORB cannot convert the representation of data as marshaled into its native representation or vice-versa.For example, DATA_CONVERSION can be raised if wide character codeset conversion fails, or if an ORB cannot convert floating point values between different representations.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception.See the section meaning of minor codes to see the minor codes for this exception."},
{"description": "An abstract value type that is meant to be used by the ORB, not the user.Semantically it is treated as a custom value type's implicit base class, although the custom valuetype does not actually inherit it in IDL.The implementer of a custom value type shall provide an implementation of the CustomMarshal operations.The manner in which this is done is specified in the IDL to Java langauge mapping.Each custom marshaled value type shall have its own implementation."},
{"description": "An extension of ValueBase that is implemented by custom value types."},
{"description": "A customizer class provides a complete custom GUI for customizing a target Java Bean.Each customizer should inherit from the java.awt.Component class so it can be instantiated inside an AWT dialog or panel.Each customizer should have a null constructor."},
{"description": "A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other.A CyclicBarrier supports an optional Runnable command that is run once per barrier point, after the last thread in the party arrives, but before any threads are released.This barrier action is useful for updating shared-state before any of the parties continue.Sample usage: Here is an example of using a barrier in a parallel decomposition design: class Solver { final int N; final float[][] data; final CyclicBarrier barrier; class Worker implements Runnable { int myRow; Worker(int row) { myRow = row; } public void run() {new ArrayList<Thread>(N); for (int i = 0; i < N; i++) { Thread thread = new Thread(new Worker(i)); threads.add(thread); thread.start(); } // wait until done for (Thread thread : threads) thread.join(); } } Here, each worker thread processes a row of the matrix then waits at the barrier until all rows have been processed.When all rows are processed the supplied Runnable barrier action is executed and merges the rows.If the barrier action does not rely on the parties being suspended when it is executed, then any of the threads in the party could execute that action when it is released.To facilitate this, each invocation of await() returns the arrival index of that thread at the barrier.You can then choose which thread should execute the barrier action, for example:The CyclicBarrier uses an all-or-none breakage model for failed synchronization attempts: If a thread leaves a barrier point prematurely because of interruption, failure, or timeout, all other threads waiting at that barrier point will also leave abnormally via BrokenBarrierException (or InterruptedException if they too were interrupted at about the same time).Actions in a thread prior to calling await() happen-before actions that are part of the barrier action, which in turn happen-before actions following a successful return from the corresponding await() in other threads."},
{"description": "The PortableServer::Current interface, derived from CORBA::Current, provides method implementations with access to the identity of the object on which the method was invoked.The Current interface is provided to support servants that implement multiple objects, but can be used within the context of POA-dispatched method invocations on any servant.To provide location transparency, ORBs are required to support use of Current in the context of both locally and remotely invoked operations.An instance of Current can be obtained by the application by issuing the CORBA::ORB::resolve_initial_references(\"POACurrent\") operation.Thereafter, it can be used within the context of a method dispatched by the POA to obtain the POA and ObjectId that identify the object on which that operation was invoked."},
{"description": "Portable Interceptors Current (also known as PICurrent) is merely a slot table, the slots of which are used by each service to transfer their context data between their context and the request's or reply's service context.Each service which wishes to use PICurrent reserves a slot or slots at initialization time and uses those slots during the processing of requests and replies.Before an invocation is made, PICurrent is obtained via a call to ORB.resolve_initial_references( \"PICurrent\" ).From within the interception points, the data on PICurrent that has moved from the thread scope to the request scope is available via the get_slot operation on the RequestInfo object.A PICurrent can still be obtained via resolve_initial_references, but that is the Interceptor's thread scope PICurrent."},
{"description": "Portable Interceptors Current (also known as PICurrent) is merely a slot table, the slots of which are used by each service to transfer their context data between their context and the request's or reply's service context.Each service which wishes to use PICurrent reserves a slot or slots at initialization time and uses those slots during the processing of requests and replies.Before an invocation is made, PICurrent is obtained via a call to ORB.resolve_initial_references( \"PICurrent\" ).From within the interception points, the data on PICurrent that has moved from the thread scope to the request scope is available via the get_slot operation on the RequestInfo object.A PICurrent can still be obtained via resolve_initial_references, but that is the Interceptor's thread scope PICurrent."},
{"description": "The PortableServer::Current interface, derived from CORBA::Current, provides method implementations with access to the identity of the object on which the method was invoked.The Current interface is provided to support servants that implement multiple objects, but can be used within the context of POA-dispatched method invocations on any servant.To provide location transparency, ORBs are required to support use of Current in the context of both locally and remotely invoked operations.An instance of Current can be obtained by the application by issuing the CORBA::ORB::resolve_initial_references(\"POACurrent\") operation.Thereafter, it can be used within the context of a method dispatched by the POA to obtain the POA and ObjectId that identify the object on which that operation was invoked."},
{"description": "Portable Interceptors Current (also known as PICurrent) is merely a slot table, the slots of which are used by each service to transfer their context data between their context and the request's or reply's service context.Each service which wishes to use PICurrent reserves a slot or slots at initialization time and uses those slots during the processing of requests and replies.Before an invocation is made, PICurrent is obtained via a call to ORB.resolve_initial_references( \"PICurrent\" ).From within the interception points, the data on PICurrent that has moved from the thread scope to the request scope is available via the get_slot operation on the RequestInfo object.A PICurrent can still be obtained via resolve_initial_references, but that is the Interceptor's thread scope PICurrent."},
{"description": "The PortableServer::Current interface, derived from CORBA::Current, provides method implementations with access to the identity of the object on which the method was invoked.The Current interface is provided to support servants that implement multiple objects, but can be used within the context of POA-dispatched method invocations on any servant.To provide location transparency, ORBs are required to support use of Current in the context of both locally and remotely invoked operations.An instance of Current can be obtained by the application by issuing the CORBA::ORB::resolve_initial_references(\"POACurrent\") operation.Thereafter, it can be used within the context of a method dispatched by the POA to obtain the POA and ObjectId that identify the object on which that operation was invoked."},
{"description": "The primary purpose of this interface is to group and provide type safety for all Data subtypes."},
{"description": "An abstract class for service providers that provide localized currency symbols and display names for the Currency class.Note that currency symbols are considered names when determining behaviors described in the LocaleServiceProvider specification."},
{"description": "Interfaces derived from the Current interface enable ORB and CORBA services to provide access to information (context) associated with the thread of execution in which they are running.This information is accessed in a structured manner using interfaces derived from the Current interface defined in the CORBA module.Each ORB or CORBA service that needs its own context derives an interface from the CORBA module's Current.Users of the service can obtain an instance of the appropriate Current interface by invoking ORB::resolve_initial_references."},
{"description": "Currencies are identified by their ISO 4217 currency codes.The class is designed so that there's never more than one Currency instance for any given currency.Therefore, there's no public constructor.You obtain a Currency instance using the getInstance methods.Users can supersede the Java runtime currency data by means of the system property java.util.currency.data.If this system property is defined then its value is the location of a properties file, the contents of which are key/value pairs of the ISO 3166 country codes and the ISO 4217 currency data respectively.The value part consists of three ISO 4217 values of a currency, i.e., an alphabetic code, a numeric code, and a minor unit.Those three ISO 4217 values are separated by commas.The lines which start with '#'s are considered comment lines.An optional UTC timestamp may be specified per currency entry if users need to specify a cutover date indicating when the new data comes into effect.The timestamp is appended to the end of the currency properties and uses a comma as a separator.If a UTC datestamp is present and valid, the JRE will only use the new currency properties if the current UTC date is later than the date specified at class loading time.The format of the timestamp must be of ISO 8601 format : 'yyyy-MM-dd'T'HH:mm:ss'.JPZ,999,0 will supersede the currency data for Japan.#Sample currency properties with cutover date JP=JPZ,999,0,2014-01-01T00:00:00 will supersede the currency data for Japan if Currency class is loaded after 1st January 2014 00:00:00 GMT.Where syntactically malformed entries are encountered, the entry is ignored and the remainder of entries in file are processed.For instances where duplicate country code entries exist, the behavior of the Currency information for that Currency is undefined and the remainder of entries in file are processed."},
{"description": "A flag that can be used as the second parameter to the method Context.get_values to restrict the search scope.When this flag is used, it restricts the search for context values to this particular Context object or to the scope specified in the first parameter to Context.get_values.\", CTX_RESTRICT_SCOPE.value, \"id*\");"},
{"description": "Definitions to be used as a key on AttributeSet's that might hold CSS attributes.Since this is a closed set (i.e. defined exactly by the specification), it is final and cannot be extended."},
{"description": "The CubicCurve2D class defines a cubic parametric curve segment in (x,y) coordinate space.This class is only the abstract superclass for all objects which store a 2D cubic curve segment.The actual storage representation of the coordinates is left to the subclass."},
{"description": "The HTML View implementations use CSS attributes to determine how they will render.This also defines methods to map between CSS/HTML/StyleConstants.Any shorthand properties, such as font, are mapped to the intrinsic properties.The following describes the CSS properties that are supported by the rendering engine: font-family font-style font-size (supports relative units) font-weight font color background-color (with the exception of transparent) background-image background-repeat background-position background text-decoration (with the exception of blink and overline) vertical-align (only sup and super)text-align (justify is treated as center)margin-top margin-right margin-bottom margin-left margin padding-top padding-right padding-bottom padding-left padding border-top-style border-right-style border-bottom-style border-left-style border-style (only supports inset, outset and none) border-top-color border-right-color border-bottom-color border-left-color border-color list-style-image list-style-type list-style-position The following are modeled, but currently not rendered.font-variant background-attachment (background always treated as scroll) word-spacing letter-spacing text-indent text-transform line-height border-top-width(this is used to indicate if a border should be used) border-right-width border-bottom-width border-left-width border-width border-top border-right border-bottom border-left border width height float clear display white-space list-style Note: for the time being we do not fully support relative units, unless noted, so that p { margin-top: 10% } will be treated as if no margin-top was specified."},
{"description": "A selector that defines a set of criteria for selecting CRLs.Classes that implement this interface are often used to specify which CRLs should be retrieved from a CertStore.Unless otherwise specified, the methods defined in this interface are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "This class is an abstraction of certificate revocation lists (CRLs) that have different formats but important common uses.For example, all CRLs share the functionality of listing revoked certificates, and can be queried on whether or not they list a given certificate.Specialized CRL types can be defined by subclassing off of this abstract class."},
{"description": "This exception may be thrown by a LoginModule if it is unable to locate a credential necessary to perform authentication."},
{"description": "The CRLReason enumeration specifies the reason that a certificate is revoked, as defined in RFC 3280:"},
{"description": "This class extends the basic ImageFilter Class to extract a given rectangular region of an existing Image and provide a source for a new image containing just the extracted region.It is meant to be used in conjunction with a FilteredImageSource object to produce cropped versions of existing images."},
{"description": "A ForkJoinTask with a completion action performed when triggered and there are no remaining pending actions.CountedCompleters are in general more robust in the presence of subtask stalls and blockage than are other forms of ForkJoinTasks, but are less intuitive to program.Uses of CountedCompleter are similar to those of other completion based components (such as CompletionHandler) except that multiple pending completions may be necessary to trigger the completion action onCompletion(CountedCompleter), not just one.Unless initialized otherwise, the pending count starts at zero, but may be (atomically) changed using methods setPendingCount(int), addToPendingCount(int), and compareAndSetPendingCount(int, int).Upon invocation of tryComplete(), if the pending action count is nonzero, it is decremented; otherwise, the completion action is performed, and if this completer itself has a completer, the process is continued with its completer.As is the case with related synchronization components such as Phaser and Semaphore, these methods affect only internal counts; they do not establish any further internal bookkeeping.In particular, the identities of pending tasks are not maintained.As illustrated below, you can create subclasses that do record some or all pending tasks or their results when needed.As illustrated below, utility methods supporting customization of completion traversals are also provided.However, because CountedCompleters provide only basic synchronization mechanisms, it may be useful to create further abstract subclasses that maintain linkages, fields, and additional support methods appropriate for a set of related usages.A concrete CountedCompleter class must define method compute(), that should in most cases (as illustrated below), invoke tryComplete() once before returning.The class may also optionally override method onCompletion(CountedCompleter) to perform an action upon normal completion, and method onExceptionalCompletion(Throwable, CountedCompleter) to perform an action upon any exception.CountedCompleters most often do not bear results, in which case they are normally declared as CountedCompleter<Void>, and will always return null as a result value.In other cases, you should override methodIn general, this method should return the value of a field (or a function of one or more fields) of the CountedCompleter object that holds the result upon completion.It is possible, but rarely applicable, to override this method to maintain other objects or fields holding result data.A CountedCompleter that does not itself have a completer (i.e., one for which getCompleter() returns null) can be used as a regular ForkJoinTask with this added functionality.However, any completer that in turn has another completer serves only as an internal helper for other computations, so its own task status (as reported in methods such as ForkJoinTask.isDone()) is arbitrary; this status changes only upon explicit invocations of complete(T), ForkJoinTask.cancel(boolean)Upon any exceptional completion, the exception may be relayed to a task's completer (and its completer, and so on), if one exists and it has not otherwise already completed.Similarly, cancelling an internal CountedCompleter has only a local effect on that completer, so is not often useful.CountedCompleters may be arranged in trees similar to those often used with RecursiveActions, although the constructions involved in setting them up typically vary.Here, the completer of each task is its parent in the computation tree.Even though they entail a bit more bookkeeping, CountedCompleters may be better choices when applying a possibly time-consuming operation (that cannot be further subdivided) to each element of an array or collection; especially when the operation takes a significantly different amount of time to complete for some elements than others, either because of intrinsic variation (for example I/O) or auxiliary effects such as garbage collection.Because CountedCompleters provide their own continuations, other threads need not block waiting to perform them.For example, here is an initial version of a class that uses divide-by-two recursive decomposition to divide work into single pieces (leaf tasks).Even when work is split into individual calls, tree-based techniques are usually preferable to directly forking leaf tasks, because they reduce inter-thread communication and improve load balancing.In the recursive case, the second of each pair of subtasks to finish triggers completion of its parent (because no result combination is performed, the default no-op implementation of method onCompletion is not overridden).A static utility method sets up the base task and invokes it (here, implicitly using the ForkJoinPool.commonPool()).// left child } else if (hi > lo) op.apply(array[lo]); tryComplete(); } } This design can be improved by noticing that in the recursive case, the task has nothing to do after forking its right task, so can directly invoke its left task before returning.(This is an analog of tail recursion removal.)Also, because the task returns upon executing its left task (rather than falling through to invoke tryComplete) the pending count is set to one:>> 1; setPendingCount(1); // only one pending new ForEach(this, array, op, mid, hi).fork(); // right child new ForEach(this, array, op, lo, mid).compute(); // direct invoke } else { if (hi > lo) op.apply(array[lo]); tryComplete(); } }As a further improvement, notice that the left task need not even exist.Instead of creating a new one, we can iterate using the original task, and add a pending count for each fork.Additionally, because no task in this tree implements an onCompletion(CountedCompleter) method, tryComplete() can be replaced with propagateCompletion().> 1; addToPendingCount(1); new ForEach(this, array, op, mid, h).fork(); // right child h = mid; } if (h > l) op.apply(array[l]); propagateCompletion(); } Additional improvements of such classes might entail precomputing pending counts so that they can be established in constructors, specializing classes for leaf steps, subdividing by say, four, instead of two per iteration, and using an adaptive threshold instead of always subdividing down to single elements.A tree of CountedCompleters can search for a value or property in different parts of a data structure, and report a result in an AtomicReference as soon as one is found.The others can poll the result to avoid unnecessary work.(You could additionally cancel other tasks, but it is usually simpler and more efficient to just let them notice that the result is set and if so skip further processing.)Illustrating again with an array using full partitioning (again, in practice, leaf tasks will almost always process more than one element):quietlyCompleteRoot(); // root task is now joinable break; } } tryComplete(); // normally complete whether or not found } boolean matches(E e) { ... } // return true if found public static <E> E search(E[] array) { return new Searcher<E>(null, array, new AtomicReferencearray.length).invoke(); } } In this example, as well as others in which tasks have no other effects except to compareAndSet a common result, the trailing unconditional invocation of tryComplete could be made conditional (tryComplete();) because no further bookkeeping is required to manage completions once the root task completes.CountedCompleter tasks that combine results of multiple subtasks usually need to access these results in method onCompletion(CountedCompleter).As illustrated in the following class (that performs a simplified form of map-reduce where mappings and reductions are all of type E), one way to do this in divide and conquer designs is to have each subtask record its sibling, so that it can be accessed in method onCompletion.This technique applies to reductions in which the order of combining left and right results does not matter; ordered reductions require explicit left/right designations.Variants of other streamlinings seen in the above examples may also apply.>> 1; MapReducer<E> left = new MapReducer(this, array, mapper, reducer, lo, mid);array, MyMapper<E> mapper, MyReducer<E> reducer) { return new MapReducer<E>(null, array, mapper, reducer, 0,array.length).invoke(); } } Here, method onCompletion takes a form common to many completion designs that combine results.This callback-style method is triggered once per task, in either of the two different contexts in which the pending count is, or becomes, zero: (1) by a task itself, if its pending count is zero upon invocation of tryComplete, or (2) by any of its subtasks when they complete and decrement the pending count to zero.The caller argument distinguishes cases.Most often, when the caller is this, no action is necessary.Otherwise the caller argument can be used (usually via a cast) to supply a value (and/or links to other values) to be combined.Assuming proper use of pending counts, the actions inside onCompletion occur (once) upon completion of a task and its subtasks.No additional synchronization is required within this method to ensure thread safety of accesses to fields of this task or other completed tasks.If using onCompletion to process completions is inapplicable or inconvenient, you can use methods firstComplete() and nextComplete() to create custom traversals.For example, to define a MapReducer that only splits out right-hand tasks in the form of the third ForEach example, the completions must cooperatively reduce along unexhausted subtask links, which can be done as follows: class MapReducer<E> extendst.result = reducer.apply(t.result, s.result); } } public E getRawResult() { return result; } public static <E> E mapReduce(E[] array, MyMapper<E> mapper, MyReducer<E> reducer) { return new MapReducer<E>(null, array, mapper, reducer, 0, array.length, null).invoke(); } } Triggers.Some CountedCompleters are themselves never forked, but instead serve as bits of plumbing in other designs; including those in which the completion of one or more async tasks triggers another async task.For example: class HeaderBuilder extends CountedCompleter<...{ ... } class PacketSender extends CountedCompleter<..."},
{"description": "A counter monitor sends a threshold notification when the value of the counter reaches or exceeds a threshold known as the comparison level.In addition, an offset mechanism enables particular counting intervals to be detected.If the offset value is not zero, whenever the threshold is triggered by the counter value reaching a comparison level, that comparison level is incremented by the offset value.This is regarded as taking place instantaneously, that is, before the count is incremented.Thus, for each level, the threshold triggers an event notification every time the count increases by an interval equal to the offset value.If the counter can wrap around its maximum value, the modulus needs to be specified.The modulus is the value at which the counter is reset to zero.If the counter difference mode is used, the value of the derived gauge is calculated as the difference between the observed counter values for two successive observations.If this difference is negative, the value of the derived gauge is incremented by the value of the modulus.The derived gauge value (V[t]) is calculated using the following method: if (counter[t] - counter[t-GP]) is positive then V[t] =if (counter[t] - counter[t-GP]) is negative then V[t] =This implementation of the counter monitor requires the observed attribute to be of the type integer (Byte, Integer, Short, Long)."},
{"description": "An object that configures how to copy or move a file.Objects of this type may be used with the Files.copy(Path,Path,CopyOption...), Files.copy(InputStream,Path,CopyOption...) and Files.move(Path,Path,CopyOption...) methods to configure how a file is copied or moved.The StandardCopyOption enumeration type defines the standard options."},
{"description": "A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.A CountDownLatch is initialized with a given count.The await methods block until the current count reaches zero due to invocations of the countDown() method, after which all waiting threads are released and any subsequent invocations of await return immediately.This is a one-shot phenomenon -- the count cannot be reset.If you need a version that resets the count, consider using a CyclicBarrier.A CountDownLatch is a versatile synchronization tool and can be used for a number of purposes.A CountDownLatch initialized with a count of one serves as a simple on/off latch, or gate: all threads invoking await wait at the gate until it is opened by a thread invoking countDown().A CountDownLatch initialized to N can be used to make one thread wait until N threads have completed some action, or some action has been completed N times.A useful property of a CountDownLatch is that it doesn't require that threads calling countDown wait for the count to reach zero before proceeding, it simply prevents any thread from proceeding past an await until all threads could pass.: Here is a pair of classes in which a group of worker threads use two countdown latches: The first is a start signal that prevents any worker from proceeding until the driver is ready for them to proceed; The second is a completion signal that allows the driver to wait until all workers have completed.; // let all threads proceed doSomethingElse(); doneSignal.await();// wait for all to finish } } class Worker implements Runnable { private final CountDownLatch startSignal; private final CountDownLatch doneSignal; Worker(CountDownLatch startSignal, CountDownLatch doneSignal) { this.startSignal = startSignal; this.doneSignal = doneSignal; } public void run() { try { startSignal.await();Another typical usage would be to divide a problem into N parts, describe each part with a Runnable that executes that portion and counts down on the latch, and queue all the Runnables to an Executor.When all sub-parts are complete, the coordinating thread will be able to pass through await.(When threads must repeatedly count down in this way, instead use a CyclicBarrier.) class Driver2 { // ... void main() throws InterruptedException { CountDownLatch doneSignal = new CountDownLatch(N);; doneSignal.await(); // wait for all to finish } } class WorkerRunnable implements Runnable { private final CountDownLatch doneSignal; private final int i; WorkerRunnable(CountDownLatch doneSignal, int i) { this.doneSignal = doneSignal; this.i = i; } public void run() { try { doWork(i); doneSignal.countDown(); } catch (InterruptedException ex) {} // return; } void doWork() { ... } } Memory consistency effects: Until the count reaches zero, actions in a thread prior to calling countDown() happen-before actions following a successful return from a corresponding await() in another thread."},
{"description": "This exception is thrown by LoginModules when they determine that a Credential has expired.For example, a LoginModule authenticating a user in its login method may determine that the user's password, although entered correctly, has expired.In this case the LoginModule throws this exception to notify the application.The application can then take the appropriate steps to assist the user in updating the password."},
{"description": "A class that can be used to compute the CRC-32 of a data stream.Passing a null argument to a method in this class will cause a NullPointerException to be thrown."},
{"description": "A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.This is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don't want to synchronize traversals, yet need to preclude interference among concurrent threads.The \"snapshot\" style iterator method uses a reference to the state of the array at the point that the iterator was created.This array never changes during the lifetime of the iterator, so interference is impossible and the iterator is guaranteed not to throw ConcurrentModificationException.The iterator will not reflect additions, removals, or changes to the list since the iterator was created.Element-changing operations on iterators themselves (remove, set, and add) are not supported.These methods throw UnsupportedOperationException.All elements are permitted, including null.This class is a member of the Java Collections Framework."},
{"description": "A Set that uses an internal CopyOnWriteArrayList for all of its operations.Thus, it shares the same basic properties: It is best suited for applications in which set sizes generally stay small, read-only operations vastly outnumber mutative operations, and you need to prevent interference among threads during traversal.Mutative operations (add, set, remove, etc.) are expensive since they usually entail copying the entire underlying array.Iterators do not support the mutative remove operation.Traversal via iterators is fast and cannot encounter interference from other threads.Iterators rely on unchanging snapshots of the array at the time the iterators were constructed.The following code sketch uses a copy-on-write set to maintain a set of Handler objects that perform some action upon state updates.{ handlers.add(h); } private long internalState; private synchronized void changeState() { internalState = ...; } public void update() { changeState(); for (Handler handler : handlers) handler.handle(); } } This class is a member of the Java Collections Framework."},
{"description": "Class Copies is an integer valued printing attribute class that specifies the number of copies to be printed.On many devices the supported number of collated copies will be limited by the number of physical output bins on the device, and may be different from the number of uncollated copies which can be supported.The effect of a Copies attribute with a value of n on a multidoc print job (a job with multiple documents) depends on the (perhaps defaulted) value of the MultipleDocumentHandling attribute: SINGLE_DOCUMENT -- The result will be n copies of a single output document comprising all the input docs.The result will be n copies of a single output document comprising all the input docs, and the first impression of each input doc will always start on a new media sheet.The result will be n copies of the first input document, followed by n copies of the second input document, . . .The result will be the first input document, the second input document, . . .the last input document, the group of documents being repeated n times.The integer value gives the IPP integer value.The category name returned by getName() gives the IPP attribute name."},
{"description": "A CookieStore object represents a storage for cookie.CookieManager will call CookieStore.add to save cookies for every incoming HTTP response, and call CookieStore.get to retrieve cookie for every outgoing HTTP request.A CookieStore is responsible for removing HttpCookie instances which have expired."},
{"description": "Class CopiesSupported is a printing attribute class, a set of integers, that gives the supported values for a Copies attribute.It is restricted to a single contiguous range of integers; multiple non-overlapping ranges are not allowed.The CopiesSupported attribute's canonical array form gives the lower and upper bound for the range of copies to be included in an IPP \"copies-supported\" attribute.The category name returned by getName() gives the IPP attribute name."},
{"description": "CookieManager provides a concrete implementation of CookieHandler, which separates the storage of cookies from the policy surrounding accepting and rejecting cookies.A CookieManager is initialized with a CookieStore which manages storage, and a CookiePolicy object, which makes policy decisions on cookie acceptance/rejection.The HTTP cookie management in java.net package looks like: use CookieHandler <-------^ | impl | use CookieManager -------CookiePolicy | use |--------| | use | use | |-------->| impl |Internal in-memory implementation CookieHandler is at the core of cookie management.User can call CookieHandler.setDefault to set a concrete CookieHanlder implementation to be used.CookiePolicy.shouldAccept will be called by CookieManager.put to see whether or not one cookie should be accepted and put into cookie store.User can use any of three pre-defined CookiePolicy, namely ACCEPT_ALL, ACCEPT_NONE and ACCEPT_ORIGINAL_SERVER, or user can define his own CookiePolicy implementation and tell CookieManager to use it.CookieStore is the place where any accepted HTTP cookie is stored in.If not specified when created, a CookieManager instance will use an internal in-memory implementation.Or user can implements one and tell CookieManager to use it.Currently, only CookieStore.add(URI, HttpCookie) and CookieStore.get(URI) are used by CookieManager.Others are for completeness and might be needed by a more sophisticated CookieStore implementation, e.g. a NetscapeCookieSotre.There're various ways user can hook up his own HTTP cookie management behavior, e.g. Use CookieHandler.setDefault to set a brand new CookieHandler implementationLet CookieManager be the default CookieHandler implementation, but implement user's own CookieStore and CookiePolicy and tell default CookieManager to use them: // this should be done at the beginning of an HTTP session; Let CookieManager be the default CookieHandler implementation, but use customized CookiePolicy: // this should be done at the beginning of an HTTP session; // this can be done at any point of an HTTP session ((CookieManager)CookieHandler.getDefault()).setCookiePolicy(new MyCookiePolicy()); The implementation conforms to RFC 2965, section 3.3."},
{"description": "The native type PortableServer::ServantLocator::Cookie is mapped to java.lang.Object.A CookieHolder class is provided for passing the Cookie type as an out parameter.The CookieHolder class follows exactly the same pattern as the other holder classes for basic types."},
{"description": "A CookieHandler object provides a callback mechanism to hook up a HTTP state management policy implementation into the HTTP protocol handler.The HTTP state management mechanism specifies a way to create a stateful session with HTTP requests and responses.A system-wide CookieHandler that to used by the HTTP protocol handler can be registered by doing a CookieHandler.setDefault(CookieHandler).The currently registered CookieHandler can be retrieved by calling CookieHandler.getDefault()."},
{"description": "This class implements a convolution from the source to the destination.Convolution using a convolution kernel is a spatial operation that computes the output pixel from an input pixel by multiplying the kernel with the surround of the input pixel.This allows the output pixel to be affected by the immediate neighborhood in a way that can be mathematically specified with a kernel.This class operates with BufferedImage data in which color components are premultiplied with the alpha component.If the Source BufferedImage has an alpha component, and the color components are not premultiplied with the alpha component, then the data are premultiplied before being convolved.If the Destination has color components which are not premultiplied, then alpha is divided out before storing into the Destination (if alpha is 0, the color components are set to 0).If the Destination has no alpha component, then the resulting alpha is discarded after first dividing it out of the color components.Rasters are treated as having no alpha channel.If the above treatment of the alpha channel in BufferedImages is not desired, it may be avoided by getting the Raster of a source BufferedImage and using the filter method of this class which works with Rasters.If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used when color conversion is required.Note that the Source and the Destination may not be the same object."},
{"description": "The ControllerEventListener interface should be implemented by classes whose instances need to be notified when a Sequencer has processed a requested type of MIDI control-change event.To register a ControllerEventListener object to receive such notifications, invoke the addControllerEventListener method of Sequencer, specifying the types of MIDI controllers about which you are interested in getting control-change notifications."},
{"description": "This abstract class represents a factory for creating LDAPv3 controls.LDAPv3 controls are defined in RFC 2251.When a service provider receives a response control, it uses control factories to return the specific/appropriate control class implementation."},
{"description": "Lines often have a set of controls, such as gain and pan, that affect the audio signal passing through the line.Java Sound's Line objects let you obtain a particular control object by passing its class as the argument to a getControl method.Because the various types of controls have different purposes and features, all of their functionality is accessed from the subclasses that define each kind of control."},
{"description": "This interface represents an LDAPv3 control as defined in RFC 2251.The LDAPv3 protocol uses controls to send and receive additional data to affect the behavior of predefined operations.Controls can be sent along with any LDAP operation to the server.These are referred to as request controls.For example, a \"sort\" control can be sent with an LDAP search operation to request that the results be returned in a particular order.Solicited and unsolicited controls can also be returned with responses from the server.Such controls are referred to as response controls.For example, an LDAP server might define a special control to return change notifications.This interface is used to represent both request and response controls."},
{"description": "ContextualRenderedImageFactory provides an interface for the functionality that may differ between instances of RenderableImageOp.Thus different operations on RenderableImages may be performed by a single class such as RenderedImageOp through the use of multiple instances of ContextualRenderedImageFactory.All operations that are to be used in a rendering-independent chain must implement ContextualRenderedImageFactory.Classes that implement this interface must provide a constructor with no arguments."},
{"description": "An instance of the Type class represents the type of the control.Static instances are provided for the common types."},
{"description": "This exception is thrown when attempting to destroy a context that is not empty.If the program wants to handle this exception in particular, it should catch ContextNotEmptyException explicitly before attempting to catch NamingException.For example, after catching ContextNotEmptyException, the program might try to remove the contents of the context before reattempting the destroy.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "An object used in Request operations to specify the context object in which context strings must be resolved before being sent along with the request invocation.A Context object contains a list of properties in the form of NamedValue objects.These properties represent information about the client, the environment, or the circumstances of a request and generally are properties that might be inconvenient to pass as parameters.A Context object is created by first calling the ORB method get_default_context and then calling the method create_child on the default context.Each property in a Context object is represented by a NamedValue object.The property name is contained in the NamedValue object's name field, and the value associated with the name is contained in the Any object that was assigned to the NamedValue object's value field.Context properties can represent a portion of a client's or application's environment that is meant to be propagated to (and made implicitly part of) a server's environment.(Examples might be a window identifier or user preference information).Once a server has been invoked (that is, after the properties are propagated), the server may query its Context object for these properties using the method get_values.When an operation declaration includes a context clause, the stubs and skeletons will have an additional argument added for the context.When an operation invocation occurs, the ORB causes the properties that were named in the operation definition in IDL and that are present in the client's Context object to be provided in the Context object parameter to the invoked method.Context property names (which are strings) typically have the form of an OMG IDL identifier or a series of OMG IDL identifiers separated by periods.A context property name pattern is either a property name or a property name followed by a single \"*\".A property name pattern without a trailing \"*\" is said to match only itself.A property name pattern of the form \"<name>*\" matches any property name that starts with <name> and continues with zero or more additional characters.Property name patterns are used in the context clause of an operation definition and as a parameter for the method Context.get_values.Context objects may be \"chained\" together to achieve a particular defaulting behavior.A Context object created with the method create_child will be chained to its parent (the Context object that created it), and that means that the parent will be searched after the child in a search for property names.Properties defined in a particular Context object effectively override those properties in the next higher level.The scope used in a search for properties may be restricted by specifying a starting scope and by using the flag CTX_RESTRICT_SCOPEA Context object may be named for purposes of specifying a starting search scope."},
{"description": "An object containing a modifiable list of String objects that represent property names.This class is used in Request operations to describe the contexts that need to be resolved and sent with the invocation.(A context is resolved by giving a property name and getting back the value associated with it.)This is done by calling the Context method get_values and supplying a string from a ContextList object as the third parameter.The method get_values returns an NVList object containing the NamedValue objects that hold the value(s) identified by the given string.A ContextList object is created by the ORB, as illustrated here: ORB orb = ORB.init(args, null); org.omg.CORBA.ContextList ctxList = orb.create_context_list(); The variable ctxList represents an empty ContextList object.Strings are added to the list with the method add, accessed with the method item, and removed with the method remove."},
{"description": "This interface represents a naming context, which consists of a set of name-to-object bindings.It contains methods for examining and updating these bindings.Names Each name passed as an argument to a Context method is relative to that context.The empty name is used to name the context itself.Most of the methods have overloaded versions with one taking a Name parameter and one taking a String.These overloaded versions are equivalent in that if the Name and String parameters are just different representations of the same name, then the overloaded versions of the same methods behave the same.In the method descriptions below, only one version is fully documented.The second version instead has a link to the first: the same documentation applies to both.For systems that support federation, String name arguments to Context methods are composite names.Name arguments that are instances of CompositeName are treated as composite names, while Name arguments that are not instances of CompositeName are treated as compound names (which might be instances of CompoundName or other implementations of compound names).This allows the results of NameParser.parse() to be used as arguments to the Context methods.Prior to JNDI 1.2, all name arguments were treated as composite names.Furthermore, for systems that support federation, all names returned in a NamingEnumeration from list() and listBindings() are composite names represented as strings.For systems that do not support federation, the name arguments (in either Name or String forms) and the names returned in NamingEnumeration may be names in their own namespace rather than names in a composite namespace, at the discretion of the service provider.Exceptions All the methods in this interface can throw a NamingException or any of its subclasses.A Context instance is not guaranteed to be synchronized against concurrent access by multiple threads.Threads that need to access a single Context instance concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating a different Context instance need not synchronize.Note that the lookup method, when passed an empty name, will return a new Context instance representing the same naming context.For purposes of concurrency control, a Context operation that returns a NamingEnumeration is not considered to have completed while the enumeration is still in use, or while any referrals generated by that operation are still being followed.Parameters A Name parameter passed to any method of the Context interface or one of its subinterfaces will not be modified by the service provider.The service provider may keep a reference to it for the duration of the operation, including any enumeration of the method's results and the processing of any referrals generated.The caller should not modify the object during this time.A Name returned by any such method is owned by the caller.The caller may subsequently modify it; the service provider may not.Environment Properties JNDI applications need a way to communicate various preferences and properties that define the environment in which naming and directory services are accessed.For example, a context might require specification of security credentials in order to access the service.These are referred to as the environment of a context.The Context interface provides methods for retrieving and updating this environment.The environment is inherited from the parent context as context methods proceed from one context to the next.Changes to the environment of one context do not directly affect those of other contexts.It is implementation-dependent when environment properties are used and/or verified for validity.For example, some of the security-related properties are used by service providers to \"log in\" to the directory.This login process might occur at the time the context is created, or the first time a method is invoked on the context.When environment properties are added or removed from the context, verifying the validity of the changes is again implementation-dependent.For example, verification of some properties might occur at the time the change is made, or at the time the next operation is performed on the context, or not at all.Any object with a reference to a context may examine that context's environment.Sensitive information such as clear-text passwords should not be stored there unless the implementation is known to protect it.To simplify the task of setting up the environment required by a JNDI application, application components and service providers may be distributed along with resource files.A JNDI resource file is a file in the properties file format (see java.util.Properties), containing a list of key/value pairs.The key is the name of the property (e.g. \"java.naming.factory.object\") and the value is a string in the format defined for that property.Here is an example of a JNDI resource file: java.naming.factory.object=com.sun.jndi.ldap.AttrsToCorba:com.wiz.from.Person java.naming.factory.state=com.sun.jndi.ldap.CorbaToAttrs:com.wiz.from.Person java.naming.factory.control=com.sun.jndi.ldap.ResponseControlFactoryThe JNDI class library reads the resource files and makes the property values freely available.Thus JNDI resource files should be considered to be \"world readable\", and sensitive information such as clear-text passwords should not be stored there.There are two kinds of JNDI resource files: provider and application.Provider Resource Files Each service provider has an optional resource that lists properties specific to that provider.The name of this resource is: [prefix/]jndiprovider.properties where prefix is the package name of the provider's context implementation(s), with each period (\".\") converted to a slash (\"/\").For example, suppose a service provider defines a context implementation with class name com.sun.jndi.ldap.LdapCtx.The provider resource for this provider is named com/sun/jndi/ldap/jndiprovider.properties.If the class is not in a package, the resource's name is simply jndiprovider.properties.Certain methods in the JNDI class library make use of the standard JNDI properties that specify lists of JNDI factories: java.naming.factory.object java.naming.factory.state java.naming.factory.controlThe JNDI library will consult the provider resource file when determining the values of these properties.Properties other than these may be set in the provider resource file at the discretion of the service provider.The service provider's documentation should clearly state which properties are allowed; other properties in the file will be ignored.When an application is deployed, it will generally have several codebase directories and JARs in its classpath.Similarly, when an applet is deployed, it will have a codebase and archives specifying where to find the applet's classes.In addition, if the file java.home/lib/jndi.properties exists and is readable, JNDI treats it as an additional application resource file.(java.home indicates the directory named by the java.home system property.)All of the properties contained in these files are placed into the environment of the initial context.This environment is then inherited by other contexts.For each property found in more than one application resource file, JNDI uses the first value found or, in a few cases where it makes sense to do so, it concatenates all of the values (details are given below).For example, if the \"java.naming.factory.object\" property is found in three jndi.properties resource files, the list of object factories is a concatenation of the property values from all three files.Using this scheme, each deployable component is responsible for listing the factories that it exports.JNDI automatically collects and uses all of these export lists when searching for factory classes.Search Algorithm for Properties When JNDI constructs an initial context, the context's environment is initialized with properties defined in the environment parameter passed to the constructor, the system properties, the applet parameters, and the application resource files.This initial environment is then inherited by other context instances.When the JNDI class library needs to determine the value of a property, it does so by merging the values from the following two sources, in order:The environment of the context being operated on.For each property found in both of these two sources, JNDI determines the property's value as follows.If the property is one of the standard JNDI properties that specify a list of JNDI factories (listed above), the values are concatenated into a single colon-separated list.For other properties, only the first value found is used.When a service provider needs to determine the value of a property, it will generally take that value directly from the environment.A service provider may define provider-specific properties to be placed in its own provider resource file.In that case it should merge values as described in the previous paragraph.In this way, each service provider developer can specify a list of factories to use with that service provider.These can be modified by the application resources specified by the deployer of the application or applet, which in turn can be modified by the user."},
{"description": "The abstract class ContentHandler is the superclass of all classes that read an Object from a URLConnection.An application does not generally call the getContent method in this class directly.Instead, an application calls the getContent method in class URL or in URLConnection.The application's content handler factory (an instance of a class that implements the interface ContentHandlerFactory set up by a call to setContentHandler) is called with a String giving the MIME type of the object being received on the socket.The factory returns an instance of a subclass of ContentHandler, and its getContent method is called to create the object.If no content handler could be found, URLConnection will look for a content handler in a user-defineable set of places.By default it looks in sun.net.www.content, but users can define a vertical-bar delimited set of class prefixes to search through in addition by defining the java.content.handler.pkgs property.The class name must be of the form: {package-prefix}.{major}.{minor}e.g. YoyoDyne.experimental.text.plain If the loading of the content handler class would be performed by a classloader that is outside of the delegation chain of the caller, the JVM will need the RuntimePermission \"getClassLoader\"."},
{"description": "This interface defines a factory for content handlers.An implementation of this interface should map a MIME type into an instance of ContentHandler.This interface is used by the URLStreamHandler class to create a ContentHandler for a MIME type."},
{"description": "A content model is basically a restricted BNF expression.It is restricted in the sense that it must be deterministic.This means that you don't have to represent it as a finite state automaton."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This is the main interface that most SAX applications implement: if the application needs to be informed of basic parsing events, it implements this interface and registers an instance with the SAX parser using the setContentHandler method.The parser uses the instance to report basic document-related events like the start and end of elements and character data.The order of events in this interface is very important, and mirrors the order of information in the document itself.For example, all of an element's content (character data, processing instructions, and/or subelements) will appear, in order, between the startElement event and the corresponding endElement event.This interface is similar to the now-deprecated SAX 1.0 DocumentHandler interface, but it adds support for Namespaces and for reporting skipped entities (in non-validating XML processors).Implementors should note that there is also a ContentHandler class in the java.net package; that means that it's probably a bad idea to do import java.net.*\" is usually a sign of sloppy programming anyway, so the user should consider this a feature rather than a bug."},
{"description": "A FocusTraversalPolicy that determines traversal order based on the order of child Components in a Container.From a particular focus cycle root, the policy makes a pre-order traversal of the Component hierarchy, and traverses a Container's children according to the ordering of the array returned by Container.getComponents().Portions of the hierarchy that are not visible and displayable will not be searched.By default, ContainerOrderFocusTraversalPolicy implicitly transfers focus down-cycle.That is, during normal forward focus traversal, the Component traversed after a focus cycle root will be the focus-cycle-root's default Component to focus.This behavior can be disabled using the setImplicitDownCycleTraversal method.By default, methods of this class will return a Component only if it is visible, displayable, enabled, and focusable.Subclasses can modify this behavior by overriding the accept method.This policy takes into account focus traversal policy providers.When searching for first/last/next/previous Component, if a focus traversal policy provider is encountered, its focus traversal policy is used to perform the search operation."},
{"description": "container object is a component that can contain other AWT components.Components added to a container are tracked in a list.The order of the list will define the components' front-to-back stacking order within the container.If no index is specified when adding a component to a container, it will be added to the end of the list (and hence to the bottom of the stacking order)."},
{"description": "The methods in this class are empty.This class exists as convenience for creating listener objects.(If you implement the ContainerListener interface, you have to define all of the methods in it.This abstract class defines null methods for them all, so you can only have to define methods for events you care about.)When the container's contents change because a component has been added or removed, the relevant method in the listener object is invoked, and the ContainerEvent is passed to it."},
{"description": "Represents an operation that accepts a single input argument and returns no result.Unlike most other functional interfaces, Consumer is expected to operate via side-effects.This is a functional interface whose functional method is accept(Object)."},
{"description": "An annotation on a constructor that shows how the parameters of that constructor correspond to the constructed object's getter methods.} private final int x, y; } The annotation shows that the first parameter of the constructor can be retrieved with the getX() method and the second with the getY() method.Since parameter names are not in general available at runtime, without the annotation there would be no way to know whether the parameters correspond to getX()"},
{"description": "Container events are provided for notification purposes ONLY; The AWT will automatically handle changes to the containers contents internally so that the program works properly regardless of whether the program is receiving these events or not.This low-level event is generated by a container object (such as a Panel) when a component is added to it or removed from it.The event is passed to every ContainerListener or ContainerAdapter object which registered to receive such events using the component's addContainerListener method.(ContainerAdapter objects implement the ContainerListener interface.)Each such listener object gets this ContainerEvent when the event occurs.An unspecified behavior will be caused if the id parameter of any particular ContainerEvent instance is not in the range from CONTAINER_FIRST to CONTAINER_LAST."},
{"description": "The class that is interested in processing a container event either implements this interface (and all the methods it contains) or extends the abstract ContainerAdapter class (overriding only the methods of interest).The listener object created from that class is then registered with a component using the component's addContainerListener method.When the container's contents change because a component has been added or removed, the relevant method in the listener object is invoked, and the ContainerEvent is passed to it.Container events are provided for notification purposes ONLY; The AWT will automatically handle add and remove operations internally so the program works properly regardless of whether the program registers a ContainerListener or not."},
{"description": "Constructor provides information about, and access to, a single constructor for a class.Constructor permits widening conversions to occur when matching the actual parameters to newInstance() with the underlying constructor's formal parameters, but throws an IllegalArgumentException if a narrowing conversion would occur."},
{"description": "A ConstantCallSite is a CallSite whose target is permanent, and can never be changed.An invokedynamic instruction linked to a ConstantCallSite is permanently bound to the call site's target."},
{"description": "This Handler publishes log records to System.err.By default the SimpleFormatter is used to generate brief summaries.By default each ConsoleHandler is initialized using the following LogManager configuration properties where <handler-name> refers to the fully-qualified class name of the handler.If properties are not defined (or have invalid values) then the specified default values are used.<handler-name>.filter specifies the name of a Filter class to use (defaults to no Filter).<handler-name>.encoding the name of the character set encoding to use (defaults to the default platform encoding).For example, the properties for ConsoleHandler would be: java.util.logging.ConsoleHandler.level=INFO java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatterFor a custom handler, e.g. com.foo.MyHandler, the properties would be: com.foo.MyHandler.level=INFO com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter"},
{"description": "An object that implements this interface will typically be registered with a naming service that is based on the Java\u2122 Naming and Directory Interface (JNDI)."},
{"description": "Whether a virtual machine has a console is dependent upon the underlying platform and also upon the manner in which the virtual machine is invoked.If the virtual machine is started from an interactive command line without redirecting the standard input and output streams then its console will exist and will typically be connected to the keyboard and display from which the virtual machine was launched.If the virtual machine is started automatically, for example by a background job scheduler, then it will typically not have a console.If this virtual machine has a console then it is represented by a unique instance of this class which can be obtained by invoking the System.console() method.If no console device is available then an invocation of that method will return null.Read and write operations are synchronized to guarantee the atomic completion of critical operations; therefore invoking methods readLine(), readPassword(), format(), printf() as well as the read, format and write operations on the objects returned by reader() and writer() may block in multithreaded scenarios.Invoking close() on the objects returned by the reader() and the writer() will not close the underlying stream of those objects.The console-read methods return null when the end of the console input stream is reached, for example by typing control-D on Unix or control-Z on Windows.Subsequent read operations will succeed if additional characters are later entered on the console's input device.Unless otherwise specified, passing a null argument to any method in this class will cause a NullPointerException to be thrown.Security note: If an application needs to read a password or other secure data, it should use readPassword() or readPassword(String, Object...) and manually zero the returned character array after processing to minimize the lifetime of sensitive data in memory."},
{"description": "Unchecked exception thrown when an attempt is made to connect a SocketChannel for which a non-blocking connection operation is already in progress."},
{"description": "An object that registers to be notified of events generated by a PooledConnection object.The ConnectionEventListener interface is implemented by a connection pooling component.A connection pooling component will usually be provided by a JDBC driver vendor or another system software vendor.A JDBC driver notifies a ConnectionEventListener object when an application is finished using a pooled connection with which the listener has registered.The notification occurs after the application calls the method close on its representation of a PooledConnection object.A ConnectionEventListener is also notified when a connection error occurs due to the fact that the PooledConnection is unfit for future use---the server has crashed, for example.The listener is notified by the JDBC driver just before the driver throws an SQLException to the application using the PooledConnection object."},
{"description": "An Event object that provides information about the source of a connection-related event.ConnectionEvent objects are generated when an application closes a pooled connection and when an error occurs.The ConnectionEvent object contains two kinds of information: The pooled connection closed by the application In the case of an error event, the SQLException about to be thrown to the application"},
{"description": "SQL statements are executed and results are returned within the context of a connection.A Connection object's database is able to provide information describing its tables, its supported SQL grammar, its stored procedures, the capabilities of this connection, and so on.This information is obtained with the getMetaData method.Note: When configuring a Connection, JDBC applications should use the appropriate Connection method such as setAutoCommit or setTransactionIsolation.Applications should not invoke SQL commands directly to change the connection's configuration when there is a JDBC method available.By default a Connection object is in auto-commit mode, which means that it automatically commits changes after executing each statement.If auto-commit mode has been disabled, the method commit must be called explicitly in order to commit changes; otherwise, database changes will not be saved.A new Connection object created using the JDBC 2.1 core API has an initially empty type map associated with it.A user may enter a custom mapping for a UDT in this type map.When a UDT is retrieved from a data source with the method ResultSet.getObject, the getObject method will check the connection's type map to see if there is an entry for that UDT.If so, the getObject method will map the UDT to the class indicated.If there is no entry, the UDT will be mapped using the standard mapping.A user may create a new type map, which is a java.util.Map object, make an entry in it, and pass it to the java.sql methods that can perform custom mapping.In this case, the method will use the given type map instead of the one associated with the connection.For example, the following code fragment specifies that the SQL type ATHLETES will be mapped to the class Athletes in the Java programming language.The code fragment retrieves the type map for the Connection object con, inserts the entry into it, and then sets the type map with the new entry as the connection's type map."},
{"description": "A ConnectException is thrown if a connection is refused to the remote host for a remote method call."},
{"description": "Signals that an error occurred while attempting to connect a socket to a remote address and port.Typically, the connection was refused remotely (e.g., no process is listening on the remote address/port)."},
{"description": "This class defines the Service Provider Interface (SPI) for the Configuration class.All the abstract methods in this class must be implemented by each service provider who wishes to supply a Configuration implementation.Subclass implementations of this abstract class must provide a public constructor that takes a Configuration.Parameters object as an input parameter.This constructor also must throw an IllegalArgumentException if it does not understand the Configuration."},
{"description": "This exception is thrown when there is a configuration problem.This can arise when installation of a provider was not done correctly, or if there are configuration problems with the server, or if configuration information required to access the provider or service is malformed or missing.For example, a request to use SSL as the security protocol when the service provider software was not configured with the SSL component would cause such an exception.Another example is if the provider requires that a URL be specified as one of the environment properties but the client failed to provide it.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "A Configuration object is responsible for specifying which LoginModules should be used for a particular application, and in what order the LoginModules should be invoked.A login configuration contains the following information.Note that this example only represents the default syntax for the Configuration.Subclass implementations of this class may implement alternative syntaxes and may retrieve the Configuration from any source such as files, databases, or servers.Each entry in the Configuration is indexed via an application name, Name, and contains a list of LoginModules configured for that application.Each LoginModule is specified via its fully qualified class name.Authentication proceeds down the module list in the exact order specified.If an application does not have a specific entry, it defaults to the specific entry for \"other\".The Flag value controls the overall behavior as authentication proceeds down the stack.The following represents a description of the valid values for Flag and their respective semantics: 1) Required - The LoginModule is required to succeed.If it succeeds or fails, authentication still continues to proceed down the LoginModule list.If it succeeds, authentication continues down the LoginModule list.If it fails, control immediately returns to the application (authentication does not proceed down the LoginModule list).If it does succeed, control immediately returns to the application (authentication does not proceed down the LoginModule list).If it fails, authentication continues down the LoginModule list.If it succeeds or fails, authentication still continues to proceed down the LoginModule list.If a Sufficient LoginModule is configured and succeeds, then only the Required and Requisite LoginModules prior to thatIf no Required or Requisite LoginModules are configured for an application, then at least one Sufficient or Optional LoginModule must succeed.ModuleOptions is a space separated list of LoginModule-specific values which are passed directly to the underlying LoginModules.Options are defined by the LoginModule itself, and control the behavior within it.For example, a LoginModule may define options to support debugging/testing capabilities.The correct way to specify options in the Configuration is by using the following key-value pairing: debug=\"true\".The key and value should be separated by an 'equals' symbol, and the value should be surrounded by double quotes.If a String in the form, ${system.property}, occurs in the value, it will be expanded to the value of the system property.Note that there is no limit to the number of options a LoginModule may define.The following represents an example Configuration entry based on the syntax above:Login { com.sun.security.auth.module.UnixLoginModule required; com.sun.security.auth.module.Krb5LoginModule optional useTicketCache=\"true\" ticketCache=\"${user.home}${/}tickets\"; }; This Configuration specifies that an application named, \"Login\", requires users to first authenticate to the com.sun.security.auth.module.UnixLoginModule, which is required to succeed.This helps hide the source of failure.Also note that the LoginModule-specific options, useTicketCache=\"true\" and ticketCache=${user.home}${/}tickets\", are passed to the Krb5LoginModule.These options instruct the Krb5LoginModule to use the ticket cache at the specified location.The system properties, user.home and / (file.separator), are expanded to their respective values.There is only one Configuration object installed in the runtime at any given time.A Configuration object can be installed by calling the setConfiguration method.The installed Configuration object can be obtained by calling the getConfiguration method.If no Configuration object has been installed in the runtime, a call to getConfiguration installs an instance of the default Configuration implementation (a default subclass implementation of this abstract class).The default Configuration implementation can be changed by setting the value of the login.configuration.provider security property to the fully qualified name of the desired Configuration subclass implementation.Application code can directly subclass Configuration to provide a custom implementation.In addition, an instance of a Configuration object can be constructed by invoking one of the getInstance factory methods with a standard type.The default policy type is \"JavaLoginConfig\"."},
{"description": "This represents a marker interface for Configuration parameters."},
{"description": "A ConnectIOException is thrown if an IOException occurs while making a connection to the remote host for a remote method call."},
{"description": "Underlying security services instantiate and pass a ConfirmationCallback to the handle method of a CallbackHandler to ask for YES/NO, OK/CANCEL, YES/NO/CANCEL or other similar confirmations."},
{"description": "The elements of the set are kept sorted according to their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used.This implementation provides expected average log(n) time cost for the contains, add, and remove operations and their variants.Insertion, removal, and access operations safely execute concurrently by multiple threads.Ascending ordered views and their iterators are faster than descending ones.Beware that, unlike in most collections, the size method is not a constant-time operation.Because of the asynchronous nature of these sets, determining the current number of elements requires a traversal of the elements, and so may report inaccurate results if this collection is modified during traversal.For example, an iterator operating concurrently with an addAll operation might view only some of the added elements.This class and its iterators implement all of the optional methods of the Set and Iterator interfaces.Like most other concurrent collection implementations, this class does not permit the use of null elements, because null arguments and return values cannot be reliably distinguished from the absence of elements.This class is a member of the Java Collections Framework."},
{"description": "This exception may be thrown by methods that have detected concurrent modification of an object when such modification is not permissible.For example, it is not generally permissible for one thread to modify a Collection while another thread is iterating over it.In general, the results of the iteration are undefined under these circumstances.Some Iterator implementations (including those of all the general purpose collection implementations provided by the JRE) may choose to throw this exception if this behavior is detected.Iterators that do this are known as fail-fast iterators, as they fail quickly and cleanly, rather that risking arbitrary, non-deterministic behavior at an undetermined time in the future.Note that this exception does not always indicate that an object has been concurrently modified by a different thread.If a single thread issues a sequence of method invocations that violates the contract of an object, the object may throw this exception.For example, if a thread modifies a collection directly while it is iterating over the collection with a fail-fast iterator, the iterator will throw this exception.Note that fail-fast behavior cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast operations throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness: ConcurrentModificationException should be used only to detect bugs."},
{"description": "As with other concurrent collections, actions in a thread prior to placing an object into a ConcurrentMap as a key or value happen-before actions subsequent to the access or removal of that object from the ConcurrentMap in another thread.This interface is a member of the Java Collections Framework."},
{"description": "This interface is a member of the Java Collections Framework."},
{"description": "Concurrent insertion, removal, and access operations execute safely across multiple threads.A ConcurrentLinkedDeque is an appropriate choice when many threads will share access to a common collection.Like most other concurrent collection implementations, this class does not permit the use of null elements.Beware that, unlike in most collections, the size method is NOT a constant-time operation.Because of the asynchronous nature of these deques, determining the current number of elements requires a traversal of the elements, and so may report inaccurate results if this collection is modified during traversal.For example, an iterator operating concurrently with an addAll operation might view only some of the added elements.This class and its iterator implement all of the optional methods of the Deque and Iterator interfaces.This class is a member of the Java Collections Framework."},
{"description": "The head of the queue is that element that has been on the queue the longest time.The tail of the queue is that element that has been on the queue the shortest time.New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.A ConcurrentLinkedQueue is an appropriate choice when many threads will share access to a common collection.Like most other concurrent collection implementations, this class does not permit the use of null elements.This implementation employs an efficient non-blocking algorithm based on one described in Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms by Maged M. Michael and Michael L. Scott.Iterators are weakly consistent, returning elements reflecting the state of the queue at some point at or since the creation of the iterator.They do not throw ConcurrentModificationException, and may proceed concurrently with other operations.Elements contained in the queue since the creation of the iterator will be returned exactly once.Beware that, unlike in most collections, the size method is NOT a constant-time operation.Because of the asynchronous nature of these queues, determining the current number of elements requires a traversal of the elements, and so may report inaccurate results if this collection is modified during traversal.For example, an iterator operating concurrently with an addAll operation might view only some of the added elements.This class and its iterator implement all of the optional methods of the Queue and Iterator interfaces.This class is a member of the Java Collections Framework."},
{"description": "A view of a ConcurrentHashMap as a Set of keys, in which additions may optionally be enabled by mapping to a common value."},
{"description": "This class obeys the same functional specification as Hashtable, and includes versions of methods corresponding to each method of Hashtable.However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access.This class is fully interoperable with Hashtable in programs that rely on its thread safety but not on its synchronization details.Retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove).Retrievals reflect the results of the most recently completed update operations holding upon their onset.For aggregate operations such as putAll and clear, concurrent retrievals may reflect insertion or removal of only some entries.Similarly, Iterators, Spliterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration.They do not throw ConcurrentModificationException.However, iterators are designed to be used by only one thread at a time.Bear in mind that the results of aggregate status methods including size, isEmpty, and containsValue are typically useful only when a map is not undergoing concurrent updates in other threads.Otherwise the results of these methods reflect transient states that may be adequate for monitoring or estimation purposes, but not for program control.The table is dynamically expanded when there are too many collisions (i.e., keys that have distinct hash codes but fall into the same slot modulo the table size), with the expected average effect of maintaining roughly two bins per mapping (corresponding to a 0.75 load factor threshold for resizing).There may be much variance around this average as mappings are added and removed, but overall, this maintains a commonly accepted time/space tradeoff for hash tables.However, resizing this or any other kind of hash table may be a relatively slow operation.When possible, it is a good idea to provide a size estimate as an optional initialCapacity constructor argument.An additional optional loadFactor constructor argument provides a further means of customizing initial table capacity by specifying the table density to be used in calculating the amount of space to allocate for the given number of elements.Also, for compatibility with previous versions of this class, constructors may optionally specify an expected concurrencyLevel as an additional hint for internal sizing.Note that using many keys with exactly the same hashCode() is a sure way to slow down performance of any hash table.To ameliorate impact, when keys are Comparable, this class may use comparison order among keys to help break ties.A Set projection of a ConcurrentHashMap may be created (using newKeySet() or newKeySet(int)), or viewed (using keySet(Object) when only keys are of interest, and the mapped values are (perhaps transiently) not used or all take the same mapping value.A ConcurrentHashMap can be used as scalable frequency map (a form of histogram or multiset) by using LongAdder values and initializing via computeIfAbsent.For example, to add a count to a ConcurrentHashMap<String,LongAdder> freqs, you can use freqs.computeIfAbsent(k -> new LongAdder()).increment(); This class and its views and iterators implement all of the optional methods of the Map and Iterator interfaces.Like Hashtable but unlike HashMap, this class does not allow null to be used as a key or value.ConcurrentHashMaps support a set of sequential and parallel bulk operations that, unlike most Stream methods, are designed to be safely, and often sensibly, applied even with maps that are being concurrently updated by other threads; for example, when computing a snapshot summary of the values in a shared registry.There are three kinds of operation, each with four forms, accepting functions with Keys, Values, Entries, and (Key, Value) arguments and/or return values.Because the elements of a ConcurrentHashMap are not ordered in any particular way, and may be processed in different orders in different parallel executions, the correctness of supplied functions should not depend on any ordering, or on any other objects or values that may transiently change while computation is in progress; and except for forEach actions, should ideally be side-effect-free.Entry objects do not support method setValue.A variant form applies a given transformation on each element before performing the action.Return the first available non-null result of applying a given function on each element; skipping further search when a result is found.There are five variants: Plain reductions.(There is not a form of this method for (key, value) function arguments since there is no corresponding return type.)Mapped reductions that accumulate the results of a given function applied to each element.These bulk operations accept a parallelismThreshold argument.Methods proceed sequentially if the current map size is estimated to be less than the given threshold.MAX_VALUE suppresses all parallelism.Using a value of 1 results in maximal parallelism by partitioning into enough subtasks to fully utilize the ForkJoinPool.commonPool() that is used for all parallel computations.Normally, you would initially choose one of these extreme values, and then measure performance of using in-between values that trade off overhead versus throughput.The concurrency properties of bulk operations follow from those of ConcurrentHashMap: Any non-null result returned from get(key) and related access methods bears a happens-before relation with the associated insertion or update.The result of any bulk operation reflects the composition of these per-element relations (but is not necessarily atomic with respect to the map as a whole unless it is somehow known to be quiescent).Conversely, because keys and values in the map are never null, null serves as a reliable atomic indicator of the current lack of any result.To maintain this property, null serves as an implicit basis for all non-scalar reduction operations.For the double, long, and int versions, the basis should be one that, when combined with any other value, returns that other value (more formally, it should be the identity element for the reduction).Most common reductions have these properties; for example, computing a sum with basis 0 or a minimum with basis MAX_VALUE.Search and transformation functions provided as arguments should similarly return null to indicate the lack of any result (in which case it is not used).In the case of mapped reductions, this also enables transformations to serve as filters, returning null (or, in the case of primitive specializations, the identity basis) if the element should not be combined.You can create compound transformations and filterings by composing them yourself underthis \"null means there is nothing there now\" rule before using them in search or reduce operations.Methods accepting and/or returning Entry arguments maintain key-value associations.They may be useful for example when finding the key for the greatest value.Note that \"plain\" Entry arguments can be supplied using new AbstractMap.Bulk operations may complete abruptly, throwing an exception encountered in the application of a supplied function.Bear in mind when handling such exceptions that other concurrently executing functions could also have thrown exceptions, or would have done so if the first exception had not occurred.Speedups for parallel compared to sequential forms are common but not guaranteed.Parallel operations involving brief functions on small maps may execute more slowly than sequential forms if the underlying work to parallelize the computation is more expensive than the computation itself.Similarly, parallelization may not lead to much actual parallelism if all processors are busy performing unrelated tasks.All arguments to all task methods must be non-null.This class is a member of the Java Collections Framework."},
{"description": "This class represents a compound name -- a name from a hierarchical name space.Each component in a compound name is an atomic name.The components of a compound name are numbered.The indexes of a compound name with N components range from 0 up to, but not including, N. This range may be written as [0,N).The most significant component is at index 0.An empty compound name has no components.The syntax of a compound name is specified using a set of properties: jndi.syntax.direction Direction for parsing (\"right_to_left\", \"left_to_right\", \"flat\").If unspecified, defaults to \"flat\", which means the namespace is flat with no hierarchical structure.If its value is not \"true\", or if the property is not present, case is considered when comparing name components.If present, specifies the string that separates attribute-value-assertions when specifying multiple attribute/value pairs.If present, specifies the string that separators attribute from value (e.g. \"=\" in \"age=65\")These properties are interpreted according to the following rules: In a string without quotes or escapes, any instance of the separator delimits two atomic names.Each atomic name is referred to as a component.A separator, quote or escape is escaped if preceded immediately (on the left) by the escape.If there are two sets of quotes, a specific begin-quote must be matched by its corresponding end-quote.A non-escaped begin-quote which precedes a component must be matched by a non-escaped end-quote at the end of the component.A component thus quoted is referred to as a quoted component.It is parsed by removing the being- and end- quotes, and by treating the intervening characters as ordinary characters unless one of the rules involving quoted components listed below applies.Quotes embedded in non-quoted components are treated as ordinary strings and need not be matched.A separator that is escaped or appears between non-escaped quotes is treated as an ordinary string and not a separator.This can be used to embed an escaped quote within a quoted component.An escaped escape string is not treated as an escape string.An escape string that does not precede a meta string (quotes or separator) and is not at the end of a component is treated as an ordinary string.A leading separator (the compound name string begins with a separator) denotes a leading empty atomic component (consisting of an empty string).A trailing separator (the compound name string ends with a separator) denotes a trailing empty atomic component.Adjacent separators denote an empty atomic component.The string form of the compound name follows the syntax described above.When the components of the compound name are turned into their string representation, the reserved syntax rules described above are applied (e.g. embedded separators are escaped or quoted) so that when the same string is parsed, it will yield the same components of the original compound name.Access A CompoundName instance is not synchronized against concurrent multithreaded access.Multiple threads trying to access and modify a CompoundName should lock the object."},
{"description": "Type inner class identifies one kind of compound control.Static instances are provided for the common types."},
{"description": "Class Compression is a printing attribute class, an enumeration, that specifies how print data is compressed.Compression is an attribute of the print data (the doc), not of the Print Job.If a Compression attribute is not specified for a doc, the printer assumes the doc's print data is uncompressed (i.e., the default Compression value is always NONE).The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "A CompoundControl, such as a graphic equalizer, provides control over two or more related properties, each of which is itself represented as a Control."},
{"description": "Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations.Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods.Conditions (also known as condition queues or condition variables) provide a means for one thread to suspend execution (to \"wait\") until notified by another thread that some state condition may now be true.Because access to this shared state information occurs in different threads, it must be protected, so a lock of some form is associated with the condition.The key property that waiting for a condition provides is that it atomically releases the associated lock and suspends the current thread, just like Object.wait.A Condition instance is intrinsically bound to a lock.As an example, suppose we have a bounded buffer which supports put and take methods.If a take is attempted on an empty buffer, then the thread will block until an item becomes available; if a put is attempted on a full buffer, then the thread will block until a space becomes available.We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer.This can be achieved using two Condition instances.lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) notFull.await();(); } finally { lock.unlock(); } } public Object take() throws InterruptedException { lock.lock(); try { while (count == 0); --count; notFull.signal(); return x; } finally { lock.unlock(); } } } (The ArrayBlockingQueue class provides this functionality, so there is no reason to implement this sample usage class.)A Condition implementation can provide behavior and semantics that is different from that of the Object monitor methods, such as guaranteed ordering for notifications, or not requiring a lock to be held when performing notifications.If an implementation provides such specialized semantics then the implementation must document those semantics.Note that Condition instances are just normal objects and can themselves be used as the target in a synchronized statement, and can have their own monitor wait and notification methods invoked.It is recommended that to avoid confusion you never use Condition instances in this way, except perhaps within their own implementation.Except where noted, passing a null value for any parameter will result in a NullPointerException being thrown.Implementation Considerations When waiting upon a Condition, a \"spurious wakeup\" is permitted to occur, in general, as a concession to the underlying platform semantics.This has little practical impact on most application programs as a Condition should always be waited upon in a loop, testing the state predicate that is being waited for.An implementation is free to remove the possibility of spurious wakeups but it is recommended that applications programmers always assume that they can occur and so always wait in a loop.The three forms of condition waiting (interruptible, non-interruptible, and timed) may differ in their ease of implementation on some platforms and in their performance characteristics.In particular, it may be difficult to provide these features and maintain specific semantics such as ordering guarantees.Further, the ability to interrupt the actual suspension of the thread may not always be feasible to implement on all platforms.Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of waiting, nor is it required to support interruption of the actual suspension of the thread.An implementation is required to clearly document the semantics and guarantees provided by each of the waiting methods, and when an implementation does support interruption of thread suspension then it must obey the interruption semantics as defined in this interface.As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor responding to an interrupt over normal method return.This is true even if it can be shown that the interrupt occurred after another action that may have unblocked the thread.An implementation should document this behavior."},
{"description": "The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used.This class implements a concurrent variant of SkipLists providing expected average log(n)time cost for the containsKey, get, put and remove operations and their variants.Insertion, removal, update, and access operations safely execute concurrently by multiple threads.Ascending key ordered views and their iterators are faster than descending ones.Entry pairs returned by methods in this class and its views represent snapshots of mappings at the time they were produced.They do not support the Entry.setValue method.(Note however that it is possible to change mappings in the associated map using put, putIfAbsent, or replace, depending on exactly which effect you need.)Beware that, unlike in most collections, the size method is not a constant-time operation.Because of the asynchronous nature of these maps, determining the current number of elements requires a traversal of the elements, and so may report inaccurate results if this collection is modified during traversal.For example, an iterator operating concurrently with a putAll operation might view only some of the added elements.This class and its views and iterators implement all of the optional methods of the Map and Iterator interfaces.Like most other concurrent collections, this class does not permit the use of null keys or values because some null return values cannot be reliably distinguished from the absence of elements.This class is a member of the Java Collections Framework."},
{"description": "A composite Border class used to compose two Border objects into a single border by nesting an inside Border object within the insets of an outside Border object.For example, this class may be used to add blank margin space to a component with an existing decorative border: Border border = comp.getBorder(); Border margin = new EmptyBorder(10,10,10,10); comp.setBorder(new CompoundBorder(border, margin)); Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "CompositeView is an abstract View implementation which manages one or more child views.(Note that CompositeView is intended for managing relatively small numbers of child views.)CompositeView is intended to be used as a starting point for View implementations, such as BoxView, that will contain child Views.Subclasses that wish to manage the collection of child Views should use the replace(int, int, javax.swing.text.View[]) method.As View invokes replace during DocumentListener notification, you normally won't need to directly invoke replace.While CompositeView does not impose a layout policy on its child Views, it does allow for inseting the child Views it will contain.In addition to the abstract methods of View, subclasses of CompositeView will need to override: isBefore(int, int,java.awt.Rectangle) - Used to test if a given View location is before the visual space of the CompositeView.java.awt.Rectangle) - Used to test if a given View location is after the visual space of the CompositeView.getChildAllocation will invoke childAllocation after offseting the bounds by the Insets of the CompositeView."},
{"description": "The CompositeType class is the open type class whose instances describe the types of CompositeData values."},
{"description": "This class represents a composite name -- a sequence of component names spanning multiple namespaces.Each component is a string name from the namespace of a naming system.If the component comes from a hierarchical namespace, that component can be further parsed into its atomic parts by using the CompoundName class.The components of a composite name are numbered.The indexes of a composite name with N components range from 0 up to, but not including, N. This range may be written as [0,N).The most significant component is at index 0.An empty composite name has no components.JNDI Composite Name Syntax JNDI defines a standard string representation for composite names.This representation is the concatenation of the components of a composite name from left to right using the component separator (a forward slash character (/)) to separate each component.The JNDI syntax defines the following meta characters: escape (backward slash \\), quote characters (single (') and double quotes (\")), and component separator (forward slash character (/)).Any occurrence of a leading quote, an escape preceding any meta character, an escape at the end of a component, or a component separator character in an unquoted component must be preceded by an escape character when that component is being composed into a composite name string.Alternatively, to avoid adding escape characters as described, the entire component can be quoted using matching single quotes or matching double quotes.A single quote occurring within a double-quoted component is not considered a meta character (and need not be escaped), and vice versa.When two composite names are compared, the case of the characters is significant.A leading component separator (the composite name string begins with a separator) denotes a leading empty component (a component consisting of an empty string).A trailing component separator (the composite name string ends with a separator) denotes a trailing empty component.Adjacent component separators denote an empty component.Composite Name ExamplesThis table shows examples of some composite names.\"\", \"y\"}Composition Examples Here are some composition examples.The right column shows composing string composite names while the left column shows composing the corresponding CompositeNames.Notice that composing the string forms of two composite names simply involves concatenating their string forms together.\"x\"{\"x\"} + {} + {} = {\"x\"}Multithreaded Access A CompositeName instance is not synchronized against concurrent multithreaded access.Multiple threads trying to access and modify a CompositeName should lock the object."},
{"description": "A concrete subclass of AbstractUndoableEdit, used to assemble little UndoableEdits into great big ones."},
{"description": "A Java class can implement this interface to indicate how it is to be converted into a CompositeData by the MXBean framework.A typical way to use this class is to add extra items to the CompositeData in addition to the ones that are declared in the CompositeType supplied by the MXBean framework.To do this, you must create another CompositeType that has all the same items, plus your extra items.For example, suppose you have a class Measure that consists of a String called units and a value that is either a long or a double.It might look like this: public class Measure implements} public String getUnits() { return units; } // Can't be called getValue(), because Number is not a valid type // in an MXBean, so the implied \"value\" property would be rejected.public Number _getValue() { return value; } public CompositeData toCompositeData(CompositeType ct) { try { List<String> itemNames = new ArrayList<String>(ct.keySet());>(); for (String item : itemNames) { itemDescriptions.add(ct.getDescription(item)); itemTypes.add(ct.getType(item)); } itemNames.add(\"value\"); itemDescriptions.add(\"long or double value of the measure\"); itemTypes.add((value instanceof Long) ?, itemTypes.toArray(new OpenType<?>[0])); CompositeData cd = new CompositeDataSupport(xct, new String[] {\"units\", \"value\"}, new Object[] {units, value}); assert ct.isValue(cd); // check we've done it right return cd; } catch (Exception e) { throw new RuntimeException(e); } } } The CompositeType that will appear in the openType field of the Descriptor for an attribute or operation of this type will show only the units item, but the actual CompositeData that is generated will have both units and value."},
{"description": "The CompositeDataSupport class is the open data class which implements the CompositeData interface."},
{"description": "The CompositeContext interface defines the encapsulated and optimized environment for a compositing operation.CompositeContext objects maintain state for compositing operations.In a multi-threaded environment, several contexts can exist simultaneously for a single Composite object."},
{"description": "The UI delegate object for a Swing component is responsible for implementing the aspects of the component that depend on the look and feel.that may vary depending on the look and feel installed.Client programs should not invoke methods on this class directly."},
{"description": "Component decorator that implements the view interface.The entire element is used to represent the component.This acts as a gateway from the display-only View implementations to interactive lightweight components (ie it allows components to be embedded into the View hierarchy).The component is placed relative to the text baseline according to the value returned by Component.getAlignmentY.For Swing components this value can be conveniently set using the method JComponent.setAlignmentY.For example, setting a value of 0.75 will cause 75 percent of the component to be above the baseline, and 25 percent of the component to be below the baseline.This class is implemented to do the extra work necessary to work properly in the presence of multiple threads (i.e. from asynchronous notification of model changes for example) by ensuring that all component access is done on the event thread.The component used is determined by the return value of the createComponent method.The default implementation of this method is to return the component held as an attribute of the element (by calling StyleConstants.getComponent).A limitation of this behavior is that the component cannot be used by more than one text component (i.e. with a shared model).Subclasses can remove this constraint by implementing the createComponent to actually create a component based upon some kind of specification contained in the attributes.The ObjectView class in the html package is an example of a ComponentView implementation that supports multiple component views of a shared model."},
{"description": "If you have an interface that contains only getter methods (such as String getName() or boolean isActive()) then you can use this class in conjunction with the Proxy class to produce an implementation of the interface where each getter returns the value of the corresponding item in a CompositeData.For example, suppose you have an interface like this: public interface NamedNumber { public int getNumber(); public String getName; then you can construct an object implementing NamedNumber and backed by the object cd like this:A call to nn.getNumber() will then return 5.If the first letter of the property defined by a getter is a capital, then this handler will look first for an item in the CompositeData beginning with a capital, then, if that is not found, for an item beginning with the corresponding lowercase letter or code point.For a getter called getNumber(), the handler will first look for an item called Number, then for number.If the method given to invoke is the method boolean equals(Object) inherited from Object, then it will return true if and only if the argument is a Proxy whose InvocationHandler is also a CompositeDataInvocationHandler and whose backing CompositeData is equal (not necessarily identical) to this object's.If the method given to invoke is the method int hashCode() inherited from Object, then it will return a value that is consistent with this definition of equals: if two objects are equal according to equals, then they will have the same hashCode."},
{"description": "The CompositeData interface specifies the behavior of a specific type of complex open data objects which represent composite data structures."},
{"description": "The Composite interface, along with CompositeContext, defines the methods to compose a draw primitive with the underlying graphics area.After the Composite is set in the Graphics2D context, it combines a shape, text, or an image being rendered with the colors that have already been rendered according to pre-defined rules.The classes implementing this interface provide the rules and a method to create the context for a particular operation.CompositeContext is an environment used by the compositing operation, which is created by the Graphics2D prior to the start of the operation.CompositeContext contains private information and resources needed for a compositing operation.When the CompositeContext is no longer needed, the Graphics2D object disposes of it in order to reclaim resources allocated for the operation.Instances of classes implementing Composite must be immutable because the Graphics2D does not clone these objects when they are set as an attribute with the setComposite method or when the Graphics2D object is cloned.This is to avoid undefined rendering behavior of Graphics2D, resulting from the modification of the Composite object after it has been set in the Graphics2D context.Since this interface must expose the contents of pixels on the target device or image to potentially arbitrary code, the use of custom objects which implement this interface when rendering directly to a screen device is governed by the readDisplayPixels AWTPermission.The permission check will occur when such a custom object is passed to the setComposite method of a Graphics2D retrieved from a Component."},
{"description": "This class represents image data which is stored such that each sample of a pixel occupies one data element of the DataBuffer.It stores the N samples which make up a pixel in N separate data array elements.Different bands may be in different banks of the DataBuffer.This class can support different kinds of interleaving, e.g. band interleaving, scanline interleaving, and pixel interleaving.Pixel stride is the number of data array elements between two samples for the same band on the same scanline.Scanline stride is the number of data array elements between a given sample and the corresponding sample in the same column of the next scanline.The bands are numbered from 0 to N-1.This class can represent image data for which each sample is an unsigned integral number which can be stored in 8, 16, or 32 bits (using DataBuffer.TYPE_INT, respectively), data for which each sample is a signed integral number which can be stored in 16 bits (using DataBuffer.TYPE_SHORT), or data for which each sample is a signed float or double quantity (using DataBuffer.All samples of a given ComponentSampleModel are stored with the same precision.This class supports TYPE_BYTE, TYPE_USHORT, TYPE_SHORT, TYPE_INT, TYPE_FLOAT, TYPE_DOUBLE,"},
{"description": "A low-level event which indicates that a component moved, changed size, or changed visibility (also, the root class for the other component-level events).Component events are provided for notification purposes ONLY; The AWT will automatically handle component moves and resizes internally so that GUI layout works properly regardless of whether a program is receiving these events or not.In addition to serving as the base class for other component-related events (InputEvent, FocusEvent, WindowEvent, ContainerEvent), this class defines the events that indicate changes in a component's size, position, or visibility.This low-level event is generated by a component object (such as a List) when the component is moved, resized, rendered invisible, or made visible again.The event is passed to every ComponentListener or ComponentAdapter object which registered to receive such events using the component's addComponentListener method.(ComponentAdapter objects implement the ComponentListener interface.)Each such listener object gets this ComponentEvent when the event occurs.An unspecified behavior will be caused if the id parameter of any particular ComponentEvent instance is not in the range from COMPONENT_FIRST to COMPONENT_LAST."},
{"description": "A ColorModel class that works with pixel values that represent color and alpha information as separate samples and that store each sample in a separate data element.This class can be used with an arbitrary ColorSpace.The number of color samples in the pixel values must be same as the number of color components in the ColorSpace.There may be a single alpha sample.For those methods that use a primitive array pixel representation of type transferType, the array length is the same as the number of color and alpha samples.Color samples are stored first in the array followed by the alpha sample, if present.The order of the color samples is specified by the ColorSpace.Typically, this order reflects the name of the color space type.For example, for TYPE_RGB, index 0 corresponds to red, index 1 to green, and index 2 to blue.The translation from pixel sample values to color/alpha components for display or processing purposes is based on a one-to-one correspondence of samples to components.Depending on the transfer type used to create an instance of ComponentColorModel, the pixel sample values represented by that instance may be signed or unsigned and may be of integral type or float or double (see below for details).The translation from sample values to normalized color/alpha components must follow certain rules.For float and double samples, the translation is an identity, i.e. normalized component values are equal to the corresponding sample values.For integral samples, the translation should be only a simple scale and offset, where the scale and offset constants may be different for each component.The result of applying the scale and offset constants is a set of color/alpha component values, which are guaranteed to fall within a certain range.Typically, the range for a color component will be the range defined by the getMinValue and getMaxValue methods of the ColorSpace class.The range for an alpha component should be 0.0 to 1.0.TYPE_INT have pixel sample values which are treated as unsigned integral values.The number of bits in a color or alpha sample of a pixel value might not be the same as the number of bits for the corresponding color or alpha sample passed to the ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int) constructor.In that case, this class assumes that the least significant n bits of a sample value hold the component value, where n is the number of significant bits for the component passed to the constructor.It also assumes that any higher-order bits in a sample value are zero.Thus, sample values range from 0 to 2n - 1.This class maps these sample values to normalized color component values such that 0 maps to the value obtained from the ColorSpace's getMinValue method for each component and 2n - 1 maps to the value obtained from getMaxValue.To create a ComponentColorModel with a different color sample mapping requires subclassing this class and overriding the getNormalizedComponents(Object, float[], int) method.The mapping for an alpha sample always maps 0 to 0.0 and 2n - 1 to 1.0.For instances with unsigned sample values, the unnormalized color/alpha component representation is only supported if two conditions hold.First, sample value value 0 must map to normalized component value 0.0 and sample value 2n - 1 to 1.0.Second the min/max range of all color components of the ColorSpace must be 0.0 to 1.0.In this case, the component representation is the n least significant bits of the corresponding sample.Thus each component is an unsigned integral value between 0 and 2n - 1, where n is the number of significant bits for a particular component.If these conditions are not met, any method taking an unnormalized component argument will throw an IllegalArgumentException.TYPE_DOUBLE have pixel sample values which are treated as signed short, float, or double values.Such instances do not support the unnormalized color/alpha component representation, so any methods taking such a representation as an argument will throw an IllegalArgumentException when called on one of these instances.The normalized component values of instances of this class have a range which depends on the transfer type as follows: for float samples, the full range of the float data type; for double samples, the full range of the float data type (resulting from casting double to float); for short samples, from approximately -maxVal to +maxVal, where maxVal is the per component maximum value for the ColorSpace (-32767 maps to -maxVal, 0 maps to 0.0, and 32767 maps to +maxVal).A subclass may override the scaling for short sample values to normalized component values by overriding the getNormalizedComponents(Object, float[], int) method.For float and double samples, the normalized component values are taken to be equal to the corresponding sample values, and subclasses should not attempt to add any non-identity scaling for these transfer types.TYPE_DOUBLE use all the bits of all sample values.Thus all color/alpha components have 16 bits when using DataBuffer.When the ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int) form of constructor is used with one of these transfer types, the bits array argument is ignored.It is possible to have color/alpha sample values which cannot be reasonably interpreted as component values for rendering.This can happen when ComponentColorModel is subclassed to override the mapping of unsigned sample values to normalized color component values or when signed sample values outside a certain range are used.(As an example, specifying an alpha component as a signed short value outside the range 0 to 32767, normalized range 0.0 to 1.0, can lead to unexpected results.)It is the responsibility of applications to appropriately scale pixel data before rendering such that color components fall within the normalized range of the ColorSpace (obtained using the getMinValue and getMaxValue methods of the ColorSpace class) and the alpha component is between 0.0 and 1.0.If color or alpha component values fall outside these ranges, rendering results are indeterminate.Methods that use a single int pixel representation throw an IllegalArgumentException, unless the number of components for the ComponentColorModel is one and the component value is unsigned -- in other words, a single color component using a transfer type of DataBuffer.A ComponentColorModel can be used in conjunction with a ComponentSampleModel, a BandedSampleModel, or a PixelInterleavedSampleModel to construct a BufferedImage."},
{"description": "A subclass of javax.swing.ComponentInputMap that implements UIResource.UI classes which provide a ComponentInputMap should use this class."},
{"description": "This would be encapsulated in a TaggedProfile."},
{"description": "A ComponentInputMap is an InputMap associated with a particular JComponent.ComponentInputMaps are used for WHEN_IN_FOCUSED_WINDOW bindings."},
{"description": "The ComponentOrientation class encapsulates the language-sensitive orientation that is to be used to order the elements of a component or of text.It is used to reflect the differences in this ordering between Western alphabets, Middle Eastern (such as Hebrew), and Far Eastern (such as Japanese).Fundamentally, this governs items (such as characters) which are laid out in lines, with the lines then laid out in a block.This also applies to items in a widget: for example, in a check box where the box is positioned relative to the text.There are four different orientations used in modern languages as in the following table.(In the header, the two-letter abbreviation represents the item direction in the first letter, and the line direction in the second.For example, LT means \"items left-to-right, lines top-to-bottom\", TL means \"items top-to-bottom, lines left-to-right\", and so on.)The orientations are: LT - Western Europe (optional for Japanese, Chinese, Korean) RT - Middle East(Arabic, Hebrew) TR - Japanese, Chinese, Korean TL - Mongolian Components whose view and controller code depends on orientation should use the isLeftToRight() and isHorizontal() methods to determine their behavior.They should not include switch-like code that keys off of the constants, such as: if (orientation =This is unsafe, since more constants may be added in the future and since it is not guaranteed that orientation objects will be unique."},
{"description": "A service that decouples the production of new asynchronous tasks from the consumption of the results of completed tasks.Producers submit tasks for execution.Consumers take completed tasks and process their results in the order they complete.A CompletionService can for example be used to manage asynchronousI/O, in which tasks that perform reads are submitted in one part of a program or system, and then acted upon in a different part of the program when the reads complete, possibly in a different order than they were requested.Typically, a CompletionService relies on a separate Executor to actually execute the tasks, in which case the CompletionService only manages an internal completion queue.The ExecutorCompletionService class provides an implementation of this approach.Actions in a thread prior to submitting a task to a CompletionService happen-before actions taken by that task, which in turn happen-before actions following a successful return from the corresponding take()."},
{"description": "The methods in this class are empty.This class exists as convenience for creating listener objects.(If you implement the ComponentListener interface, you have to define all of the methods in it.This abstract class defines null methods for them all, so you can only have to define methods for events you care about.)When the component's size, location, or visibility changes, the relevant method in the listener object is invoked, and the ComponentEvent is passed to it."},
{"description": "The class that is interested in processing a component event either implements this interface (and all the methods it contains) or extends the abstract ComponentAdapter class (overriding only the methods of interest).The listener object created from that class is then registered with a component using the component's addComponentListener method.When the component's size, location, or visibility changes, the relevant method in the listener object is invoked, and the ComponentEvent is passed to it.Component events are provided for notification purposes ONLY; The AWT will automatically handle component moves and resizes internally so that GUI layout works properly regardless of whether a program registers a ComponentListener or not."},
{"description": "Enumeration of the common ways the baseline of a component can change as the size changes.The baseline resize behavior is primarily for layout managers that need to know how the position of the baseline changes as the component size changes.In general the baseline resize behavior will be valid for sizes greater than or equal to the minimum size (the actual minimum size; not a developer specified minimum size).For sizes smaller than the minimum size the baseline may change in a way other than the baseline resize behavior indicates.Similarly, as the size approaches Integer.MAX_VALUE the baseline may change in a way other than the baseline resize behavior indicates."},
{"description": "A stage of a possibly asynchronous computation, that performs an action or computes a value when another CompletionStage completes.A stage completes upon termination of its computation, but this may in turn trigger other dependent stages.The functionality defined in this interface takes only a few basic forms, which expand out to a larger set of methods to capture a range of usage styles: The computation performed by a stage may be expressed as a Function, Consumer, or Runnable (using methods with names including apply, accept, or run, respectively) depending on whether it requires arguments and/or produces results.An additional form (compose) applies functions of stages themselves, rather than their results.One stage's execution may be triggered by completion of a single stage, or both of two stages, or either of two stages.Dependencies on a single stage are arranged using methods with prefix then.Those triggered by completion of both of two stages may combine their results or effects, using correspondingly named methods.Those triggered by either of two stages make no guarantees about which of the results or effects are used for the dependent stage's computation.Dependencies among stages control the triggering of computations, but do not otherwise guarantee any particular ordering.Additionally, execution of a new stage's computations may be arranged in any of three ways: default execution, default asynchronous execution (using methods with suffix async that employ the stage's default asynchronous execution facility), or custom (via a supplied Executor).The execution properties of default and async modes are specified by CompletionStage implementations, not this interface.Methods with explicit Executor arguments may have arbitrary execution properties, and might not even support concurrent execution, but are arranged for processing in a way that accommodates asynchrony.Two method forms support processing whether the triggering stage completed normally or exceptionally: Method whenComplete allows injection of an action regardless of outcome, otherwise preserving the outcome in its completion.Method handle additionally allows the stage to compute a replacement result that may enable further processing by other dependent stages.In all other cases, if a stage's computation terminates abruptly with an (unchecked) exception or error, then all dependent stages requiring its completion complete exceptionally as well, with a CompletionException holding the exception as its cause.If a stage is dependent on both of two stages, and both complete exceptionally, then the CompletionException may correspond to either one of these exceptions.If a stage is dependent on either of two others, and only one of them completes exceptionally, no guarantees are made about whether the dependent stage completes normally or exceptionally.In the case of method whenComplete, when the supplied action itself encounters an exception, then the stage exceptionally completes with this exception if not already completed exceptionally.All methods adhere to the above triggering, execution, and exceptional completion specifications (which are not repeated in individual method specifications).Additionally, while arguments used to pass a completion result (that is, for parameters of type T) for methods accepting them may be null, passing a null value for any other parameter will result in a NullPointerException being thrown.This interface does not define methods for initially creating, forcibly completing normally or exceptionally, probing completion status or results, or awaiting completion of a stage.Implementations of CompletionStage may provide means of achieving such effects, as appropriate.Method toCompletableFuture() enables interoperability among different implementations of this interface by providing a common conversion type."},
{"description": "A component is an object having a graphical representation that can be displayed on the screen and that can interact with the user.Examples of components are the buttons, checkboxes, and scrollbars of a typical graphical user interface.The Component class is the abstract superclass of the nonmenu-related Abstract Window Toolkit components.Class Component can also be extended directly to create a lightweight component.A lightweight component is a component that is not associated with a native window.On the contrary, a heavyweight component is associated with a native window.The isLightweight() method may be used to distinguish between the two kinds of the components.Lightweight and heavyweight components may be mixed in a single component hierarchy.However, for correct operating of such a mixed hierarchy of components, the whole hierarchy must be valid.When the hierarchy gets invalidated, like after changing the bounds of components, or adding/removing components to/from containers, the whole hierarchy must be validated afterwards by means of the Container.validate() method invoked on the top-most invalid container of the hierarchy.It is important to note that only AWT listeners which conform to the Serializable protocol will be saved when the object is stored.If an AWT object has listeners that aren't marked serializable, they will be dropped at writeObject time.Developers will need, as always, to consider the implications of making an object serializable.One situation to watch out for is this: import java.awt.*; import java.io.Serializable; class MyApp implements ActionListener, Serializable { BigObjectThatShouldNotBeSerializedWithAButton bigOne; Button aButton = new Button(); MyApp() { // Oops, now aButton has a listener with a reference // to bigOne!System.out.println(\"Hello There\"); } } In this example, serializing aButton by itself will cause MyApp and everything it refers to to be serialized as well.The problem is that the listener is serializable by coincidence, not by design.To separate the decisions about MyApp and the ActionListener being serializable one can use a nested class, as in the following example: import java.awt.*; import java.io.Serializable; class MyApp implements java.io.Serializable { BigObjectThatShouldNotBeSerializedWithAButton bigOne; Button aButton = new Button(); static class MyActionListener implements ActionListener { public void actionPerformed(ActionEvent e) { System.out.println(\"Hello There\"); } } MyApp() { aButton.addActionListener(new MyActionListener()); } } Note: For more information on the paint mechanisms utilitized by AWT and Swing, including information on how to write the most efficient painting code, see Painting in AWT and Swing."},
{"description": "The class CompletionStatus contains three CompletionStatus instances, which are constants representing each possible completion status: COMPLETED_MAYBE, COMPLETED_NO, and COMPLETED_YES.It also contains three int members, each a constant corresponding to one of the CompletionStatus instances.These int members make it possible to use a switch statement.The class also contains two methods: public int value() -- which accesses the value field of a CompletionStatus object public static CompletionStatus from_int(int i) -- for creating an instance from one of the int members"},
{"description": "The asynchronous channels defined in this package allow a completion handler to be specified to consume the result of an asynchronous operation.The implementations of these methods should complete in a timely manner so as to avoid keeping the invoking thread from dispatching to other completion handlers."},
{"description": "A Future that may be explicitly completed (setting its value and status), and may be used as a CompletionStage, supporting dependent functions and actions that trigger upon its completion.When two or more threads attempt to complete, completeExceptionally, or cancel a CompletableFuture, only one of them succeeds.In addition to these and related methods for directly manipulating status and results, CompletableFuture implements interface CompletionStage with the following policies: Actions supplied for dependent completions of non-async methods may be performed by the thread that completes the current CompletableFuture, or by any other caller of a completion method.All async methods without an explicit Executor argument are performed using the ForkJoinPool.commonPool() (unless it does not support a parallelism level of at least two, in which case, a new Thread is created to run each task).To simplify monitoring, debugging, and tracking, all generated asynchronous tasks are instances of the marker interface CompletableFuture.All CompletionStage methods are implemented independently of other public methods, so the behavior of one method is not impacted by overrides of others in subclasses.CompletableFuture also implements Future with the following policies:this class has no direct control over the computation that causes it to be completed, cancellation is treated as just another form of exceptional completion.Method cancel has the same effect as completeExceptionally(new CancellationException()).Method isCompletedExceptionally() can be used to determine if a CompletableFuture completed in any exceptional fashion.In case of exceptional completion with a CompletionException, methods get() and get(long, TimeUnit) throw an ExecutionException with the same cause as held in the corresponding CompletionException.To simplify usage in most contexts, this class also defines methods join() and getNow(T) that instead throw the CompletionException directly in these cases."},
{"description": "State might be stored in the form of Java classes, Java class files or scripting language opcodes.Each CompiledScript is associated with a ScriptEngine -- A call to an eval method of the CompiledScript causes the execution of the script by the ScriptEngine.Changes in the state of the ScriptEngine caused by execution of the CompiledScript may visible during subsequent executions of scripts by the engine."},
{"description": "The Compiler class is provided to support Java-to-native-code compilers and related services.By design, the Compiler class does nothing; it serves as a placeholder for a JIT compiler implementation.(System properties are accessible through System.getProperty(String) and System.getProperty(String, String).If so, it is assumed to be the name of a library (with a platform-dependent exact location and type);String) is called to load that library.If this loading succeeds, the function named java_lang_Compiler_start() in that library is called.If no compiler is available, these methods do nothing."},
{"description": "Exception thrown when an error or other exception is encountered in the course of completing a result or task."},
{"description": "A completion is text meant to be inserted into a program as part of an annotation."},
{"description": "This may be useful for monitoring, debugging, and tracking asynchronous activities."},
{"description": "The optional interface implemented by ScriptEngines whose methods compile scripts to a form that can be executed repeatedly without recompilation."},
{"description": "Note that this is the definition of a comment in XML, and, in practice, HTML, although some HTML tools may implement the full SGML comment structure.No lexical check is done on the content of a comment and it is therefore possible to have the character sequence \"--\" (double-hyphen) in the content, which is illegal in a comment per section 2.5 of [XML 1.0].The presence of this character sequence must generate a fatal error during serialization."},
{"description": "This exception is thrown when the client is unable to communicate with the directory or naming service.The inability to communicate with the service might be a result of many factors, such as network partitioning, hardware or interface problems, failures on either the client or server side.This exception is meant to be used to capture such communication problems.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "Interface that defines the methods which are common between DataSource, XADataSource and ConnectionPoolDataSource."},
{"description": "A Java virtual machine has a single instance of the implementation class of this interface.This instance implementing this interface is an MXBean that can be obtained by calling the ManagementFactory.getCompilationMXBean() method or from the platform MBeanServer method.The ObjectName for uniquely identifying the MXBean for the compilation system within an MBeanServer is: java.lang:type=CompilationIt can be obtained by calling the PlatformManagedObject.getObjectName() method."},
{"description": "A comparison function, which imposes a total ordering on some collection of objects.Comparators can be passed to a sort method (such as Collections.sort or Arrays.sort) to allow precise control over the sort order.Comparators can also be used to control the order of certain data structures (such as sorted sets or sorted maps), or to provide an ordering for collections of objects that don't have a natural ordering.The ordering imposed by a comparator c on a set of elements S is said to be consistent with equals if and only if c.compare(e1, e2)==0 has the same boolean value as e1.equals(e2) for every e1 and e2 in S. Caution should be exercised when using a comparator capable of imposing an ordering inconsistent with equals to order a sorted set (or sorted map).Suppose a sorted set (or sorted map) with an explicit comparator c is used with elements (or keys) drawn from a set S.If the ordering imposed by c on S is inconsistent with equals, the sorted set (or sorted map) will behave \"strangely.\"In particular the sorted set (or sorted map) will violate the general contract for set (or map), which is defined in terms of equals.For example, suppose one adds two elements a and b such that (a.equals(b) && c.compare(a, b) !The second add operation will return true (and the size of the tree set will increase) because a and b are not equivalent from the tree set's perspective, even though this is contrary to the specification of the Set.add method.Note: It is generally a good idea for comparators to also implement java.io.Serializable, as they may be used as ordering methods in serializable data structures (like TreeSet, TreeMap).In order for the data structure to serialize successfully, the comparator (if provided) must implement Serializable.For the mathematically inclined, the relation that defines the imposed ordering that a given comparator c imposes on a given set of objects S is: {(x, y)The quotient for this total order is: {(x, y)It follows immediately from the contract for compare that the quotient is an equivalence relation on S, and that the imposed ordering is a total order on S. When we say that the ordering imposed by c on S is consistent with equals, we mean that the quotient for the ordering is the equivalence relation defined by the objects' equals(Object) method(s): {(x, y) such that x.equals(y)}.Unlike Comparable, a comparator may optionally permit comparison of null arguments, while maintaining the requirements for an equivalence relation.This interface is a member of the Java Collections Framework."},
{"description": "This interface imposes a total ordering on the objects of each class that implements it.This ordering is referred to as the class's natural ordering, and the class's compareTo method is referred to as its natural comparison method.Lists (and arrays) of objects that implement this interface can be sorted automatically by Collections.sort (and Arrays.sort).Objects that implement this interface can be used as keys in a sorted map or as elements in a sorted set, without the need to specify a comparator.The natural ordering for a class C is said to be consistent with equals if and only if e1.compareTo(e2) == 0 has the same boolean value as e1.equals(e2) for every e1 and e2 of class C. Note that null is not an instance of any class, and e.compareTo(null) should throw a NullPointerException even though e.equals(null) returns false.It is strongly recommended (though not required) that natural orderings be consistent with equals.This is so because sorted sets (and sorted maps) without explicit comparators behave \"strangely\" when they are used with elements (or keys) whose natural ordering is inconsistent with equals.In particular, such a sorted set (or sorted map) violates the general contract for set (or map), which is defined in terms of the equals method.For example, if one adds two keys a and b such that (!a.equals(b) && a.compareTo(b) == 0) to a sorted set that does not use an explicit comparator, the second add operation returns false (and the size of the sorted set does not increase) because a and b are equivalent from the sorted set's perspective.Virtually all Java core classes that implement Comparable have natural orderings that are consistent with equals.One exception is java.math.BigDecimal, whose natural ordering equates BigDecimal objects with equal values and different precisions (such as 4.0 and 4.00).For the mathematically inclined, the relation that defines the natural ordering on a given class C is: {(x, y) such that x.compareTo(y) <= 0}.The quotient for this total order is: {(x, y) such that x.compareTo(y) == 0}.It follows immediately from the contract for compareTo that the quotient is an equivalence relation on C, and that the natural ordering is a total order on C. When we say that a class's natural ordering is consistent with equals, we mean that the quotient for the natural ordering is the equivalence relation defined by the class's equals(Object) method: {(x, y)This interface is a member of the Java Collections Framework."},
{"description": "The CommandMap class provides an interface to a registry of command objects available in the system.Developers are expected to either use the CommandMap implementation included with this package (MailcapCommandMap) or develop their own.Note that some of the methods in this class are abstract."},
{"description": "The CommandInfo class is used by CommandMap implementations to describe the results of command requests.It provides the requestor with both the verb requested, as well as an instance of the bean.There is also a method that will return the name of the class that implements the command but it is not guaranteed to return a valid value.The reason for this is to allow CommandMap implmentations that subclass CommandInfo to provide special behavior.For example a CommandMap could dynamically generate JavaBeans.In this case, it might not be possible to create an object with all the correct state information solely from the class name."},
{"description": "JavaBeans components that are Activation Framework aware implement this interface to find out which command verb they're being asked to perform, and to obtain the DataHandler representing the data they should operate on.JavaBeans that don't implement this interface may be used as well.Such commands may obtain the data using the Externalizable interface, or using an application-specific method."},
{"description": "The interface which defines the methods required for the implementation of the popup portion of a combo box.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This exception is raised if communication is lost while an operation is in progress, after the request was sent by the client, but before the reply from the server has been returned to the client.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception.See the section meaning of minor codes to see the minor codes for this exception."},
{"description": "This interface extends ListDataModel and adds the concept of a selected item.The selected item is generally the item which is visible in the combo box display area.The selected item may not necessarily be managed by the underlying ListModel.This disjoint behavior allows for the temporary storage and retrieval of a selected item in the model."},
{"description": "The editor component used for JComboBox components."},
{"description": "A typesafe enumeration of colors that can be fetched from a style.Each SynthStyle has a set of ColorTypes that are accessed by way of the SynthStyle.getColor(SynthContext, ColorType) method.SynthStyle's installDefaults will install the FOREGROUND color as the foreground of the Component, and the BACKGROUND color to the background of the component (assuming that you have not explicitly specified a foreground and background color).Some components support more color based properties, for example JList has the property selectionForeground which will be mapped to FOREGROUND with a component state of SynthConstants.The following example shows a custom SynthStyle that returns a red Color for the DISABLED state, otherwise a black color.class MyStyle extends SynthStyle { private Color disabledColor ="},
{"description": "Class ColorSupported is a printing attribute class, an enumeration, that identifies whether the device is capable of any type of color printing at all, including highlight color as well as full process color.All document instructions having to do with color are embedded within the print data (none are attributes attached to the job outside the print data).End users are able to determine the nature and details of the color support by querying the PrinterMoreInfoManufacturer attribute.Chromaticity is an attribute the client can specify for a job to tell the printer whether to print a document in monochrome or color, possibly causing the printer to print a color document in monochrome.ColorSupported is a printer description attribute that tells whether the printer can print in color regardless of how the client specifies to print any particular document.IPP Compatibility: The IPP boolean value is \"true\" for SUPPORTED and \"false\" for NOT_SUPPORTED.The category name returned by getName() is the IPP attribute name.The enumeration's integer value is the IPP enum value.The toString() method returns the IPP string representation of the attribute value."},
{"description": "This abstract class is used to serve as a color space tag to identify the specific color space of a Color object or, via a ColorModel object, of an Image, a BufferedImage, or a GraphicsDevice.It contains methods that transform colors in a specific color space to/from sRGB and to/from a well-defined CIEXYZ color space.For purposes of the methods in this class, colors are represented as arrays of color components represented as floats in a normalized range defined by each ColorSpace.For many ColorSpaces (e.g. sRGB), this range is 0.0 to 1.0.However, some ColorSpaces have components whose values have a different range.Methods are provided to inquire per component minimum and maximum normalized values.Several variables are defined for purposes of referring to color space types (e.g. TYPE_RGB, TYPE_XYZ, etc.) and to refer to specific color spaces (e.g. CS_sRGB and CS_CIEXYZ).sRGB is a proposed standard RGB color space.The purpose of the methods to transform to/from the well-defined CIEXYZ color space is to support conversions between any two color spaces at a reasonably high degree of accuracy.It is expected that particular implementations of subclasses of ColorSpace (e.g. ICC_ColorSpace) will support high performance conversion based on underlying platform color management systems.The CS_CIEXYZ space used by the toCIEXYZ/fromCIEXYZ methods can be described as follows:\u00a0 CIEXYZ\u00a0 viewing illuminance:For developers creating an ICC profile for this conversion\u00a0 space, the following is applicable.Use a simple Von Kries\u00a0 white point adaptation folded into the 3X3 matrix parameters\u00a0 and fold the flare and surround effects into the three\u00a0 one-dimensional lookup tables (assuming one uses the minimal\u00a0 model for monitors)."},
{"description": "A model that supports selecting a Color."},
{"description": "This class performs a pixel-by-pixel color conversion of the data in the source image.The resulting color values are scaled to the precision of the destination image.Color conversion can be specified via an array of ColorSpace objects or an array of ICC_Profile objects.If the source is a BufferedImage with premultiplied alpha, the color components are divided by the alpha component before color conversion.If the destination is a BufferedImage with premultiplied alpha, the color components are multiplied by the alpha component after conversion.Rasters are treated as having no alpha channel, i.e. all bands are color bands.If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used to control color conversion.Note that Source and Destination may be the same object."},
{"description": "The ColorModel abstract class encapsulates the methods for translating a pixel value to color components (for example, red, green, and blue) and an alpha component.In order to render an image to the screen, a printer, or another image, pixel values must be converted to color and alpha components.As arguments to or return values from methods of this class, pixels are represented as 32-bit ints or as arrays of primitive types.The number, order, and interpretation of color components for a ColorModel is specified by its ColorSpace.A ColorModel used with pixel data that does not include alpha information treats all pixels as opaque, which is an alpha value of 1.0.This ColorModel class supports two representations of pixel values.A pixel value can be a single 32-bit int or an array of primitive types.1.1 APIs represented pixels as single byte or single int values.For purposes of the ColorModel class, pixel value arguments were passed as ints.The Java(tm) 2 Platform API introduced additional classes for representing images.With BufferedImage or RenderedImage objects, based on Raster and SampleModel classes, pixel values might not be conveniently representable as a single int.Consequently, ColorModel now has methods that accept pixel values represented as arrays of primitive types.The primitive type used by a particular ColorModel object is called its transfer type.ColorModel objects used with images for which pixel values are not conveniently representable as a single int throw an IllegalArgumentException when methods taking a single int pixel argument are called.Subclasses of ColorModel must specify the conditions under which this occurs.This does not occur with DirectColorModel or IndexColorModel objects.Currently, the transfer types supported by the Java 2D(tm) API are DataBuffer.Most rendering operations will perform much faster when using ColorModels and images based on the first three of these types.In addition, some image filtering operations are not supported for ColorModels and images based on the latter three types.The transfer type for a particular ColorModel object is specified when the object is created, either explicitly or by default.All subclasses of ColorModel must specify what the possible transfer types are and how the number of elements in the primitive arrays representing pixels is determined.For BufferedImages, the transfer type of its Raster and of the Raster object's SampleModel (available from the getTransferType methods of these classes) must match that of the ColorModel.The number of elements in an array representing a pixel for the Raster and SampleModel (available from the getNumDataElements methods of these classes) must match that of the ColorModel.The algorithm used to convert from pixel values to color and alpha components varies by subclass.For example, there is not necessarily a one-to-one correspondence between samples obtained from the SampleModel of a BufferedImage object's Raster and color/alpha components.Even when there is such a correspondence, the number of bits in a sample is not necessarily the same as the number of bits in the corresponding color/alpha component.Each subclass must specify how the translation from pixel values to color/alpha components is done.Methods in the ColorModel class use two different representations of color and alpha components - a normalized form and an unnormalized form.In the normalized form, each component is a float value between some minimum and maximum values.For the alpha component, the minimum is 0.0 and the maximum is 1.0.For color components the minimum and maximum values for each component can be obtained from the ColorSpace object.These values will often be 0.0 and 1.0 (e.g. normalized component values for the default sRGB color space range from 0.0 to 1.0), but some color spaces have component values with different upper and lower limits.These limits can be obtained using the getMinValue and getMaxValue methods of the ColorSpace class.All ColorModels must support the normalized form.In the unnormalized form, each component is an unsigned integral value between 0 and 2n - 1, where n is the number of significant bits for a particular component.If pixel values for a particular ColorModel represent color samples premultiplied by the alpha sample, unnormalized color component values are also premultiplied.The unnormalized form is used only with instances of ColorModel whose ColorSpace has minimum component values of 0.0 for all components and maximum values of 1.0 for all components.The unnormalized form for color and alpha components can be a convenient representation for ColorModels whose normalized component values all lie between 0.0 and 1.0.In such cases the integral value 0 maps to 0.0 and the value 2n - 1 maps to 1.0.In other cases, such as when the normalized component values can be either negative or positive, the unnormalized form is not convenient.Such ColorModel objects throw an IllegalArgumentException when methods involving an unnormalized argument are called.Subclasses of ColorModel must specify the conditions under which this occurs."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The Color class is used to encapsulate colors in the default sRGB color space or colors in arbitrary color spaces identified by a ColorSpace.Every color has an implicit alpha value of 1.0 or an explicit one provided in the constructor.The alpha value defines the transparency of a color and can be represented by a float value in the range 0.0\u00a0-\u00a01.0 or 0\u00a0-\u00a0255.An alpha value of 1.0 or 255 means that the color is completely opaque and an alpha value of 0 or 0.0 means that the color is completely transparent.When constructing a Color with an explicit alpha or getting the color/alpha components of a Color, the color components are never premultiplied by the alpha component.API is sRGB, a proposed standard RGB color space."},
{"description": "Characteristics indicating properties of a Collector, which can be used to optimize reduction implementations."},
{"description": "This class consists exclusively of static methods that operate on or return collections.It contains polymorphic algorithms that operate on collections, \"wrappers\", which return a new collection backed by a specified collection, and a few other odds and ends.The methods of this class all throw a NullPointerException if the collections or class objects provided to them are null.The documentation for the polymorphic algorithms contained in this class generally includes a brief description of the implementation.Such descriptions should be regarded as implementation notes, rather than parts of the specification.Implementors should feel free to substitute other algorithms, so long as the specification itself is adhered to.(For example, the algorithm used by sort does not have to be a mergesort, but it does have to be stable.)The \"destructive\" algorithms contained in this class,that is, the algorithms that modify the collection on which they operate, are specified to throw UnsupportedOperationException if the collection does not support the appropriate mutation primitive(s), such as the set method.These algorithms may, but are not required to, throw this exception if an invocation would have no effect on the collection.For example, invoking the sort method on an unmodifiable list that is already sorted may or may not throw UnsupportedOperationException.This class is a member of the Java Collections Framework."},
{"description": "A mutable reduction operation that accumulates input elements into a mutable result container, optionally transforming the accumulated result into a final representation after all input elements have been processed.Reduction operations can be performed either sequentially or in parallel.Examples of mutable reduction operations include: accumulating elements into a Collection; concatenating strings using a StringBuilder; computing summary information about elements such as sum, min, max, or average; computing \"pivot table\" summaries such as \"maximum valued transaction by seller\", etc.The class Collectors provides implementations of many common mutable reductions.A Collector is specified by four functions that work together to accumulate entries into a mutable result container, and optionally perform a final transform on the result.They are: creation of a new result container (supplier()) incorporating a new data element into a result container (accumulator()) combining two result containers into one (combiner()) performing an optional final transform on the container (finisher())Collectors also have a set of characteristics, such as Collector.CONCURRENT, that provide hints that can be used by a reduction implementation to provide better performance.A sequential implementation of a reduction using a collector would create a single result container using the supplier function, and invoke the accumulator function once for each input element.A parallel implementation would partition the input, create a result container for each partition, accumulate the contents of each partition into a subresult for that partition, and then use the combiner function to merge the subresults into a combined result.To ensure that sequential and parallel executions produce equivalent results, the collector functions must satisfy an identity and an associativity constraints.The identity constraint says that for any partially accumulated result, combining it with an empty result container must produce an equivalent result.That is, for a partially accumulated result a that is the result of any series of accumulator and combiner invocations, a must be equivalent to combiner.apply(a, supplier.get()).The associativity constraint says that splitting the computation must produce an equivalent result.That is, for any input elements t1 and t2, the results r1 and r2 in the computation below must be equivalent: A a1 =// result without splitting A a2 =accumulator.accept(a3, t2); R r2 = finisher.apply(combiner.apply(a2, a3)); // result with splitting For collectors that do not have the UNORDERED characteristic, two accumulated results a1 and a2 are equivalent if finisher.apply(a1).equals(finisher.apply(a2)).For unordered collectors, equivalence is relaxed to allow for non-equality related to differences in order.(For example, an unordered collector that accumulated elements to a List would consider two lists equivalent if they contained the same elements, ignoring order.)Libraries that implement reduction based on Collector, such as Stream.collect(Collector), must adhere to the following constraints: The first argument passed to the accumulator function, both arguments passed to the combiner function, and the argument passed to the finisher function must be the result of a previous invocation of the result supplier, accumulator, or combiner functions.The implementation should not do anything with the result of any of the result supplier, accumulator, or combiner functions other than to pass them again to the accumulator, combiner, or finisher functions, or return them to the caller of the reduction operation.If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again.Once a result is passed to the combiner or finisher function, it is never passed to the accumulator function again.For non-concurrent collectors, any result returned from the result supplier, accumulator, or combiner functions must be serially thread-confined.This enables collection to occur in parallel without the Collector needing to implement any additional synchronization.The reduction implementation must manage that the input is properly partitioned, that partitions are processed in isolation, and combining happens only after accumulation is complete.For concurrent collectors, an implementation is free to (but not required to) implement reduction concurrently.A concurrent reduction is one where the accumulator function is called concurrently from multiple threads, using the same concurrently-modifiable result container, rather than keeping the result isolated during accumulation.A concurrent reduction should only be applied if the collector has the Collector.For example, you could create a collector that accumulates widgets into a TreeSet with: Collector<Widget, ?, TreeSet<Widget>> { left.addAll(right); return left; }); (This behavior is also implemented by the predefined collector Collectors.toCollection(Supplier))."},
{"description": "Implementations of Collector that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc.The following are examples of using the predefined collectors to perform common mutable reduction tasks: //; // Convert elements to strings and concatenate them, separated by commas String joined = things.stream() .map(Object::toString) .collect(Collectors.joining"},
{"description": "A collection represents a group of objects, known as its elements.The JDK does not provide any direct implementations of this interface: it provides implementations of more specific subinterfaces like Set and List.This interface is typically used to pass collections around and manipulate them where maximum generality is desired.Bags or multisets (unordered collections that may contain duplicate elements) should implement this interface directly.All general-purpose Collection implementation classes (which typically implement Collection indirectly through one of its subinterfaces) should provide two \"standard\" constructors: a void (no arguments) constructor, which creates an empty collection, and a constructor with a single argument of type Collection, which creates a new collection with the same elements as its argument.In effect, the latter constructor allows the user to copy any collection, producing an equivalent collection of the desired implementation type.There is no way to enforce this convention (as interfaces cannot contain constructors) but all of the general-purpose Collection implementations in the Java platform libraries comply.The \"destructive\" methods contained in this interface, that is, the methods that modify the collection on which they operate, are specified to throw UnsupportedOperationException if this collection does not support the operation.If this is the case, these methods may, but are not required to, throw an UnsupportedOperationException if the invocation would have no effect on the collection.For example, invoking the addAll(Collection) method on an unmodifiable collection may, but is not required to, throw the exception if the collection to be added is empty.Some collection implementations have restrictions on the elements that they may contain.For example, some implementations prohibit null elements, and some have restrictions on the types of their elements.Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException.Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter.More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the collection may throw an exception or it may succeed, at the option of the implementation.Such exceptions are marked as \"optional\" in the specification for this interface.It is up to each collection to determine its own synchronization policy.In the absence of a stronger guarantee by the implementation, undefined behavior may result from the invocation of any method on a collection that is being mutated by another thread; this includes direct invocations, passing the collection to a method that might perform invocations, and using an existing iterator to examine the collection.Many methods in Collections Framework interfaces are defined in terms of the equals method.For example, the specification for the contains(Object o) method says: \"returns true if and only if this collection contains at least one element e\" This specification should not be construed to imply that invoking Collection.contains with a non-null argument o will cause o.equals(e) to be invoked for any element e. Implementations are free to implement optimizations whereby the equals invocation is avoided, for example, by first comparing the hash codes of the two elements.(The Object.hashCode() specification guarantees that two objects with unequal hash codes cannot be equal.)More generally, implementations of the various Collections Framework interfaces are free to take advantage of the specified behavior of underlying Object methods wherever the implementor deems it appropriate.Some collection operations which perform recursive traversal of the collection may fail with an exception for self-referential instances where the collection directly or indirectly contains itself.This includes the clone(), equals(), hashCode() and toString() methods.Implementations may optionally handle the self-referential scenario, however most current implementations do not do so.This interface is a member of the Java Collections Framework."},
{"description": "Parameters used as input for the Collection CertStore algorithm.This class is used to provide necessary configuration parameters to implementations of the Collection CertStore algorithm.The only parameter included in this class is the Collection from which the CertStore will retrieve certificates and CRLs.Unless otherwise specified, the methods defined in this class are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "An abstract class for service providers that provide concrete implementations of the Collator class."},
{"description": "The CollationElementIterator class is used as an iterator to walk through each character of an international string.The ordering priority of a character, which we refer to as a key, defines how a character is collated in the given collation object.For example, consider the following in Spanish: \"ca\" \u2192 the first key is key('c') and second key is key('a').\"cha\" \u2192 the first key is key('ch') and second key is key('a').And in German, \"\u00e4b\" \u2192 the first key is key('a'), the second key is key('e'), and the third key is key('b').The key of a character is an integer composed of primary order(short), secondary order(byte), and tertiary order(byte).Java strictly defines the size and signedness of its primitive data types.\"This is a test\"; Collator col = Collator.getInstance(); if (col instanceof RuleBasedCollator) { RuleBasedCollator ruleBasedCollator =; int primaryOrder = CollationElementIterator.primaryOrder(collationElementIterator.next()); : } CollationElementIterator.next returns the collation order of the next character.A collation order consists of primary order, secondary order and tertiary order.The data type of the collation order is int.The first 16 bits of a collation order is its primary order; the next 8 bits is the secondary order and the last 8 bits is the tertiary order.It is only usable with RuleBasedCollator instances."},
{"description": "Instances of this class are used to specify how malformed-input and unmappable-character errors are to be handled by charset decoders and encoders."},
{"description": "The Collator class performs locale-sensitive String comparison.You use this class to build searching and sorting routines for natural language text.Collator is an abstract base class.Subclasses implement specific collation strategies.One subclass, RuleBasedCollator, is currently provided with the Java Platform and is applicable to a wide set of languages.Other subclasses may be created to handle more specialized needs.Like other locale-sensitive classes, you can use the static factory method, getInstance, to obtain the appropriate Collator object for a given locale.You will only need to look at the subclasses of Collator if you need to understand the details of a particular collation strategy or if you need to modify that strategy.The following example shows how to compare two strings using the Collator for the default locale.(); if( myCollator.compare(\"abc\", \"ABC\") < 0 ) System.out.println(\"abc is less than ABC\"); else System.out.println(\"abc is greater than or equal to ABC\"); You can set a Collator's strength property to determine the level of difference considered significant in comparisons.The exact assignment of strengths to language features is locale dependant.For example, in Czech, \"e\" and \"f\" are considered primary differences, while \"e\" and \"\u011b\" are secondary differences, \"e\" and \"E\" are tertiary differences and \"e\" and \"e\"The following shows how both case and accents could be ignored for US English.= 0 ) { System.out.println(\"Strings are equivalent\"); } For comparing Strings exactly once, the compare method provides the best performance.When sorting a list of Strings however, it is generally necessary to compare each String multiple times.In this case, CollationKeys provide better performance.The CollationKey class converts a String to a series of bits that can be compared bitwise against other CollationKeys.A CollationKey is created by a Collator object for a given String.Note: CollationKeys from different Collators can not be compared."},
{"description": "A CollationKey represents a String under the rules of a specific Collator object.Comparing two CollationKeys returns the relative order of the Strings they represent.Using CollationKeys to compare Strings is generally faster than using Collator.compare.Thus, when the Strings must be compared multiple times, for example when sorting a list of Strings.It's more efficient to use CollationKeys.You can not create CollationKeys directly.You can only compare CollationKeys generated from the same Collator object.Generating a CollationKey for a String involves examining the entire String and converting it to series of bits that can be compared bitwise.This allows fast comparisons once the keys are generated.The cost of generating keys is recouped in faster comparisons when Strings need to be compared many times.On the other hand, the result of a comparison is often determined by the first couple of characters of each String.Collator.compare examines only as many characters as it needs which allows it to be faster when doing single comparisons.The following example shows how CollationKeys might be used to sort a list of Strings.Collator myCollator = Collator.getInstance(); CollationKey[] keys = new CollationKey[3]Inside body of sort routine, compare keys this way if (keys[i].compareTo(keys[j])Finally, when we've returned from sort."},
{"description": "This adapter removes leading and trailing whitespaces, then truncate any sequnce of tab, CR, LF, and SP by a single whitespace character ' '."},
{"description": "This class encapsulates information about a code signer."},
{"description": "This class extends the concept of a codebase to encapsulate not only the location (URL) but also the certificate chains that were used to verify signed code originating from that location."},
{"description": "This exception is raised whenever meaningful communication is not possible between client and server native code sets."},
{"description": "A charset coder, that is, either a decoder or an encoder, consumes bytes (or characters) from an input buffer, translates them, and writes the resulting characters (or bytes) to an output buffer.A coding process terminates for one of four categories of reasons, which are described by instances of this class: Underflow is reported when there is no more input to be processed, or there is insufficient input and additional input is required.This condition is represented by the unique result object UNDERFLOW, whose isUnderflow method returns true.Overflow is reported when there is insufficient room remaining in the output buffer.This condition is represented by the unique result object OVERFLOW, whose isOverflow method returns true.A malformed-input error is reported when a sequence of input units is not well-formed.Such errors are described by instances of this class whose isMalformed method returns true and whose length method returns the length of the malformed sequence.There is one unique instance of this class for all malformed-input errors of a given length.An unmappable-character error is reported when a sequence of input units denotes a character that cannot be represented in the output charset.Such errors are described by instances of this class whose isUnmappable method returns true and whose length method returns the length of the input sequence denoting the unmappable character.There is one unique instance of this class for all unmappable-character errors of a given length.For convenience, the isError method returns true for result objects that describe malformed-input and unmappable-character errors but false for those that describe underflow or overflow conditions."},
{"description": "Codecs are obtained from the CodecFactory.The CodecFactory is obtained through a call to ORB.resolve_initial_references( \"CodecFactory\" )."},
{"description": "Codecs are obtained from the CodecFactory.The CodecFactory is obtained through a call to ORB.resolve_initial_references( \"CodecFactory\" )."},
{"description": "Codecs are obtained from the CodecFactory.The CodecFactory is obtained through a call to ORB.resolve_initial_references( \"CodecFactory\" )."},
{"description": "Error thrown when the decodeLoop method of a CharsetDecoder, or the encodeLoop method of a CharsetEncoder, throws an unexpected exception."},
{"description": "The formats of IOR components and service context data used by ORB services are often defined as CDR encapsulations encoding instances of IDL defined data types.The Codec provides a mechanism to transfer these components between their IDL data types and their CDR encapsulation representations.A Codec is obtained from the CodecFactory.The CodecFactory is obtained through a call to ORB.resolve_initial_references( \"CodecFactory\" )."},
{"description": "The formats of IOR components and service context data used by ORB services are often defined as CDR encapsulations encoding instances of IDL defined data types.The Codec provides a mechanism to transfer these components between their IDL data types and their CDR encapsulation representations.A Codec is obtained from the CodecFactory.The CodecFactory is obtained through a call to ORB.resolve_initial_references( \"CodecFactory\" )."},
{"description": "This exception is thrown if the native CMM returns an error."},
{"description": "Unchecked exception thrown when an attempt is made to invoke an operation on a directory stream that is closed."},
{"description": "Unchecked exception thrown when an attempt is made to invoke an operation on a file and the file system is closed."},
{"description": "Checked exception received by a thread when another thread interrupts it while it is blocked in an I/O operation upon a channel.Before this exception is thrown the channel will have been closed and the interrupt status of the previously-blocked thread will have been set."},
{"description": "Checked exception thrown when an attempt is made to invoke or complete an I/O operation upon channel that is closed, or at least closed to that operation.A socket channel whose write half has been shut down, for example, may still be open for reading."},
{"description": "Unchecked exception thrown when an attempt is made to invoke an I/O operation upon a closed selector."},
{"description": "Unchecked exception thrown when an attempt is made to invoke an operation on a watch service that is closed."},
{"description": "A Closeable is a source or destination of data that can be closed.The close method is invoked to release resources that the object is holding (such as open files)."},
{"description": "An SQL CLOB is a built-in type that stores a Character Large Object as a column value in a row of a database table.By default drivers implement a Clob object using an SQL locator(CLOB), which means that a Clob object contains a logical pointer to the SQL CLOB data rather than the data itself.A Clob object is valid for the duration of the transaction in which it was created.The Clob interface provides methods for getting the length of an SQL CLOB (Character Large Object) value, for materializing a CLOB value on the client, and for searching for a substring or CLOB object within a CLOB value.Methods in the interfaces ResultSet, CallableStatement, and PreparedStatement, such as getClob and setClob allow a programmer to access an SQL CLOB value.In addition, this interface has methods for updating a CLOB value.All methods on the Clob interface must be fully implemented if the JDBC driver supports the data type."},
{"description": "Defines the interface for classes that will provide data to a clipboard.An instance of this interface becomes the owner of the contents of a clipboard (clipboard owner) if it is passed as an argument to Clipboard.setContents(java.awt.datatransfer.Transferable, java.awt.datatransfer.ClipboardOwner) method of the clipboard and this method returns successfully.The instance remains the clipboard owner until another application or another object within this application asserts ownership of this clipboard."},
{"description": "A class that implements a mechanism to transfer data using cut/copy/paste operations.FlavorListeners may be registered on an instance of the Clipboard class to be notified about changes to the set of DataFlavors available on this clipboard (see addFlavorListener(java.awt.datatransfer."},
{"description": "The Clip interface represents a special kind of data line whose audio data can be loaded prior to playback, instead of being streamed in real time.Because the data is pre-loaded and has a known length, you can set a clip to start playing at any position in its audio data.You can also create a loop, so that when the clip is played it will cycle repeatedly.Loops are specified with a starting and ending sample frame, along with the number of times that the loop should be played.Clips may be obtained from a Mixer that supports lines of this type.Data is loaded into a clip when it is opened.Playback of an audio clip may be started and stopped using the start and stop methods.These methods do not reset the media position; start causes playback to continue from the position where playback was last stopped.To restart playback from the beginning of the clip's audio data, simply follow the invocation of stop with setFramePosition(0), which rewinds the media to the beginning of the clip."},
{"description": "A class implements the Cloneable interface to indicate to the Object.clone() method that it is legal for that method to make a field-for-field copy of instances of that class.Invoking Object's clone method on an instance that does not implement the Cloneable interface results in the exception CloneNotSupportedException being thrown.By convention, classes that implement this interface should override Object.clone (which is protected) with a public method.Note that this interface does not contain the clone method.Therefore, it is not possible to clone an object merely by virtue of the fact that it implements this interface.Even if the clone method is invoked reflectively, there is no guarantee that it will succeed."},
{"description": "Instances of this class are used to find the current instant, which can be interpreted using the stored time-zone to find the current date and time.Use of a Clock is optional.All key date-time classes also have a now() factory method that uses the system clock in the default time zone.The primary purpose of this abstraction is to allow alternate clocks to be plugged in as and when required.Applications use an object to obtain the current time rather than a static method.This can simplify testing.Best practice for applications is to pass a Clock into any method that requires the current instant.A dependency injection framework is one way to achieve this: public class MyBean { private Clock clock; // dependency inject ...{ if (eventDate.isBefore(LocalDate.now(clock)) { ... } } } This approach allows an alternate clock, such as fixed or offset to be used during testing.The system factory methods provide clocks based on the best available system clockThis may use System.currentTimeMillis(), or a higher resolution clock if one is available."},
{"description": "Thrown to indicate that the clone method in class Object has been called to clone an object, but that the object's class does not implement the Cloneable interface.Applications that override the clone method can also throw this exception to indicate that an object could not or should not be cloned."},
{"description": "A request Interceptor is designed to intercept the flow of a request/reply sequence through the ORB at specific points so that services can query the request information and manipulate the service contexts which are propagated between clients and servers.The primary use of request Interceptors is to enable ORB services to transfer context information between clients and servers.There are two types of request Interceptors: client-side and server-side."},
{"description": "Some attributes and operations on ClientRequestInfo are not valid at all interception points.The following table shows the validity of each attribute or operation.If it is not valid, attempting to access it will result in a BAD_INV_ORDER being thrown with a standard minor code of 14. \u00a0 send_request send_poll receive_reply receive_exception receive_other Inherited from RequestInfo: request_id yesWhen ClientRequestInfo is passed to send_request, there is an entry in the list for every argument, whether in, inout, or out.If the reply_status atribute is not LOCATION_FORWARD, accessing this attribute will throw BAD_INV_ORDER with a standard minor code of 14."},
{"description": "A Java virtual machine has a single instance of the implementation class of this interface.This instance implementing this interface is an MXBean that can be obtained by calling the ManagementFactory.getClassLoadingMXBean() method or from the platform MBeanServer.The ObjectName for uniquely identifying the MXBean for the class loading system within an MBeanServer is: java.lang:type=ClassLoadingIt can be obtained by calling the PlatformManagedObject.getObjectName() method."},
{"description": "Enumeration for status of the reason that a property could not be set via a call to Connection.setClientInfo"},
{"description": "For example, if a dynamic language needs to construct a message dispatch table for each class encountered at a message send call site, it can use a ClassValue to cache information needed to perform the message send quickly, for each class encountered."},
{"description": "Thrown when an application tries to load in a class through its string name using: The forName method in class Class.but no definition for the class with the specified name could be found.As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.The \"optional exception that was raised while loading the class\" that may be provided at construction time and accessed via the getException() method is now known as the cause, and may be accessed via the Throwable.getCause() method, as well as the aforementioned \"legacy method.\""},
{"description": "A request Interceptor is designed to intercept the flow of a request/reply sequence through the ORB at specific points so that services can query the request information and manipulate the service contexts which are propagated between clients and servers.The primary use of request Interceptors is to enable ORB services to transfer context information between clients and servers.There are two types of request Interceptors: client-side and server-side."},
{"description": "Some attributes and operations on ClientRequestInfo are not valid at all interception points.The following table shows the validity of each attribute or operation.If it is not valid, attempting to access it will result in a BAD_INV_ORDER being thrown with a standard minor code of 14. \u00a0 send_request send_poll receive_reply receive_exception receive_other Inherited from RequestInfo: request_id yesWhen ClientRequestInfo is passed to send_request, there is an entry in the list for every argument, whether in, inout, or out.If the reply_status atribute is not LOCATION_FORWARD, accessing this attribute will throw BAD_INV_ORDER with a standard minor code of 14."},
{"description": "Instances of this interface are used to keep the list of ClassLoaders registered in an MBean Server.They provide the necessary methods to load classes using the registered ClassLoaders.The first ClassLoader in a ClassLoaderRepository is always the MBean Server's own ClassLoader.When an MBean is registered in an MBean Server, if it is of a subclass of ClassLoader and if it does not implement the interface PrivateClassLoader, it is added to the end of the MBean Server's ClassLoaderRepository.If it is subsequently unregistered from the MBean Server, it is removed from the ClassLoaderRepository.The order of MBeans in the ClassLoaderRepository is significant.For any two MBeans X and Y in the ClassLoaderRepository, X must appear before Y if the registration of X was completed before the registration of Y started."},
{"description": "A class loader is an object that is responsible for loading classes.The class ClassLoader is an abstract class.Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class.A typical strategy is to transform the name into a file name and then read a \"class file\" of that name from a file system.Every Class object contains a reference to the ClassLoader that defined it.Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime.The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.Applications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes.Class loaders may typically be used by security managers to indicate security domains.The ClassLoader class uses a delegation model to search for classes and resources.Each instance of ClassLoader has an associated parent class loader.When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself.The virtual machine's built-in class loader, called the \"bootstrap class loader\", does not itself have a parent but may serve as the parent of a ClassLoader instance.Class loaders that support concurrent loading of classes are known as parallel capable class loaders and are required to register themselves at their class initialization time by invoking the ClassLoader.registerAsParallelCapable method.Note that the ClassLoader class is registered as parallel capable by default.However, its subclasses still need to register themselves if they are parallel capable.In environments in which the delegation model is not strictly hierarchical, class loaders need to be parallel capable, otherwise class loading can lead to deadlocks because the loader lock is held for the duration of the class loading process (see loadClass methods).Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner.For example, on UNIX systems, the virtual machine loads classes from the directory defined by the CLASSPATH environment variable.However, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application.The method defineClass converts an array of bytes into an instance of class Class.Instances of this newly defined class can be created using Class.newInstance.The methods and constructors of objects created by a class loader may reference other classes.To determine the class(es) referred to, the Java virtual machine invokes the loadClass method of the class loader that originally created the class.For example, an application could create a network class loader to download class files from a server.Sample code might look like: ClassLoader loader\u00a0= new NetworkClassLoader(host,\u00a0port); Object main\u00a0= loader.loadClass(\"Main\", true).newInstanceThe network class loader subclass must define the methods findClass and loadClassData to load a class from the network.Once it has downloaded the bytes that make up the class, it should use the method defineClass to create a class instance.A sample implementation is: class NetworkClassLoader extends ClassLoader { String host; int port; public Class findClass(String name) { byte[] b = loadClassData(name); return defineClass(name, b, 0, b.length); } private byte[] loadClassData(String name) {} Binary names Any class name provided as a String parameter to methods in ClassLoader must be a binary name as defined by The Java\u2122 Language Specification.Examples of valid class names include: \"java.lang.String\" \"javax.swing.JSpinner$DefaultEditor\""},
{"description": "Thrown when the Java Virtual Machine attempts to read a class file and determines that the file is malformed or otherwise cannot be interpreted as a class file."},
{"description": "An agent provides an implementation of this interface in order to transform class files.The transformation occurs before the class is defined by the JVM.Note the term class file is used as defined in section 3.1 of The Java\u2122 Virtual Machine Specification, to mean a sequence of bytes in class file format, whether or not they reside in a file."},
{"description": "This class is used to marshal java.lang.Class objects over IIOP."},
{"description": "This class serves as a parameter block to the Instrumentation.redefineClasses method.Serves to bind the Class that needs redefining together with the new class file bytes."},
{"description": "Thrown to indicate that the code has attempted to cast an object to a subclass of which it is not an instance.For example, the following code generates a ClassCastException:"},
{"description": "Thrown when the Java Virtual Machine detects a circularity in the superclass hierarchy of a class being loaded."},
{"description": "Instances of the class Class represent classes and interfaces in a running Java application.An enum is a kind of class and an annotation is a kind of interface.Every array also belongs to a class that is reflected as a Class object that is shared by all arrays with the same element type and number of dimensions.The primitive Java types (boolean, byte, char, short, int, long, float, and double), and the keyword void are also represented as Class objects.Class has no public constructor.Instead Class objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the defineClass method in the class loader.The following example uses a Class object to print the class name of an object: void printClassName(Object obj) { System.out.println(\"The class of \" + obj+ \" is \" + obj.getClass().getName()); } It is also possible to get the Class object for a named type (or for void) using a class literal.For example: System.out.println(\"The name of class Foo is: \"+Foo.class.getName());"},
{"description": "This class defines the Service Provider Interface (SPI) for the Cipher class.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular cipher algorithm.In order to create an instance of Cipher, which encapsulates an instance of this CipherSpi class, an application calls one of the getInstance factory methods of the Cipher engine class and specifies the requested transformation.Optionally, the application may also specify the name of a provider.A transformation is a string that describes the operation (or set of operations) to be performed on the given input, to produce some output.A transformation always includes the name of a cryptographic algorithm (e.g., AES), and may be followed by a feedback mode and padding scheme.A transformation is of the form:\"algorithm/mode/padding\" or \"algorithm\" (in the latter case, provider-specific default values for the mode and padding scheme are used).For example, the following is a valid transformation:Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); A provider may supply a separate class for each combination of algorithm/mode/padding, or may decide to provide more generic classes representing sub-transformations corresponding to algorithm or algorithm/mode or algorithm//padding (note the double slashes), in which case the requested mode and/or padding are set automatically by the getInstance methods of Cipher, which invoke the engineSetMode and engineSetPadding methods of the provider's subclass of CipherSpi.A Cipher property in a provider master class may have one of the following formats: // provider's subclass of \"CipherSpi\" implements \"algName\" with // pluggable mode and padding Cipher.algName // provider's subclass of \"CipherSpi\" implements \"algName\" in the // specified \"mode\", with pluggable padding Cipher.algName/mode // provider's subclass of \"CipherSpi\" implements \"algName\" with the // specified \"padding\", with pluggable mode Cipher.algName//padding // provider's subclass of \"CipherSpi\" implements \"algName\" with the // specified \"mode\" and \"padding\"For example, a provider may supply a subclass of CipherSpi that implements AES/ECB/PKCS5Padding, one that implements AES/CBC/PKCS5Padding, one that implements AES/CFB/PKCS5Padding, and yet another one that implements AES/OFB/PKCS5Padding.That provider would have the following Cipher properties in its master class: Cipher.Another provider may implement a class for each of the above modes (i.e., one class for ECB, one for CBC, one for CFB, and one for OFB), one class for PKCS5Padding, and a generic AES class that subclasses from CipherSpi.That provider would have the following Cipher properties in its master class: Cipher.AES The getInstance factory method of the Cipher engine class follows these rules in order to instantiate a provider's implementation of CipherSpi for a transformation of the form \"algorithm\":Check if the provider has registered a subclass of CipherSpi for the specified \"algorithm\".If the answer is YES, instantiate this class, for whose mode and padding scheme default values (as supplied by the provider) are used.If the answer is NO, throw a NoSuchAlgorithmException exception.The getInstance factory method of the Cipher engine class follows these rules in order to instantiate a provider's implementation of CipherSpi for a transformation of the form \"algorithm/mode/padding\":Check if the provider has registered a subclass of CipherSpi for the specified \"algorithm/mode/padding\" transformation.If the answer is YES, instantiate it.If the answer is NO, go to the next step.Check if the provider has registered a subclass of CipherSpi for the sub-transformation \"algorithm/mode\".If the answer is YES, instantiate it, and call engineSetPadding(padding) on the new instance.If the answer is NO, go to the next step.Check if the provider has registered a subclass of CipherSpi for the sub-transformation \"algorithm//padding\" (note the double slashes).If the answer is YES, instantiate it, and call engineSetMode(mode) on the new instance.If the answer is NO, go to the next step.Check if the provider has registered a subclass of CipherSpi for the sub-transformation \"algorithm\".If the answer is YES, instantiate it, and call engineSetMode(mode) and engineSetPadding(padding) on the new instance.If the answer is NO, throw a NoSuchAlgorithmException exception."},
{"description": "A CipherOutputStream is composed of an OutputStream and a Cipher so that write() methods first process the data before writing them out to the underlying OutputStream.The cipher must be fully initialized before being used by a CipherOutputStream.For example, if the cipher is initialized for encryption, the CipherOutputStream will attempt to encrypt data before writing out the encrypted data.This class has exactly those methods specified in its ancestor classes, and overrides them all.Moreover, this class catches all exceptions that are not thrown by its ancestor classes.In particular, this class catches BadPaddingException and other exceptions thrown by failed integrity checks during decryption.Because of this behavior, this class may not be suitable for use with decryption in an authenticated mode of operation (e.g. GCM) if the application requires explicit notification when authentication fails.Such an application can use the Cipher API directly as an alternative to using this class.It is crucial for a programmer using this class not to use methods that are not defined or overriden in this class (such as a new method or constructor that is later added to one of the super classes), because the design and implementation of those methods are unlikely to have considered security impact with regard to CipherOutputStream."},
{"description": "A CipherInputStream is composed of an InputStream and a Cipherso that read() methods return data that are read in from the underlying InputStream but have been additionally processed by the Cipher.The Cipher must be fully initialized before being used by a CipherInputStream.For example, if the Cipher is initialized for decryption, the CipherInputStream will attempt to read in data and decrypt them, before returning the decrypted data.This class has exactly those methods specified in its ancestor classes, and overrides them all.Moreover, this class catches all exceptions that are not thrown by its ancestor classes.In particular, the skip method skips, and the available method counts only data that have been processed by the encapsulated Cipher.This class may catch BadPaddingException and other exceptions thrown by failed integrity checks during decryption.Because of this behavior, this class may not be suitable for use with decryption in an authenticated mode of operation (e.g. GCM).Applications that require authenticated encryption can use the Cipher API directly as an alternative to using this class.It is crucial for a programmer using this class not to use methods that are not defined or overriden in this class (such as a new method or constructor that is later added to one of the super classes), because the design and implementation of those methods are unlikely to have considered security impact with regard to CipherInputStream."},
{"description": "This set of units provide unit-based access to manipulate a date, time or date-time.The standard set of units can be extended by implementing TemporalUnit.These units are intended to be applicable in multiple calendar systems.For example, most non-ISO calendar systems define units of years, months and days, just with slightly different rules.The documentation of each unit explains how it operates."},
{"description": "This class provides the functionality of a cryptographic cipher for encryption and decryption.It forms the core of the Java Cryptographic Extension (JCE) framework.In order to create a Cipher object, the application calls the Cipher's getInstance method, and passes the name of the requested transformation to it.Optionally, the name of a provider may be specified.A transformation is a string that describes the operation (or set of operations) to be performed on the given input, to produce some output.A transformation always includes the name of a cryptographic algorithm (e.g., AES), and may be followed by a feedback mode and padding scheme.A transformation is of the form:\"algorithm/mode/padding\" or \"algorithm\" (in the latter case, provider-specific default values for the mode and padding scheme are used).For example, the following is a valid transformation:Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); Using modes such as CFB and OFB, block ciphers can encrypt data in units smaller than the cipher's actual block size.When requesting such a mode, you may optionally specify the number of bits to be processed at a time by appending this number to the mode name as shown in the \"AES/CFB8/NoPadding\" and \"AES/OFB32/PKCS5Padding\" transformations.Thus, block ciphers can be turned into byte-oriented stream ciphers by using an 8 bit mode such as CFB8 or OFB8.Modes such as Authenticated Encryption with Associated Data (AEAD) provide authenticity assurances for both confidential data and Additional Associated Data (AAD) that is not encrypted.Both confidential and AAD data can be used when calculating the authentication tag (similar to a Mac).This tag is appended to the ciphertext during encryption, and is verified on decryption.AEAD modes such as GCM/CCM perform all AAD authenticity calculations before starting the ciphertext authenticity calculations.To avoid implementations having to internally buffer ciphertext, all AAD data must be supplied to GCM/CCM implementations (via the updateAAD methods) before the ciphertext is processed (via the update and doFinal methods).Note that GCM mode has a uniqueness requirement on IVs used in encryption with a given key.When IVs are repeated for GCM encryption, such usages are subject to forgery attacks.Thus, after each encryption operation using GCM mode, callers should re-initialize the cipher objects with GCM parameters which has a different IV value.GCMParameterSpec s = ...; cipher.init(..., s); // If the GCM parameters were generated by the provider, it can // be retrieved by: // cipher.getParameters().getParameterSpec(GCMParameterSpec.class); cipher.updateAAD(...);Every implementation of the Java platform is required to support the following standard Cipher transformations with the keysizes in parentheses: AES/CBC/NoPadding (128) AES/CBC/PKCS5PaddingThese transformations are described in the Cipher section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other transformations are supported."},
{"description": "Most applications should declare method signatures, fields and variables as ZonedDateTime, not this interface.A ChronoZonedDateTime is the abstract representation of an offset date-time where the Chronology chronology, or calendar system, is pluggable.The date-time is defined in terms of fields expressed by TemporalField, where most common implementations are defined in ChronoField.The chronology defines how the calendar system operates and the meaning of the standard fields.When to use this interface The design of the API encourages the use of ZonedDateTime rather than this interface, even in the case where the application needs to deal with multiple calendar systems.The rationale for this is explored in detail in ChronoLocalDate.Ensure that the discussion in ChronoLocalDate has been read and understood before using this interface."},
{"description": "This interface models a date-based amount of time in a calendar system.While most calendar systems use years, months and days, some do not.Therefore, this interface operates solely in terms of a set of supported units that are defined by the Chronology.The set of supported units is fixed for a given chronology.The amount of a supported unit may be set to zero.The period is modeled as a directed amount of time, meaning that individual parts of the period may be negative."},
{"description": "This set of fields provide field-based access to manipulate a date, time or date-time.The standard set of fields can be extended by implementing TemporalField.These fields are intended to be applicable in multiple calendar systems.For example, most non-ISO calendar systems define dates as a year, month and day, just with slightly different rules.The documentation of each field explains how it operates."},
{"description": "Most applications should declare method signatures, fields and variables as LocalDate, not this interface.A ChronoLocalDate is the abstract representation of a date where the Chronology chronology, or calendar system, is pluggable.The date is defined in terms of fields expressed by TemporalField, where most common implementations are defined in ChronoField.The chronology defines how the calendar system operates and the meaning of the standard fields.When to use this interface The design of the API encourages the use of LocalDate rather than this interface, even in the case where the application needs to deal with multiple calendar systems.This concept can seem surprising at first, as the natural way to globalize an application might initially appear to be to abstract the calendar system.However, as explored below, abstracting the calendar system is usually the wrong approach, resulting in logic errors and hard to find bugs.As such, it should be considered an application-wide architectural decision to choose to use this interface as opposed to LocalDate.Architectural issues to consider These are some of the points that must be considered before using this interface throughout an application.This is because the calendar system in use is not known at development time.A key cause of bugs is where the developer applies assumptions from their day-to-day knowledge of the ISO calendar system to code that is intended to deal with any arbitrary calendar system.The section below outlines how those assumptions can cause problems The primary mechanism for reducing this increased risk of bugs is a strong code review process.This should also be considered a extra cost in maintenance for the lifetime of the code.This interface does not enforce immutability of implementations.While the implementation notes indicate that all implementations must be immutable there is nothing in the code or type system to enforce this.Any method declared to accept a ChronoLocalDate could therefore be passed a poorly or maliciously written mutable implementation.3) Applications using this interface must consider the impact of eras.LocalDate shields users from the concept of eras, by ensuring that getYear() returns the proleptic year.That decision ensures that developers can think of LocalDate instances as consisting of three fields - year, month-of-year and day-of-month.By contrast, users of this interface must think of dates as consisting of four fields - era, year-of-era, month-of-year and day-of-month.The extra era field is frequently forgotten, yet it is of vital importance to dates in an arbitrary calendar system.For example, in the Japanese calendar system, the era represents the reign of an Emperor.Whenever one reign ends and another starts, the year-of-era is reset to one.The only agreed international standard for passing a date between two systems is the ISO-8601 standard which requires the ISO calendar system.Using this interface throughout the application will inevitably lead to the requirement to pass the date across a network or component boundary, requiring an application specific protocol or format.Long term persistence, such as a database, will almost always only accept dates in the ISO-8601 calendar system (or the related Julian-Gregorian).Passing around dates in other calendar systems increases the complications of interacting with persistence.Most of the time, passing a ChronoLocalDate throughout an application is unnecessary, as discussed in the last section below.False assumptions causing bugs in multi-calendar system code As indicated above, there are many issues to consider when try to use and manipulate a date in an arbitrary calendar system.These are some of the key issues.Code that queries the day-of-month and assumes that the value will never be more than 31 is invalid.Some calendar systems have more than 31 days in some months.Code that adds 12 months to a date and assumes that a year has been added is invalid.Some calendar systems have a different number of months, such as 13 in the Coptic or Ethiopic.Code that adds one month to a date and assumes that the month-of-year value will increase by one or wrap to the next year is invalid.Some calendar systems have a variable number of months in a year, such as the Hebrew.Code that adds one month, then adds a second one month and assumes that the day-of-month will remain close to its original value is invalid.Some calendar systems have a large difference between the length of the longest month and the length of the shortest month.For example, the Coptic or Ethiopic have 12 months of 30 days and 1 month of 5 days.Code that adds seven days and assumes that a week has been added is invalid.Some calendar systems have weeks of other than seven days, such as the French Revolutionary.Code that assumes that because the year of date1 is greater than the year of date2 then date1 is after date2 is invalid.This is invalid for all calendar systems when referring to the year-of-era, and especially untrue of the Japanese calendar system where the year-of-era restarts with the reign of every new Emperor.Code that treats month-of-year one and day-of-month one as the start of the year is invalid.Not all calendar systems start the year when the month value is one.In general, manipulating a date, and even querying a date, is wide open to bugs when the calendar system is unknown at development time.This is why it is essential that code using this interface is subjected to additional code reviews.It is also why an architectural decision to avoid this interface type is usually the correct one.Using LocalDate instead The primary alternative to using this interface throughout your application is as follows.Declare all method signatures referring to dates in terms of LocalDate.Either store the chronology (calendar system) in the user profile or lookup the chronology from the user locale Convert the ISO LocalDate to and from the user's preferred calendar system during printing and parsing This approach treats the problem of globalized calendar systems as a localization issue and confines it to the UI layer.This approach is in keeping with other localization issues in the java platform.As discussed above, performing calculations on a date where the rules of the calendar system are pluggable requires skill and is not recommended.Fortunately, the need to perform calculations on a date in an arbitrary calendar system is extremely rare.For example, it is highly unlikely that the business rules of a library book rental scheme will allow rentals to be for one month, where meaning of the month is dependent on the user's preferred calendar system.A key use case for calculations on a date in an arbitrary calendar system is producing a month-by-month calendar for display and user interaction.Again, this is a UI issue, and use of this interface solely within a few methods of the UI layer may be justified.In any other part of the system, where a date must be manipulated in a calendar system other than ISO, the use case will generally specify the calendar system to use.For example, an application may need to calculate the next Islamic or Hebrew holiday which may require manipulating the date.This kind of use case can be handled as follows:start from the ISO LocalDate being passed to the method convert the date to the alternate calendar system, which for this use case is known rather than arbitrary perform the calculation convert back to LocalDate Developers writing low-level frameworks or libraries should also avoid this interface.Instead, one of the two general purpose access interfaces should be used.Use TemporalAccessor if read-only access is required, or use Temporal if read-write access is required."},
{"description": "A ChoiceFormat allows you to attach a format to a range of numbers.It is generally used in a MessageFormat for handling plurals.The choice is specified with an ascending list of doubles, where each item specifies a half-open interval up to the next item:X matches j if and only if limit[j] \u2264If there is no match, then either the first or last index is used, depending on whether the number (X) is too low or too high.If the limit array is not in ascending order, the results of formatting will be incorrect.Note: ChoiceFormat differs from the other Format classes in that you create a ChoiceFormat object with a constructor (not with a getInstance style factory method).The factory methods aren't necessary because ChoiceFormat doesn't require any complex setup for a given locale.In fact, ChoiceFormat doesn't implement any locale specific behavior.When creating a ChoiceFormat, you must specify an array of formats and an array of limits.The length of these arrays must be the same.For example, limits = {1,2,3,4,5,6,7} formats = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"} limits = {0, 1, ChoiceFormat.nextDouble(1)} formats = {\"no files\", \"one file\", \"many files\"} (nextDouble can be used to get the next higher double, to make the half-open interval.)Here is a simple example that shows formatting and parsing:String[] dayOfWeekNames = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"}; ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames); ParsePosition status = new ParsePosition(0); for (double i = 0.0; i <= 8.0; ++i) { status.setIndex(0); System.out.println(i + \" -> \" + form.format(i) + \" -> \" + form.parse(form.format(i),status)); } Here is a more complex example, with a pattern format: double[] filelimits = {0,1,2}; String[] filepart = {\"are no files\",\"is one file\",\"are {2} files\"}; ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart); Format[] testFormats = {fileform, null, NumberFormat.getInstance()};; testArgs[2] = testArgs[0]; System.out.println(pattform.format(testArgs)); } Specifying a pattern for ChoiceFormat objects is fairly straightforward.For example: ChoiceFormat fmt = new ChoiceFormat( \"-1#is negative| 0#is zero or fraction | 1#is one |1.0<is 1+ |2#is two |2<is more than 2.\"); System.out.println(\"Formatter Pattern : \" + fmt.toPattern());System.out.println(\"Format with -INF : \" + fmt.format(Double.NEGATIVE_INFINITY)); System.out.println(\"Format with -1.0 : \" + fmt.format(-1.0)); System.out.println(\"Format with 0 : \" + fmt.format(0)); System.out.println(\"Format with 0.9 : \" + fmt.format(0.9)); System.out.println(\"Format with 1.0 : \" + fmt.format(1)); System.out.println(\"Format with 1.5 : \" + fmt.format(1.5)); System.out.println(\"Format with 2 : \" + fmt.format(2)); System.out.println(\"Format with 2.1 : \" + fmt.format(2.1)); System.out.println(\"Format with NaN : \" + fmt.format(Double.NaN)); System.out.println(\"Format with +INF : \" + fmt.format(Double.POSITIVE_INFINITY)); And the output result would be like the following: Format with -INF : is negative Format with -1.0 : is negative Format with 0 : is zero or fraction Format with 0.9 : is zero or fraction Format with 1.0 :is one Format with 1.5 : is 1+ Format with 2 :is two Format with 2.1 : is more than 2.Format with NaN : is negative Format with +INF : is more than 2.It is recommended to create separate format instances for each thread.If multiple threads access a format concurrently, it must be synchronized externally."},
{"description": "Most applications should declare method signatures, fields and variables as LocalDateTime, not this interface.A ChronoLocalDateTime is the abstract representation of a local date-time where the Chronology chronology, or calendar system, is pluggable.The date-time is defined in terms of fields expressed by TemporalField, where most common implementations are defined in ChronoField.The chronology defines how the calendar system operates and the meaning of the standard fields.When to use this interface The design of the API encourages the use of LocalDateTime rather than this interface, even in the case where the application needs to deal with multiple calendar systems.The rationale for this is explored in detail in ChronoLocalDate.Ensure that the discussion in ChronoLocalDate has been read and understood before using this interface."},
{"description": "The main date and time API is built on the ISO calendar system.The chronology operates behind the scenes to represent the general concept of a calendar system.Most other calendar systems also operate on the shared concepts of year, month and day, linked to the cycles of the Earth around the Sun, and the Moon around the Earth.These shared concepts are defined by ChronoField and are available for use by any Chronology implementation: LocalDate isoDate = ...YEAR); As shown, although the date objects are in different calendar systems, represented by different Chronology instances, both can be queried using the same constant on ChronoField.In general, the advice is to use the known ISO-based LocalDate, rather than ChronoLocalDate.While a Chronology object typically uses ChronoField and is based on an era, year-of-era, month-of-year, day-of-month model of a date, this is not required.A Chronology instance may represent a totally different kind of calendar system, such as the Mayan.In practical terms, the Chronology instance also acts as a factory.The of(String) method allows an instance to be looked up by identifier, while the ofLocale(Locale) method allows lookup by locale.The Chronology instance provides a set of methods to create ChronoLocalDate instances.The date classes are used to manipulate specific dates.The set of available chronologies can be extended by applications.Adding a new calendar system requires the writing of an implementation of Chronology, ChronoLocalDate and Era.The majority of the logic specific to the calendar system will be in the ChronoLocalDate implementation.The Chronology implementation acts as a factory.To permit the discovery of additional chronologies, the ServiceLoader is used.A file must be added to the META-INF/services directory with the name 'java.time.chrono.Chronology' listing the implementation classes.For lookup by id or calendarType, the system provided calendars are found first followed by application provided calendars.Each chronology must define a chronology ID that is unique within the system.If the chronology represents a calendar system defined by the CLDR specification then the calendar type is the concatenation of the CLDR type and, if applicable, the CLDR variant,"},
{"description": "Class Chromaticity is a printing attribute class, an enumeration, that specifies monochrome or color printing.This is used by a print client to specify how the print data should be generated or processed.It is not descriptive of the color capabilities of the device.Query the service's ColorSupported attribute to determine if the device can be verified to support color printing.The table below shows the effects of specifying a Chromaticity attribute of MONOCHROME or COLOR for a monochrome or color document.ChromaticityAttribute Effect onMonochrome Document Effect onColor Document MONOCHROME Printed as is, in monochrome Printed in monochrome, with colors converted to shades of gray COLOR Printed as is, in monochrome Printed as is, in color IPP Compatibility: Chromaticity is not an IPP attribute at present."},
{"description": "The Choice class presents a pop-up menu of choices.The current choice is displayed as the title of the menu.The following code example produces a pop-up menu: Choice ColorChooser = new Choice(); ColorChooser.add(\"Green\"); ColorChooser.add(\"Red\"); ColorChooser.add(\"Blue\"); After this choice menu has been added to a panel, it appears as follows in its normal state:In the picture, \"Green\" is the current choice.Pushing the mouse button down on the object causes a menu to appear with the current choice highlighted.Some native platforms do not support arbitrary resizing of Choice components and the behavior of setSize()/getSize() is bound by such limitations.Native GUI Choice components' size are often bound by such attributes as font size and length of items contained within the Choice."},
{"description": "Underlying security services instantiate and pass a ChoiceCallback to the handle method of a CallbackHandler to display a list of choices and to retrieve the selected choice(s)."},
{"description": "An output stream that also maintains a checksum of the data being written.The checksum can then be used to verify the integrity of the output data."},
{"description": "An input stream that also maintains a checksum of the data being read.The checksum can then be used to verify the integrity of the input data."},
{"description": "A check box is a graphical component that can be in either an \"on\" (true) or \"off\" (false) state.Clicking on a check box changes its state from \"on\" to \"off,\" or from \"off\" to \"on.\"The following code example creates a set of check boxes in a grid layout:add(new Checkbox(\"two\")); add(new Checkbox(\"three\")); This image depicts the check boxes and grid layout created by this code example: The button labeled one is in the \"on\" state, and the other two are in the \"off\" state.In this example, which uses the GridLayout class, the states of the three check boxes are set independently.Alternatively, several check boxes can be grouped together under the control of a single object, using the CheckboxGroup class.In a check box group, at most one button can be in the \"on\" state at any given time.Clicking on a check box to turn it on forces any other check box in the same group that is on into the \"off\" state."},
{"description": "This class represents a check box that can be included in a menu.Selecting the check box in the menu changes its state from \"on\" to \"off\" or from \"off\" to \"on.\"The following picture depicts a menu which contains an instance of CheckBoxMenuItem: The item labeled Check shows a check box menu item in its \"off\" state.When a check box menu item is selected, AWT sends an item event to the item.Since the event is an instance of ItemEvent, the processEvent method examines the event and passes it along to processItemEvent.The latter method redirects the event to any ItemListener objects that have registered an interest in item events generated by this menu item."},
{"description": "The CheckboxGroup class is used to group together a set of Checkbox buttons.Exactly one check box button in a CheckboxGroup can be in the \"on\" state at any given time.Pushing any button sets its state to \"on\" and forces any other button that is in the \"on\" state into the \"off\" state.The following code example produces a new check box group, with three check boxes: setLayout(new GridLayout(3, 1));CheckboxGroup cbg = new CheckboxGroup(); add(new Checkbox(\"one\", cbg, true)); add(new Checkbox(\"two\", cbg, false)); add(new Checkbox(\"three\", cbg, false)); This image depicts the check box group created by this example:"},
{"description": "A charset provider is a concrete subclass of this class that has a zero-argument constructor and some number of associated charset implementation classes.Charset providers may be installed in an instance of the Java platform as extensions, that is, jar files placed into any of the usual extension directories.Providers may also be made available by adding them to the applet or application class path or by some other platform-specific means.Charset providers are looked up via the current thread's context class loader.A charset provider identifies itself with a provider-configuration file named java.nio.charset.spi.CharsetProvider in the resource directory META-INF/services.The file should contain a list of fully-qualified concrete charset-provider class names, one per line.A line is terminated by any one of a line feed ('\\n'), a carriage return ('\\r'), or a carriage return followed immediately by a line feed.Space and tab characters surrounding each name, as well as blank lines, are ignored.The comment character is '#' ('\\u0023'); on each line all characters following the first comment character are ignored.The file must be encoded in UTF-8.If a particular concrete charset provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored.The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself.The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file."},
{"description": "An engine that can transform a sequence of sixteen-bit Unicode characters into a sequence of bytes in a specific charset.The input character sequence is provided in a character buffer or a series of such buffers.The output byte sequence is written to a byte buffer or a series of such buffers.An encoder should always be used by making the following sequence of method invocations, hereinafter referred to as an encoding operation: Reset the encoder via the reset method, unless it has not been used before; Invoke the encode method zero or more times, as long as additional input may be available, passing false for the endOfInput argument and filling the input buffer and flushing the output buffer between invocations; Invoke the encode method one final time, passing true for the endOfInput argument; and then Invoke the flush method so that the encoder can flush any internal state to the output buffer.Each invocation of the encode method will encode as many characters as possible from the input buffer, writing the resulting bytes to the output buffer.The encode method returns when more input is required, when there is not enough room in the output buffer, or when an encoding error has occurred.In each case a CoderResult object is returned to describe the reason for termination.An invoker can examine this object and fill the input buffer, flush the output buffer, or attempt to recover from an encoding error, as appropriate, and try again.There are two general types of encoding errors.If the input character sequence is not a legal sixteen-bit Unicode sequence then the input is considered malformed.If the input character sequence is legal but cannot be mapped to a valid byte sequence in the given charset then an unmappable character has been encountered.How an encoding error is handled depends upon the action requested for that type of error, which is described by an instance of the CodingErrorAction class.The possible error actions are to ignore the erroneous input, report the error to the invoker via the returned CoderResult object, or replace the erroneous input with the current value of the replacement byte array.The replacement is initially set to the encoder's default replacement, which often (but not always) has the initial value\u00a0{\u00a0(byte)'?'\u00a0}; its value may be changed via the replaceWith method.The default action for malformed-input and unmappable-character errors is to report them.The malformed-input error action may be changed via the onMalformedInput method; the unmappable-character action may be changed via the onUnmappableCharacter method.This class is designed to handle many of the details of the encoding process, including the implementation of error actions.An encoder for a specific charset, which is a concrete subclass of this class, need only implement the abstract encodeLoop method, which encapsulates the basic encoding loop.A subclass that maintains internal state should, additionally, override the implFlush and implReset methods.Instances of this class are not safe for use by multiple concurrent threads."},
{"description": "An engine that can transform a sequence of bytes in a specific charset into a sequence of sixteen-bit Unicode characters.The input byte sequence is provided in a byte buffer or a series of such buffers.The output character sequence is written to a character buffer or a series of such buffers.A decoder should always be used by making the following sequence of method invocations, hereinafter referred to as a decoding operation: Reset the decoder via the reset method, unless it has not been used before; Invoke the decode method zero or more times, as long as additional input may be available, passing false for the endOfInput argument and filling the input buffer and flushing the output buffer between invocations; Invoke the decode method one final time, passing true for the endOfInput argument; and then Invoke the flush method so that the decoder can flush any internal state to the output buffer.Each invocation of the decode method will decode as many bytes as possible from the input buffer, writing the resulting characters to the output buffer.The decode method returns when more input is required, when there is not enough room in the output buffer, or when a decoding error has occurred.In each case a CoderResult object is returned to describe the reason for termination.An invoker can examine this object and fill the input buffer, flush the output buffer, or attempt to recover from a decoding error, as appropriate, and try again.There are two general types of decoding errors.If the input byte sequence is not legal for this charset then the input is considered malformed.If the input byte sequence is legal but cannot be mapped to a valid Unicode character then an unmappable character has been encountered.How a decoding error is handled depends upon the action requested for that type of error, which is described by an instance of the CodingErrorAction class.The possible error actions are to ignore the erroneous input, report the error to the invoker via the returned CoderResult object, or replace the erroneous input with the current value of the replacement string.The replacement has the initial value \"\\uFFFD\"; its value may be changed via the replaceWith method.The default action for malformed-input and unmappable-character errors is to report them.The malformed-input error action may be changed via the onMalformedInput method; the unmappable-character action may be changed via the onUnmappableCharacter method.This class is designed to handle many of the details of the decoding process, including the implementation of error actions.A decoder for a specific charset, which is a concrete subclass of this class, need only implement the abstract decodeLoop method, which encapsulates the basic decoding loop.A subclass that maintains internal state should, additionally, override the implFlush and implReset methods.Instances of this class are not safe for use by multiple concurrent threads."},
{"description": "A Holder class for a char that is used to store \"out\" and \"inout\" parameters in IDL methods.If an IDL method signature has an IDL char as an \"out\" or \"inout\" parameter, the programmer must pass an instance of CharHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myCharHolder is an instance of CharHolder, the value stored in its value field can be accessed with myCharHolder.value."},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "This class defines four categories of operations upon char buffers: Absolute and relative get and put methods that read and write single chars; Relative bulk get methods that transfer contiguous sequences of chars from this buffer into an array; and Relative bulk put methods that transfer contiguous sequences of chars from a char array, a string, or some other char buffer into this buffer; and Methods for compacting, duplicating, and slicing a char buffer.Char buffers can be created either by allocation, which allocates space for the buffer's content, by wrapping an existing char array or string into a buffer, or by creating a view of an existing byte buffer.Like a byte buffer, a char buffer is either direct or non-direct.A char buffer created via the wrap methods of this class will be non-direct.A char buffer created as a view of a byte buffer will be direct if, and only if, the byte buffer itself is direct.Whether or not a char buffer is direct may be determined by invoking the isDirect method.This class implements the CharSequence interface so that character buffers may be used wherever character sequences are accepted, for example in the regular-expression package java.util.regex.Methods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked.The sequence of statements cb.put(\"text/\"); cb.put(subtype); cb.put(\"; charset=\"); cb.put(enc); can, for example, be replaced by the single statement cb.put(\"text/\").put(subtype).put(\"; charset=\").put(enc);"},
{"description": "This class defines methods for creating decoders and encoders and for retrieving the various names associated with a charset.Instances of this class are immutable.This class also defines static methods for testing whether a particular charset is supported, for locating charset instances by name, and for constructing a map that contains every charset for which support is available in the current Java virtual machine.Support for new charsets can be added via the service-provider interface defined in the CharsetProvider class.All of the methods defined in this class are safe for use by multiple concurrent threads.Charset names Charsets are named by strings composed of the following characters: The uppercase letters 'A' through 'Z' ('\\u0041'\u00a0through\u00a0'\\u005a'),A charset name must begin with either a letter or a digit.The empty string is not a legal charset name.Charset names are not case-sensitive; that is, case is always ignored when comparing charset names.Charset names generally follow the conventions documented in RFC\u00a02278:\u00a0IANA Charset Registration Procedures.Every charset has a canonical name and may also have one or more aliases.The canonical name is returned by the name method of this class.Canonical names are, by convention, usually in upper case.The aliases of a charset are returned by the aliases method.Some charsets have an historical name that is defined for compatibility with previous versions of the Java platform.A charset's historical name is either its canonical name or one of its aliases.The historical name is returned by the getEncoding() methods of the InputStreamReader and OutputStreamWriter classes.If a charset listed in the IANA Charset Registry is supported by an implementation of the Java platform then its canonical name must be the name listed in the registry.Many charsets are given more than one name in the registry, in which case the registry identifies one of the names as MIME-preferred.If a charset has more than one registry name then its canonical name must be the MIME-preferred name and the other names in the registry must be valid aliases.If a supported charset is not listed in the IANA registry then its canonical name must begin with one of the strings \"X-\" or \"x-\".The IANA charset registry does change over time, and so the canonical name and the aliases of a particular charset may also change over time.To ensure compatibility it is recommended that no alias ever be removed from a charset, and that if the canonical name of a charset is changed then its previous canonical name be made into an alias.Standard charsets Every implementation of the Java platform is required to support the following standard charsets.Consult the release documentation for your implementation to see if any other charsets are supported.The behavior of such optional charsets may differ between implementations.the Basic Latin block of the Unicode character set ISO-8859-1\u00a0\u00a0 ISO Latin Alphabet No. 1,The UTF-8 charset is specified by RFC\u00a02279; the transformation format upon which it is based is specified in Amendment\u00a02 of ISO\u00a010646-1 and is also described in the Unicode Standard.The UTF-16 charsets are specified by RFC\u00a02781; the transformation formats upon which they are based are specified in Amendment\u00a01 of ISO\u00a010646-1 and are also described in the Unicode Standard.The UTF-16 charsets use sixteen-bit quantities and are therefore sensitive to byte order.In these encodings the byte order of a stream may be indicated by an initial byte-order mark represented by the Unicode character '\\uFEFF'.When decoding, the UTF-16BE and UTF-16LE charsets interpret the initial byte-order marks as a ZERO-WIDTH NON-BREAKING SPACE; when encoding, they do not write byte-order marks.When decoding, the UTF-16 charset interprets the byte-order mark at the beginning of the input stream to indicate the byte-order of the stream but defaults to big-endian if there is no byte-order mark; when encoding, it uses big-endian byte order and writes a big-endian byte-order mark.In any case, byte order marks occurring after the first element of an input sequence are not omitted since the same code is used to represent ZERO-WIDTH NON-BREAKING SPACE.Every instance of the Java virtual machine has a default charset, which may or may not be one of the standard charsets.The default charset is determined during virtual-machine startup and typically depends upon the locale and charset being used by the underlying operating system.The StandardCharsets class defines constants for each of the standard charsets.The name of this class is taken from the terms used in RFC\u00a02278.In that document a charset is defined as the combination of one or more coded character sets and a character-encoding scheme.(This definition is confusing; some other software systems define charset as a synonym for coded character set.)A coded character set is a mapping between a set of abstract characters and a set of integers.US-ASCII, ISO\u00a08859-1, JIS\u00a0X\u00a00201, and Unicode are examples of coded character sets.Some standards have defined a character set to be simply a set of abstract characters without an associated assigned numbering.An alphabet is an example of such a character set.However, the subtle distinction between character set and coded character set is rarely used in practice; the former has become a short form for the latter, including in the Java API specification.A character-encoding scheme is a mapping between one or more coded character sets and a set of octet (eight-bit byte) sequences.UTF-8, UTF-16, ISO\u00a02022, and EUC are examples of character-encoding schemes.Encoding schemes are often associated with a particular coded character set;Some schemes, however, are associated with multiple coded character sets; EUC, for example, can be used to encode characters in a variety of Asian coded character sets.When a coded character set is used exclusively with a single character-encoding scheme then the corresponding charset is usually named for the coded character set; otherwise a charset is usually named for the encoding scheme and, possibly, the locale of the coded character sets that it supports.Hence US-ASCII is both the name of a coded character set and of the charset that encodes it, while EUC-JP is the name of the charset that encodes the JIS\u00a0X\u00a00201, JIS\u00a0X\u00a00208, and JIS\u00a0X\u00a00212 coded character sets for the Japanese language.The native character encoding of the Java programming language is UTF-16.A charset in the Java platform therefore defines a mapping between sequences of sixteen-bit UTF-16 code units (that is, sequences of chars) and sequences of bytes."},
{"description": "A CharSequence is a readable sequence of char values.This interface provides uniform, read-only access to many different kinds of char sequences.A char value represents a character in the Basic Multilingual Plane (BMP) or a surrogate.This interface does not refine the general contracts of the equals and hashCode methods.The result of comparing two objects that implement CharSequence is therefore, in general, undefined.Each object may be implemented by a different class, and there is no guarantee that each class will be capable of testing its instances for equality with those of the other.It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map."},
{"description": "This class implements a character buffer that can be used as an Writer.The buffer automatically grows when data is written to the stream.The data can be retrieved using toCharArray() and toString().on this class has no effect, and methods of this class can be called after the stream has closed without generating an IOException."},
{"description": "This interface defines a protocol for bidirectional iteration over text.The iterator iterates over a bounded sequence of characters.Characters are indexed with values beginning with the value returned by getBeginIndex() and continuing through the value returned by getEndIndex()-1.Iterators maintain a current character index, whose valid range is from getBeginIndex() to getEndIndex(); the value getEndIndex() is included to allow handling of zero-length text ranges and for historical reasons.The current index can be retrieved by calling getIndex() and set directly by calling setIndex(), first(), and last().The methods previous() and next() are used for iteration.They return DONE if they would move outside the range from getBeginIndex() to getEndIndex() -1, signaling that the iterator has reached the end of the sequence.DONE is also returned by other methods to indicate that the current index is outside this range.Calls to notBoundary() in this example represents some additional stopping criteria."},
{"description": "The CharacterData interface extends Node with a set of attributes and methods for accessing character data in the DOM.For clarity this set is defined here rather than on each object that uses these attributes and methods.No DOM objects correspond directly to CharacterData, though Text and others do inherit the interface from it.All offsets in this interface start from 0.As explained in the DOMString interface, text strings in the DOM are represented in UTF-16, i.e. as a sequence of 16-bit units.In the following, the term 16-bit units is used whenever necessary to indicate that indexing on CharacterData is done in 16-bit units."},
{"description": "Every Unicode character is assigned to a single Unicode script, either a specific script, such as Latin, or one of the following three special values, Inherited, Common or Unknown."},
{"description": "This class implements a character buffer that can be used as a character-input stream."},
{"description": "This describes the interface to Characters events.All text events get reported as Characters events.Content, CData and whitespace are all reported as Characters events.IgnorableWhitespace, in most cases, will be set to false unless an element declaration of element content is present for the current element."},
{"description": "Character blocks generally define characters used for a specific script or purpose.A character is contained by at most one Unicode block."},
{"description": "The Character class wraps a value of the primitive type char in an object.An object of class Character contains a single field whose type is char.In addition, this class provides a large number of static methods for determining a character's category (lowercase letter, digit, etc.)The fields and methods of class Character are defined in terms of character information from the Unicode Standard, specifically the UnicodeData file that is part of the Unicode Character Database.The file is available from the Unicode Consortium at http://www.unicode.org.The Java SE 8 Platform uses character information from version 6.2 of the Unicode Standard, with two extensions.First, the Java SE 8 Platform allows an implementation of class Character to use the Japanese Era code point, U+32FF, from the first version of the Unicode Standard after 6.2 that assigns the code point.Second, in recognition of the fact that new currencies appear frequently, the Java SE 8 Platform allows an implementation of class Character to use the Currency Symbols block from version 10.0 of the Unicode Standard.Consequently, the behavior of fields and methods of class Character may vary across implementations of the Java SE 8 Platform when processing the aforementioned code points ( outside of version 6.2 ), except for the following methods that define Java identifiers: isJavaIdentifierStart(int), isJavaIdentifierStart(char), isJavaIdentifierPart(int), and isJavaIdentifierPart(char).Code points in Java identifiers must be drawn from version 6.2 of the Unicode Standard.The char data type (and therefore the value that a Character object encapsulates) are based on the original Unicode specification, which defined characters as fixed-width 16-bit entities.The Unicode Standard has since been changed to allow for characters whose representation requires more than 16 bits.The range of legal code points is now U+0000 to U+10FFFF, known as Unicode scalar value.The set of characters from U+0000 to U+FFFF is sometimes referred to as the Basic Multilingual Plane (BMP).The Java platform uses the UTF-16 representation in char arrays and in the String and StringBuffer classes.In this representation, supplementary characters are represented as a pair of char values, the first from the high-surrogates range, (\\uD800-\\uDBFF), the second from the low-surrogates range (\\uDC00-\\uDFFF).A char value, therefore, represents Basic Multilingual Plane (BMP) code points, including the surrogate code points, or code units of the UTF-16 encoding.An int value represents all Unicode code points, including supplementary code points.The lower (least significant) 21 bits of int are used to represent Unicode code points and the upper (most significant) 11 bits must be zero.Unless otherwise specified, the behavior with respect to supplementary characters and surrogate char values is as follows: The methods that only accept a char value cannot support supplementary characters.They treat char values from the surrogate ranges as undefined characters.For example, Character.isLetter('\\uD840') returns false, even though this specific value if followed by any low-surrogate value in a string would represent a letter.The methods that accept an int value support all Unicode characters, including supplementary characters.For example, Character.isLetter(0x2F81A) returns true because the code point value represents a letter (a CJK ideograph).In the Java SE API documentation, Unicode code point is used for character values in the range between U+0000 and U+10FFFF, and Unicode code unit is used for 16-bit char values that are code units of the UTF-16 encoding."},
{"description": "This class defines static methods that support the interoperation of the stream classes of the java.io package with the channel classes of this package."},
{"description": "ChangedCharSetException as the name indicates is an exception thrown when the charset is changed."},
{"description": "A channel represents an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinctI/O operations, for example reading or writing.A channel is open upon creation, and once closed it remains closed.Once a channel is closed, any attempt to invoke an I/O operation upon it will cause a ClosedChannelException to be thrown.Whether or not a channel is open may be tested by invoking its isOpen method.Channels are, in general, intended to be safe for multithreaded access as described in the specifications of the interfaces and classes that extend and implement this interface."},
{"description": "Defines an object which listens for ChangeEvents."},
{"description": "ChangeEvent is used to notify interested parties that state has changed in the event source.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Instances of this class represent particular subsets of the Unicode character set.The only family of subsets defined in the Character class is Character.Other portions of the Java API may define other subsets for their own purposes."},
{"description": "This class encapsulates the concept of caller-provided channel binding information.Channel bindings are used to strengthen the quality with which peer entity authentication is provided during context establishment.They enable the GSS-API callers to bind the establishment of the security context to relevant characteristics like addresses or to application specific data.The caller initiating the security context must determine the appropriate channel binding values to set in the GSSContext object.The acceptor must provide an identical binding in order to validate that received tokens possess correct channel-related characteristics.Use of channel bindings is optional in GSS-API.ChannelBinding can be set for the GSSContext using the setChannelBinding method before the first call to initSecContext or acceptSecContext has been performed.Unless the setChannelBinding method has been used to set the ChannelBinding for a GSSContext object, null ChannelBinding will be assumed.Conceptually, the GSS-API concatenates the initiator and acceptor address information, and the application supplied byte array to form an octet string.The mechanism calculates a MIC over this octet string and binds the MIC to the context establishment token emitted by initSecContext method of the GSSContext interface.The same bindings are set by the context acceptor for its GSSContext object and during processing of the acceptSecContext method a MIC is calculated in the same way.The calculated MIC is compared with that found in the token, and if the MICs differ, accept will throw a GSSException with the major code set to BAD_BINDINGS, and the context will not be established.Some mechanisms may include the actual channel binding data in the token (rather than just a MIC); applications should therefore not use confidential data as channel-binding components.Individual mechanisms may impose additional constraints on addresses that may appear in channel bindings.For example, a mechanism may verify that the initiator address field of the channel binding contains the correct network address of the host system.Portable applications should therefore ensure that they either provide correct information for the address fields, or omit setting of the addressing information."},
{"description": "All CertStore implementations must include a class (the SPI class) that extends this class (CertStoreSpi), provides a constructor with a single argument of type CertStoreParameters, and implements all of its methods.In general, instances of this class should only be accessed through the CertStore class.The public methods of all CertStoreSpi objects must be thread-safe.That is, multiple threads may concurrently invoke these methods on a single CertStoreSpi object (or more than one) with no ill effects.This allows a CertPathBuilder to search for a CRL while simultaneously searching for further certificates, for instance.Simple CertStoreSpi implementations will probably ensure thread safety by adding a synchronized keyword to their engineGetCertificates and engineGetCRLs methods.More sophisticated ones may allow truly concurrent access."},
{"description": "The purpose of this interface is to group (and provide type safety for) all CertStore parameter specifications.All CertStore parameter specifications must implement this interface.Typically, a CertStoreParameters object is passed as a parameter to one of the CertStore.getInstance methods.The getInstance method returns a CertStore that is used for retrieving Certificates and CRLs.The CertStore that is returned is initialized with the specified parameters.The type of parameters needed may vary between different types of CertStores."},
{"description": "A CertStoreException provides support for wrapping exceptions.The getCause method returns the throwable, if any, that caused this exception to be thrown.Unless otherwise specified, the methods defined in this class are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "All CertPathValidator implementations must include a class (the SPI class) that extends this class (CertPathValidatorSpi) and implements all of its methods.In general, instances of this class should only be accessed through the CertPathValidator class.Concurrent Access Instances of this class need not be protected against concurrent access from multiple threads.Threads that need to access a single CertPathValidatorSpi instance concurrently should synchronize amongst themselves and provide the necessary locking before calling the wrapping CertPathValidator object.However, implementations of CertPathValidatorSpi may still encounter concurrency issues, since multiple threads each manipulating a different CertPathValidatorSpi instance need not synchronize."},
{"description": "This class uses a provider-based architecture.Once the CertStore has been created, it can be used to retrieve Certificates and CRLs by calling its getCertificates and getCRLs methods.Unlike a KeyStore, which provides access to a cache of private keys and trusted certificates, a CertStore is designed to provide access to a potentially vast repository of untrusted certificates and CRLs.For example, an LDAP implementation of CertStore provides access to certificates and CRLs stored in one or more directories using the LDAP protocol and the schema as defined in the RFC service attribute.Every implementation of the Java platform is required to support the following standard CertStore type:Collection This type is described in the CertStore section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other types are supported.All public methods of CertStore objects must be thread-safe.That is, multiple threads may concurrently invoke these methods on a single CertStore object (or more than one) with no ill effects.This allows a CertPathBuilder to search for a CRL while simultaneously searching for further certificates, for instance.The static methods of this class are also guaranteed to be thread-safe.Multiple threads may concurrently invoke the static methods defined in this class with no ill effects."},
{"description": "A selector that defines a set of criteria for selecting Certificates.Classes that implement this interface are often used to specify which Certificates should be retrieved from a CertStore.Unless otherwise specified, the methods defined in this interface are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "The purpose of this interface is to group (and provide type safety for) all certification path validator results.All results returned by the CertPathValidator.validate method must implement this interface."},
{"description": "The BasicReason enumerates the potential reasons that a certification path of any type may be invalid."},
{"description": "A CertPathValidatorException provides support for wrapping exceptions.The getCause method returns the throwable, if any, that caused this exception to be thrown.A CertPathValidatorException may also include the certification path that was being validated when the exception was thrown, the index of the certificate in the certification path that caused the exception to be thrown, and the reason that caused the failure.Unless otherwise specified, the methods defined in this class are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "This class uses a provider-based architecture.To create a CertPathValidator, call one of the static getInstance methods, passing in the algorithm name of the CertPathValidator desired and optionally the name of the provider desired.Once a CertPathValidator object has been created, it can be used to validate certification paths by calling the validate method and passing it the CertPath to be validated and an algorithm-specific set of parameters.If successful, the result is returned in an object that implements the CertPathValidatorResult interface.The getRevocationChecker() method allows an application to specify additional algorithm-specific parameters and options used by the CertPathValidator when checking the revocation status of certificates.Here is an example demonstrating how it is used with the PKIX algorithm: CertPathValidator cpv = CertPathValidator.getInstance(\"PKIX\"); PKIXRevocationChecker rc =CertPathValidatorResult cpvr = cpv.validate(path, params); Every implementation of the Java platform is required to support the following standard CertPathValidator algorithm: PKIX This algorithm is described in the CertPathValidator section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other algorithms are supported.The static methods of this class are guaranteed to be thread-safe.Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.However, this is not true for the non-static methods defined by this class.Unless otherwise documented by a specific provider, threads that need to access a single CertPathValidator instance concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating a different CertPathValidator instance need not synchronize."},
{"description": "This class is used to pass validation settings to CertPath based TrustManagers using the TrustManagerFactory.init() method.Instances of this class are immutable."},
{"description": "All results returned by the CertPathBuilder.build method must implement this interface.At a minimum, a CertPathBuilderResult contains the CertPath built by the CertPathBuilder instance.Implementations of this interface may add methods to return implementation or algorithm specific information, such as debugging information or certification path validation results.Unless otherwise specified, the methods defined in this interface are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "The purpose of this interface is to group (and provide type safety for) all CertPath parameter specifications.All CertPath parameter specifications must implement this interface."},
{"description": "A CertPathChecker implementation is typically created to extend a certification path validation algorithm.For example, an implementation may check for and process a critical private extension of each certificate in a certification path."},
{"description": "All CertPathBuilder implementations must include a class (the SPI class) that extends this class (CertPathBuilderSpi) and implements all of its methods.In general, instances of this class should only be accessed through the CertPathBuilder class.Concurrent Access Instances of this class need not be protected against concurrent access from multiple threads.Threads that need to access a single CertPathBuilderSpi instance concurrently should synchronize amongst themselves and provide the necessary locking before calling the wrapping CertPathBuilder object.However, implementations of CertPathBuilderSpi may still encounter concurrency issues, since multiple threads each manipulating a different CertPathBuilderSpi instance need not synchronize."},
{"description": "A CertPathBuilderException provides support for wrapping exceptions.The getCause method returns the throwable, if any, that caused this exception to be thrown.Unless otherwise specified, the methods defined in this class are not thread-safe.Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating separate objects need not synchronize."},
{"description": "This is an abstract class that defines the methods common to all CertPaths.Subclasses can handle different kinds of certificates (X.509, PGP, etc.).All CertPath objects have a type, a list of Certificates, and one or more supported encodings.Because the CertPath class is immutable, a CertPath cannot change in any externally visible way after being constructed.This stipulation applies to all public fields and methods of this class and any added or overridden by subclasses.The type is a String that identifies the type of Certificates in the certification path.The list of Certificates is an ordered List of zero or more Certificates.This List and all of the Certificates contained in it must be immutable.Each CertPath object must support one or more encodings so that the object can be translated into a byte array for storage or transmission to other parties.Preferably, these encodings should be well-documented standards (such as PKCS#7).One of the encodings supported by a CertPath is considered the default encoding.This encoding is used if no encoding is explicitly requested (for the getEncoded() method, for instance).CertPath objects are resolved into an alternate CertPathRep object during serialization.This allows a CertPath object to be serialized into an equivalent representation regardless of its underlying implementation.CertPath objects can be created with a CertificateFactory or they can be returned by other classes, such as a CertPathBuilder.By convention, X.509 CertPaths (consisting of X509Certificates), are ordered starting with the target certificate and ending with a certificate issued by the trust anchor.That is, the issuer of one certificate is the subject of the following one.The certificate representing the TrustAnchor should not be included in the certification path.Unvalidated X.509 CertPaths may not follow these conventions.PKIX CertPathValidators will detect any departure from these conventions that cause the certification path to be invalid and throw a CertPathValidatorException.Every implementation of the Java platform is required to support the following standard CertPath encodings:These encodings are described in the CertPath Encodings section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other encodings are supported.That is, multiple threads may concurrently invoke the methods defined in this class on a single CertPath object (or more than one) with no ill effects.This is also true for the List returned by CertPath.getCertificates.Requiring CertPath objects to be immutable and thread-safe allows them to be passed around to various pieces of code without worrying about coordinating access.Providing this thread-safety is generally not difficult, since the CertPath and List objects in question are immutable."},
{"description": "This class uses a provider-based architecture.To create a CertPathBuilder, call one of the static getInstance methods, passing in the algorithm name of the CertPathBuilder desired and optionally the name of the provider desired.Once a CertPathBuilder object has been created, certification paths can be constructed by calling the build method and passing it an algorithm-specific set of parameters.If successful, the result (including the CertPath that was built) is returned in an object that implements the CertPathBuilderResult interface.The getRevocationChecker() method allows an application to specify additional algorithm-specific parameters and options used by the CertPathBuilder when checking the revocation status of certificates.Here is an example demonstrating how it is used with the PKIX algorithm(PKIXRevocationChecker)cpb.getRevocationChecker(); rc.setOptions(EnumSet.of(Option.PREFER_CRLS)); params.addCertPathChecker(rc); CertPathBuilderResult cpbr = cpb.build(params); Every implementation of the Java platform is required to support the following standard CertPathBuilder algorithm: PKIX This algorithm is described in the CertPathBuilder section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other algorithms are supported.The static methods of this class are guaranteed to be thread-safe.Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.However, this is not true for the non-static methods defined by this class.Unless otherwise documented by a specific provider, threads that need to access a single CertPathBuilder instance concurrently should synchronize amongst themselves and provide the necessary locking.Multiple threads each manipulating a different CertPathBuilder instance need not synchronize."},
{"description": "A CertificateRevokedException contains additional information about the revoked certificate, such as the date on which the certificate was revoked and the reason it was revoked."},
{"description": "This is thrown whenever invalid DER encoded certificate is parsed or unsupported DER features are found in the Certificate.Note: The classes in the package javax.security.cert exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE).New applications should instead use the standard Java SE certificate classes located in java.security.cert."},
{"description": "Certificate is not yet valid exception.This is thrown whenever the current Date or the specified Date is before the notBefore date/time in the Certificate validity period.Note: The classes in the package javax.security.cert exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE).New applications should instead use the standard Java SE certificate classes located in java.security.cert."},
{"description": "This is thrown whenever an invalid DER-encoded certificate is parsed or unsupported DER features are found in the Certificate."},
{"description": "Certificate is not yet valid exception.This is thrown whenever the current Date or the specified Date is before the notBefore date/time in the Certificate validity period."},
{"description": "This class defines the Service Provider Interface (SPI) for the CertificateFactory class.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a certificate factory for a particular certificate type, e.g., X.509.Certificate factories are used to generate certificate, certification path (CertPath) and certificate revocation list (CRL) objects from their encodings.A certificate factory for X.509 must return certificates that are an instance of java.security.cert.X509Certificate, and CRLs that are an instance of java.security.cert.X509CRL."},
{"description": "This is thrown whenever the current Date or the specified Date is after the notAfter date/time specified in the validity period of the certificate.Note: The classes in the package javax.security.cert exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE).New applications should instead use the standard Java SE certificate classes located in java.security.cert."},
{"description": "This class defines the functionality of a certificate factory, which is used to generate certificate, certification path (CertPath) and certificate revocation list (CRL) objects from their encodings.For encodings consisting of multiple certificates, use generateCertificates when you want to parse a collection of possibly unrelated certificates.Otherwise, use generateCertPath when you want to generate a CertPath (a certificate chain) and subsequently validate it with a CertPathValidator.A certificate factory for X.509 must return certificates that are an instance of java.security.cert.X509Certificate, and CRLs that are an instance of java.security.cert.X509CRL.The following example reads a file with Base64 encoded certificates, which are each bounded at the beginning by -----BEGIN CERTIFICATE-----, and bounded at the end by -----END CERTIFICATE-----.We convert the FileInputStream (which does not support mark and reset) to a BufferedInputStream (which supports those methods), so that each call to generateCertificate consumes only one certificate, and the read position of the input stream is positioned to the next certificate in the file: FileInputStream fis = new FileInputStream(filename); BufferedInputStream bis = new BufferedInputStream(fis); CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");; } The following example parses a PKCS#7-formatted certificate reply stored in a file and extracts all the certificates from it: FileInputStream fis = new FileInputStream(filename);(Certificate)i.next(); System.out.println(cert); } Every implementation of the Java platform is required to support the following standard CertificateFactory type: X.509 and the following standard CertPath encodings: PKCS7 PkiPathThe type and encodings are described in the CertificateFactory section and the CertPath Encodings section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other types or encodings are supported."},
{"description": "This exception indicates one of a variety of certificate problems.Note: The classes in the package javax.security.cert exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE).New applications should instead use the standard Java SE certificate classes located in java.security.cert."},
{"description": "This is thrown whenever the current Date or the specified Date is after the notAfter date/time specified in the validity period of the certificate."},
{"description": "This is thrown whenever an error occurs whilst attempting to encode a certificate.Note: The classes in the package javax.security.cert exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE).New applications should instead use the standard Java SE certificate classes located in java.security.cert."},
{"description": "This exception indicates one of a variety of certificate problems."},
{"description": "This is thrown whenever an error occurs while attempting to encode a certificate."},
{"description": "This class is inserted in between cell renderers and the components that use them.It just exists to thwart the repaint() and invalidate() methods which would otherwise propagate up the tree when the renderer was configured.It's used by the implementations of JTable, JTree, and JList.For example, here's how CellRendererPane is used in the code the paints each row in a JList:A renderer component must override isShowing() and unconditionally return true to work correctly because the Swing paint does nothing for components with isShowing false.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "An identity certificate is a binding of a principal to a public key which is vouched for by another principal.(A principal represents an entity such as an individual user, a group, or a corporation.)This class is an abstraction for certificates that have different formats but important common uses.For example, different types of certificates, such as X.509 and PGP, share general certificate functionality (like encoding and verifying) and some types of information (like a public key).X.509, PGP, and SDSI certificates can all be implemented by subclassing the Certificate class, even though they contain different sets of information, and they store and retrieve the information in different ways."},
{"description": "This interface defines the methods any general editor should be able to implement.Having this interface enables complex components (the client of the editor) such as JTree and JTable to allow any generic editor to edit values in a table cell, or tree cell, etc.Without this generic editor interface, JTable would have to know about specific editors, such as JTextField, JCheckBox, JComboBox, etc.In addition, without this interface, clients of editors such as JTable would not be able to work with any editors developed in the future by the user or a 3rd party ISV.To use this interface, a developer creating a new editor can have the new component implement the interface.Or the developer can choose a wrapper based approach and provide a companion object which implements the CellEditor interface (See DefaultCellEditor for example).The wrapper approach is particularly useful if the user want to use a 3rd party ISV editor with JTable, but the ISV didn't implement the CellEditor interface.The user can simply create an object that contains an instance of the 3rd party editor object and \"translate\" the CellEditor API into the 3rd party editor's API."},
{"description": "CellEditorListener defines the interface for an object that listens to changes in a CellEditor"},
{"description": "A new certificate handling package is created in the Java platform.This Certificate interface is entirely deprecated and is here to allow for a smooth transition to the new package."},
{"description": "An identity certificate is a guarantee by a principal that a public key is that of another principal.(A principal represents an entity such as an individual user, a group, or a corporation.)This class is an abstraction for certificates that have different formats but important common uses.For example, different types of certificates, such as X.509 and PGP, share general certificate functionality (like encoding and verifying) and some types of information (like a public key).X.509, PGP, and SDSI certificates can all be implemented by subclassing the Certificate class, even though they contain different sets of information, and they store and retrieve the information in different ways.Note: The classes in the package javax.security.cert exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE).New applications should instead use the standard Java SE certificate classes located in java.security.cert."},
{"description": "CaretEvent is used to notify interested parties that the text caret has changed in the event source.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The XML Schema Definition is defined as: <element name=\"CanonicalizationMethod> A CanonicalizationMethod instance may be created by invoking the newCanonicalizationMethod method of the XMLSignatureFactory class."},
{"description": "A CardLayout object is a layout manager for a container.It treats each component in the container as a card.Only one card is visible at a time, and the container acts as a stack of cards.The first component added to a CardLayout object is the visible component when the container is first displayed.The ordering of cards is determined by the container's own internal ordering of its component objects.CardLayout defines a set of methods that allow an application to flip through these cards sequentially, or to show a specified card.Component, java.lang.Object) method can be used to associate a string identifier with a given card for fast random access."},
{"description": "A Canvas component represents a blank rectangular area of the screen onto which the application can draw or from which the application can trap input events from the user.An application must subclass the Canvas class in order to get useful functionality such as creating a custom component.The paint method must be overridden in order to perform custom graphics on the canvas."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "CDATA sections are used to escape blocks of text containing characters that would otherwise be regarded as markup.The only delimiter that is recognized in a CDATA section is the \"]]>\" string that ends the CDATA section.Their primary purpose is for including material such as XML fragments, without needing to escape all the delimiters.The CharacterData.data attribute holds the text that is contained by the CDATA section.Note that this may contain characters that need to be escaped outside of CDATA sections and that, depending on the character encoding (\"charset\") chosen for serialization, it may be impossible to write out some characters as part of a CDATA section.Adjacent CDATASection nodes are not merged by use of the normalize method of the Node interface.No lexical check is done on the content of a CDATA section and it is therefore possible to have the character sequence \"]]\" in the content, which is illegal in a CDATA section per section 2.7 of [XML 1.0].The presence of this character sequence must generate a fatal error during serialization or the cdata section must be splitted before the serialization (see also the parameter \"split-cdata-sections\" in the DOMConfiguration interface).Note: Because no markup is recognized within a CDATASection, character numeric references cannot be used as an escape mechanism when serializing.Therefore, action needs to be taken when serializing a CDATASection with a character encoding where some of the contained characters cannot be represented.Failure to do so would not produce well-formed XML.Note: One potential solution in the serialization process is to end the CDATA section before the character, output the character using a character reference or entity reference, and open a new CDATA section for any further characters in the text node.Note, however, that some code conversion libraries at the time of writing do not return an error or exception when a character is missing from the encoding, making the task of ensuring that data is not corrupted on serialization more difficult."},
{"description": "A place within a document view that represents where things can be inserted into the document model.A caret has a position in the document referred to as a dot.The dot is where the caret is currently located in the model.There is a second position maintained by the caret that represents the other end of a selection called mark.If there is no selection the dot and mark will be equal.The dot can be placed by either calling setDot or moveDot.Setting the dot has the effect of removing any selection that may have previously existed.Moving the dot has the effect of creating a selection as the mark is left at whatever position it previously had."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This exception is thrown to indicate that the operation reached a point in the name where the operation cannot proceed any further.When performing an operation on a composite name, a naming service provider may reach a part of the name that does not belong to its namespace.At that point, it can construct a CannotProceedException and then invoke methods provided by javax.naming.spi.NamingManager (such as getContinuationContext()) to locate another provider to continue the operation.If this is not possible, this exception is raised to the caller of the context operation.If the program wants to handle this exception in particular, it should catch CannotProceedException explicitly before attempting to catch NamingException.A CannotProceedException instance is not synchronized against concurrent multithreaded access.Multiple threads trying to access and modify CannotProceedException should lock the object."},
{"description": "Unchecked exception thrown when an attempt is made to use a selection key that is no longer valid."},
{"description": "Exception indicating that the result of a value-producing task, such as a FutureTask, cannot be retrieved because the task was cancelled."},
{"description": "This interface is used by a printing application to cancel a print job.This interface extends DocPrintJob.A DocPrintJob implementation returned from a print service implements this interface if the print job can be cancelled.Before trying to cancel a print job, the client needs to test if the DocPrintJob object returned from the print service actually implements this interface.Clients should never assume that a DocPrintJob implements this interface.A print service might support cancellation only for certain types of print data and representation class names.This means that only some of the DocPrintJob objects returned from a service will implement this interface.Service implementors are encouraged to implement this optional interface and to deliver a javax.print.event.PrintJobEvent.JOB_CANCELLED event to any listeners if a job is successfully cancelled with an implementation of this interface.Services should also note that an implementation of this method may be made from a separate client thread than that which made the print request.Thus the implementation of this interface must be made thread safe."},
{"description": "A CallSite is a holder for a variable MethodHandle, which is called its target.An invokedynamic instruction linked to a CallSite delegates all calls to the site's current target.A CallSite may be associated with several invokedynamic instructions, or it may be \"free floating\", associated with none.In any case, it may be invoked through an associated method handle called its dynamic invoker.CallSite is an abstract class which does not allow direct subclassing by users.It has three immediate, concrete subclasses that may be either instantiated or subclassed.If a mutable target is not required, an invokedynamic instruction may be permanently bound by means of a constant call site.If a mutable target is required which has volatile variable semantics, because updates to the target must be immediately and reliably witnessed by other threads, a volatile call site may be used.A non-constant call site may be relinked by changing its target.The new target must have the same type as the previous target.Thus, though a call site can be relinked to a series of successive targets, it cannot change its type.Here is a sample use of call sites and bootstrap methods which links every dynamic call site to print its arguments:static void test() throws Throwable { //THE FOLLOWING LINE IS PSEUDOCODE FOR A JVM INSTRUCTION InvokeDynamic[#bootstrapDynamic].baz(\"baz arg\", 2, 3.14);}private static void printArgs(Object...(who am I?)"},
{"description": "An application implements a CallbackHandler and passes it to underlying security services so that they may interact with the application to retrieve specific authentication data, such as usernames and passwords, or to display certain information, such as error and warning messages.CallbackHandlers are implemented in an application-dependent fashion.For example, implementations for an application with a graphical user interface (GUI) may pop up windows to prompt for requested information or to display error messages.An implementation may also choose to obtain requested information from an alternate source without asking the end user.Underlying security services make requests for different types of information by passing individual Callbacks to the CallbackHandler.The CallbackHandler implementation decides how to retrieve and display information depending on the Callbacks passed to it.For example, if the underlying service needs a username and password to authenticate a user, it uses a NameCallback and PasswordCallback.The CallbackHandler can then choose to prompt for a username and password serially, or to prompt for both in a single window.A default CallbackHandler class implementation may be specified by setting the value of the auth.login.defaultCallbackHandler security property.If the security property is set to the fully qualified name of a CallbackHandler implementation class, then a LoginContext will load the specified CallbackHandler and pass it to the underlying LoginModules.The LoginContext only loads the default handler if it was not provided one.All default handler implementations must provide a public zero-argument constructor."},
{"description": "Implementations of this interface are passed to a CallbackHandler, allowing underlying security services the ability to interact with a calling application to retrieve specific authentication data such as usernames and passwords, or to display certain information, such as error and warning messages.Callback implementations do not retrieve or display the information requested by underlying security services.Callback implementations simply provide the means to pass such requests to applications, and for applications, if appropriate, to return requested information back to the underlying security services."},
{"description": "The interface used to execute SQL stored procedures.The JDBC API provides a stored procedure SQL escape syntax that allows stored procedures to be called in a standard way for all RDBMSs.This escape syntax has one form that includes a result parameter and one that does not.If used, the result parameter must be registered as an OUT parameter.The other parameters can be used for input, output or both.Parameters are referred to sequentially, by number, with the first parameter being 1. {?} IN parameter values are set using the set methods inherited from PreparedStatement.The type of all OUT parameters must be registered prior to executing the stored procedure; their values are retrieved after execution via the get methods provided here.A CallableStatement can return one ResultSet object or multiple ResultSet objects.Multiple ResultSet objects are handled using operations inherited from Statement.For maximum portability, a call's ResultSet objects and update counts should be processed prior to getting the values of output parameters."},
{"description": "A task that returns a result and may throw an exception.Implementors define a single method with no arguments called call.The Callable interface is similar to Runnable, in that both are designed for classes whose instances are potentially executed by another thread.A Runnable, however, does not return a result and cannot throw a checked exception.The Executors class contains utility methods to convert from other common forms to Callable classes."},
{"description": "An abstract class for service providers that provide localized string representations (display names) of Calendar field values.Calendar Types Calendar types are used to specify calendar systems for which the getDisplayName and getDisplayNames methods provide calendar field value names.Calendar Fields Calendar fields are specified with the constants defined in Calendar.The following are calendar-common fields and their values to be supported for each calendar system.Some calendar systems have 13 months.Month names need to be supported in both the formatting and stand-alone forms if required by the supported locales.If there's no distinction in the two forms, the same names should be returned in both of the forms.SATURDAY Day-of-week numbering is 1-based starting from Sunday (i.e., 1 - Sunday, ..., 7 - Saturday).The following are calendar-specific fields and their values to be supported.It should be returned when a long style (Calendar.LONG_FORMAT or Calendar.Calendar field value names for \"gregory\" must be consistent with the date-time symbols provided by DateFormatSymbolsProvider.Time zone names are supported by TimeZoneNameProvider."},
{"description": "Builder is used for creating a Calendar from various date-time parameters.There are two ways to set a Calendar to a date-time value.One is to set the instant parameter to a millisecond offset from the Epoch.The other is to set individual field parameters, such as YEAR, to their desired values.However, it is permitted to override previous values of the instant or field parameters.If no enough field parameters are given for determining date and/or time, calendar specific default values are used when building a Calendar.For example, if the YEAR value isn't given for the Gregorian calendar, 1970 will be used.If there are any conflicts among field parameters, the resolution rules are applied.In addition to the date-time parameters, the locale, time zone, week definition, and leniency mode parameters can be set.Examples The following are sample usages.The following code produces a Calendar with date 2012-12-31 (Gregorian) because Monday is the first day of a week with the ISO 8601 compatible week parameters.; The following code produces a Japanese Calendar with date 1989-01-08 (Gregorian), assuming that the default ERA is Heisei that started on that day."},
{"description": "An abstract class for service providers that provide locale-dependent Calendar parameters."},
{"description": "The Calendar class is an abstract class that provides methods for converting between a specific instant in time and a set of calendar fields such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so on, and for manipulating the calendar fields, such as getting the date of the next week.An instant in time can be represented by a millisecond value that is an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian).The class also provides additional fields and methods for implementing a concrete calendar system outside the package.Like other locale-sensitive classes, Calendar provides a class method, getInstance, for getting a generally useful object of this type.Calendar's getInstance method returns a Calendar object whose calendar fields have been initialized with the current date and time:Calendar rightNow = Calendar.getInstance(); A Calendar object can produce all the calendar field values needed to implement the date-time formatting for a particular language and calendar style (for example, Japanese-Gregorian, Japanese-Traditional).Calendar defines the range of values returned by certain calendar fields, as well as their meaning.For example, the first month of the calendar system has value MONTH == JANUARY for all calendars.Other values are defined by the concrete subclass, such as ERA.The calendar field values can be set by calling the set methods.Any field values set in a Calendar will not be interpreted until it needs to calculate its time value (milliseconds from the Epoch) or values of the calendar fields.Calling the get, getTimeInMillis, getTime, add and roll involves such calculation.Leniency Calendar has two modes for interpreting the calendar fields, lenient and non-lenient.When a Calendar is in lenient mode, it accepts a wider range of calendar field values than it produces.When a Calendar recomputes calendar field values for return by get(), all of the calendar fields are normalized.For example, a lenient GregorianCalendar interprets MONTH ==When a Calendar is in non-lenient mode, it throws an exception if there is any inconsistency in its calendar fields.For example, a GregorianCalendar always produces DAY_OF_MONTH values between 1 and the length of the month.A non-lenient GregorianCalendar throws an exception upon calculating its time or calendar field values if any out-of-range field value has been set.First Week Calendar defines a locale-specific seven day week using two parameters: the first day of the week and the minimal days in first week (from 1 to 7).These numbers are taken from the locale resource data when a Calendar is constructed.They may also be specified explicitly through the methods for setting their values.When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must determine the first week of the month or year as a reference point.The first week of a month or year is defined as the earliest seven day period beginning on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days of that month or year.weeks numbered 2, 3,... follow it.Note that the normalized numbering returned by get() may be different.For example, a specific Calendar subclass may designate the week before week 1 of a year as week n of the previous year.When computing a date and time from the calendar fields, there may be insufficient information for the computation (such as only year and month with no day of month), or there may be inconsistent information (such as Tuesday, July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday).Calendar will resolve calendar field values to determine the date and time in the following way.If there is any conflict in calendar field values, Calendar gives priorities to calendar fields that have been set more recently.The following are the default combinations of the calendar fields.The most recent combination, as determined by the most recently set single field, will be used.+ HOUR If there are any calendar fields whose values haven't been set in the selected field combination, Calendar uses their default values.The default value of each field may vary by concrete calendar systems.For example, in GregorianCalendar, the default of a field is the same as that of the start of the Epoch:Note: There are certain possible ambiguities in interpretation of certain singular times, which are resolved in the following ways: 23:59 is the last minute of the day and 00:00 is the first minute of the next day.Although historically not precise, midnight also belongs to \"am\", and noon belongs to \"pm\", so on the same day, 12:00 am (midnight)< 12:01 pm The date or time format strings are not part of the definition of a calendar, as those must be modifiable or overridable by the user at runtime.The calendar fields can be changed using three methods: set(), add(), and roll().set(f, value) changes calendar field f to value.In addition, it sets an internal member variable to indicate that calendar field f has been changed.Although calendar field f is changed immediately, the calendar's time value in milliseconds is not recomputed until the next call to get(), getTime(), getTimeInMillis(), add(), or roll() is made.Thus, multiple calls to set() do not trigger multiple, unnecessary computations.As a result of changing a calendar field using set(), other calendar fields may also change, depending on the calendar field, the calendar field value, and the calendar system.In addition, get(f) will not necessarily return value set by the call to the set method after the calendar fields have been recomputed.The specifics are determined by the concrete calendar class.SEPTEMBER) sets the date to September 31, 1999.This is a temporary internal representation that resolves to October 1, 1999 if getTime()is then called.DAY_OF_MONTH, 30) before the call to getTime() sets the date to September 30, 1999, since no recomputation occurs after set() itself.add(f, delta) adds delta tofield f. This is equivalent to calling set(f, get(f)The value of field f after the call minus the value of field f before the call is delta, modulo any overflow that has occurred in field f. Overflow occurs when a field value exceeds its range and, as a result, the next larger field is incremented or decremented and the field value is adjusted back into its range.If a smaller field is expected to be invariant, but it is impossible for it to be equal to its prior value because of changes in its minimum or maximum after field f is changed or other constraints, such as time zone offset changes, then its value is adjusted to be as close as possible to its expected value.A smaller field represents a smaller unit of time.HOUR is a smaller field than DAY_OF_MONTH.No adjustment is made to smaller fields that are not expected to be invariant.In addition, unlike set(), add() forces an immediate recomputation of the calendar's milliseconds and all fields.MONTH, 13) sets the calendar to September 30, 2000.Add rule 1 sets the MONTH field to September, since adding 13 months to August gives September of the next year.Since DAY_OF_MONTH cannot be 31 in September in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest possible value.Although it is a smaller field, DAY_OF_WEEK is not adjusted by rule 2, since it is expected to change when the month changes in a GregorianCalendar.roll(f, delta) adds delta to field f without changing larger fields.This is equivalent to calling add(f, delta) with the following adjustment: Roll rule.Larger fields are unchanged after the call.A larger field represents a larger unit of time.DAY_OF_MONTH is a larger field than HOUR.If the interface reads January 31, 1999 and the user presses the month increment button, what should it read?If the underlying implementation uses set(), it might read March 3, 1999.A better result would be February 28, 1999.Furthermore, if the user presses the month increment button again, it should read March 31, 1999, not March 28, 1999.By saving the original date and using either add() or roll(), depending on whether larger fields should be affected, the user interface can behave as most users will intuitively expect."},
{"description": "Instances of such a class provide an InputStream that returns the entity body, and also a getHeaders() method which returns the associated response headers."},
{"description": "Instances of such a class provide an OutputStream object which is called by protocol handlers to store the resource data into the cache, and also an abort() method which allows a cache store operation to be interrupted and abandoned.If an IOException is encountered while reading the response or writing to the cache, the current cache store operation will be aborted."},
{"description": "The interface that all standard implementations of CachedRowSet must implement.The reference implementation of the CachedRowSet interface provided by Oracle Corporation is a standard implementation.Developers may use this implementation just as it is, they may extend it, or they may choose to write their own implementations of this interface.A CachedRowSet object is a container for rows of data that caches its rows in memory, which makes it possible to operate without always being connected to its data source.Further, it is a JavaBeans\u2122 component and is scrollable, updatable, and serializable.A CachedRowSet object typically contains rows from a result set, but it can also contain rows from any file with a tabular format, such as a spread sheet.The reference implementation supports getting data only from a ResultSet object, but developers can extend the SyncProvider implementations to provide access to other tabular data sources.An application can modify the data in a CachedRowSet object, and those modifications can then be propagated back to the source of the data.A CachedRowSet object is a disconnected rowset, which means that it makes use of a connection to its data source only briefly.It connects to its data source while it is reading data to populate itself with rows and again while it is propagating changes back to its underlying data source.The rest of the time, a CachedRowSet object is disconnected, including while its data is being modified.Being disconnected makes a RowSet object much leaner and therefore much easier to pass to another component.For example, a disconnected RowSet object can be serialized and passed over the wire to a thin client such as a personal digital assistant (PDA).1.0 Creating a CachedRowSet Object The following line of code uses the default constructor for CachedRowSet supplied in the reference implementation (RI) to create a default CachedRowSet object.(); This new CachedRowSet object will have its properties set to the default properties of a BaseRowSet object, and, in addition, it will have an RIOptimisticProvider object as its synchronization provider.RIOptimisticProvider, one of two SyncProvider implementations included in the RI, is the default provider that the SyncFactory singleton will supply when no synchronization provider is specified.A SyncProvider object provides a CachedRowSet object with a reader (a RowSetReader object) for reading data from a data source to populate itself with data.A reader can be implemented to read data from a ResultSet object or from a file with a tabular format.A SyncProvider object also provides a writer (a RowSetWriter object) for synchronizing any modifications to the CachedRowSet object's data made while it was disconnected with the data in the underlying data source.A writer can be implemented to exercise various degrees of care in checking for conflicts and in avoiding them.(A conflict occurs when a value in the data source has been changed after the rowset populated itself with that value.)The RIOptimisticProvider implementation assumes there will be few or no conflicts and therefore sets no locks.It updates the data source with values from the CachedRowSet object only if there are no conflicts.Other writers can be implemented so that they always write modified data to the data source, which can be accomplished either by not checking for conflicts or, on the other end of the spectrum, by setting locks sufficient to prevent data in the data source from being changed.Still other writer implementations can be somewhere in between.A CachedRowSet object may use any SyncProvider implementation that has been registered with the SyncFactory singleton.An application can find out which SyncProvider implementations have been registered by calling the following line of code.(); There are two ways for a CachedRowSet object to specify which SyncProvider object it will use.Supplying the name of the implementation to the constructor The following line of code creates the CachedRowSet object crs2 that is initialized with default values except that its SyncProvider object is the one specified.Setting the SyncProvider using the CachedRowSet method setSyncProvider The following line of code resets the SyncProvider object for crs, the CachedRowSet object created with the default constructor.2.0 Retrieving Data from a CachedRowSet Object Data is retrieved from a CachedRowSet object by using the getter methods inherited from the ResultSet interface.The following examples, in which crs is a CachedRowSet object, demonstrate how to iterate through the rows, retrieving the column values in each row.The first example uses the version of the getter methods that take a column number; the second example uses the version that takes a column name.Column numbers are generally used when the RowSet object's command is of the form SELECT * FROM TABLENAME; column names are most commonly used when the command specifies columns by name.System.out.println(name + \" \" + id + \" \" + comment + \" \" + dept); } 2.1 Retrieving RowSetMetaDataAn application can get information about the columns in a CachedRowSet object by calling ResultSetMetaData and RowSetMetaData methods on a RowSetMetaData object.The following code fragment, in which crs is a CachedRowSet object, illustrates the process.The first line creates a RowSetMetaData object with information about the columns in crs.The method getMetaData, inherited from the ResultSet interface, returns a ResultSetMetaData object, which is cast to a RowSetMetaData object before being assigned to the variable rsmd.The second line finds out how many columns jrs has, and the third line gets the JDBC type of values stored in the second column of jrs.It includes setter methods: A RowSet object uses these methods internally when it is populated with data from a different ResultSet object.It contains fewer getter methods: Some ResultSetMetaData methods to not apply to a RowSet object.For example, methods retrieving whether a column value is writable or read only do not apply because all of a RowSet object's columns will be writable or read only, depending on whether the rowset is updatable or not.In order to return a RowSetMetaData object, implementations must override the getMetaData() method defined in java.sql.ResultSet and return a RowSetMetaData object.Updating a CachedRowSet object is similar to updating a ResultSet object, but because the rowset is not connected to its data source while it is being updated, it must take an additional step to effect changes in its underlying data source.After calling the method updateRow or insertRow, a CachedRowSet object must also call the method acceptChanges to have updates written to the data source.The following example, in which the cursor is on a row in the CachedRowSet object crs, shows the code required to update two column values in the current row and also update the RowSet object's underlying data source.crs.updateShort(3, 58); crs.updateInt(4, 150000); crs.updateRow(); crs.acceptChanges(); The next example demonstrates moving to the insert row, building a new row on the insert row, inserting it into the rowset, and then calling the method acceptChanges to add the new row to the underlying data source.Note that as with the getter methods, the updater methods may take either a column index or a column name to designate the column being acted upon.; NOTE: Where the insertRow() method inserts the contents of a CachedRowSet object's insert row is implementation-defined.The reference implementation for the CachedRowSet interface inserts a new row immediately following the current row, but it could be implemented to insert new rows in any number of other places.Another thing to note about these examples is how they use the method acceptChanges.It is this method that propagates changes in a CachedRowSet object back to the underlying data source, calling on the RowSet object's writer internally to write changes to the data source.To do this, the writer has to incur the expense of establishing a connection with that data source.The preceding two code fragments call the method acceptChanges immediately after calling updateRow or insertRow.However, when there are multiple rows being changed, it is more efficient to call acceptChanges after all calls to updateRow and insertRow have been made.Updating the Underlying Data Source When the method acceptChanges is executed, the CachedRowSet object's writer, a RowSetWriterImpl object, is called behind the scenes to write the changes made to the rowset to the underlying data source.The writer is implemented to make a connection to the data source and write updates to it.A writer is made available through an implementation of the SyncProvider interface, as discussed in section 1, \"Creating a CachedRowSet Object.The default reference implementation provider, RIOptimisticProvider, has its writer implemented to use an optimistic concurrency control mechanism.That is, it maintains no locks in the underlying database while the rowset is disconnected from the database and simply checks to see if there are any conflicts before writing data to the data source.If there are any conflicts, it does not write anything to the data source.The reader/writer facility provided by the SyncProvider class is pluggable, allowing for the customization of data retrieval and updating.If a different concurrency control mechanism is desired, a different implementation of SyncProvider can be plugged in using the method setSyncProvider.In order to use the optimistic concurrency control routine, the RIOptismisticProvider maintains both its current value and its original value (the value it had immediately preceding the current value).Note that if no changes have been made to the data in a RowSet object, its current values and its original values are the same, both being the values with which the RowSet object was initially populated.However, once any values in the RowSet object have been changed, the current values and the original values will be different, though at this stage, the original values are still the initial values.With any subsequent changes to data in a RowSet object, its original values and current values will still differ, but its original values will be the values that were previously the current values.Keeping track of original values allows the writer to compare the RowSet object's original value with the value in the database.If the values in the database differ from the RowSet object's original values, which means that the values in the database have been changed, there is a conflict.Whether a writer checks for conflicts, what degree of checking it does, and how it handles conflicts all5.0 Registering and Notifying Listeners Being JavaBeans components, all rowsets participate in the JavaBeans event model, inheriting methods for registering listeners and notifying them of changes from the BaseRowSet class.A listener for a CachedRowSet object is a component that wants to be notified whenever there is a change in the rowset.For example, if a CachedRowSet object contains the results of a query and those results are being displayed in, say, a table and a bar graph, the table and bar graph could be registered as listeners with the rowset so that they can update themselves to reflect changes.To become listeners, the table and bar graph classes must implement the RowSetListener interface.Then they can be added to the CachedRowSet object's list of listeners, as is illustrated in the following lines of code.; crs.addRowSetListener(barGraph); Each CachedRowSet method that moves the cursor or changes data also notifies registered listeners of the changes, so table and barGraph will be notified when there is a change in crs.Passing Data to Thin Clients One of the main reasons to use a CachedRowSet object is to pass data between different components of an application.Because it is serializable, a CachedRowSet object can be used, for example, to send the result of a query executed by an enterprise JavaBeans component running in a server environment over a network to a client running in a web browser.While a CachedRowSet object is disconnected, it can be much leaner than a ResultSet object with the same data.As a result, it can be especially suitable for sending data to a thin client such as a PDA, where it would be inappropriate to use a JDBC driver due to resource limitations or security considerations.Thus, a CachedRowSet object provides a means to \"get rows in\" without the need to implement the full JDBC API.A second major use for CachedRowSet objects is to provide scrolling and updating for ResultSet objects that do not provide these capabilities themselves.In other words, a CachedRowSet object can be used to augment the capabilities of a JDBC technology-enabled driver (hereafter called a \"JDBC driver\") when the DBMS does not provide full support for scrolling and updating.To achieve the effect of making a non-scrollble and read-only ResultSet object scrollable and updatable, a programmer simply needs to create a CachedRowSet object populated with that ResultSet object's data.This is demonstrated in the following code fragment, where stmt is a Statement object.(); crs.populate(rs); The object crs now contains the data from the table EMPLOYEES, just as the object rs does.The difference is that the cursor for crs can be moved forward, backward, or to a particular row even if the cursor for rs can move only forward.In addition, crs is updatable even if rs is not because by default, a CachedRowSet object is both scrollable and updatable.In summary, a CachedRowSet object can be thought of as simply a disconnected set of rows that are being cached outside of a data source.Being thin and serializable, it can easily be sent across a wire, and it is well suited to sending data to a thin client.However, a CachedRowSet object does have a limitation: It is limited in size by the amount of data it can store in memory at one time.Another advantage of the CachedRowSet class is that it makes it possible to retrieve and store data from sources other than a relational database.The reader for a rowset can be implemented to read and populate its rowset with data from any tabular data source, including a spreadsheet or flat file.Because both a CachedRowSet object and its metadata can be created from scratch, a component that acts as a factory for rowsets can use this capability to create a rowset containing data from non-SQL data sources.Nevertheless, it is expected that most of the time, CachedRowSet objects will contain data that was fetched from an SQL database using the JDBC API.All rowsets maintain a set of properties, which will usually be set using a tool.The number and kinds of properties a rowset has will vary, depending on what the rowset does and how it gets its data.For example, rowsets that get their data from a ResultSet object need to set the properties that are required for making a database connection.If a rowset uses the DriverManager facility to make a connection, it needs to set a property for the JDBC URL that identifies the appropriate driver, and it needs to set the properties that give the user name and password.If, on the other hand, the rowset uses a DataSource object to make the connection, which is the preferred method, it does not need to set the property for the JDBC URL.Instead, it needs to set properties for the logical name of the data source, for the user name, and for the password.In order to use a DataSource object for making a connection, the DataSource object must have been registered with a naming service that uses the Java Naming and Directory Interface\u2122 (JNDI) API.This registration is usually done by a person acting in the capacity of a system administrator.In order to be able to populate itself with data from a database, a rowset needs to set a command property.This property is a query that is a PreparedStatement object, which allows the query to have parameter placeholders that are set at run time, as opposed to design time.To set these placeholder parameters with values, a rowset provides setter methods for setting values of each data type, similar to the setter methods provided by the PreparedStatement interface.The following code fragment illustrates how the CachedRowSet object crs might have its command property set.Note that if a tool is used to set properties, this is the code that the tool would use.; The values that will be used to set the command's placeholder parameters are contained in the RowSet object's params field, which is a Vector object.The CachedRowSet class provides a set of setter methods for setting the elements in its params field.The following code fragment demonstrates setting the two parameters in the query from the previous example.crs.setInt(1, 5000); crs.setString(2, \"West\"); The params field now contains two elements, each of which is an array two elements long.The first element is the parameter number; the second is the value to be set.In this case, the first element of params is 1, 5000, and the second element is 2, \"West\".When an application calls the method execute, it will in turn call on this RowSet object's reader, which will in turn invoke its readData method.As part of its implementation, readData will get the values in params and use them to set the command's placeholder parameters.The following code fragment gives an idea of how the reader does this, after obtaining the Connection object con.; reader.decodeParams(); // decodeParams figures out which setter methods to use and does something // like the following:} At this point, the command for crs is the query \"SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERSAfter the readData method executes this command with the following line of code, it will have the data from rs with which to populate crs.(); The preceding code fragments give an idea of what goes on behind the scenes; they would not appear in an application, which would not invoke methods like readData and decodeParams.In contrast, the following code fragment shows what an application might do.It sets the rowset's command, sets the command's parameters, and executes the command.Simply by calling the execute method, crs populates itself with the requested data from the table CUSTOMERS.crs.setInt(1, 5000); crs.setString(2, \"West\"); crs.execute(); 10.0 Paging Data Because a CachedRowSet object stores data in memory, the amount of data that it can contain at any one time is determined by the amount of memory available.To get around this limitation, a CachedRowSet object can retrieve data from a ResultSet object in chunks of data, called pages.To take advantage of this mechanism, an application sets the number of rows to be included in a page using the method setPageSize.In other words, if the page size is set to five, a chunk of five rows of data will be fetched from the data source at one time.An application can also optionally set the maximum number of rows that may be fetched at one time.If the maximum number of rows is set to zero, or no maximum number of rows is set, there is no limit to the number of rows that may be fetched at a time.After properties have been set, the CachedRowSet object must be populated with data using either the method populate or the method execute.The following lines of code demonstrate using the method populate.Note that this version of the method takes two parameters, a ResultSet handle and the row in the ResultSet object from which to start retrieving rows.(); crs.setMaxRows(20); crs.setPageSize(4); crs.populate(rsHandle, 10); When this code runs, crs will be populated with four rows from rsHandle starting with the tenth row.The next code fragment shows populating a CachedRowSet object using the method execute, which may or may not take a Connection object as a parameter.This code passes execute the Connection object conHandle.Note that there are two differences between the following code fragment and the previous one.First, the method setMaxRows is not called, so there is no limit set for the number of rows that crs may contain.(Remember that crs always has the overriding limit of how much data it can store in memory.)The second difference is that the you cannot pass the method execute the number of the row in the ResultSet object from which to start retrieving rows.This method always starts with the first row.(); crs.setPageSize(5); crs.execute(conHandle); After this code has run, crs will contain five rows of data from the ResultSet object produced by the command for crs.The writer for crs will use conHandle to connect to the data source and execute the command for crs.An application is then able to operate on the data in crs in the same way that it would operate on data in any other CachedRowSet object.To access the next page (chunk of data), an application calls the method nextPage.This method creates a new CachedRowSet object and fills it with the next page of data.For example, assume that the CachedRowSet object's command returns a ResultSet object rs with 1000 rows of data.If the page size has been set to 100, the first call to the method nextPage will create a CachedRowSet object containing the first 100 rows of rs.After doing what it needs to do with the data in these first 100 rows, the application can again call the method nextPage to create another CachedRowSet object with the second 100 rows from rs.The data from the first CachedRowSet object will no longer be in memory because it is replaced with the data from the second CachedRowSet object.After the tenth call to the method nextPage, the tenth CachedRowSet object will contain the last 100 rows of data from rs, which are stored in memory.At any given time, the data from only one CachedRowSet object is stored in memory.The method nextPage returns true as long as the current page is not the last page of rows and false when there are no more pages.It can therefore be used in a while loop to retrieve all of the pages, as is demonstrated in the following lines of code.operate on chunks (of 100 rows each) in crs, // row by row } } After this code fragment has been run, the application will have traversed all 1000 rows, but it will have had no more than 100 rows in memory at a time.The CachedRowSet interface also defines the method previousPage.Just as the method nextPage is analogous to the ResultSet method next, the method previousPage is analogous to the ResultSet method previous., previousPage creates a CachedRowSet object containing the number of rows set as the page size.So, for instance, the method previousPage could be used in a while loop at the end of the preceding code fragment to navigate back through the pages from the last page to the first page.The method previousPage is also similar to nextPage in that it can be used in a while loop, except that it returns true as long as there is another page preceding it and false when there are no more pages ahead of it.The code could also have left the cursor before the first row on each page and then used the method next in a while loop to navigate each page from the first row to the last row.The following code fragment assumes a continuation from the previous code fragment, meaning that the cursor for the tenth CachedRowSet object is on the last row.The code moves the cursor to after the last row so that the first call to the method previous will put the cursor back on the last row.After going through all of the rows in the last page (the CachedRowSet object crs), the code then enters the while loop to get to the ninth page, go through the rows backwards, go to the eighth page, go through the rows backwards, and so on to the first row of the first page."},
{"description": "This class defines a lookup table object.The output of a lookup operation using an object of this class is interpreted as an unsigned byte quantity.The lookup table contains byte data arrays for one or more bands (or components) of an image, and it contains an offset which will be subtracted from the input values before indexing the arrays.This allows an array smaller than the native data size to be provided for a constrained input.If there is only one array in the lookup table, it will be applied to all bands."},
{"description": "The purpose of this interface is to group (and provide type safety for) all canonicalization (C14N) parameter specifications.All canonicalization parameter specifications must implement this interface."},
{"description": "A Holder class for a byte that is used to store \"out\" and \"inout\" parameters in IDL methods.If an IDL method signature has an IDL octet as an \"out\" or \"inout\" parameter, the programmer must pass an instance of ByteHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myByteHolder is an instance of ByteHolder, the value stored in its value field can be accessed with myByteHolder.value."},
{"description": "This class defines six categories of operations upon byte buffers: Absolute and relative get and put methods that read and write single bytes; Relative bulk get methods that transfer contiguous sequences of bytes from this buffer into an array; Relative bulk put methods that transfer contiguous sequences of bytes from a byte array or some other byte buffer into this buffer; Absolute and relative get and put methods that read and write values of other primitive types, translating them to and from sequences of bytes in a particular byte order; Methods for creating view buffers, which allow a byte buffer to be viewed as a buffer containing values of some other primitive type; and Methods for compacting, duplicating, and slicing a byte buffer.Byte buffers can be created either by allocation, which allocates space for the buffer's content, or by wrapping an existing byte array into a buffer.Given a direct byte buffer, the Java virtual machine will make a best effort to perform nativeThat is, it will attempt to avoid copying the buffer's content to (or from) an intermediate buffer before (or after)A direct byte buffer may be created by invoking the allocateDirect factory method of this class.The buffers returned by this method typically have somewhat higher allocation and deallocation costs than non-direct buffers.The contents of direct buffers may reside outside of the normal garbage-collected heap, and so their impact upon the memory footprint of an application might not be obvious.It is therefore recommended that direct buffers be allocated primarily for large, long-lived buffers that are subject to the underlying system's nativeIn general it is best to allocate direct buffers only when they yield a measureable gain in program performance.A direct byte buffer may also be created by mapping a region of a file directly into memory.An implementation of the Java platform may optionally support the creation of direct byte buffers from native code via JNI.If an instance of one of these kinds of buffers refers to an inaccessible region of memory then an attempt to access that region will not change the buffer's content and will cause an unspecified exception to be thrown either at the time of the access or at some later time.Whether a byte buffer is direct or non-direct may be determined by invoking its isDirect method.This method is provided so that explicit buffer management can be done in performance-critical code.Access to binary data This class defines methods for reading and writing values of all other primitive types, except boolean.Primitive values are translated to (or from) sequences of bytes according to the buffer's current byte order, which may be retrieved and modified via the order methods.Specific byte orders are represented by instances of the ByteOrder class.The initial order of a byte buffer is always BIG_ENDIAN.For access to heterogeneous binary data, that is, sequences of values of different types, this class defines a family of absolute and relative get and put methods for each type.For 32-bit floating-point values, for example, this class defines: float getFloat() float getFloat(int index)Corresponding methods are defined for the types char, short, int, long, and double.The index parameters of the absolute get and put methods are in terms of bytes rather than of the type being read or written.For access to homogeneous binary data, that is, sequences of values of the same type, this class defines methods that can create views of a given byte buffer.A view buffer is simply another buffer whose content is backed by the byte buffer.Changes to the byte buffer's content will be visible in the view buffer, and vice versa; the two buffers' position, limit, and mark values are independent.The asFloatBuffer method, for example, creates an instance of the FloatBuffer class that is backed by the byte buffer upon which the method is invoked.Corresponding view-creation methods are defined for the types char, short, int, long, and double.View buffers have three important advantages over the families of type-specific get and put methods described above: A view buffer is indexed not in terms of bytes but rather in terms of the type-specific size of its values; A view buffer provides relative bulk get and put methods that can transfer contiguous sequences of values between a buffer and an array or some other buffer of the same type; and A view buffer is potentially much more efficient because it will be direct if, and only if, its backing byte buffer is direct.The byte order of a view buffer is fixed to be that of its byte buffer at the time that the view is created.Invocation chaining Methods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked."},
{"description": "A channel that can read and write bytes.This interface simply unifies ReadableByteChannel and WritableByteChannel; it does not specify any new operations."},
{"description": "A ByteArrayInputStream contains an internal buffer that contains bytes that may be read from the stream.An internal counter keeps track of the next byte to be supplied by the read method.Closing a ByteArrayInputStream has no effect.The methods in this class can be called after the stream has been closed without generating an IOException."},
{"description": "This class implements an output stream in which the data is written into a byte array.The buffer automatically grows as data is written to it.The data can be retrieved using toByteArray() and toString().Closing a ByteArrayOutputStream has no effect.The methods in this class can be called after the stream has been closed without generating an IOException."},
{"description": "The Byte class wraps a value of primitive type byte in an object.An object of type Byte contains a single field whose type is byte.In addition, this class provides several methods for converting a byte to a String and a String to a byte, as well as other constants and methods useful when dealing with a byte."},
{"description": "This class is used to create a multiple-exclusion scope for a set of buttons.Creating a set of buttons with the same ButtonGroup object means that turning \"on\" one of those buttons turns off all other buttons in the group.A ButtonGroup can be used with any set of objects that inherit from AbstractButton.Typically a button group contains instances of JRadioButton, JRadioButtonMenuItem, or JToggleButton.It wouldn't make sense to put an instance of JButton or JMenuItem in a button group because JButton and JMenuItem don't implement the selected state.Initially, all buttons in the group are unselected.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This model is used for regular buttons, as well as check boxes and radio buttons, which are special kinds of buttons.In practice, a button's UI takes the responsibility of calling methods on its model to manage the state, as detailed below: In simple terms, pressing and releasing the mouse over a regular button triggers the button and causes and ActionEvent to be fired.The same behavior can be produced via a keyboard key defined by the look and feel of the button (typically the SPACE BAR).Pressing and releasing this key while the button has focus will give the same results.For check boxes and radio buttons, the mouse or keyboard equivalent sequence just described causes the button to become selected.In details, the state model for buttons works as follows when used with the mouse: Pressing the mouse on top of a button makes the model both armed and pressed.As long as the mouse remains down, the model remains pressed, even if the mouse moves outside the button.On the contrary, the model is only armed while the mouse remains pressed within the bounds of the button (it can move in or out of the button, but the model is only armed during the portion of time spent within the button).A button is triggered, and an ActionEvent is fired, when the mouse is released while the model is armed - meaning when it is released over top of the button after the mouse has previously been pressed on that button (and not already released).Upon mouse release, the model becomes unarmed and unpressed.In details, the state model for buttons works as follows when used with the keyboard: Pressing the look and feel defined keyboard key while the button has focus makes the model both armed and pressed.As long as this key remains down, the model remains in this state.Releasing the key sets the model to unarmed and unpressed, triggers the button, and causes an ActionEvent to be fired."},
{"description": "This class creates a labeled button.This image depicts three views of a \"Quit\" button as it appears under the Solaris operating system: The first view shows the button as it appears normally.The second view shows the button when it has input focus.Its outline is darkened to let the user know that it is an active object.The third view shows the button when the user clicks the mouse over the button, and thus requests that an action be performed.The gesture of clicking on a button with the mouse is associated with one instance of ActionEvent, which is sent out when the mouse is both pressed and released over the button.If an application is interested in knowing when the button has been pressed but not released, as a separate gesture, it can specialize processMouseEvent, or it can register itself as a listener for mouse events by calling addMouseListener.Both of these methods are defined by Component, the abstract superclass of all components.When a button is pressed and released, AWT sends an instance of ActionEvent to the button, by calling processEvent on the button.The button's processEvent method receives all events for the button; it passes an action event along by calling its own processActionEvent method.The latter method passes the action event on to any action listeners that have registered an interest in action events generated by this button.If an application wants to perform some action based on a button being pressed and released, it should implement ActionListener and register the new listener to receive events from this button, by calling the button's addActionListener method.The application can make use of the button's action command as a messaging protocol."},
{"description": "Unchecked exception thrown when a relative get operation reaches the source buffer's limit."},
{"description": "The BufferStrategy class represents the mechanism with which to organize complex memory on a particular Canvas or Window.Hardware and software limitations determine whether and how a particular buffer strategy can be implemented.These limitations are detectable through the capabilities of the GraphicsConfiguration used when creating the Canvas or Window.It is worth noting that the terms buffer and surface are meant to be synonymous: an area of contiguous memory, either in video device memory or in system memory.There are several types of complex buffer strategies, including sequential ring buffering and blit buffering.buffering (i.e., double or triple buffering) is the most common; an application draws to a single back buffer and then moves the contents to the front (display) in a single step, either by copying the data or moving the video pointer.Moving the video pointer exchanges the buffers so that the first buffer drawn becomes the front buffer, or what is currently displayed on the device; this is called page flipping.Alternatively, the contents of the back buffer can be copied, or blitted forward in a chain instead of moving the video pointer.* *********** *********** *********** Here is an example of how buffer strategies can be created and used: //The following loop ensures that the contents of the drawing buffer // are consistent in case the underlying surface was recreated do { // Get a new graphics context every time through the loop // to make sure; // Repeat the rendering if the drawing buffer contents // were restored } while (strategy.contentsRestored());// Repeat the rendering if the drawing buffer was lost } while (strategy.contentsLost()); } // Dispose the window w.setVisible(false); w.dispose();"},
{"description": "A class implementing this interface is an MXBean.A Java virtual machine has one or more implementations of this interface.The getPlatformMXBeans method can be used to obtain the list of BufferPoolMXBean objects representing the management interfaces for pools of buffers as follows: List<BufferPoolMXBean> pools = ManagementFactory.getPlatformMXBeans(BufferPoolMXBean.class); The management interfaces are also registered with the platform MBeanServer.The ObjectName that uniquely identifies the management interface within the MBeanServer takes the form:java.nio:type=BufferPool,name=pool name where pool name is the name of the buffer pool."},
{"description": "The default is large enough for most purposes.A newLine() method is provided, which uses the platform's own notion of line separator as defined by the system property line.separator.Not all platforms use the newline character ('\\n') to terminate lines.Calling this method to terminate each output line is therefore preferred to writing a newline character directly.In general, a Writer sends its output immediately to the underlying character or byte stream.Unless prompt output is required, it is advisable to wrap a BufferedWriter around any Writer whose write() operations may be costly, such as FileWriters and OutputStreamWriters.Without buffering, each invocation of a print() method would cause characters to be converted into bytes that would then be written immediately to the file, which can be very inefficient."},
{"description": "The default is large enough for most purposes.In general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream.It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders.For example, BufferedReader in = new BufferedReader(new FileReader(\"foo.in\")); will buffer the input from the specified file.Without buffering, each invocation of read() or readLine() could cause bytes to be read from the file, converted into characters, and then returned, which can be very inefficient.Programs that use DataInputStreams for textual input can be localized by replacing each DataInputStream with an appropriate BufferedReader."},
{"description": "Unchecked exception thrown when a relative put operation reaches the target buffer's limit."},
{"description": "The class implements a buffered output stream.By setting up such an output stream, an application can write bytes to the underlying output stream without necessarily causing a call to the underlying system for each byte written."},
{"description": "A BufferedInputStream adds functionality to another input stream-namely, the ability to buffer the input and to support the mark and reset methods.As bytes from the stream are read or skipped, the internal buffer is refilled as necessary from the contained input stream, many bytes at a time.The mark operation remembers a point in the input stream and the reset operation causes all the bytes read since the most recent mark operation to be reread before new bytes are taken from the contained input stream."},
{"description": "This interface describes single-input/single-output operations performed on BufferedImage objects.It is implemented by AffineTransformOp, ConvolveOp, ColorConvertOp, RescaleOp, and LookupOp.These objects can be passed into a BufferedImageFilter to operate on a BufferedImage in the ImageProducer-ImageFilter-ImageConsumer paradigm.Classes that implement this interface must specify whether or not they allow in-place filtering-- filter operations where the source object is equal to the destination object.This interface cannot be used to describe more sophisticated operations such as those that take multiple sources.Note that this restriction also means that the values of the destination pixels prior to the operation are not used as input to the filter operation."},
{"description": "The BufferedImageFilter class subclasses an ImageFilter to provide a simple means of using a single-source/single-destination image operator (BufferedImageOp) to filter a BufferedImage in the Image Producer/Consumer/Observer paradigm.Examples of these image operators are: ConvolveOp, AffineTransformOp and LookupOp."},
{"description": "The BufferedImage subclass describes an Image with an accessible buffer of image data.A BufferedImage is comprised of a ColorModel and a Raster of image data.The number and types of bands in the SampleModel of the Raster must match the number and types required by the ColorModel to represent its color and alpha components.All BufferedImage objects have an upper left corner coordinate of (0,\u00a00).Any Raster used to construct a BufferedImage must therefore have minX=0 and minY=0.This class relies on the data fetching and setting methods of Raster, and on the color characterization methods of ColorModel."},
{"description": "A buffer is a linear, finite sequence of elements of a specific primitive type.Aside from its content, the essential properties of a buffer are its capacity, limit, and position: A buffer's capacity is the number of elements it contains.The capacity of a buffer is never negative and never changes.A buffer's limit is the index of the first element that should not be read or written.A buffer's limit is never negative and is never greater than its capacity.A buffer's position is the index of the next element to be read or written.A buffer's position is never negative and is never greater than its limit.There is one subclass of this class for each non-boolean primitive type.Transferring data Each subclass of this class defines two categories of get and put operations: Relative operations read or write one or more elements starting at the current position and then increment the position by the number of elements transferred.If the requested transfer exceeds the limit then a relative get operation throws a BufferUnderflowException and a relative put operation throws a BufferOverflowException; in either case, no data is transferred.Absolute operations take an explicit element index and do not affect the position.Absolute get and put operations throw an IndexOutOfBoundsException if the index argument exceeds the limit.Data may also, of course, be transferred in to or out of a buffer by the I/O operations of an appropriate channel, which are always relative to the current position.Marking and resetting A buffer's mark is the index to which its position will be reset when the reset method is invoked.The mark is not always defined, but when it is defined it is never negative and is never greater than the position.If the mark is defined then it is discarded when the position or the limit is adjusted to a value smaller than the mark.If the mark is not defined then invoking the reset method causes an InvalidMarkException to be thrown.The following invariant holds for the mark, position, limit, and capacity values: 0position <= limit <= capacity A newly-created buffer always has a position of zero and a mark that is undefined.The initial limit may be zero, or it may be some other value that depends upon the type of the buffer and the manner in which it is constructed.Each element of a newly-allocated buffer is initialized to zero.Clearing, flipping, and rewinding In addition to methods for accessing the position, limit, and capacity values and for marking and resetting, this class also defines the following operations upon buffers: clear() makes a buffer ready for a new sequence of channel-read or relative put operations: It sets the limit to the capacity and the position to zero.flip() makes a buffer ready for a new sequence of channel-write or relative get operations: It sets the limit to the current position and then sets the position to zero.rewind() makes a buffer ready for re-reading the data that it already contains: It leaves the limit unchanged and sets the position to zero.The mutation methods of each buffer class are specified as optional operations that will throw a ReadOnlyBufferException when invoked upon a read-only buffer.Whether or not a buffer is read-only may be determined by invoking its isReadOnly method.Thread safety Buffers are not safe for use by multiple concurrent threads.If a buffer is to be used by more than one thread then access to the buffer should be controlled by appropriate synchronization.Invocation chaining Methods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked.This allows method invocations to be chained; for example, the sequence of statements b.flip(); b.position(23); b.limit(42); can be replaced by the single, more compact statement b.flip().position(23).limit(42);"},
{"description": "Exception thrown when a thread tries to wait upon a barrier that is in a broken state, or which enters the broken state while the thread is waiting."},
{"description": "An abstract class for service providers that provide concrete implementations of the BreakIterator class."},
{"description": "The components will not wrap so, for example, a vertical arrangement of components will stay vertically arranged when the frame is resized.The diagram shows two panels arranged horizontally, each of which contains 3 components arranged vertically.The BoxLayout manager is constructed with an axis parameter that specifies the type of layout that will be done.There are four choices: X_AXIS - Components are laid out horizontally from left to right.Y_AXIS - Components are laid out vertically from top to bottom.LINE_AXIS - Components are laid out the way words are laid out in a line, based on the container's ComponentOrientation property.For horizontal orientations, if the container's ComponentOrientation is left to right then components are laid out left to right, otherwise they are laid out right to left.For vertical orientations components are always laid out from top to bottom.PAGE_AXIS - Components are laid out the way text lines are laid out on a page, based on the container's ComponentOrientation property.For horizontal orientations, if the container's ComponentOrientation is left to right then components are laid out left to right, otherwise they are laid out right to left.\u00a0 For vertical orientations components are always laid out from top to bottom.For all directions, components are arranged in the same order as they were added to the container.BoxLayout attempts to arrange components at their preferred widths (for horizontal layout) or heights (for vertical layout).For a horizontal layout, if not all the components are the same height, BoxLayout attempts to make all the components as high as the highest component.If that's not possible for a particular component, then BoxLayout aligns that component vertically, according to the component's Y alignment.By default, a component has a Y alignment of 0.5, which means that the vertical center of the component should have the same Y coordinate as the vertical centers of other components with 0.5 Y alignment.Similarly, for a vertical layout, BoxLayout attempts to make all components in the column as wide as the widest component.If that fails, it aligns them horizontally according to their X alignments.For PAGE_AXIS layout, horizontal alignment is done based on the leading edge of the component.In other words, an X alignment value of 0.0 means the left edge of a component if the container's ComponentOrientation is left to rightand it means the right edge of the component otherwise.Instead of using BoxLayout directly, many programs use the Box class.The Box class is a lightweight container that uses a BoxLayout.It also provides handy methods to help you use BoxLayout well.Adding components to multiple nested boxes is a powerful way to get the arrangement you want.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Instances of BreakIterator maintain a current position and scan over text returning the index of characters where boundaries occur.A StringCharacterIterator is used to scan String objects passed to setText.You use the factory methods provided by this class to create instances of various types of break iterators.In particular, use getWordInstance, getLineInstance, getSentenceInstance, and getCharacterInstance to create BreakIterators that perform word, line, sentence, and character boundary analysis respectively.A single BreakIterator can work only on one unit (word, line, sentence, and so on).You must use a different iterator for each unit boundary analysis you wish to perform.The mechanism correctly handles punctuation and hyphenated words.Sentence boundary analysis allows selection with correct interpretation of periods within numbers and abbreviations, and trailing punctuation marks such as quotation marks and parentheses.Word boundary analysis is used by search and replace functions, as well as within text editing applications that allow the user to select words with a double click.Word selection provides correct interpretation of punctuation marks within and following words.Characters that are not part of a word, such as symbols or punctuation marks, have word-breaks on both sides.Character boundary analysis allows users to interact with characters as they expect to, for example, when moving the cursor through a text string.Character boundary analysis provides correct navigation through character strings, regardless of how the character is stored.The boundaries returned may be those of supplementary characters, combining character sequences, or ligature clusters.For example, an accented character might be stored as a base character and a diacritical mark.What users consider to be a character can differ between languages.The BreakIterator instances returned by the factory methods of this class are intended for use with natural languages only, not for programming language text.It is however possible to define subclasses that tokenize a programming language.Creating and using text boundaries: public static void main(String args[]) {US); boundary.setText(stringToExamine); printEachBackward(boundary, stringToExamine); printFirst(boundary, stringToExamine); printLast(boundary, stringToExamine); } } Print each element in order: public static void printEachForward(BreakIterator boundary, String source) { int start = boundary.first(); for (int end = boundary.next(); end != BreakIterator.; } } Print each element in reverse order: public static void printEachBackward(BreakIterator boundary, String source) { int end =boundary.last(); for (int start = boundary.previous(); start !=; } Print last element: public static void printLast(BreakIterator boundary, String source) { int end = boundary.last(); int start = boundary.previous(); System.out.println(source.substring(start,end)); } Print the element at a specified position: public static void printAt(BreakIterator boundary, int pos, String source) { int end = boundary.following(pos); int start =DONE; } (The iterator returned by BreakIterator.getWordInstance() is unique in that the break positions it returns don't represent both the start and end of the thing being iterated over.That is, a sentence-break iterator returns breaks that each represent the end of one sentence and the beginning of the next.With the word-break iterator, the characters between two boundaries might be a word, or they might be the punctuation or whitespace between two words.The above code uses a simple heuristic to determine which boundary is the beginning of a word: If the characters between this boundary and the next boundary include at least one letter (this can be an alphabetical letter, a CJK ideograph, a Hangul syllable, a Kana character, etc.), then the text between this boundary and the next is a word; otherwise, it's the material between words.)"},
{"description": "A view that arranges its children into a box shape by tiling its children along an axis.The box is somewhat like that found in TeX where there is alignment of the children, flexibility of the children is considered, etc.This is a building block that might be useful to represent things like a collection of lines, paragraphs, lists, columns, pages, etc.The axis along which the children are tiled is considered the major axis.The orthogonal axis is the minor axis.Layout for each axis is handled separately by the methods layoutMajorAxis and layoutMinorAxis.Subclasses can change the layout algorithm by reimplementing these methods.These methods are typically called if the given size along the axis changes, or if layoutChanged is called to force an updated layout.The layoutChanged method invalidates cached layout information, if there is any.The requirements published to the parent view are calculated by the methods calculateMajorAxisRequirements and calculateMinorAxisRequirements."},
{"description": "An implementation of a lightweight component that participates in layout but has no view.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "These methods raise Bounds when the index parameter is greater than or equal to the number of members constituting the type."},
{"description": "A lightweight container that uses a BoxLayout object as its layout manager.Box provides several class methods that are useful for containers using BoxLayout -- even non-Box containers.The Box class can create several kinds of invisible components that affect layout: glue, struts, and rigid areas.If all the components your Box contains have a fixed size, you might want to use a glue component (returned by createGlue) to control the components' positions.If you need a fixed amount of space between two components, try using a strut (createHorizontalStrut or createVerticalStrut).If you need an invisible component that always takes up the same amount of space, get it by invoking createRigidArea.If you are implementing a BoxLayout you can find further information and examples in How to Use BoxLayout, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A user exception thrown when a parameter is not within the legal bounds for the object that a method is trying to access."},
{"description": "These four integers define two nested ranges like this:maximum The outer range is minimum,maximum and the inner range is value,value+extent.The inner range must lie within the outer one, i.e. value must be less than or equal to maximum and value+extent must greater than or equal to minimum, and maximum must be greater than or equal to minimum.There are a few features of this model that one might find a little surprising.These quirks exist for the convenience of the Swing BoundedRangeModel clients, such as Slider and ScrollBar.The minimum and maximum set methods \"correct\" the other three properties to accommodate their new value argument.The value and extent set methods \"correct\" their argument to fit within the limits defined by the other three properties.maximum, setExtent(10) would change the extent (back) to zero.The four BoundedRangeModel values are defined as Java Beans properties however Swing ChangeEvents are used to notify clients of changes rather than PropertyChangeEvents.This was done to keep the overhead of monitoring a BoundedRangeModel low.Changes are often reported at MouseDragged rates."},
{"description": "A border layout lays out a container, arranging and resizing its components to fit in five regions: north, south, east, west, and center.Each region may contain no more than one component, and is identified by a corresponding constant: NORTH, SOUTH, EAST, WEST, and CENTER.SOUTH); As a convenience, BorderLayout interprets the absence of a string specification the same as the constant CENTER: Panel p2 = new Panel(); p2.setLayout(new BorderLayout()); p2.add(new TextArea()); // Same as p.add(new TextArea(), BorderLayout.CENTER); In addition, BorderLayout supports the relative positioning constants, PAGE_START, PAGE_END, LINE_START, and LINE_END.In a container whose ComponentOrientation is set to ComponentOrientation.For compatibility with previous releases, BorderLayout also includes the relative positioning constants BEFORE_FIRST_LINE, AFTER_LAST_LINE, BEFORE_LINE_BEGINS and AFTER_LINE_ENDS.These are equivalent to PAGE_START, PAGE_END, LINE_START and LINE_END respectively.For consistency with the relative positioning constants used by other components, the latter constants are preferred.Mixing both absolute and relative positioning constants can lead to unpredictable results.If you use both types, the relative constants will take precedence.For example, if you add components using both the NORTH and PAGE_START constants in a container whose orientation is LEFT_TO_RIGHT, only the PAGE_START will be layed out.Currently (in the Java 2 platform v1.2), BorderLayout does not support vertical orientations.The isVertical setting on the container's ComponentOrientation is not respected.The components are laid out according to their preferred sizes and the constraints of the container's size.The NORTH and SOUTH components may be stretched horizontally; the EAST and WEST components may be stretched vertically; the CENTER component may stretch both horizontally and vertically to fill any space left over.Here is an example of five buttons in an applet laid out using the BorderLayout layout manager: The code for this applet is as follows: import java.awt.*; import java.applet.Applet; public class buttonDir extends Applet { public void init() { setLayout(new"},
{"description": "Wherever possible, this factory will hand out references to shared Border instances."},
{"description": "In the Swing component set, borders supercede Insets as the mechanism for creating a (decorated or plain) area around the edge of a component.Use EmptyBorder to create a plain border (this mechanism replaces its predecessor, setInsets).Rather than creating a new border object using one of border classes, use the BorderFactory methods, which produces a shared instance of the common border types.Additional border styles include BevelBorder, SoftBevelBorder, EtchedBorder, LineBorder, TitledBorder, and MatteBorder."},
{"description": "Thrown to indicate that an invokedynamic instruction has failed to find its bootstrap method, or the bootstrap method has failed to provide a call site with a target of the correct method type."},
{"description": "This is the boolean-producing primitive specialization of Supplier.There is no requirement that a new or distinct result be returned each time the supplier is invoked.This is a functional interface whose functional method is getAsBoolean()."},
{"description": "A Holder class for a boolean that is used to store \"out\" and \"inout\" parameters in IDL methods.If an IDL method signature has an IDL boolean as an \"out\" or \"inout\" parameter, the programmer must pass an instance of BooleanHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myBooleanHolder is an instance of BooleanHolder, the value stored in its value field can be accessed with myBooleanHolder.value."},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "A BooleanControl provides the ability to switch between two possible settings that affect a line's audio.The settings are boolean values (true and false).A graphical user interface might represent the control by a two-state button, an on/off switch, two mutually exclusive buttons, or a checkbox (among other possibilities).For example, depressing a button might activate a MUTE control to silence the line's audio.As with other Control subclasses, a method is provided that returns string labels for the values, suitable for display in the user interface."},
{"description": "Type class identifies one kind of boolean control.Static instances are provided for the common types."},
{"description": "The Book class provides a representation of a document in which pages may have different page formats and page painters.This class uses the Pageable interface to interact with a PrinterJob."},
{"description": "The Boolean class wraps a value of the primitive type boolean in an object.An object of type Boolean contains a single field whose type is boolean.In addition, this class provides many methods for converting a boolean to a String and a String to a boolean, as well as other constants and methods useful when dealing with a boolean."},
{"description": "This class allows for the specification of various parameters while writing a BMP format image file.By default, the data layout is bottom-up, such that the pixels are stored in bottom-up order, the first scanline being stored last.The particular compression scheme to be used can be specified by using the setCompressionType() method with the appropriate type string.The compression scheme specified will be honored if and only if it is compatible with the type of image being written.If the specified compression scheme is not compatible with the type of image being written then the IOException will be thrown by the BMP image writer.In this case the BMP image writer will select a compression type that supports encoding of the given image without loss of the color resolution.The compression type strings and the image type(s) each supports are listed in the following table: Compression Types Type String Description Image Types BI_RGB Uncompressed RLE <= 8-bits/sample BI_RLE8 8-bit Run Length Encoding <= 8-bits/sample BI_RLE4 4-bit Run Length Encoding <= 4-bits/sample"},
{"description": "This is the two-arity specialization of Predicate.This is a functional interface whose functional method is test(Object, Object)."},
{"description": "Specifies whether the given binding is for a object (that is not a naming context) or for a naming context."},
{"description": "This class implements a vector of bits that grows as needed.Each component of the bit set has a boolean value.The bits of a BitSet are indexed by nonnegative integers.One BitSet may be used to modify the contents of another BitSet through logical AND, logical inclusive OR, and logical exclusive OR operations.By default, all bits in the set initially have the value false.Every bit set has a current size, which is the number of bits of space currently in use by the bit set.Note that the size is related to the implementation of a bit set, so it may change with implementation.The length of a bit set relates to logical length of a bit set and is defined independently of implementation.Unless otherwise noted, passing a null parameter to any of the methods in a BitSet will result in a NullPointerException.A BitSet is not safe for multithreaded use without external synchronization."},
{"description": "Specifies whether the given binding is for a object (that is not a naming context) or for a naming context."},
{"description": "Specifies whether the given binding is for a object (that is not a naming context) or for a naming context."},
{"description": "A Queue that additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element.BlockingQueue methods come in four forms, with different ways of handling operations that cannot be satisfied immediately, but may be satisfied at some point in the future: one throws an exception, the second returns a special value (either null or false, depending on the operation), the third blocks the current thread indefinitely until the operation can succeed, and the fourth blocks for only a given maximum time limit before giving up.These methods are summarized in the following table:Summary of BlockingQueue methods Throws exception Special value Blocks Times out Insert add(e) offer(e) put(e) offer(e, time, unit)() peek() not applicable not applicable A BlockingQueue does not accept null elements.Implementations throw NullPointerException on attempts to add, put or offer a null.A null is used as a sentinel value to indicate failure of poll operations.A BlockingQueue may be capacity bounded.At any given time it may have a remainingCapacity beyond which no additional elements can be put without blocking.A BlockingQueue without any intrinsic capacity constraints always reports a remaining capacity of Integer.BlockingQueue implementations are designed to be used primarily for producer-consumer queues, but additionally support the Collection interface.So, for example, it is possible to remove an arbitrary element from a queue using remove(x).However, such operations are in general not performed very efficiently, and are intended for only occasional use, such as when a queued message is cancelled.All queuing methods achieve their effects atomically using internal locks or other forms of concurrency control.However, the bulk Collection operations addAll, containsAll, retainAll and removeAll are not necessarily performed atomically unless specified otherwise in an implementation.So it is possible, for example, for addAll(c) to fail (throwing an exception) after adding only some of the elements in c. A BlockingQueue does not intrinsically support any kind of \"close\" or \"shutdown\" operation to indicate that no more items will be added.The needs and usage of such features tend to be implementation-dependent.For example, a common tactic is for producers to insert special end-of-stream or poison objects, that are interpreted accordingly when taken by consumers.Note that a BlockingQueue can safely be used with multiple producers and multiple consumers.class Producer implements Runnable { private final BlockingQueue queue; Producer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { queue.put(produce()); } } catch (InterruptedException ex) { ... handle ...} } Object produce() { ... } } class Consumer implements Runnable { private final BlockingQueue queue; Consumer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { consume(queue.take()); } } catch (InterruptedException ex) { ... handle ...} } void consume(Object x) { ... } } class Setup { void main() { BlockingQueue q = new SomeQueueImplementation(); Producer p = new Producer(q); Consumer c1 =This interface is a member of the Java Collections Framework."},
{"description": "A Deque that additionally supports blocking operations that wait for the deque to become non-empty when retrieving an element, and wait for space to become available in the deque when storing an element.BlockingDeque methods come in four forms, with different ways of handling operations that cannot be satisfied immediately, but may be satisfied at some point in the future: one throws an exception, the second returns a special value (either null or false, depending on the operation), the third blocks the current thread indefinitely until the operation can succeed, and the fourth blocks for only a given maximum time limit before giving up.These methods are summarized in the following table: Summary of BlockingDeque methods First Element (Head) Throws exception Special value Blocks Times out Insert addFirst(e), a BlockingDeque is thread safe, does not permit null elements, and may (or may not) be capacity-constrained.A BlockingDeque implementation may be used directly as a FIFO BlockingQueue.The methods inherited from the BlockingQueue interface are precisely equivalent to BlockingDeque methods as indicated in the following table: Comparison of BlockingQueue and BlockingDeque methodsBlockingQueue Method Equivalent BlockingDeque Method Insert add(e) addLast(e) offer(e)As with other concurrent collections, actions in a thread prior to placing an object into a BlockingDeque happen-before actions subsequent to the access or removal of that element from the BlockingDeque in another thread.This interface is a member of the Java Collections Framework."},
{"description": "An SQL BLOB is a built-in type that stores a Binary Large Object as a column value in a row of a database table.By default drivers implement Blob using an SQL locator(BLOB), which means that a Blob object contains a logical pointer to the SQL BLOB data rather than the data itself.A Blob object is valid for the duration of the transaction in which is was created.Methods in the interfaces ResultSet, CallableStatement, and PreparedStatement, such as getBlob and setBlob allow a programmer to access an SQL BLOB value.The Blob interface provides methods for getting the length of an SQL BLOB (Binary Large Object) value, for materializing a BLOB value on the client, and for determining the position of a pattern of bytes within a BLOB value.In addition, this interface has methods for updating a BLOB value.All methods on the Blob interface must be fully implemented if the JDBC driver supports the data type."},
{"description": "The BindingType annotation is used to specify the binding to use for a web service endpoint implementation class.This annotation may be overriden programmatically or via deployment descriptors, depending on the platform in use."},
{"description": "A mapping of key/value pairs, all of whose keys are Strings."},
{"description": "The BindingProvider interface provides access to the protocol binding and associated context objects for request and response message processing."},
{"description": "The BindingIterator interface allows a client to iterate through the bindings using the next_one or next_n operations.The bindings iterator is obtained by using the list method on the NamingContext."},
{"description": "The BindingIterator interface allows a client to iterate through the bindings using the next_one or next_n operations.The bindings iterator is obtained by using the list method on the NamingContext."},
{"description": "The BindingIterator interface allows a client to iterate through the bindings using the next_one or next_n operations.The bindings iterator is obtained by using the list method on the NamingContext."},
{"description": "The BindingIterator interface allows a client to iterate through the bindings using the next_one or next_n operations.The bindings iterator is obtained by using the list method on the NamingContext."},
{"description": "The BindingIterator interface allows a client to iterate through the bindings using the next_one or next_n operations.The bindings iterator is obtained by using the list method on the NamingContext."},
{"description": "The Binding interface is the base interface for JAX-WS protocol bindings."},
{"description": "This class represents a name-to-object binding found in a context.A context consists of name-to-object bindings.The Binding class represents such a binding.It consists of a name and an object.The Context.listBindings() method returns an enumeration of Binding.Use subclassing for naming systems that generate contents of a binding dynamically.A Binding instance is not synchronized against concurrent access by multiple threads.Threads that need to access a Binding concurrently should synchronize amongst themselves and provide the necessary locking."},
{"description": "Signals that an error occurred while attempting to bind a socket to a local address and port.Typically, the port is in use, or the requested local address could not be assigned."},
{"description": "This class represents the binary form of the address of a communications end-point.A BinaryRefAddr consists of a type that describes the communication mechanism and an opaque buffer containing the address description specific to that communication mechanism.The format and interpretation of the address type and the contents of the opaque buffer are based on the agreement of three parties: the client that uses the address, the object/server that can be reached using the address, and the administrator or program that creates the address.An example of a binary reference address is an BER X.500 presentation address.Another example of a binary reference address is a serialized form of a service's object handle.A binary reference address is immutable in the sense that its fields once created, cannot be replaced.However, it is possible to access the byte array used to hold the opaque buffer.Programs are strongly recommended against changing this byte array.Changes to this byte array need to be explicitly synchronized."},
{"description": "Immutable, arbitrary-precision signed decimal numbers.A BigDecimal consists of an arbitrary precision integer unscaled value and a 32-bit integer scale.If zero or positive, the scale is the number of digits to the right of the decimal point.If negative, the unscaled value of the number is multiplied by ten to the power of the negation of the scale.The value of the number represented by the BigDecimal is therefore (unscaledValue \u00d7 10-scale).The BigDecimal class provides operations for arithmetic, scale manipulation, rounding, comparison, hashing, and format conversion.The toString() method provides a canonical representation of a BigDecimal.The BigDecimal class gives its user complete control over rounding behavior.If no rounding mode is specified and the exact result cannot be represented, an exception is thrown; otherwise, calculations can be carried out to a chosen precision and rounding mode by supplying an appropriate MathContext object to the operation.In either case, eight rounding modes are provided for the control of rounding.Using the integer fields in this class (such as ROUND_HALF_UP) to represent rounding mode is largely obsolete; the enumeration values of the RoundingMode enum, (such as RoundingMode.When a MathContext object is supplied with a precision setting of 0 (for example, MathContext.UNLIMITED), arithmetic operations are exact, as are the arithmetic methods which take no MathContext object.(This is the only behavior that was supported in releases prior to 5.)As a corollary of computing the exact result, the rounding mode setting of a MathContext object with a precision setting of 0 is not used and thus irrelevant.In the case of divide, the exact quotient could have an infinitely long decimal expansion; for example, 1 divided by 3.If the quotient has a nonterminating decimal expansion and the operation is specified to return an exact result, an ArithmeticException is thrown.Otherwise, the exact result of the division is returned, as done for other operations.When the precision setting is not 0, the rules of BigDecimal arithmetic are broadly compatible with selected modes of operation of the arithmetic defined in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4).Unlike those standards, BigDecimal includes many rounding modes, which were mandatory for division in BigDecimal releases prior to 5.Any conflicts between these ANSI standards and the BigDecimal specification are resolved in favor of BigDecimal.Since the same numerical value can have different representations (with different scales), the rules of arithmetic and rounding must specify both the numerical result and the scale used in the result's representation.In general the rounding modes and precision setting determine how operations return results with a limited number of digits when the exact result has more digits (perhaps infinitely many in the case of division) than the number of digits returned.First, the total number of digits to return is specified by the MathContext's precision setting; this determines the result's precision.The digit count starts from the leftmost nonzero digit of the exact result.The rounding mode determines how any discarded trailing digits affect the returned result.For all arithmetic operators , the operation is carried out as though an exact intermediate result were first calculated and then rounded to the number of digits specified by the precision setting (if necessary), using the selected rounding mode.If the exact result is not returned, some digit positions of the exact result are discarded.When rounding increases the magnitude of the returned result, it is possible for a new digit position to be created by a carry propagating to a leading \"9\" digit.For example, rounding the value 999.9 to three digits rounding up would be numerically equal to one thousand, represented as 100\u00d7101.In such cases, the new \"1\" is the leading digit position of the returned result.Besides a logical exact result, each arithmetic operation has a preferred scale for representing a result.The preferred scale for each operation is listed in the table below.() + multiplicand.scale() Dividedividend.scale() - divisor.scale() These scales are the ones used by the methods which return exact arithmetic results; except that an exact divide may have to use a larger scale since the exact result may have more digits.For example, 1/32 is 0.03125.Before rounding, the scale of the logical exact intermediate result is the preferred scale for that operation.If the exact numerical result cannot be represented in precision digits, rounding selects the set of digits to return and the scale of the result is reduced from the scale of the intermediate result to the least scale which can represent the precision digits actually returned.If the exact result can be represented with at most precision digits, the representation of the result with the scale closest to the preferred scale is returned.In particular, an exactly representable quotient may be represented in fewer than precision digits by removing trailing zeros and decreasing the scale.scale=3 Note that for add, subtract, and multiply, the reduction in scale will equal the number of digit positions of the exact result which are discarded.If the rounding causes a carry propagation to create a new high-order digit position, an additional digit of the result is discarded than when no new digit position is created.Other methods may have slightly different rounding semantics.For example, the result of the pow method using the specified algorithm can occasionally differ from the rounded mathematical result by more than one unit in the last place, one ulp.Two types of operations are provided for manipulating the scale of a BigDecimal: scaling/rounding operations and decimal point motion operations.Scaling/rounding operations (setScale and round) return a BigDecimal whose value is approximately (or exactly) equal to that of the operand, but whose scale or precision is the specified value; that is, they increase or decrease the precision of the stored number with minimal effect on its value.movePointLeft and movePointRight) return a BigDecimal created from the operand by moving the decimal point a specified distance in the specified direction.For the sake of brevity and clarity, pseudo-code is used throughout the descriptions of BigDecimal methods.The pseudo-code expression (i + j) is shorthand for \"a BigDecimal whose value is that of the BigDecimal i added to that of the BigDecimal j.\"The pseudo-code expression (i == j) is shorthand for \"true if and only if the BigDecimal i represents the same value as the BigDecimal j.\" Other pseudo-code expressions are interpreted similarly.Square brackets are used to represent the particular BigInteger and scale pair defining a BigDecimal value; for example [19, 2] is the BigDecimal numerically equal to 0.19 having a scale of 2.Note: care should be exercised if BigDecimal objects are used as keys in a SortedMap or elements in a SortedSet since BigDecimal's natural ordering is inconsistent with equals.All methods and constructors for this class throw NullPointerException when passed a null object reference for any input parameter."},
{"description": "Represents a function that accepts two arguments and produces a result.This is the two-arity specialization of Function.This is a functional interface whose functional method is apply(Object, Object)."},
{"description": "Represents an operation that accepts two input arguments and returns no result.This is the two-arity specialization of Consumer.Unlike most other functional interfaces, BiConsumer is expected to operate via side-effects.This is a functional interface whose functional method is accept(Object, Object)."},
{"description": "An instance of this class maintains the association between XML nodes of an infoset preserving view and a JAXB representation of an XML document.Navigation between the two views is provided by the methods getXMLNode(Object) and getJAXBNode(Object).Modifications can be made to either the infoset preserving view or the JAXB representation of the document while the other view remains unmodified.The binder is able to synchronize the changes made in the modified view back into the other view using the appropriate Binder update methods, updateXML(Object, Object) or updateJAXB(Object).A typical usage scenario is the following: load XML document into an XML infoset representation unmarshal(Object)(Note to conserve resources, it is possible to only unmarshal a subtree of the XML infoset view to the JAXB view.)updateXML(Object) synchronizes modifications to JAXB view back into the XML infoset view.A Binder instance is created using the factory method JAXBContext.createBinder() or JAXBContext.createBinder(Class).The template parameter, XmlNode, is the root interface/class for the XML infoset preserving representation.A Binder implementation is required to minimally support an XmlNode value of org.w3c.dom.Node.class.A Binder implementation can support alternative XML infoset preserving representations."},
{"description": "This is a specialization of BiFunction for the case where the operands and the result are all of the same type.This is a functional interface whose functional method is BiFunction.apply(Object, Object)."},
{"description": "All operations behave as if BigIntegers were represented in two's-complement notation (like Java's primitive integer types).BigInteger provides analogues to all of Java's primitive integer operators, and all relevant methods from java.lang.Math.Additionally, BigInteger provides operations for modular arithmetic, GCD calculation, primality testing, prime generation, bit manipulation, and a few other miscellaneous operations.Semantics of arithmetic operations exactly mimic those of Java's integer arithmetic operators, as defined in The Java Language Specification.For example, division by zero throws an ArithmeticException, and division of a negative by a positive yields a negative (or zero) remainder.All of the details in the Spec concerning overflow are ignored, as BigIntegers are made as large as necessary to accommodate the results of an operation.Semantics of shift operations extend those of Java's shift operators to allow for negative shift distances.The unsigned right shift operator (>>>) is omitted, as this operation makes little sense in combination with the \"infinite word size\" abstraction provided by this class.Semantics of bitwise logical operations exactly mimic those of Java's bitwise integer operators.The binary operators (and, or, xor) implicitly perform sign extension on the shorter of the two operands prior to performing the operation.Comparison operations perform signed integer comparisons, analogous to those performed by Java's relational and equality operators.Modular arithmetic operations are provided to compute residues, perform exponentiation, and compute multiplicative inverses.These methods always return a non-negative result, between 0 and (modulus - 1), inclusive.Bit operations operate on a single bit of the two's-complement representation of their operand.If necessary, the operand is sign- extended so that it contains the designated bit.None of the single-bit operations can produce a BigInteger with a different sign from the BigInteger being operated on, as they affect only a single bit, and the \"infinite word size\" abstraction provided by this class ensures that there are infinitely many \"virtual sign bits\" preceding each BigInteger.For the sake of brevity and clarity, pseudo-code is used throughout the descriptions of BigInteger methods.The pseudo-code expression (i + j) is shorthand for \"a BigInteger whose value is that of the BigInteger i plus that of the BigInteger j.\" The pseudo-code expression (i == j) is shorthand for \"true if and only if the BigInteger i represents the same value as the BigInteger j.\" Other pseudo-code expressions are interpreted similarly.All methods and constructors in this class throw NullPointerException when passed a null object reference for any input parameter.BigInteger must support values in the range -2Integer.The range of probable prime values is limited and may be less than the full supported positive range of BigInteger.The range must be at least 1 to 2500000000."},
{"description": "A class which implements a simple two-line bevel border.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "protected final subclass that encapsulates an iterator but implements a noop remove() method."},
{"description": "This helper class provides a utility implementation of the java.beans.beancontext.BeanContext interface.Since this class directly implements the BeanContext interface, the class can, and is intended to be used either by subclassing this implementation, or via ad-hoc delegation of an instance of this class from another."},
{"description": "This class implements the Unicode Bidirectional Algorithm.A Bidi object provides information on the bidirectional reordering of the text used to create it.This is required, for example, to properly display Arabic or Hebrew text.These languages are inherently mixed directional, as they order numbers from left-to-right while ordering most other text from right-to-left.Once created, a Bidi object can be queried to see if the text it represents is all left-to-right or all right-to-left.If there are multiple runs of text, information about the runs can be accessed by indexing to get the start, limit, and level of a run.The level represents both the direction and the 'nesting level' of a directional run.So for example level 0 represents left-to-right text, while level 1 represents right-to-left text, and level 2 represents left-to-right text embedded in a right-to-left run."},
{"description": "subclasses may subclass this nested class to add behaviors for each BeanContextServicesProvider."},
{"description": "This class provides some general purpose beans control methods."},
{"description": "When developing your bean, you can implement the bean features required for your application task omitting the rest of the BeanInfo features.They will be obtained through the automatic analysis by using the low-level reflection of the bean methods and applying standard design patterns.You have an opportunity to provide additional bean information through various descriptor classes.See the SimpleBeanInfo class that is a convenient basic class for BeanInfo classes.You can override the methods and properties of the SimpleBeanInfo class to define specific information."},
{"description": "A BeanDescriptor provides global information about a \"bean\", including its Java class, its displayName, etc.This is one of the kinds of descriptor returned by a BeanInfo object, which also returns descriptors for properties, method, and events."},
{"description": "The BeanContextServices interface provides a mechanism for a BeanContext to expose generic \"services\" to the BeanContextChild objects within."},
{"description": "A class that is interested in processing a BeanContextServiceAvailableEvent implements this interface."},
{"description": "A class that is interested in processing a BeanContextServiceRevokedEvent implements this interface."},
{"description": "A BeanContextServiceProvider implementor who wishes to provide explicit information about the services their bean may provide shall implement a BeanInfo class that implements this BeanInfo subinterface and provides explicit information about the methods, properties, events, etc, of their services."},
{"description": "One of the primary functions of a BeanContext is to act a as rendezvous between JavaBeans, and BeanContextServiceProviders.A JavaBean nested within a BeanContext, may ask that BeanContext to provide an instance of a \"service\", based upon a reference to a Java Class object that represents that service.If such a service has been registered with the context, or one of its nesting context's, in the case where a context delegate to its context to satisfy a service request, then the BeanContextServiceProvider associated with the service is asked to provide an instance of that service.The ServcieProvider may always return the same instance, or it may construct a new instance for each request."},
{"description": "This event type is used by the BeanContextServicesListener in order to identify the service being registered."},
{"description": "This helper class provides a utility implementation of the java.beans.beancontext.BeanContextServices interface.Since this class directly implements the BeanContextServices interface, the class can, and is intended to be used either by subclassing this implementation, or via delegation of an instance of this class from another through the BeanContextProxy interface."},
{"description": "This interface is implemented by BeanContextChildren that have an AWT Component associated with them."},
{"description": "This interface is implemented by a JavaBean that does not directly have a BeanContext(Child) associated with it (via implementing that interface or a subinterface thereof), but has a public BeanContext(Child) delegated from it.For example, a subclass of java.awt.Container may have a BeanContext associated with it that all Component children of that Container shall be contained within.An Object may not implement this interface and the BeanContextChild interface (or any subinterfaces thereof)Callers of this interface shall examine the return type in order to obtain a particular subinterface of BeanContextChild as follows:o.getBeanContextProxy(); if (bcc instanceof BeanContext) { // ... } or BeanContextChild bcc =; BeanContext bc = null; try { bc = (BeanContext)bcc; } catch (ClassCastException cce) { // cast failed, bcc is not an instanceof BeanContext }The return value is a constant for the lifetime of the implementing instance"},
{"description": "BeanContextEvent is the abstract root event class for all events emitted from, and pertaining to the semantics of, a BeanContext.This class introduces a mechanism to allow the propagation of BeanContextEvent subclasses through a hierarchy of BeanContexts.The setPropagatedFrom() and getPropagatedFrom() methods allow a BeanContext to identify itself as the source of a propagated event."},
{"description": "This interface is implemented by BeanContexts' that have an AWT Container associated with them."},
{"description": "This is a general support class to provide support for implementing the BeanContextChild protocol.This class may either be directly subclassed, or encapsulated and delegated to in order to implement this interface for a given component."},
{"description": "JavaBeans wishing to be nested within, and obtain a reference to their execution environment, or context, as defined by the BeanContext sub-interface shall implement this interface.Note that a BeanContextChild may refuse a change in state by throwing PropertyVetoedException in response.In order for persistence mechanisms to function properly on BeanContextChild instances across a broad variety of scenarios, implementing classes of this interface are required to define as transient, any or all fields, or instance variables, that may contain, or represent, references to the nesting BeanContext instance or other resources obtained from the BeanContext via any unspecified mechanisms."},
{"description": "The BeanContext acts a logical hierarchical container for JavaBeans."},
{"description": "This event type is used by the BeanContextServiceRevokedListener in order to identify the service being revoked."},
{"description": "The subclass of SQLException thrown when an error occurs during a batch update operation.In addition to the information provided by SQLException, a BatchUpdateException provides the update counts for all commands that were executed successfully during the batch update, that is, all commands that were executed before the error occurred.The order of elements in an array of update counts corresponds to the order in which commands were added to the batch.After a command in a batch update fails to execute properly and a BatchUpdateException is thrown, the driver may or may not continue to process the remaining commands in the batch.If the driver continues processing after a failure, the array returned by the method BatchUpdateException.getUpdateCounts will have an element for every command in the batch rather than only elements for the commands that executed successfully before the error.In the case where the driver continues processing commands, the array element for any command that failed is Statement.A JDBC driver implementation should use the constructor BatchUpdateException(String reason, String SQLState, int vendorCode, long []updateCounts,Throwable cause) instead of constructors that take int[] for the update counts to avoid the possibility of overflow.If Statement.executeLargeBatch method is invoked it is recommended that getLargeUpdateCounts be called instead of getUpdateCounts in order to avoid a possible overflow of the integer update count."},
{"description": "This implementation is a \"combined\" view/controller."},
{"description": "This implementation is a \"combined\" view/controller."},
{"description": "This provides the basic editor view and controller services that may be useful when creating a look-and-feel for an extension of JTextComponent.Most state is held in the associated JTextComponent as bound properties, and the UI installs default values for the various properties.This default will install something for all of the properties.Typically, a LAF implementation will do more however.At a minimum, a LAF would generally install key bindings.This class also provides some concurrency support if the Document associated with the JTextComponent is a subclass of AbstractDocument.Access to the View (or View hierarchy) is serialized between any thread mutating the model and the Swing event thread (which is expected to render, do model/view coordinate translation, etc).Any access to the root view should first acquire a read-lock on the AbstractDocument and release that lock in a finally block.An important method to define is the getPropertyPrefix() method which is used as the basis of the keys used to fetch defaults from the UIManager.The string should reflect the type of TextUI (eg.To build a view of the model, one of the following strategies can be employed.One strategy is to simply redefine the ViewFactory interface in the UI.By default, this UI itself acts as the factory for View implementations.This is useful for simple factories.A common strategy for creating more complex types of documents is to have the EditorKit implementation return a factory.Since the EditorKit ties all of the pieces necessary to maintain a type of document, the factory is typically an important part of that and should be produced by the EditorKit implementation.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "In this implementation the default UI is extended to act as a simple view factory.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The BasicStroke class defines a basic set of rendering attributes for the outlines of graphics primitives, which are rendered with a Graphics2D object that has its Stroke attribute set to this BasicStroke.The rendering attributes defined by BasicStroke describe the shape of the mark made by a pen drawn along the outline of a Shape and the decorations applied at the ends and joins of path segments of the Shape.These rendering attributes include: widthThe pen width, measured perpendicularly to the pen trajectory.The decoration applied to the ends of unclosed subpaths and dash segments.Subpaths that start and end on the same point are still considered unclosed if they do not have a CLOSE segment.The three different decorations are: CAP_BUTT, CAP_ROUND, and CAP_SQUARE.line joins The decoration applied at the intersection of two path segments and at the intersection of the endpoints of a subpath that is closed using SEG_CLOSE.The three different decorations are: JOIN_BEVEL, JOIN_MITER, and JOIN_ROUND.miter limit The limit to trim a line join that has a JOIN_MITER decoration.A line join is trimmed when the ratio of miter length to stroke width is greater than the miterlimit value.The miter length is the diagonal length of the miter, which is the distance between the inside corner and the outside corner of the intersection.The smaller the angle formed by two line segments, the longer the miter length and the sharper the angle of intersection.The default miterlimit value of 10.0f causes all angles less than 11 degrees to be trimmed.Trimming miters converts the decoration of the line join to bevel.dash attributes The definition of how to make a dash pattern by alternating between opaque and transparent sections.All attributes that specify measurements and distances controlling the shape of the returned outline are measured in the same coordinate system as the original unstroked Shape argument.When a Graphics2D object uses a Stroke object to redefine a path during the execution of one of its draw methods, the geometry is supplied in its original form before the Graphics2D transform attribute is applied.Therefore, attributes such as the pen width are interpreted in the user space coordinate system of the Graphics2D object and are subject to the scaling and shearing effects of the user-space-to-device-space transform in that particular Graphics2D.For example, the width of a rendered shape's outline is determined not only by the width attribute of this BasicStroke, but also by the transform attribute of the Graphics2D object.// sets the Graphics2D object's Stroke attribute g2d.setStroke(new BasicStroke(1.5f)); Assuming there are no other scaling transforms added to the Graphics2D object, the resulting line will be approximately 15 pixels wide.As the example code demonstrates, a floating-point line offers better precision, especially when large transforms are used with a Graphics2D object.When a line is diagonal, the exact width depends on how the rendering pipeline chooses which pixels to fill as it traces the theoretical widened outline.The choice of which pixels to turn on is affected by the antialiasing attribute because the antialiasing rendering pipeline can choose to color partially-covered pixels."},
{"description": "A BeanContextMembershipEvent encapsulates the list of children added to, or removed from, the membership of a particular BeanContext.An instance of this event is fired whenever a successful add(), remove(), retainAll(), removeAll(), or clear() is invoked on a given BeanContext instance.Objects interested in receiving events of this type must implement the BeanContextMembershipListener interface, and must register their intent via the BeanContext's addBeanContextMembershipListener(BeanContextMembershipListener bcml) method."},
{"description": "This implementation is a \"combined\" view/controller."},
{"description": "Subclassers may wish to override paint to do something more interesting.The border effect is drawn in BasicSplitPaneUI, so if you don't like that border, reset it there.To conditionally drag from certain areas subclass mousePressed and call super when you wish the dragging to begin.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Basic implementation of RootPaneUI, there is one shared between all JRootPane instances."},
{"description": "This implementation is a \"combined\" view/controller."},
{"description": "This implementation is a \"combined\" view/controller."},
{"description": "The BasicPermission class extends the Permission class, and can be used as the base class for permissions that want to follow the same naming convention as BasicPermission.The name for a BasicPermission is the name of the given permission (for example, \"exit\", \"setFactory\", \"print.queueJob\", etc).The naming convention follows the hierarchical property naming convention.An asterisk may appear by itself, or if immediately preceded by a \".*\" signify a wildcard match, while \"*java\", \"a*b\", and \"java*\" do not.The action string (inherited from Permission) is unused.Thus, BasicPermission is commonly used as the base class for \"named\" permissions (ones that contain a name but no actions list; you either have the named permission or you don't.)Subclasses may implement actions on top of BasicPermission, if desired."},
{"description": "The only difference from the standard text field is that the view of the text is simply a string of the echo character as specified in JPasswordField, rather than the real text contained in the field."},
{"description": "ButtonAreaLayout behaves in a similar manner to FlowLayout.It lays out all components from left to right.If syncAllWidths is true, the widths of each component will be set to the largest preferred size width.This class should be treated as a \"protected\" inner class."},
{"description": "BasicMessagePaneUI provides a means to place an icon, message and buttons into a Container.| i | message | | c | message | | o | message | | n | message | ------------------| buttons | |________________| icon is an instance of Icon that is wrapped inside a JLabel.The message is an opaque object and is tested for the following: if the message is a Component it is added to the Container, if it is an Icon it is wrapped inside a JLabel and added to the Container otherwise it is wrapped inside a JLabel.The layout will be adjusted appropriately for other orientations.The Container, message, icon, and buttons are all determined from abstract methods."},
{"description": "This implementation is a \"combined\" view/controller."},
{"description": "BasicListUI instances cannot be shared between multiple lists."},
{"description": "Each of the ComponentUIs provided by BasicLookAndFeel derives its behavior from the defaults table.Unless otherwise noted each of the ComponentUI implementations in this package document the set of defaults they use.Unless otherwise noted the defaults are installed at the time installUI is invoked, and follow the recommendations outlined in LookAndFeel for installing defaults.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This implementation is completely static, i.e. there's only one UIView implementation that's shared by all JLabel objects."},
{"description": "This implementation is a \"combined\" view/controller."},
{"description": "The class that manages a basic title bar Warning:Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Factory object that can vend Icons appropriate for the basic L & F. Warning:Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This translates a simple html string to a javax.swing.text.View implementation that can render the html and provide the necessary layout semantics."},
{"description": "A file attribute view that provides a view of a basic set of file attributes common to many file systems.The basic set of file attributes consist of mandatory and optional file attributes as defined by the BasicFileAttributes interface.The file attributes are retrieved from the file system as a bulk operation by invoking the readAttributes method.This class also defines the setTimes method to update the file's time attributes.Where dynamic access to file attributes is required, the attributes supported by this attribute view have the following names and types: Name Type \"lastModifiedTime\" FileTime \"lastAccessTime\" FileTime \"creationTime\" FileTime \"size\" Long \"isRegularFile\" Boolean \"isDirectory\" Boolean \"isSymbolicLink\" Boolean \"isOther\" Boolean \"fileKey\"Object The getAttribute method may be used to read any of these attributes as if by invoking the readAttributes() method.The setAttribute method may be used to update the file's last modified time, last access time or create time attributes as if by invoking the setTimes method."},
{"description": "The combo box is a compound component which means that it is an aggregate of many simpler components.This class creates and manages the listeners on the combo box and the combo box model.These listeners update the user interface in response to changes in the properties and state of the combo box.All event handling is handled by listener classes created with the createxxxListener() methods and internal classes.You can change the behavior of this class by overriding the createxxxListener() methods and supplying your own event listeners or subclassing from the ones supplied in this class."},
{"description": "This class provides a basic implementation of the Control interface.It represents an LDAPv3 Control as defined in RFC 2251."},
{"description": "This is a basic implementation of the ComboPopup interface.This class represents the ui for the popup portion of the combo box.All event handling is handled by listener classes created with the createxxxListener() methods and internal classes.You can change the behavior of this class by overriding the createxxxListener() methods and supplying your own event listeners or subclassing from the ones supplied in this class.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Basic file attributes are attributes that are common to many file systems and consist of mandatory and optional file attributes as defined by this interface."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A subclass of BasicComboBoxRenderer that implements UIResource.BasicComboBoxRenderer doesn't implement UIResource directly so that applications can safely override the cellRenderer property with BasicListCellRenderer subclasses.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "ComboBox renderer Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A subclass of BasicComboBoxEditor that implements UIResource.BasicComboBoxEditor doesn't implement UIResource directly so that applications can safely override the cellRenderer property with BasicListCellRenderer subclasses.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "CheckboxUI implementation for BasicCheckboxUI Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The editor is implemented as a JTextField."},
{"description": "To work correctly you should also install a border on the divider (property SplitPaneDivider.border)."},
{"description": "Base interface for streams, which are sequences of elements supporting sequential and parallel aggregate operations.The following example illustrates an aggregate operation using the stream types Stream and IntStream, computing the sum of the weights of the red widgets: int sum(); See the class documentation for Stream and the package documentation for java.util.stream for additional specification of streams, stream operations, stream pipelines, and parallelism, which governs the behavior of all stream types."},
{"description": "Factory object that can vend Borders appropriate for the basic L & F."},
{"description": "This class implements an encoder for encoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.Instances of Base64.Encoder class are safe for use by multiple concurrent threads.Unless otherwise noted, passing a null argument to a method of this class will cause a NullPointerException to be thrown."},
{"description": "This class provides a basic implementation of the Attributes interface.BasicAttributes is either case-sensitive or case-insensitive (case-ignore).This property is determined at the time the BasicAttributes constructor is called.In a case-insensitive BasicAttributes, the case of its attribute identifiers is ignored when searching for an attribute, or adding attributes.In a case-sensitive BasicAttributes, the case is significant.When the BasicAttributes class needs to create an Attribute, it uses BasicAttribute.There is no other dependency on BasicAttribute.Note that updates to BasicAttributes (such as adding or removing an attribute) does not affect the corresponding representation in the directory.Updates to the directory can only be effected using operations in the DirContext interface.A BasicAttributes instance is not synchronized against concurrent multithreaded access.Multiple threads trying to access and modify a single BasicAttributes instance should lock the object."},
{"description": "This class provides a basic implementation of the Attribute interface.This implementation does not support the schema methods getAttributeDefinition() and(). They simply throw OperationNotSupportedException.Subclasses of BasicAttribute should override these methods if they support them.The BasicAttribute class by default uses Object.equals() to determine equality of attribute values when testing for equality or when searching for values, except when the value is an array.For an array, each element of the array is checked using Object.equals().Subclasses of BasicAttribute can make use of schema information when doing similar equality checks by overriding methods in which such use of schema is meaningful.Similarly, the BasicAttribute class by default returns the values passed to its constructor and/or manipulated using the add/remove methods.Subclasses of BasicAttribute can override get() and getAll() to get the values dynamically from the directory (or implement the Attribute interface directly instead of subclassing BasicAttribute).Note that updates to BasicAttribute (such as adding or removing a value) does not affect the corresponding representation of the attribute in the directory.Updates to the directory can only be effected using operations in the DirContext interface.A BasicAttribute instance is not synchronized against concurrent multithreaded access.Multiple threads trying to access and modify a BasicAttribute should lock the object."},
{"description": "JButton object that draws a scaled Arrow in one of the cardinal directions.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The basic functions include having properties and sending event notifications, which all JavaBeans\u2122 components must implement.The BaseRowSet class provides the core functionality for all RowSet implementations, and all standard implementations may use this class in combination with one or more RowSet interfaces in order to provide a standard vendor-specific implementation.To clarify, all implementations must implement at least one of the RowSet interfaces (JdbcRowSet, CachedRowSet, JoinRowSet, FilteredRowSet, or WebRowSet).This means that any implementation that extends the BaseRowSet class must also implement one of the RowSet interfaces.The BaseRowSet class provides the following: Properties Fields for storing current properties Methods for getting and setting properties Event notificationA complete set of setter methods for setting the parameters in a RowSet object's command Streams Fields for storing stream instances Constants for indicating the type of a stream 2.0 Setting Properties All rowsets maintain a set of properties, which will usually be set using a tool.The number and kinds of properties a rowset has will vary, depending on what the RowSet implementation does and how it gets its data.For example, rowsets that get their data from a ResultSet object need to set the properties that are required for making a database connection.If a RowSet object uses the DriverManager facility to make a connection, it needs to set a property for the JDBC URL that identifies the appropriate driver, and it needs to set the properties that give the user name and password.If, on the other hand, the rowset uses a DataSource object to make the connection, which is the preferred method, it does not need to set the property for the JDBC URL.Instead, it needs to set the property for the logical name of the data source along with the properties for the user name and password.In order to use a DataSource object for making a connection, the DataSource object must have been registered with a naming service that uses the Java Naming and Directory Interface\u2122 (JNDI) API.This registration is usually done by a person acting in the capacity of a system administrator.3.0 Setting the Command and Its Parameters When a rowset gets its data from a relational database, it executes a command (a query) that produces a ResultSet object.This query is the command that is set for the RowSet object's command property.The rowset populates itself with data by reading the data from the ResultSet object into itself.If the query contains placeholders for values to be set, the BaseRowSet setter methods are used to set these values.All setter methods allow these values to be set to null if required.The following code fragment illustrates how the CachedRowSet\u2122 object crs might have its command property set.Note that if a tool is used to set properties, this is the code that the tool would use.\"); In this example, the values for CREDIT_LIMIT and REGION are placeholder parameters, which are indicated with a question mark (?).The first question mark is placeholder parameter number 1, the second question mark is placeholder parameter number 2, and so on.Any placeholder parameters must be set with values before the query can be executed.To set these placeholder parameters, the BaseRowSet class provides a set of setter methods, similar to those provided by the PreparedStatement interface, for setting values of each data type.A RowSet object stores the parameter values internally, and its execute method uses them internally to set values for the placeholder parameters before it sends the command to the DBMS to be executed.The following code fragment demonstrates setting the two parameters in the query from the previous example.crs.setInt(1, 5000); crs.setString(2, \"West\"); If the execute method is called at this point, the query sent to the DBMS will be: \"SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS\" +Setting Array, Clob, Blob and Ref objects as a command parameter, stores these values as SerialArray, SerialClob, SerialBlob and SerialRef objects respectively.4.0 Handling of Parameters Behind the Scenes NOTE:The BaseRowSet class provides two kinds of setter methods, those that set properties and those that set placeholder parameters.The setter methods discussed in this section are those that set placeholder parameters.The placeholder parameters set with the BaseRowSet setter methods are stored as objects in an internal Hashtable object.Primitives are stored as their Object type.For example, byte is stored as Byte object, and int is stored as an Integer object.When the method execute is called, the values in the Hashtable object are substituted for the appropriate placeholder parameters in the command.A call to the method getParams returns the values stored in the Hashtable object as an array of Object instances.An element in this array may be a simple Object instance or an array (which is a type of Object).The particular setter method used determines whether an element in this array is an Object or an array.The majority of methods for setting placeholder parameters take two parameters, with the first parameter indicating which placeholder parameter is to be set, and the second parameter giving the value to be set.Methods such as setInt, setString, setBoolean, and setLong fall into this category.After these methods have been called, a call to the method getParams will return an array with the values that have been set.Each element in the array is an Object instance representing the values that have been set.The order of these values in the array is determined by the int (the first parameter) passed to the setter method.The values in the array are the values (the second parameter) passed to the setter method.In other words, the first element in the array is the value to be set for the first placeholder parameter in the RowSet object's command.The second element is the value to be set for the second placeholder parameter, and so on.Several setter methods send the driver and DBMS information beyond the value to be set.When the method getParams is called after one of these setter methods has been used, the elements in the arraywill themselves be arrays to accommodate the additional information.In this category, the method setNull is a special case because one version takes only two parameters (setNull(int parameterIndex, int SqlType)).Nevertheless, it requires an array to contain the information that will be passed to the driver and DBMS.The first element in this array is the value to be set, which is null, and the second element is the int supplied for sqlType, which indicates the type of SQL value that is being set to null.This information is needed by some DBMSs and is therefore required in order to ensure that applications are portable.The other version is intended to be used when the value to be set to null is a user-defined type.It takes three parameters (setNull(int parameterIndex, int sqlType, String typeName)) and also requires an array to contain the information to be passed to the driver and DBMS.The first two elements in this array are the same as for the first version of setNull.The third element, typeName, gives the SQL name of the user-defined type.As is true with the other setter methods, the number of the placeholder parameter to be set is indicated by an element's position in the array returned by getParams.So, for example, if the parameter supplied to setNull is 2, the second element in the array returned by getParams will be an array of two or three elements.Some methods, such as setObject and setDate have versions that take more than two parameters, with the extra parameters giving information to the driver or the DBMS.For example, the methods setDate, setTime, and setTimestamp can take a Calendar object as their third parameter.If the DBMS does not store time zone information, the driver uses the Calendar object to construct the Date, Time, or Timestamp object being set.As is true with other methods that provide additional information, the element in the array returned by getParams is an array instead of a simple Object instance.The methods setAsciiStream, setBinaryStream, setCharacterStream, and setUnicodeStream (which is deprecated, so applications should use getCharacterStream instead) take three parameters, so for them, the element in the array returned by getParams is also an array.What is different about these setter methods is that in addition to the information provided by parameters, the array contains one of the BaseRowSet constants indicating the type of stream being set.The method getParams is called internally by RowSet implementations extending this class; it is not normally called by an application programmer directly.The BaseRowSet class provides the event notification mechanism for rowsets.It contains the field listeners, methods for adding and removing listeners, and methods for notifying listeners of changes.A listener is an object that has implemented the RowSetListener interface.If it has been added to a RowSet object's list of listeners, it will be notified when an event occurs on that RowSet object.Each listener's implementation of the RowSetListener methods defines what that object will do when it is notified that an event has occurred.There are three possible events for a RowSet object: the cursor moves an individual row is changed (updated, deleted, or inserted)the contents of the entire RowSet object are changed The BaseRowSet method used for the notification indicates the type of event that has occurred.For example, the method notifyRowChanged indicates that a row has been updated, deleted, or inserted.Each of the notification methods creates a RowSetEvent object, which is supplied to the listener in order to identify the RowSet object on which the event occurred.What the listener does with this information, which may be nothing, depends on how it was implemented.BaseRowSet object is initialized with many starting values.The following is true of a default RowSet instance that extends the BaseRowSet class: Has a scrollable cursor and does not show changes made by others.Does not show rows that have been deleted.Has no time limit for how long a driver may take to execute the RowSet object's command.Has no limit for the number of rows it may contain.Has no limit for the number of bytes a column may contain.This limit applies only to columns that hold values of the following types: BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR.If other values are desired, an application must set the property values explicitly.For example, the following line of code sets the maximum number of rows for the CachedRowSet object crs to 500.crs.setMaxRows(500); Methods implemented in extensions of this BaseRowSet class must throw an SQLException object for any violation of the defined assertions.Also, if the extending class overrides and reimplements any BaseRowSet method and encounters connectivity or underlying data source issues, that method may in addition throw an SQLException object for that reason."},
{"description": "This class consists exclusively of static methods for obtaining encoders and decoders for the Base64 encoding scheme.The implementation of this class supports the following types of Base64 as specified in RFC 4648 and RFC 2045.The encoder does not add any line feed (line separator) character.The decoder rejects data that contains characters outside the base64 alphabet.URL and Filename safe Uses the \"URL and Filename safe Base64 Alphabet\" as specified in Table 2 of RFC 4648 for encoding and decoding.The encoder does not add any line feed (line separator) character.The decoder rejects data that contains characters outside the base64 alphabet.MIME Uses the \"The Base64 Alphabet\" as specified in Table 1 of RFC 2045 for encoding and decoding operation.The encoded output must be represented in lines of no more than 76 characters each and uses a carriage return '\\r' followed immediately by a linefeed '\\n' as the line separator.No line separator is added to the end of the encoded output.All line separators or other characters not found in the base64 alphabet table are ignored in decoding operation.Unless otherwise noted, passing a null argument to a method of this class will cause a NullPointerException to be thrown."},
{"description": "This class implements a decoder for decoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.The Base64 padding character '=' is accepted and interpreted as the end of the encoded byte data, but is not required.So if the final unit of the encoded byte data only has two or three Base64 characters (without the corresponding padding character(s) padded), they are decoded as if followed by padding character(s).If there is a padding character present in the final unit, the correct number of padding character(s) must be present, otherwise IllegalArgumentException ( IOException when reading from a Base64 stream) is thrown during decoding.Instances of Base64.Decoder class are safe for use by multiple concurrent threads.Unless otherwise noted, passing a null argument to a method of this class will cause a NullPointerException to be thrown."},
{"description": "The exception BadKind is thrown when an inappropriate operation is invoked on a TypeCode object.For example, invoking the method discriminator_type() on an instance of TypeCode that does not represent an IDL union will cause the exception BadKind to be thrown."},
{"description": "This class performs an arbitrary linear combination of the bands in a Raster, using a specified matrix.The width of the matrix must be equal to the number of bands in the source Raster, optionally plus one.If there is one more column in the matrix than the number of bands, there is an implied 1 at the end of the vector of band samples representing a pixel.The height of the matrix must be equal to the number of bands in the destination.For example, a 3-banded Raster might have the following transformation applied to each pixel in order to invert the second band of the Raster.[ 1 ] Note that the source and destination can be the same object."},
{"description": "This class represents image data which is stored in a band interleaved fashion and for which each sample of a pixel occupies one data element of the DataBuffer.It subclasses ComponentSampleModel but provides a more efficient implementation for accessing band interleaved image data than is provided by ComponentSampleModel.This class should typically be used when working with images which store sample data for each band in a different bank of the DataBuffer.Pixel stride is the number of data array elements between two samples for the same band on the same scanline.The pixel stride for a BandedSampleModel is one.Scanline stride is the number of data array elements between a given sample and the corresponding sample in the same column of the next scanline.The bands are numbered from 0 toN-1. Bank indices denote the correspondence between a bank of the data buffer and a band of image data.This class supports TYPE_BYTE, TYPE_USHORT, TYPE_SHORT, TYPE_INT, TYPE_FLOAT, and TYPE_DOUBLE datatypes"},
{"description": "Thrown when an invalid string operation is passed to a method for constructing a query."},
{"description": "This exception is to report bad locations within a document model (that is, attempts to reference a location that doesn't exist).Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This exception is thrown when a particular padding mechanism is expected for the input data but the data is not padded properly."},
{"description": "Thrown when an invalid expression is passed to a method for constructing a query.This exception is used internally by JMX during the evaluation of a query.User code does not usually see it."},
{"description": "Thrown when an invalid MBean attribute is passed to a query constructing method.This exception is used internally by JMX during the evaluation of a query.User code does not usually see it."},
{"description": "Exception thrown when the ORB has encountered a malformed type code (for example, a type code with an invalid TCKind value).It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "The BAD_QOS exception is raised whenever an object cannot support the quality of service required by an invocation parameter that has a quality of service semantics associated with it."},
{"description": "Contains the value used to indicate a policy value that is incorrect for a valid policy type in a call to the create_policy method defined in the ORB class."},
{"description": "A PolicyErrorCode which would be filled in the PolicyError exception."},
{"description": "A PolicyErrorCode which would be filled in the PolicyError exception."},
{"description": "Exception thrown when a parameter passed to a call is out of range or otherwise considered illegal.An ORB may raise this exception if null values or null pointers are passed to an operation (for language mappings where the concept of a null pointers or null values applies).BAD_PARAM can also be raised as a result of a client generating requests with incorrect parameters using the DII.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "Exception thrown when an object reference denotes an existing object, but that the object does not support the operation that was invoked.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "Exception thrown when an operation is invoked by a client but the passed context does not contain the context values required by the operation.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "This exception indicates that the caller has invoked operations in the wrong order.For example, it can be raised by an ORB if an application makes an ORB-related call without having correctly initialized the ORB first.It contains a minor code, which gives more detailed information about what caused the exception, and a completion status.It may also contain a string describing the exception."},
{"description": "This class is for AWT permissions.An AWTPermission contains a target name but no actions list; you either have the named permission or you don't.The target name is the name of the AWT permission (see below).The naming convention follows the hierarchical property naming convention.Also, an asterisk could be used to represent all AWT permissions.The following table lists all the possible AWTPermission target names, and for each provides a description of what the permission allows and a discussion of the risks of granting code the permission.What the Permission Allows Risks of Allowing this PermissionThis would allow malfeasant code to share potentially sensitive or confidential information.After retrieving the AWT event queue, malicious code may peek at and even remove existing events from its event queue, as well as post bogus events which may purposefully cause the application or applet to misbehave in an insecure manner.accessSystemTray Access to the AWT SystemTray instance This would allow malicious code to add tray icons to the system tray.First, such an icon may look like the icon of some known application (such as a firewall or anti-virus) and order a user to do something unsafe (with help of balloon messages).Second, the system tray may be glutted with tray icons so that no one could add a tray icon anymore.createRobot Create java.awt.Robot objects The java.awt.Robot object allows code to generate native-level mouse and keyboard events as well as read the screen.It could allow malicious code to control the system, run other programs, read the display, and deny mouse and keyboard access to the user.full-screen exclusive mode Entering full-screen exclusive mode allows direct access to low-level graphics card memory.This could be used to spoof the system, since the program is in direct control of rendering.Depending on the implementation, the security warning may not be shown for the windows used to enter the full-screen exclusive mode (assuming that the fullScreenExclusive permission has been granted to this application).Note that this behavior does not mean that the showWindowWithoutWarningBanner permission will be automatically granted to the application which has the fullScreenExclusive permission: non-full-screen windows will continue to be shown with the security warning.listenToAllAWTEvents Listen to all AWT events, system-wide After adding an AWT event listener, malicious code may scan all AWT events dispatched in the system, allowing it to read all user input (such as passwords).Each AWT event listener is called from within the context of that event queue's EventDispatchThread, so if the accessEventQueue permission is also enabled, malicious code could modify the contents of AWT event queues system-wide, causing the application or applet to misbehave in an insecure manner.Interfaces such as the java.awt.Composite interface or the java.awt.Robot class allow arbitrary code to examine pixels on the display enable malicious code to snoop on the activities of the user.When SecurityManager is installed, the invoking thread must be granted this permission in order to replace the current KeyboardFocusManager.Setting the stub which implements Applet container services Malicious code could set an applet's stub and result in unexpected behavior or denial of service to an applet.The malicious window might make itself look and behave like a real full desktop, so that information entered by the unsuspecting user is captured and subsequently misused showWindowWithoutWarningBanner Display of a window without also displaying a banner warning that the window was created by an applet Without this warning, an applet may pop up windows without the user knowing that they belong to an applet.Since users may make security-sensitive decisions based on whether or not the window belongs to an applet (entering a username and password into a dialog box, for example), disabling this warning banner may allow applets to trick the user into entering such information.When a toolkit-modal dialog is shown from an applet, it blocks all other applets in the browser.When launching applications from Java Web Start, its windows (such as the security dialog) may also be blocked by toolkit-modal dialogs, shown from these applications.watchMousePointer Getting the information about the mouse pointer position at any time Constantly watching the mouse pointer, an applet can make guesses about what the user is doing, i.e. moving the mouse to the lower left corner of the screen most likely means that the user is about to launch an application.If a virtual keypad is used so that keyboard is emulated using the mouse, an applet may guess what is being typed."},
{"description": "Thrown to indicate that a preferences operation could not complete because of a failure in the backing store, or a failure to contact the backing store."},
{"description": "An AWTKeyStroke represents a key action on the keyboard, or equivalent input device.AWTKeyStrokes can correspond to only a press or release of a particular key, just as KEY_PRESSED and KEY_RELEASED KeyEvents do; alternately, they can correspond to typing a specific Java character, just as KEY_TYPED KeyEvents do.In all cases, AWTKeyStrokes can specify modifiers (alt, shift, control, meta, altGraph, or a combination thereof) which must be present during the action for an exact match.Client code should never create an AWTKeyStroke on its own, but should instead use a variant of getAWTKeyStroke.Client use of these factory methods allows the AWTKeyStroke implementation to cache and share instances efficiently."},
{"description": "AWTEventMulticaster implements efficient and thread-safe multi-cast event dispatching for the AWT events defined in the java.awt.event package.The following example illustrates how to use this class: public myComponent extends Component { ActionListener actionListener = null; public synchronized void addActionListener(ActionListener l) { actionListener = AWTEventMulticaster.add(actionListener, l); } public synchronized void removeActionListener(ActionListener l) { actionListener = AWTEventMulticaster.remove(actionListener, l); } public void processEvent(AWTEvent e) { // when event occurs which causes \"action\" semantic ActionListener listener = actionListener; if (listener != null) { listener.actionPerformed(new ActionEvent()); } } } The important point to note is the first argument to the add and remove methods is the field maintaining the listeners.In addition you must assign the result of the add and remove methods to the field maintaining the listeners.AWTEventMulticaster is implemented as a pair of EventListeners that are set at construction time.The add and remove methods do not alter AWTEventMulticaster in anyway.In this way it is safe to add and remove listeners during the process of an event dispatching.However, event listeners added during the process of an event dispatch operation are not notified of the event currently being dispatched.All of the add methods allow null arguments.If the first argument is null, the second argument is returned.If the first argument is not null and the second argument is null, the first argument is returned.If both arguments are non-null, a new AWTEventMulticaster is created using the two arguments and returned.For the remove methods that take two arguments, the following is returned: null, if the first argument is null, or the arguments are equal, by way of ==.the first argument, if the first argument is not an instance of AWTEventMulticaster.Swing makes use of EventListenerList for similar logic."},
{"description": "A class which extends the EventListenerProxy specifically for adding an AWTEventListener for a specific event mask.Instances of this class can be added as AWTEventListeners to a Toolkit object.The getAWTEventListeners method of Toolkit can return a mixture of AWTEventListener and AWTEventListenerProxy objects."},
{"description": "During DnD operations it is possible that a user may wish to drop the subject of the operation on a region of a scrollable GUI control that is not currently visible to the user.In such situations it is desirable that the GUI control detect this and institute a scroll operation in order to make obscured region(s) visible to the user.If a GUI control is both an active DropTarget and is also scrollable, it can receive notifications of autoscrolling gestures by the user from the DnD system by implementing this interface.An autoscrolling gesture is initiated by the user by keeping the drag cursor motionless with a border region of the Component, referred to as the \"autoscrolling region\", for a predefined period of time, this will result in repeated scroll requests to the Component until the drag Cursor resumes its motion."},
{"description": "An object that may hold resources (such as file or socket handles) until it is closed.The close() method of an AutoCloseable object is called automatically when exiting a try-with-resources block for which the object has been declared in the resource specification header.This construction ensures prompt release, avoiding resource exhaustion exceptions and errors that may otherwise occur."},
{"description": "This class defines login and logout methods for a provider.While callers may invoke login directly, the provider may also invoke login on behalf of callers if it determines that a login must be performed prior to certain operations."},
{"description": "This class and its subclasses supercede the original java.awt.Event class.Subclasses of this root AWTEvent class defined outside of the java.awt.event package should define event ID values greater than the value defined by RESERVED_ID_MAX.The event masks defined in this class are needed by Component subclasses which are using Component.enableEvents() to select for event types not selected by registered listeners.If a listener is registered on a component, the appropriate event mask is already set internally by the component.The masks are also used to specify to which types of events an AWTEventListener should listen.The masks are bitwise-ORed together and passed to Toolkit.addAWTEventListener."},
{"description": "The listener interface for receiving notification of events dispatched to objects that are instances of Component or MenuComponent or their subclasses.Unlike the other EventListeners in this package, AWTEventListeners passively observe events being dispatched in the AWT, system-wide.Most applications should never use this class; applications which might use AWTEventListeners include event recorders for automated testing, and facilities such as the Java Accessibility package.The class that is interested in monitoring AWT events implements this interface, and the object created with that class is registered with the Toolkit, using the Toolkit's addAWTEventListener method.When an event is dispatched anywhere in the AWT, that object's eventDispatched method is invoked."},
{"description": "This class is for authentication permissions.An AuthPermission contains a name (also referred to as a \"target name\") but no actions list; you either have the named permission or you don't.The target name is the name of a security configuration parameter (see below).Currently the AuthPermission object is used to guard access to the Policy, Subject, LoginContext, and Configuration objects.The possible target names for an Authentication Permission are: doAs - allow the caller to invoke the Subject.doAs methods.doAsPrivileged - allow the caller to invoke the Subject.doAsPrivileged methods.getSubject - allow for the retrieval of the Subject(s) associated with the current Thread.getSubjectFromDomainCombiner - allow for the retrieval of the Subject associated with the a SubjectDomainCombiner. setReadOnly - allow the caller to set a Subject to be read-only.modifyPrincipals - allow the caller to modify the Set of Principals associated with a Subject modifyPublicCredentials - allow the caller to modify the Set of public credentials associated with a Subject modifyPrivateCredentials - allow the caller to modify the Set of private credentials associated with a Subject refreshCredential - allow code to invoke the refresh method on a credential which implements the Refreshable interface.destroyCredential - allow code to invoke the destroy method on a credential object which implements the Destroyable interface.createLoginContext.{name} - allow code to instantiate a LoginContext with the specified name.name is used as the index into the installed login Configuration (that returned by Configuration.getConfiguration()).name can be wildcarded (set to '*') to allow for any name.The following target name has been deprecated in favor of createLoginContext.{name}.javax.security.auth.Policy has been deprecated in favor of java.security.Policy.getPolicy - allow the caller to retrieve the system-wide Subject-based access control policy.setPolicy - allow the caller to set the system-wide Subject-based access control policy.refreshPolicy - allow the caller to refresh the system-wide Subject-based access control policy."},
{"description": "This callback is used by SaslServer to determine whether one entity (identified by an authenticated authentication id) can act on behalf of another entity (identified by an authorization id)."},
{"description": "The class Authenticator represents an object that knows how to obtain authentication for a network connection.Usually, it will do this by prompting the user for information.Applications use this class by overriding getPasswordAuthentication() in a sub-class.This method will typically use the various getXXX() accessor methods to get information about the entity requesting authentication.It must then acquire a username and password either by interacting with the user or through some other non-interactive means.The credentials are then returned as a PasswordAuthentication return value.An instance of this concrete sub-class is then registered with the system by calling setDefault(Authenticator).When authentication is required, the system will invoke one of the requestPasswordAuthentication() methods which in turn will call the getPasswordAuthentication() method of the registered object.All methods that request authentication have a default implementation that fails."},
{"description": "This exception is thrown by a SASL mechanism implementation to indicate that the SASL exchange has failed due to reasons related to authentication, such as an invalid identity, passphrase, or key.Note that the lack of an AuthenticationException does not mean that the failure was not due to an authentication error.A SASL mechanism implementation might throw the more general SaslException instead of AuthenticationException if it is unable to determine the nature of the failure, or if does not want to disclose the nature of the failure, for example, due to security reasons."},
{"description": "This exception is thrown when the particular flavor of authentication requested is not supported.For example, if the program is attempting to use strong authentication but the directory/naming supports only simple authentication, this exception would be thrown.Identification of a particular flavor of authentication is provider- and server-specific.It may be specified using specific authentication schemes such those identified using SASL, or a generic authentication specifier (such as \"simple\" and \"strong\").If the program wants to handle this exception in particular, it should catch AuthenticationNotSupportedException explicitly before attempting to catch NamingException.After catching AuthenticationNotSupportedException, the program could reattempt the authentication using a different authentication flavor by updating the resolved context's environment properties accordingly.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "The AudioSystem class acts as the entry point to the sampled-audio system resources.This class lets you query and access the mixers that are installed on the system.AudioSystem includes a number of methods for converting audio data between different formats, and for translating between audio files and streams.It also provides a method for obtaining a Line directly from the AudioSystem without dealing explicitly with mixers.Properties can be used to specify the default mixer for specific line types.The sound.properties properties file is read from an implementation-specific location (typically it is the lib directory in the Java installation directory).If a property exists both as a system property and in the properties file, the system property takes precedence.If none is specified, a suitable default is chosen among the available devices.The syntax of the properties file is specified in Properties.load.The following table lists the available property keys and which methods consider them: Audio System Property Keys Property Key Interface Affected Method(s)The property value consists of the provider class name and the mixer name, separated by the hash mark (\"#\").The provider class name is the fully-qualified name of a concrete mixer provider class.The mixer name is matched against the String returned by the getName method of Mixer.If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of Mixer.Info objects is retrieved from the provider.Otherwise, or when these mixers do not provide a subsequent match, the list is retrieved from getMixerInfo() to contain all available Mixer.If a mixer name is specified, the resulting list of Mixer.Info objects is searched: the first one with a matching name, and whose Mixer provides the respective line interface, will be returned.Info object is found, or the mixer name is not specified, the first mixer from the resulting list, which provides the respective line interface, will be returned.For example, the property javax.sound.sampled.Clip with a value \"com.sun.media.sound.MixerProvider#SunClip\" will have the following consequences when getLine is called requesting a Clip instance: if the class com.sun.media.sound.MixerProvider exists in the list of installed mixer providers, the first Clip from the first mixer with name \"SunClip\" will be returned.If it cannot be found, the first Clip from the first mixer of the specified provider will be returned, regardless of name.If there is none, the first Clip from the first Mixer with name \"SunClip\" in the list of all mixers (as returned by getMixerInfo) will be returned, or, if not found, the first Clip of the first Mixerthat can be found in the list of all mixers is returned."},
{"description": "This exception is thrown when an authentication error occurs while accessing the naming or directory service.An authentication error can happen, for example, when the credentials supplied by the user program is invalid or otherwise fails to authenticate the user to the naming/directory service.If the program wants to handle this exception in particular, it should catch AuthenticationException explicitly before attempting to catch NamingException.After catching AuthenticationException, the program could reattempt the authentication by updating the resolved context's environment properties with the appropriate appropriate credentials.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "The AudioPermission class represents access rights to the audio system resources.An AudioPermission contains a target name but no actions list; you either have the named permission or you don't.The target name is the name of the audio permission (see the table below).The names follow the hierarchical property-naming convention.Also, an asterisk can be used to represent all the audio permissions.The following table lists the possible AudioPermission target names.For each name, the table provides a description of exactly what that permission allows, as well as a discussion of the risks of granting code the permission.What the Permission Allows Risks of Allowing this Permission play Audio playback through the audio device or devices on the system.In some cases use of this permission may affect other applications because the audio from one line may be mixed with other audio being played on the system, or because manipulation of a mixer affects the audio for all lines using that mixer.In some cases use of this permission may affect other applications because manipulation of a mixer affects the audio for all lines using that mixer.This permission can enable an applet or application to eavesdrop on a user."},
{"description": "An audio input stream is an input stream with a specified audio format and length.The length is expressed in sample frames, not bytes.Several methods are provided for reading a certain number of bytes from the stream, or an unspecified number of bytes.The audio input stream keeps track of the last byte that was read.You can skip over an arbitrary number of bytes to get to a later position for reading.An audio input stream may support marks.When you set a mark, the current position is remembered so that you can return to it later.The AudioSystem class includes many methods that manipulate AudioInputStream objects.For example, the methods let you: obtain an audio input stream from an external audio file, stream, or URL write an external file from an audio input stream convert an audio input stream to a different audio format"},
{"description": "An instance of the Type class represents one of the standard types of audio file.Static instances are provided for the common types."},
{"description": "An instance of the AudioFileFormat class describes an audio file, including the file type, the file's length in bytes, the length in sample frames of the audio data contained in the file, and the format of the audio data.The AudioSystem class includes methods for determining the format of an audio file, obtaining an audio input stream from an audio file, and writing an audio file from an audio input stream.An AudioFileFormat object can include a set of properties.A property is a pair of key and value: the key is of type String, the associated property value is an arbitrary object.Properties specify additional informational meta data (like a author, copyright, or file duration).Properties are optional information, and file reader and file writer implementations are not required to provide or recognize properties.The following table lists some common properties that should be used in implementations: Audio File Format Properties Property key Value type Description \"duration\" Long playback duration of the file in microseconds \"author\" String name of the author of this file \"title\" String title of this file \"copyright\" String copyright message \"date\" Date date of the recording or release \"comment\" String an arbitrary text"},
{"description": "Classes providing concrete implementations can parse the format information from one or more types of audio file, and can produce audio input streams from files of these types."},
{"description": "Classes providing concrete implementations can write one or more types of audio file from an audio stream."},
{"description": "The AudioClip interface is a simple abstraction for playing a sound clip.Multiple AudioClip items can be playing at the same time, and the resulting sound is mixed together to produce a composite."},
{"description": "The Encoding class names the specific type of data representation used for an audio stream.The encoding includes aspects of the sound format other than the number of channels, sample rate, sample size, frame rate, frame size, and byte order.One ubiquitous type of audio encoding is pulse-code modulation (PCM), which is simply a linear (proportional) representation of the sound waveform.With PCM, the number stored in each sample is proportional to the instantaneous amplitude of the sound pressure at that point in time.The numbers may be signed or unsigned integers or floats.Besides PCM, other encodings include mu-law and a-law, which are nonlinear mappings of the sound amplitude that are often used for recording speech.You can use a predefined encoding by referring to one of the static objects created by this class, such as PCM_SIGNED or PCM_UNSIGNED.Service providers can create new encodings, such as compressed audio formats, and make these available through the AudioSystem class.The Encoding class is static, so that all AudioFormat objects that have the same encoding will refer to the same object (rather than different instances of the same class)."},
{"description": "AudioFormat is the class that specifies a particular arrangement of data in a sound stream.By examining the information stored in the audio format, you can discover how to interpret the bits in the binary sound data.Every data line has an audio format associated with its data stream.The audio format of a source (playback) data line indicates what kind of data the data line expects to receive for output.For a target (capture) data line, the audio format specifies the kind of the data that can be read from the line.Sound files also have audio formats, of course.The AudioFileFormat class encapsulates an AudioFormat in addition to other, file-specific information.Similarly, an AudioInputStream has an AudioFormat.The AudioFormat class accommodates a number of common sound-file encoding techniques, including pulse-code modulation (PCM), mu-law encoding, and a-law encoding.These encoding techniques are predefined, but service providers can create new encoding types.The encoding that a specific format uses is named by its encoding field.In addition to the encoding, the audio format includes other properties that further specify the exact arrangement of the data.These include the number of channels, sample rate, sample size, byte order, frame rate, and frame size.Sounds may have different numbers of audio channels: one for mono, two for stereo.The sample rate measures how many \"snapshots\" (samples) of the sound pressure are taken per second, per channel.(If the sound is stereo rather than mono, two samples are actually measured at each instant of time: one for the left channel, and another for the right channel; however, the sample rate still measures the number per channel, so the rate is the same regardless of the number of channels.This is the standard use of the term.)The sample size indicates how many bits are used to store each snapshot; 8 and 16 are typical values.For 16-bit samples (or any other sample size larger than a byte), byte order is important; the bytes in each sample are arranged in either the \"little-endian\" or \"big-endian\" style.For encodings like PCM, a frame consists of the set of samples for all channels at a given point in time, and so the size of a frame (in bytes) is always equal to the size of a sample (in bytes)However, with some other sorts of encodings a frame can contain a bundle of compressed data for a whole series of samples, as well as additional, non-sample data.For such encodings, the sample rate and sample size refer to the data after it is decoded into PCM, and so they are completely different from the frame rate and frame size.An AudioFormat object can include a set of properties.A property is a pair of key and value: the key is of type String, the associated property value is an arbitrary object.Properties specify additional format specifications, like the bit rate for compressed formats.Properties are mainly used as a means to transport additional information of the audio format to and from the service providers.Therefore, properties are ignored in the matches(AudioFormat) method.However, methods which rely on the installed service providers, like (AudioFormat, AudioFormat) isConversionSupported may consider properties, depending on the respective service provider implementation.The following table lists some common properties which service providers should use, if applicable: Audio Format Properties Property key Value type Description \"bitrate\" Integer average bit rate in bits per second \"vbr\" Boolean true, if the file is encoded in variable bit rate (VBR) \"quality\" Integer encoding/conversion quality, 1..100 Vendors of service providers (plugins) are encouraged to seek information about other already established properties in third party plugins, and follow the same conventions."},
{"description": "An object that provides a read-only or updatable view of non-opaque values associated with an object in a filesystem.This interface is extended or implemented by specific attribute views that define the attributes supported by the view.A specific attribute view will typically define type-safe methods to read or update the attributes that it supports."},
{"description": "This interface is the type signature that is expected to be present on any attribute key that contributes to the determination of what font to use to render some text.This is not considered to be a closed set, the definition can change across version of the platform and can be amended by additional user added entries that correspond to logical settings that are specific to some type of content."},
{"description": "This interface is the type signature that is expected to be present on any attribute key that contributes to the paragraph level presentation."},
{"description": "This interface is the type signature that is expected to be present on any attribute key that contributes to character level presentation.This would be any attribute that applies to a so-called run of style."},
{"description": "This interface is the type signature that is expected to be present on any attribute key that contributes to presentation of color."},
{"description": "Instances of this class are usually obtained using Query.attr."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This class provides a default implementation of the SAX2 Attributes interface, with the addition of manipulators so that the list can be modified or reused.There are two typical uses of this class: to take a persistent snapshot of an Attributes object in a startElement event; or to construct or modify an Attributes object in a SAX2 driver or filter.This class replaces the now-deprecated SAX1 AttributeListImpl class; in addition to supporting the updated Attributes interface rather than the deprecated AttributeList interface, it also includes a much more efficient implementation using a single array rather than a set of Vectors."},
{"description": "Class AttributeSetUtilities provides static methods for manipulating AttributeSets.AttributeSet An unmodifiable view U of an AttributeSet S provides a client with \"read-only\" access to S. Query operations on U \"read through\" to S; thus, changes in S are reflected in U. However, any attempt to modify U, results in an UnmodifiableSetException.S provides a client with synchronized (multiple thread safe) access to S.Each operation of V is synchronized using V itself as the lock object and then merely invokes the corresponding operation of S.In order to guarantee mutually exclusive access, it is critical that all access to S is accomplished through V. The synchronized view object V will be serializable if the attribute set objectUsage to the contrary is incorrect coding and may result in a run time exception either immediately or at some later time."},
{"description": "Interface AttributeSet specifies the interface for a set of printing attributes.A printing attribute is an object whose class implements interface Attribute.An attribute set contains a group of attribute values, where duplicate values are not allowed in the set.Furthermore, each value in an attribute set is a member of some category, and at most one value in any particular category is allowed in the set.For an attribute set, the values are Attribute objects, and the categories are Class objects.An attribute's category is the class (or interface) at the root of the class hierarchy for that kind of attribute.Note that an attribute object's category may be a superclass of the attribute object's class rather than the attribute object's class itself.An attribute object's category is determined by calling the getCategory() method defined in interface Attribute.The interfaces of an AttributeSet resemble those of the Java Collections API's java.util.Map interface, but is more restrictive in the types it will accept, and combines keys and values into an Attribute.Attribute sets are used in several places in the Print Service API.In each context, only certain kinds of attributes are allowed to appear in the attribute set, as determined by the tagging interfaces which the attribute class implements --There are four specializations of an attribute set that are restricted to contain just one of the four kinds of attribute -- DocAttributeSet, PrintRequestAttributeSet, PrintJobAttributeSet, and PrintServiceAttributeSet, respectively.Note that many attribute classes implement more than one tagging interface and so may appear in more than one context.A DocAttributeSet, containing DocAttributes, specifies the characteristics of an individual doc and the print job settings to be applied to an individual doc.A PrintJobAttributeSet, containing PrintJobAttributes, reports the status of a print job.A PrintServiceAttributeSet, containing PrintServiceAttributes, reports the status of a Print Service instance.In some contexts, the client is only allowed to examine an attribute set's contents but not change them (the set is read-only).In other places, the client is allowed both to examine and to change an attribute set's contents (the set is read-write).For a read-only attribute set, calling a mutating operation throws an UnmodifiableSetException.The Print Service API provides one implementation of interface AttributeSet, class HashAttributeSet.A client can use class HashAttributeSet or provide its own implementation of interface AttributeSet.The Print Service API also provides implementations of interface AttributeSet's subinterfaces -- classes HashDocAttributeSet, HashPrintRequestAttributeSet, HashPrintJobAttributeSet, and HashPrintServiceAttributeSet."},
{"description": "Name class represents an attribute name stored in this Map.Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length.Attribute values can contain any characters and will be UTF8-encoded when written to the output stream."},
{"description": "Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length.Attribute values can contain any characters and will be UTF8-encoded when written to the output stream."},
{"description": "If an implementation supports this extension, the attributes provided in ContentHandler.startElement() will implement this interface, and the http://xml.org/sax/features/use-attributes2 feature flag will have the value true.This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.XMLReader implementations are not required to support this information, and it is not part of core-only SAX2 distributions.it will of necessity also have been declared (isDeclared()) in the DTD.Similarly if an attribute's type is anything except CDATA, then it must have been declared."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This interface allows access to a list of attributes in three different ways: by attribute index; by Namespace-qualified name; or by qualified (prefixed) name.The list will not contain attributes that were declared #IMPLIED but not specified in the start tag.It will also not contain attributes used as Namespace declarations (xmlns*) unless the http://xml.org/sax/features/namespace-prefixes feature is set to true (it is false by default).Because SAX2 conforms to the original \"Namespaces in XML\" recommendation, it normally does not give namespace declaration attributes a namespace URI.Some SAX2 parsers may support using an optional feature flag (http://xml.org/sax/features/xmlns-uris) to request that those attributes be given URIs, conforming to a later backwards-incompatible revision of that recommendation.(The attribute's \"local name\" will be the prefix, or \"xmlns\" when defining a default element namespace.)For portability, handler code should always resolve that conflict, rather than requiring parsers that can change the setting of that feature flag.If the namespace-prefixes feature (see above) is false, access by qualified name may not be available; if the http://xml.org/sax/features/namespaces feature is false, access by Namespace-qualified names may not be available.This interface replaces the now-deprecated SAX1 AttributeList interface, which does not contain Namespace support.In addition to Namespace support, it adds the getIndex methods (below).The order of attributes in the list is unspecified, and will vary from implementation to implementation."},
{"description": "This interface represents a collection of attributes.The Attributes interface represents a collection of attributes.For example, you can request from the directory the attributes associated with an object.Those attributes are returned in an object that implements the Attributes interface.Attributes in an object that implements the Attributes interface are unordered.The object can have zero or more attributes.This property is determined at the time the Attributes object is created.In a case-insensitive Attributes, the case of its attribute identifiers is ignored when searching for an attribute, or adding attributes.In a case-sensitive Attributes, the case is significant.Note that updates to Attributes (such as adding or removing an attribute) do not affect the corresponding representation in the directory.Updates to the directory can only be effected using operations in the DirContext interface."},
{"description": "This is a read-only, immutable interface.An attribute is basically a key and a value assigned to the key.The collection may represent something like a style run, a logical style, etc.These are generally used to describe features that will contribute to some graphical representation such as a font.The set of possible keys is unbounded and can be anything.Typically View implementations will respond to attribute definitions and render something to represent the attributes.Attributes can potentially resolve in a hierarchy.If a key doesn't resolve locally, and a resolving parent exists, the key will be resolved through the parent."},
{"description": "This module, both source code and documentation, is in the Public Domain, and comes with NO WARRANTY.This is not part of core-only SAX2 distributions.The specified flag for each attribute will always be true, unless it has been set to false in the copy constructor or using setSpecified(int, boolean).Similarly, the declared flag for each attribute will always be false, except for defaulted attributes (specified is false), non-CDATA attributes, or when it is set to true using setDeclared(int, boolean).If you change an attribute's type by hand, you may need to modify its declared flag to match."},
{"description": "This exception is thrown when an attempt is made to add, or remove, or modify an attribute, its identifier, or its values that conflicts with the attribute's (schema) definition or the attribute's state.It is thrown in response to DirContext.modifyAttributes().It contains a list of modifications that have not been performed, in the order that they were supplied to modifyAttributes().If the list is null, none of the modifications were performed successfully.An AttributeModificationException instance is not synchronized against concurrent multithreaded access.Multiple threads trying to access and modify a single AttributeModification instance should lock the object."},
{"description": "This class implements a deprecated interface, AttributeList; that interface has been replaced by Attributes, which is implemented in the AttributesImpl helper class."},
{"description": "This interface has been replaced by the SAX2 Attributes interface, which includes Namespace support."},
{"description": "For compatibility reasons, it is possible, though highly discouraged, to add objects to an AttributeList that are not instances of Attribute.However, an AttributeList can be made type-safe, which means that an attempt to add an object that is not an Attribute will produce an IllegalArgumentException.An AttributeList becomes type-safe when the method asList() is called on it."},
{"description": "This exception is thrown when an operation attempts to add an attribute that already exists.Synchronization and serialization issues that apply to NamingException apply directly here."},
{"description": "This class defines the attributes of an SGML element as described in a DTD using the ATTLIST construct.An AttributeList can be obtained from the Element class using the getAttributes() method.It is actually an element in a linked list."},
{"description": "Interface AttributeException is a mixin interface which a subclass of PrintException can implement to report an error condition involving one or more printing attributes that a particular Print Service instance does not support.The Print Service API does not define any print exception classes that implement interface AttributeException, that being left to the Print Service implementor's discretion."},
{"description": "An AttributedString holds text and related attribute information.It may be used as the actual data storage in some cases where a text reader wants to access attributed text through the AttributedCharacterIterator interface.An attribute is a key/value pair, identified by the key.No two attributes on a given character can have the same key.The values for an attribute are immutable, or must not be mutated by clients or storage.They are always passed by reference, and not cloned."},
{"description": "Defines attribute keys that are used to identify text attributes.These keys are used in AttributedCharacterIterator and AttributedString."},
{"description": "An AttributedCharacterIterator allows iteration through both text and related attribute information.An attribute is a key/value pair, identified by the key.No two attributes on a given character can have the same key.The values for an attribute are immutable, or must not be mutated by clients or storage.They are always passed by reference, and not cloned.A run with respect to an attribute is a maximum text range for which: the attribute is undefined or null for the entire range, or the attribute value is defined and has the same non-null value for the entire range.A run with respect to a set of attributes is a maximum text range for which this condition is met for each member attribute.When getting a run with no explicit attributes specified (i.e., calling getRunStart() and getRunLimit()), any contiguous text segments having the same attributes (the same set of attribute/value pairs) are treated as separate runs if the attributes have been given to those text segments separately.The returned indexes are limited to the range of the iterator.The returned attribute information is limited to runs that contain the current character.Attribute keys are instances of AttributedCharacterIterator.Attribute and its subclasses, such as TextAttribute."},
{"description": "The filtering is performed on the name of the observed attribute.It manages a list of enabled attribute names."},
{"description": "Interface Attribute is the base interface implemented by any and every printing attribute class to indicate that the class represents a printing attribute."},
{"description": "It's up to the MBean owning the attribute of interest to create and send attribute change notifications when the attribute change occurs.So the NotificationBroadcaster interface has to be implemented by any MBean for which an attribute change is of interest.Example: If an MBean called myMbean needs to notify registered listeners when its attribute: String myString is modified, myMbean creates and emits the following notification: new AttributeChangeNotification(myMbean, sequenceNumber, timeStamp, msg, \"myString\", \"String\", oldValue, newValue);"},
{"description": "An interface that contains information about an attribute.Attributes are reported as a set of events accessible from a StartElement.Other applications may report Attributes as first-order events, for example as the results of an XPath expression."},
{"description": "This interface represents an attribute associated with a named object.The Attribute interface represents an attribute associated with a named object.An attribute contains 0 or more, possibly null, values.The attribute values can be ordered or unordered (see isOrdered()).The content and representation of an attribute and its values is defined by the attribute's schema.The schema contains information about the attribute's syntax and other properties about the attribute.Equality of two attributes is determined by the implementation class.A simple implementation can use Object.equals() to determine equality of attribute values, while a more sophisticated implementation might make use of schema information to determine equality.Similarly, one implementation might provide a static storage structure which simply returns the values passed to its constructor, while another implementation might define get() and getAll().Note that updates to Attribute (such as adding or removing a value) do not affect the corresponding representation of the attribute in the directory.Updates to the directory can only be effected using operations in the DirContext interface."},
{"description": "The MBean server and other objects use this class to get and set attributes values."},
{"description": "A SOAPMessage object may contain zero, one, or many AttachmentPart objects.Each AttachmentPart object consists of two parts, application-specific content and associated MIME headers.The MIME headers consists of name/value pairs that can be used to identify and describe the content.An AttachmentPart object must conform to certain standards.It must conform to MIME [RFC2045] standards It MUST contain contentThe header portion MUST include the following header:This header identifies the type of data in the content of an AttachmentPart object and MUST conform to [RFC2045].The following is an example of a Content-Type header:The following line of code, in which ap is an AttachmentPart object, sets the header shown in the previous example.; There are no restrictions on the content portion of an AttachmentPart object.The content may be anything from a simple plain text object to a complex XML document or image file.An AttachmentPart object is created with the method SOAPMessage.createAttachmentPart.After setting its MIME headers, the AttachmentPart object is added to the message that created it with the method SOAPMessage.addAttachmentPart.The following code fragment, in which m is a SOAPMessage object and contentStringl is a String, creates an instance of AttachmentPart, sets the AttachmentPart object with some content and header information, and adds the AttachmentPart object to the SOAPMessage object.; ap1.setContent(contentString1, \"text/plain\"); m.addAttachmentPart(ap1); The following code fragment creates and adds a second AttachmentPart instance to the same message.jpegData is a binary byte buffer representing the jpeg file.= m.createAttachmentPart(); byte[] jpegData = ...; ap2.setContent(new ByteArrayInputStream(jpegData), \"image/jpeg\"); m.addAttachmentPart(ap2); The getContent method retrieves the contents and header from an AttachmentPart object.Depending on the DataContentHandler objects present, the returned Object can either be a typed Java object corresponding to the MIME type or an InputStream object that contains the content as bytes.String content1 = ap1.getContent(); java.io.InputStream content2 = ap2.getContent(); The method clearContent removes all the content from an AttachmentPart object but does not affect its header information."},
{"description": "The Attr interface represents an attribute in an Element object.Typically the allowable values for the attribute are defined in a schema associated with the document.Attr objects inherit the Node interface, but since they are not actually child nodes of the element they describe, the DOM does not consider them part of the document tree.The DOM takes the view that attributes are properties of elements rather than having a separate identity from the elements they are associated with; this should make it more efficient to implement such features as default attributes associated with all elements of a given type.Furthermore, Attr nodes may not be immediate children of a DocumentFragment.However, they can be associated with Element nodes contained within a DocumentFragment.In short, users and implementors of the DOM need to be aware that Attr nodes have some things in common with other objects inheriting the Node interface, but they also are quite distinct.The attribute's effective value is determined as follows: if this attribute has been explicitly assigned any value, that value is the attribute's effective value; otherwise, if there is a declaration for this attribute, and that declaration includes a default value, then that default value is the attribute's effective value; otherwise, the attribute does not exist on this element in the structure model until it has been explicitly added.Note that the Node.nodeValue attribute on the Attr instance can also be used to retrieve the string version of the attribute's value(s).If the attribute was not explicitly given a value in the instance document but has a default value provided by the schema associated with the document, an attribute node will be created with specified set to false.Removing attribute nodes for which a default value is defined in the schema generates a new attribute node with the default value and specified set to false.If validation occurred while invoking Document.normalizeDocument(), attribute nodes with specified equals to false are recomputed according to the default attribute values provided by the schema.If no default value is associate with this attribute in the schema, the attribute node is discarded.In XML, where the value of an attribute can contain entity references, the child nodes of the Attr node may be either Text or EntityReference nodes (when these are in use; see the description of EntityReference for discussion).The DOM Core represents all attribute values as simple strings, even if the DTD or schema associated with the document declares them of some specific type such as tokenized.The way attribute value normalization is performed by the DOM implementation depends on how much the implementation knows about the schema in use.Typically, the value and nodeValue attributes of an Attr node initially returns the normalized value given by the parser.It is also the case after Document.normalizeDocument() is called (assuming the right options have been set).But this may not be the case after mutation, independently of whether the mutation is performed by setting the string value directly or by changing the Attr child nodes.In particular, this is true when character references are involved, given that they are not represented in the DOM and they impact attribute value normalization.On the other hand, if the implementation knows about the schema in use when the attribute value is changed, and it is of a different type than CDATA, it may normalize it again at that time.This is especially true of specialized DOM implementations, such as SVG DOM implementations, which store attribute values in an internal form different from a string.The following table gives some examples of the relations between the attribute value in the original document (parsed attribute), the value as exposed in the DOM, and the serialization of the value: Examples Parsed attribute value Initial Attr.value Serialized attribute value Character reference \"x&#178;=5\" \"x\u00b2=5\" \"x&#178;=5\" Built-in character entity/Save Options See also the Document Object Model (DOM) Level 3 Core Specification."},
{"description": "This API enables an efficient cooperative creation of optimized binary data formats between a JAXB marshalling process and a MIME-based package processor.A JAXB implementation marshals the root body of a MIME-based package, delegating the creation of referenceable MIME parts to the MIME-based package processor that implements this abstraction.WS-I Attachment Profile 1.0 is supported by addSwaRefAttachment(DataHandler) being called by the marshaller for each JAXB property related to {http://ws-i.org/profiles/basic/1.1/xsd}swaRef."},
{"description": "An AtomicStampedReference maintains an object reference along with an integer \"stamp\", that can be updated atomically.Implementation note: This implementation maintains stamped references by creating internal objects representing \"boxed\" [reference, integer] pairs."},
{"description": "An array of object references in which elements may be updated atomically."},
{"description": "This API enables an efficient cooperative processing of optimized binary data formats between a JAXB 2.0 implementation and MIME-based package processor (MTOM/XOP and WS-I AP 1.0).JAXB unmarshals the body of a package, delegating the understanding of the packaging format being used to a MIME-based package processor that implements this abstract class.This abstract class identifies if a package requires XOP processing, isXOPPackage() and provides retrieval of binary content stored as attachments by content-id.For XOP processing, the infoset representation of the cid is described in step 2a in Section 3.2 Interpreting XOP Packages For WS-I AP 1.0, the cid is identified as an element or attribute of type ref:swaRef specified in Section 4.4 Referencing Attachments from the SOAP Envelope"},
{"description": "A reflection-based utility that enables atomic updates to designated volatile reference fields of designated classes.This class is designed for use in atomic data structures in which several reference fields of the same node are independently subject to atomic updates.For example, a tree node might be declared as class Node { private volatile Node left, right; private static final AtomicReferenceFieldUpdater<Node, Node>AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, \"right\"); Node getLeft() { return left; } boolean compareAndSetLeft(Node expect, Node update) { return leftUpdater.compareAndSet(this, expect, update); } // ...Note that the guarantees of the compareAndSet method in this class are weaker than in other atomic classes.Because this class cannot ensure that all uses of the field are appropriate for purposes of atomic access, it can guarantee atomicity only with respect to other invocations of compareAndSet and set on the same updater."},
{"description": "Checked exception thrown when a file cannot be moved as an atomic file system operation."},
{"description": "A reflection-based utility that enables atomic updates to designated volatile long fields of designated classes.This class is designed for use in atomic data structures in which several fields of the same node are independently subject to atomic updates.Note that the guarantees of the compareAndSet method in this class are weaker than in other atomic classes.Because this class cannot ensure that all uses of the field are appropriate for purposes of atomic access, it can guarantee atomicity only with respect to other invocations of compareAndSet and set on the same updater."},
{"description": "An AtomicMarkableReference maintains an object reference along with a mark bit, that can be updated atomically.Implementation note: This implementation maintains markable references by creating internal objects representing \"boxed\" [reference, boolean] pairs."},
{"description": "An AtomicLong is used in applications such as atomically incremented sequence numbers, and cannot be used as a replacement for a Long.However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes."},
{"description": "A long array in which elements may be updated atomically."},
{"description": "An int array in which elements may be updated atomically."},
{"description": "A reflection-based utility that enables atomic updates to designated volatile int fields of designated classes.This class is designed for use in atomic data structures in which several fields of the same node are independently subject to atomic updates.Note that the guarantees of the compareAndSet method in this class are weaker than in other atomic classes.Because this class cannot ensure that all uses of the field are appropriate for purposes of atomic access, it can guarantee atomicity only with respect to other invocations of compareAndSet and set on the same updater."},
{"description": "An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer.However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes."},
{"description": "An AtomicBoolean is used in applications such as atomically updated flags, and cannot be used as a replacement for a Boolean."},
{"description": "Asynchronous socket channels are created in one of two ways.A newly-created AsynchronousSocketChannel is created by invoking one of the open methods defined by this class.A connected AsynchronousSocketChannel is created when a connection is made to the socket of an AsynchronousServerSocketChannel.It is not possible to create an asynchronous socket channel for an arbitrary, pre-existing socket.A newly-created channel is connected by invoking its connect method; once connected, a channel remains connected until it is closed.Whether or not a socket channel is connected may be determined by invoking its getRemoteAddress method.An attempt to invoke an I/O operation upon an unconnected channel will cause a NotYetConnectedException to be thrown.Channels of this type are safe for use by multiple concurrent threads.They support concurrent reading and writing, though at most one read operation and one write operation can be outstanding at any time.If a thread initiates a read operation before a previous read operation has completed then a ReadPendingException will be thrown.Similarly, an attempt to initiate a write operation before a previous write has completed will throw a WritePendingException.Socket options are configured using the setOption method.Asynchronous socket channels support the following options: Option Name DescriptionThe size of the socket send buffer SO_RCVBUFThe size of the socket receive bufferSO_KEEPALIVE Keep connectionTimeouts The read and write methods defined by this class allow a timeout to be specified when initiating a read or write operation.If the timeout elapses before an operation completes then the operation completes with the exception InterruptedByTimeoutException.A timeout may leave the channel, or the underlying connection, in an inconsistent state.Where the implementation cannot guarantee that bytes have not been read from the channel then it puts the channel into an implementation specific error state.A subsequent attempt to initiate a read operation causes an unspecified runtime exception to be thrown.Similarly if a write operation times out and the implementation cannot guarantee bytes have not been written to the channel then further attempts to write to the channel cause an unspecified runtime exception to be thrown.When a timeout elapses then the state of the ByteBuffer, or the sequence of buffers, for the I/O operation is not defined.All methods that accept timeout parameters treat values less than or equal to zero to mean that the I/O operation does not timeout."},
{"description": "Checked exception received by a thread when another thread closes the channel or the part of the channel upon which it is blocked in an I/O operation."},
{"description": "An asynchronous file channel is created when a file is opened by invoking one of the open methods defined by this class.The file contains a variable-length sequence of bytes that can be read and written and whose current size can be queried.The size of the file increases when bytes are written beyond its current size; the size of the file decreases when it is truncated.An asynchronous file channel does not have a current position within the file.Instead, the file position is specified to each read and write method that initiates asynchronous operations.A CompletionHandler is specified as a parameter and is invoked to consume the result of the I/O operation.This class also defines read and write methods that initiate asynchronous operations, returning a Future to represent the pending result of the operation.The Future may be used to check if the operation has completed, wait for its completion, and retrieve the result.In addition to read and write operations, this class defines the following operations: Updates made to a file may be forced out to the underlying storage device, ensuring that data are not lost in the event of a system crash.A region of a file may be locked against access by other programs.An AsynchronousFileChannel is associated with a thread pool to which tasks are submitted to handle I/O events and dispatch to completion handlers that consume the results of I/O operations on the channel.The completion handler for an I/O operation initiated on a channel is guaranteed to be invoked by one of the threads in the thread pool(This ensures that the completion handler is run by a thread with the expected identity).Where an I/O operation completes immediately, and the initiating thread is itself a thread in the thread pool, then the completion handler may be invoked directly by the initiating thread.When an AsynchronousFileChannel is created without specifying a thread pool then the channel is associated with a system-dependent default thread pool that may be shared with other channels.The default thread pool is configured by the system properties defined by the AsynchronousChannelGroup class.Channels of this type are safe for use by multiple concurrent threads.The close method may be invoked at any time, as specified by the Channel interface.This causes all outstanding asynchronous operations on the channel to complete with the exceptionMultiple read and write operations may be outstanding at the same time.When multiple read and write operations are outstanding then the ordering of the I/O operations, and the order that the completion handlers are invoked, is not specified; they are not, in particular, guaranteed to execute in the order that the operations were initiated.The ByteBuffers used when reading or writing are not safe for use by multiple concurrentAs with FileChannel, the view of a file provided by an instance of this class is guaranteed to be consistent with other views of the same file provided by other instances in the same program.The view provided by an instance of this class may or may not, however, be consistent with the views seen by other concurrently-running programs due to caching performed by the underlying operating system and delays induced by network-filesystem protocols.This is true regardless of the language in which these other programs are written, and whether they are running on the same machine or on some other machine.The exact nature of any such inconsistencies are system-dependent and are therefore unspecified."},
{"description": "An asynchronous server-socket channel is created by invoking the open method of this class.It can be bound to a local address and configured to listen for connections by invoking the bind method.Once bound, the accept method is used to initiate the accepting of connections to the channel's socket.An attempt to invoke the accept method on an unbound channel will cause a NotYetBoundException to be thrown.Channels of this type are safe for use by multiple concurrent threads though at most one accept operation can be outstanding at any time.If a thread initiates an accept operation before a previous accept operation has completed then an AcceptPendingException will be thrown.Socket options are configured using the setOption method.The size of the socket receive buffer SO_REUSEADDR Re-use address Additional (implementation specific) options may also be supported.; listener.accept(null, new CompletionHandler<AsynchronousSocketChannel,Void>() { public void completed(AsynchronousSocketChannel ch, Void att) { // accept the next connection listener.accept(null, this); // handle this connection handle(ch); } public void failed(Throwable exc, Void att) { ... } });"},
{"description": "An asynchronous channel provider is a concrete subclass of this class that has a zero-argument constructor and implements the abstract methods specified below.A given invocation of the Java virtual machine maintains a single system-wide default provider instance, which is returned by the provider method.The first invocation of that method will locate the default provider as specified below.All of the methods in this class are safe for use by multiple concurrent threads."},
{"description": "An asynchronous channel group encapsulates the mechanics required to handle the completion of I/O operations initiated by asynchronous channels that are bound to the group.A group has an associated thread pool to which tasks are submitted to handle I/O events and dispatch to completion-handlers that consume the result of asynchronous operations performed on channels in the group.In addition to handling I/O events, the pooled threads may also execute other tasks required to support the execution of asynchronous I/O operations.An asynchronous channel group is created by invoking the withFixedThreadPool or withCachedThreadPool methods defined here.Channels are bound to a group by specifying the group when constructing the channel.The associated thread pool is owned by the group; termination of the group results in the shutdown of the associated thread pool.In addition to groups created explicitly, the Java virtual machine maintains a system-wide default group that is constructed automatically.Asynchronous channels that do not specify a group at construction time are bound to the default group.The default group has an associated thread pool that creates new threads as needed.The default group may be configured by means of system properties defined in the table below.Where the ThreadFactory for the default group is not configured then the pooled threads of the default group are daemon threads.The value of this property is taken to be the fully-qualified name of a concrete ThreadFactory class.The class is loaded using the system class loader and instantiated.The factory's newThread method is invoked to create each thread for the default group's thread pool.If the process to load and instantiate the value of the property fails then an unspecified error is thrown during the construction of the default group.The value of the property is taken to be the String representation of an Integer that is the initial size parameter.If the value cannot be parsed as an Integer it causes an unspecified error to be thrown during the construction of the default group.Threading The completion handler for an I/O operation initiated on a channel bound to a group is guaranteed to be invoked by one of the pooled threads in the group.This ensures that the completion handler is run by a thread with the expected identity.Where an I/O operation completes immediately, and the initiating thread is one of the pooled threads in the groupthen the completion handler may be invoked directly by the initiating thread.To avoid stack overflow, an implementation may impose a limit as to the number of activations on the thread stack.Some I/O operations may prohibit invoking the completion handler directly by the initiating thread (see accept).The shutdown method is used to initiate an orderly shutdown of a group.An orderly shutdown marks the group as shutdown; further attempts to construct a channel that binds to the group will throw ShutdownChannelGroupException.Whether or not a group is shutdown can be tested using the isShutdown method.Once shutdown, the group terminates when all asynchronous channels that are bound to the group are closed, all actively executing completion handlers have run to completion, and resources used by the group are released.No attempt is made to stop or interrupt threads that are executing completion handlers.The shutdownNow method can be used to initiate a forceful shutdown of the group.In addition to the actions performed by an orderly shutdown, the shutdownNow method closes all open channels in the group as if by invoking the close method."},
{"description": "A channel that supports asynchronous I/O operations.Asynchronous I/O operations will usually take one of two forms:where operation is the name of the I/O operation (read or write for example), V is the result type of the I/O operation, and A is the type of an object attached to the I/O operation to provide context when consuming the result.The attachment is important for cases where a state-less CompletionHandler is used to consume the result of many I/O operations.In the first form, the methods defined by the Future interface may be used to check if the operation has completed, wait for its completion, and to retrieve the result.In the second form, a CompletionHandler is invoked to consume the result of the I/O operation when it completes or fails.A channel that implements this interface is asynchronously closeable: If an I/O operation is outstanding on the channel and the channel's close method is invoked, then the I/O operation fails with the exceptionAsynchronous channels are safe for use by multiple concurrent threads.Some channel implementations may support concurrent reading and writing, but may not allow more than one read and one write operation to be outstanding at any given time.Cancellation The Future interface defines the cancel method to cancel execution.This causes all threads waiting on the result of the I/O operation to throw CancellationException.Where cancellation leaves the channel, or the entity to which it is connected, in an inconsistent state, then the channel is put into an implementation specific error state that prevents further attempts to initiate I/O operations that are similar to the operation that was cancelled.For example, if a read operation is cancelled but the implementation cannot guarantee that bytes have not been read from the channel then it puts the channel into an error state; further attempts to initiate a read operation cause an unspecified runtime exception to be thrown.Similarly, if a write operation is cancelled but the implementation cannot guarantee that bytes have not been written to the channel then subsequent attempts to initiate a write will fail with an unspecified runtime exception.Where the cancel method is invoked with the mayInterruptIfRunning parameter set to true then the I/O operation may be interrupted by closing the channel.In that case all threads waiting on the result of the I/O operation throw CancellationException and any otherWhere the cancel method is invoked to cancel read or write operations then it is recommended that all buffers used in the I/O operations be discarded or care taken to ensure that the buffers are not accessed while the channel remains open."},
{"description": "The seven one-argument public constructors provided by this class ensure that the assertion error returned by the invocation: new AssertionError(expression) has as its detail message the string conversion of expression (as defined in section 15.18.1.1 of The Java\u2122 Language Specification), regardless of the type of expression."},
{"description": "An asynchronous channel that can read and write bytes.Some channels may not allow more than one read or write to be outstanding at any given time.If a thread invokes a read method before a previous read operation has completed then a ReadPendingException will be thrown.Whether or not other kinds of I/O operations may proceed concurrently with a read operation depends upon the type of the channel.Note that ByteBuffers are not safe for use by multiple concurrent threads.When a read or write operation is initiated then care must be taken to ensure that the buffer is not accessed until the operation completes."},
{"description": "The AsyncHandler interface is implemented by clients that wish to receive callback notification of the completion of service endpoint operations invoked asynchronously."},
{"description": "A multidimensional array type is represented as an array type whose component type is also an array type."},
{"description": "Thrown to indicate that an attempt has been made to store the wrong type of object into an array of objects.For example, the following code generates an ArrayStoreException: Object x[] ="},
{"description": "A box that does layout asynchronously.This is useful to keep the GUI event thread moving by not doing any layout on it.The layout is done on a granularity of operations on the child views.After each child view is accessed for some part of layout (a potentially time consuming operation)the remaining tasks can be abandoned or a new higher priority task (i.e. to service a synchronous request or a visible area) can be taken on.While the child view is being accessed a read lock is acquired on the associated document so that the model is stable while being accessed."},
{"description": "The ArrayType class is the open type class whose instances describe all open data values which are n-dimensional arrays of open data values.Examples of valid ArrayType instances are: //"},
{"description": "This class contains various methods for manipulating arrays (such as sorting and searching).This class also contains a static factory that allows arrays to be viewed as lists.The methods in this class all throw a NullPointerException, if the specified array reference is null, except where noted.The documentation for the methods contained in this class includes briefs description of the implementations.Such descriptions should be regarded as implementation notes, rather than parts of the specification.Implementors should feel free to substitute other algorithms, so long as the specification itself is adhered to.(For example, the algorithm used by sort(Object[]) does not have to be a MergeSort, but it does have to be stable.)This class is a member of the Java Collections Framework."},
{"description": "Array deques have no capacity restrictions; they grow as necessary to support usage.They are not thread-safe; in the absence of external synchronization, they do not support concurrent access by multiple threads.This class is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue.Most ArrayDeque operations run in amortized constant time.Exceptions include remove, removeFirstOccurrence, removeLastOccurrence, contains, iterator.remove(), and the bulk operations, all of which run in linear time.The iterators returned by this class's iterator method are fail-fast: If the deque is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will generally throw a ConcurrentModificationException.Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast iterators throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces.This class is a member of the Java Collections Framework."},
{"description": "For example, an integer \"divide by zero\" throws an instance of this class.ArithmeticException objects may be constructed by the virtual machine as if suppression were disabled and/or the stack trace was not writable."},
{"description": "The head of the queue is that element that has been on the queue the longest time.The tail of the queue is that element that has been on the queue the shortest time.New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.This is a classic \"bounded buffer\", in which a fixed-sized array holds elements inserted by producers and extracted by consumers.Attempts to put an element into a full queue will result in the operation blocking; attempts to take an element from an empty queue will similarly block.This class supports an optional fairness policy for ordering waiting producer and consumer threads.By default, this ordering is not guaranteed.However, a queue constructed with fairness set to true grants threads access in FIFO order.Fairness generally decreases throughput but reduces variability and avoids starvation.This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces.This class is a member of the Java Collections Framework."},
{"description": "By default, an Array value is a transaction-duration reference to an SQL ARRAY value.By default, an Array object is implemented using an SQL LOCATOR(array) internally, which means that an Array object contains a logical pointer to the data in the SQL ARRAY value rather than containing the ARRAY value's data.The Array interface provides methods for bringing an SQL ARRAY value's data to the client as either an array or a ResultSet object.If the elements of the SQL ARRAY are a UDT, they may be custom mapped.To create a custom mapping, a programmer must do two things: create a class that implements the SQLData interface for the UDT to be custom mapped.make an entry in a type map that contains the fully-qualified SQL type name of the UDT the Class object for the class implementing SQLData When a type map with an entry for the base type is supplied to the methods getArray and getResultSet, the mapping it contains will be used to map the elements of the ARRAY value.If no type map is supplied, which would typically be the case, the connection's type map is used by default.If the connection's type map or a type map supplied to a method has no entry for the base type, the elements are mapped according to the standard mapping.All methods on the Array interface must be fully implemented if the JDBC driver supports the data type."},
{"description": "The Array class provides static methods to dynamically create and access Java arrays.Array permits widening conversions to occur during a get or set operation, but throws an IllegalArgumentException if a narrowing conversion would occur."},
{"description": "Thrown to indicate that an array has been accessed with an illegal index.The index is either negative or greater than or equal to the size of the array."},
{"description": "In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list.(This class is roughly equivalent to Vector, except that it is unsynchronized.)The size, isEmpty, get, set, iterator, and listIterator operations run in constant time.The add operation runs in amortized constant time, that is, adding n elements requires O(n) time.All of the other operations run in linear time (roughly speaking).The constant factor is low compared to that for the LinkedList implementation.Each ArrayList instance has a capacity.The capacity is the size of the array used to store the elements in the list.It is always at least as large as the list size.As elements are added to an ArrayList, its capacity grows automatically.The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost.An application can increase the capacity of an ArrayList instance before adding a large number of elements using the ensureCapacity operation.This may reduce the amount of incremental reallocation.If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally.(A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.)This is typically accomplished by synchronizing on some object that naturally encapsulates the list.If no such object exists, the list should be \"wrapped\" using the Collections.synchronizedList method.This is best done at creation time, to prevent accidental unsynchronized access to the list:List list = Collections.synchronizedList(new ArrayList(...)); The iterators returned by this class's iterator and listIterator methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException.Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.Fail-fast iterators throw ConcurrentModificationException on a best-effort basis.Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.This class is a member of the Java Collections Framework."},
{"description": "A constant that signifies an \"output\" argument to an invocation, meaning that the argument is being passed from the server to the client.ARG_OUT.value is one of the possible values used to indicate the direction in which a parameter is being passed during a dynamic invocation using the Dynamic Invocation Interface (DII).The code fragment below shows a typical usage: ORB orb = ORB.init(args, null); org.omg.CORBA.NamedValue nv = orb.create_named_value"},
{"description": "Signifies an argument used for both input and output in an invocation, meaning that the argument is being passed from the client to the server and then back from the server to the client.ARG_INOUT.value is one of the possible values used to indicate the direction in which a parameter is being passed during a dynamic invocation using the Dynamic Invocation Interface (DII).The code fragment below shows a typical usage: ORB orb = ORB.init(args, null); org.omg.CORBA.NamedValue nv = orb.create_named_value"},
{"description": "Signifies an \"input\" argument to an invocation, meaning that the argument is being passed from the client to the server.ARG_IN.value is one of the possible values used to indicate the direction in which a parameter is being passed during an invocation performed using the Dynamic Invocation Interface (DII).The code fragment below shows a typical usage: ORB orb = ORB.init(args, null); org.omg.CORBA.NamedValue nv = orb.create_named_value"},
{"description": "An ImageFilter class for scaling images using a simple area averaging algorithm that produces smoother results than the nearest neighbor algorithm.This class extends the basic ImageFilter Class to scale an existing image and provide a source for a new image containing the resampled image.The pixels in the source image are blended to produce pixels for an image of the specified size.The blending process is analogous to scaling up the source image to a multiple of the destination size using pixel replication and then scaling it back down to the destination size by simply averaging all the pixels in the supersized image that fall within a given pixel of the destination image.If the data from the source is not delivered in TopDownLeftRight order then the filter will back off to a simple pixel replication behavior and utilize the requestTopDownLeftRightResend() method to refilter the pixels in a better way at the end.It is meant to be used in conjunction with a FilteredImageSource object to produce scaled versions of existing images.Due to implementation dependencies, there may be differences in pixel values of an image filtered on different platforms."},
{"description": "An Area object stores and manipulates a resolution-independent description of an enclosed area of 2-dimensional space.Area objects can be transformed and can perform various Constructive Area Geometry (CAG) operations when combined with other Area objects.The CAG operations include area addition, subtraction, intersection, and exclusive or.The Area class implements the Shape interface and provides full support for all of its hit-testing and path iteration facilities, but an Area is more specific than a generalized path in a number of ways:Area objects constructed from unclosed paths are implicitly closed during construction as if those paths had been filled by the Graphics2D.fill method.The interiors of the individual stored sub-paths are all non-empty and non-overlapping.Paths are decomposed during construction into separate component non-overlapping parts, empty pieces of the path are discarded, and then these non-empty and non-overlapping properties are maintained through all subsequent CAG operations.Outlines of different component sub-paths may touch each other, as long as they do not cross so that their enclosed areas overlap.The geometry of the path describing the outline of the Area resembles the path from which it was constructed only in that it describes the same enclosed 2-dimensional area, but may use entirely different types and ordering of the path segments to do so.Interesting issues which are not always obvious when using the Area include: Creating an Area from an unclosed (open) Shape results in a closed outline in the Area object.Creating an Area from a Shape which encloses no area (even when \"closed\") produces an empty Area.A common example of this issue is that producing an Area from a line will be empty since the line encloses no area.An empty Area will iterate no geometry in its PathIterator objects.A self-intersecting Shape may be split into two (or more) sub-paths each enclosing one of the non-intersecting portions of the original path.An Area may take more path segments to describe the same geometry even when the original outline is simple and obvious.The analysis that the Area class must perform on the path may not reflect the same concepts of \"simple and obvious\" as a human being perceives."},
{"description": "This class defines an arc specified in float precision."},
{"description": "This class defines an arc specified in double precision."},
{"description": "This class is used for reporting application level exceptions between ORBs and stubs."},
{"description": "When an applet is first created, an applet stub is attached to it using the applet's setStub method.This stub serves as the interface between the applet and the browser environment or applet viewer environment in which the application is running."},
{"description": "This interface is designed to work in collusion with java.beans.Beans.instantiate.The interface is intended to provide mechanism to allow the proper initialization of JavaBeans that are also Applets, during their instantiation by java.beans.Beans.instantiate()."},
{"description": "This interface corresponds to an applet's environment: the document containing the applet and the other applets in the same document.The methods in this interface can be used by an applet to obtain information about its environment."},
{"description": "An object to which char sequences and values can be appended.The Appendable interface must be implemented by any class whose instances are intended to receive formatted output from a Formatter.The characters to be appended should be valid Unicode characters as described in Unicode Character Representation.Note that supplementary characters may be composed of multiple 16-bit char values.Appendables are not necessarily safe for multithreaded access.Thread safety is the responsibility of classes that extend and implement this interface.Since this interface may be implemented by existing classes with different styles of error handling there is no guarantee that errors will be propagated to the invoker."},
{"description": "This class represents a single LoginModule entry configured for the application specified in the getAppConfigurationEntry(String appName) method in the Configuration class.Each respective AppConfigurationEntry contains a LoginModule name, a control flag (specifying whether this LoginModule is REQUIRED, REQUISITE, SUFFICIENT, or OPTIONAL), and LoginModule-specific options."},
{"description": "An applet is a small program that is intended not to be run on its own, but rather to be embedded inside another application.The Applet class must be the superclass of any applet that is to be embedded in a Web page or viewed by the Java Applet Viewer.The Applet class provides a standard interface between applets and their environment."},
{"description": "The class definition has been modified to conform to the following OMG specifications : ORB core as defined by CORBA 2.3.1 (formal/99-10-07)"},
{"description": "Serves as a container for any data that can be described in IDL or for any IDL primitive type.An Any object is used as a component of a NamedValue object, which provides information about arguments or return values in requests, and which is used to define name/value pairs in Context objects.An Any object consists of two parts: a data value a TypeCode object describing the type of the data value contained in the Any object.For example, a TypeCode object for an array contains a field for the length of the array and a field for the type of elements in the array.(Note that in this case, the second field of the TypeCode object is itself a TypeCode object.)A large part of the Any class consists of pairs of methods for inserting values into and extracting values from an Any object.This method allows the insertion of an instance x of primitive type X into the value field of the Any object.Note that the method insert_X also resets the Any object's type field if necessary.X extract_X() This method allows the extraction of an instance of type X from the Any object.This method throws the exception BAD_OPERATION under two conditions: the type of the element contained in the Any object is not Xthe method extract_X is called before the value field of the Any object has been setThere are distinct method pairs for each primitive IDL data type (insert_long and extract_long, insert_string and extract_string, and so on).The class Any also has methods for getting and setting the type code, for testing two Any objects for equality, and for reading an Any object from a stream or writing it to a stream."},
{"description": "A value is of one of the following types: a wrapper class (such as Integer) for a primitive type String TypeMirror VariableElement (representing an enum constant)(representing the elements, in declared order, if the value is an array)"},
{"description": "Thrown to indicate that a program has attempted to access an element of an annotation whose type has changed after the annotation was compiled (or serialized).This exception can be thrown by the API used to read annotations reflectively."},
{"description": "An annotation associates a value with each element of an annotation type.Annotations should be compared using the equals method.There is no guarantee that any particular annotation will always be represented by the same object."},
{"description": "A Holder class for Any objects that is used to store \"out\" and \"inout\" parameters in IDL methods.If an IDL method signature has an IDL any as an \"out\" or \"inout\" parameter, the programmer must pass an instance of AnyHolder as the corresponding parameter in the method invocation; for \"inout\" parameters, the programmer must also fill the \"in\" value to be sent to the server.Before the method invocation returns, the ORB will fill in the value corresponding to the \"out\" value returned from the server.If myAnyHolder is an instance of AnyHolder, the value stored in its value field can be accessed with myAnyHolder.value."},
{"description": "Unlike a standard visitor which dispatches based on the concrete type of a member of a type hierarchy, this visitor dispatches based on the type of data stored; there are no distinct subclasses for storing, for example, boolean values versus int values.Classes implementing this interface are used to operate on a value when the type of that value is unknown at compile time.When a visitor is passed to a value's accept method, the visitXYZ method applicable to that value is invoked.Classes implementing this interface may or may not throw a NullPointerException if the additional parameter p is null; see documentation of the implementing class for details.It is possible that methods will be added to this interface to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, visitor classes directly implementing this interface may be source incompatible with future versions of the platform.To avoid this source incompatibility, visitor implementations are encouraged to instead extend the appropriate abstract visitor class that implements this interface.However, an API should generally use this visitor interface as the type for parameters, return type, etc.Note that methods to accommodate new language constructs could be added in a source compatible way if they were added as default methods.However, default methods are only available on Java SE 8 and higher releases and the javax.lang.model.* packages bundled in Java SE 8 are required to also be runnable on Java SE 7.Therefore, default methods cannot be used when extending javax.lang.model.However, default methods may be used in subsequent revisions of the javax.lang.model.* packages that are only required to run on Java SE 8 and higher platform versions."},
{"description": "Thrown when the annotation parser attempts to read an annotation from a class file and determines that the annotation is malformed.This error can be thrown by the API used to read annotations reflectively."},
{"description": "An Annotation object is used as a wrapper for a text attribute value if the attribute has annotation characteristics.These characteristics are: The text range that the attribute is applied to is critical to the semantics of the range.That means, the attribute cannot be applied to subranges of the text range that it applies to, and, if two adjacent text ranges have the same value for this attribute, the attribute still cannot be applied to the combined range as a whole with this value.An example is grammatical information attached to a sentence: For the previous sentence, you can say that \"an example\" is the subject, but you cannot say the same about \"an\", \"example\", or \"exam\".Another example is Japanese reading information (yomi).Wrapping the attribute value into an Annotation object guarantees that adjacent text runs don't get merged even if the attribute values are equal, and indicates to text containers that the attribute should be discarded if the underlying text is modified."},
{"description": "AnnotatedWildcardType represents the potentially annotated use of a wildcard type argument, whose upper or lower bounds may themselves represent annotated uses of types."},
{"description": "Note that an interface that manually extends this one does not define an annotation type.Also note that this interface does not itself define an annotation type.More information about annotation types can be found in section 9.6 of The Java\u2122 Language Specification.The AnnotatedElement interface discusses compatibility concerns when evolving an annotation type from being non-repeatable to being repeatable."},
{"description": "AnnotatedTypeVariable represents the potentially annotated use of a type variable, whose declaration may have bounds which themselves represent annotated uses of types."},
{"description": "AnnotatedType represents the potentially annotated use of a type in the program currently running in this VM.The use may be of any type in the Java programming language, including an array type, a parameterized type, a type variable, or a wildcard type."},
{"description": "All annotations returned by methods in this interface are immutable and serializable.The arrays returned by methods of this interface may be modified by callers without affecting the arrays returned to other callers.The getAnnotationsByType(Class) and getDeclaredAnnotationsByType(Class) methods support multiple annotations of the same type on an element.If the argument to either method is a repeatable annotation type (JLS 9.6), then the method will \"look through\" a container annotation (JLS 9.7), if present, and return any annotations inside the container.Container annotations may be generated at compile-time to wrap multiple annotations of the argument type.The terms directly present, indirectly present, present, and associated are used throughout this interface to describe precisely which annotations are returned by methods:An annotation A is directly present on an element E if E has a RuntimeVisibleAnnotations or RuntimeVisibleParameterAnnotations or RuntimeVisibleTypeAnnotations attribute, and the attribute contains A.A is indirectly present on an element E if E has a RuntimeVisibleAnnotations or RuntimeVisibleParameterAnnotations or RuntimeVisibleTypeAnnotations attribute, and A 's type is repeatable, and the attribute contains exactly one annotation whose value element contains A and whose type is the containing annotation type of A 's type.An annotation A is present on an element E if either:A is directly present on E; or No annotation of A 's type is directly present on E, and E is a class, and A 's type is inheritable, and A is present on the superclass of E. An annotation A is associated with an element E if either:A is directly or indirectly present on E; or No annotation of A 's type is directly or indirectly present on E, and E is a class, and A's type is inheritable, and A is associated with the superclass of E. The table below summarizeswhich kind of annotation presence different methods in this interface examine.For an invocation of get[Declared]AnnotationsByType( Class < T >), the order of annotations which are directly or indirectly present on an element E is computed as if indirectly present annotations on E are directly present on E in place of their container annotation, in the order in which they appear in the value element of the container annotation.There are several compatibility concerns to keep in mind if an annotation type T is originally not repeatable and later modified to be repeatable.The containing annotation type for T is TC.Modifying T to be repeatable is source and binary compatible with existing uses of T and with existing uses of TC.That is, for source compatibility, source code with annotations of type T or of type TC will still compile.For binary compatibility, class files with annotations of type T or of type TC (or with other kinds of uses of type T or of type TC) will link against the modified version of T if they linked against the earlier version.(An annotation type TC may informally serve as an acting containing annotation type before T is modified to be formally repeatable.Alternatively, when T is made repeatable, TC can be introduced as a new type.)If an annotation type TC is present on an element, and T is modified to be repeatable with TC as its containing annotation type then:The change to T is behaviorally compatible with respect to the get[Declared]Annotation(Class<T>) (called with an argument of T or TC) and get[Declared]Annotations() methods because the results of the methods will not change due to TC becoming the containing annotation type for T.The change to T changes the results of the get[Declared]AnnotationsByType(Class<T>) methods called with an argument of T, because those methods will now recognize an annotation of type TC as a container annotation for T and will \"look through\" it to expose annotations of type T.If an annotation of type T is present on an element and T is made repeatable and more annotations of type T are added to the element: The addition of the annotations of type T is both source compatible and binary compatible.The addition of the annotations of type T changes the results of the get[Declared]Annotation(Class<T>) methods and get[Declared]Annotations() methods, because those methods will now only see a container annotation on the element and not see an annotation of type T.The addition of the annotations of type T changes the results of the get[Declared]AnnotationsByType(Class<T>) methods, because their results will expose the additional annotations of type T whereas previously they exposed only a single annotation of type T. If an annotation returned by a method in this interface contains (directly or indirectly) a Class-valued member referring to a class that is not accessible in this VM, attempting to read the class by calling the relevant Class-returning method on the returned annotation will result in a TypeNotPresentException.Similarly, attempting to read an enum-valued member will result in a EnumConstantNotPresentException if the enum constant in the annotation is no longer present in the enum type.If an annotation type T is (meta-)annotated with an @Repeatable annotation whose value element indicates a type TC, but TC does not declare a value() method with a return type of T[], then an exception of type AnnotationFormatError is thrown.Finally, attempting to read a member whose definition has evolved incompatibly will result in a AnnotationTypeMismatchException or an IncompleteAnnotationException."},
{"description": "AnnotatedParameterizedType represents the potentially annotated use of a parameterized type, whose type arguments may themselves represent annotated uses of types."},
{"description": "AncestorListener Interface to support notification when changes occur to a JComponent or one of its ancestors.These include movement and when the component becomes visible or invisible, either by the setVisible() method or by being added or removed from the component hierarchy."},
{"description": "An event reported to a child component that originated from an ancestor in the component hierarchy.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "Unchecked exception thrown when an attempt is made to connect a SocketChannel that is already connected."},
{"description": "An AlreadyBoundException is thrown if an attempt is made to bind an object in the registry to a name that already has an associated binding."},
{"description": "AnnotatedArrayType represents the potentially annotated use of an array type, whose component type may itself represent the annotated use of a type."},
{"description": "Represents a construct that can be annotated.A construct is either an element or a type.Annotations on an element are on a declaration, whereas annotations on a type are on a specific use of a type name.The terms directly present, present, indirectly present, and associated are used throughout this interface to describe precisely which annotations are returned by the methods defined herein.In the definitions below, an annotation A has an annotation type AT.If AT is a repeatable annotation type, the type of the containing annotation is ATC.Annotation A is directly present on a construct C if either: A is explicitly or implicitly declared as applying to the source code representation ofC. Typically, if exactly one annotation of type AT appears in the source code of representation of C, then A is explicitly declared as applying to C.If there are multiple annotations of type AT present on C, then if AT is repeatable annotation type, an annotation of type ATC is implicitly declared on C. A representation of A appears in the executable output for C, such as the RuntimeVisibleAnnotations or RuntimeVisibleParameterAnnotations attributes of a class file.An annotation A is present on a construct C if either:A is directly present on C. No annotation of type AT is directly present on C, and C is a class and AT is inheritable and A is present on the superclass of C. An annotationA is indirectly present on a construct Cif both: AT is a repeatable annotation type with a containing annotation type ATC.An annotation of type ATC is directly present on C and A is an annotation included in the result of calling the value method of the directly present annotation of type ATC.An annotation A is associated with a construct C if either: A is directly or indirectly present on C. No annotation of type AT is directly or indirectly present on C, and C is a class, and AT is inheritable, and A is associated with the superclass of C."},
{"description": "The specific rules implemented by this class are the basic set of 12 rules described in T. Porter and T. Duff, \"Compositing Digital Images\", SIGGRAPH 84, 253-259.The rest of this documentation assumes some familiarity with the definitions and concepts outlined in that paper.This class extends the standard equations defined by Porter and Duff to include one additional factor.An instance of the AlphaComposite class can contain an alpha value that is used to modify the opacity or coverage of every source pixel before it is used in the blending equations.It is important to note that the equations defined by the Porter and Duff paper are all defined to operate on color components that are premultiplied by their corresponding alpha components.Since the ColorModel and Raster classes allow the storage of pixel data in either premultiplied or non-premultiplied form, all input data must be normalized into premultiplied form before applying the equations and all results might need to be adjusted back to the form required by the destination before the pixel values are stored.Also note that this class defines only the equations for combining color and alpha values in a purely mathematical sense.The accurate application of its equations depends on the way the data is retrieved from its sources and stored in its destinations.The following factors are used in the description of the blending equation in the Porter and Duff paper: Factor\u00a0\u00a0Definition Asthe alpha component of the source pixelCsa color component of the source pixel in premultiplied form Adthe alpha component of the destination pixel Cda color component of the destination pixel in premultiplied form Fsthe fraction of the source pixel that contributes to the output Fdthe fraction of the destination pixel that contributes to the output Arthe alpha component of the resultCra color component of the result in premultiplied form Using these factors, Porter and Duff define 12 ways of choosing the blending factorsThe equations for determining Fs and Fd are given in the descriptions of the 12 static fields that specify visual effects.Once a set of equations for determining the blending factors is known they can then be applied to each pixel to produce a result using the following set of equations:+ Cd*Fd The following factors will be used to discuss our extensions to the blending equation in the Porter and Duff paper: Factor\u00a0\u00a0Definition Csr one of the raw color components of the source pixel Cdr one of the raw color components of the destination pixelthe \"extra\" alpha component from the AlphaComposite instance Asr the raw alpha component of the source pixelAdrthe raw alpha component of the destination pixel Adf the final alpha component stored in the destinationThe AlphaComposite class defines an additional alpha value that is applied to the source alpha.This value is applied as if an implicit SRC_IN rule were first applied to the source pixel against a pixel with the indicated alpha by multiplying both the raw source alpha and the raw source colors by the alpha in the AlphaComposite.This leads to the following equation for producing the alpha used in the Porter and Duff blending equation:* Aac All of the raw source color components need to be multiplied by the alpha in the AlphaComposite instance.Additionally, if the source was not in premultiplied form then the color components also need to be multiplied by the source alpha.Thus, the equation for producing the source color components for the Porter and Duff equation depends on whether the source pixels are premultiplied or not: Cs =No adjustment needs to be made to the destination alpha:The destination color components need to be adjusted only if they are not in premultiplied form:As, Ad, Cs, and Cd are used in the standard Porter and Duff equations to calculate the blending factors Fs and FdThe results only need to be adjusted if they are to be stored back into a destination buffer that holds data that is not premultiplied, using the following equations:Ar (if dest is not premultiplied) Note that since the division is undefined if the resulting alpha is zero, the division in that case is omitted to avoid the \"divide by zero\" and the color components are left as all zeros., it is preferable that Raster objects passed to the compose method of a CompositeContext object created by the AlphaComposite class have premultiplied data.If either the source Raster or the destination Raster is not premultiplied, however, appropriate conversions are performed before and after the compositing operation.Implementation Caveats Many sources, such as some of the opaque image types listed in the BufferedImage class, do not store alpha values for their pixels.Such sources supply an alpha of 1.0 for all of their pixels.Many destinations also have no place to store the alpha values that result from the blending calculations performed by this class.Such destinations thus implicitly discard the resulting alpha values that this class produces.It is recommended that such destinations should treat their stored color values as non-premultiplied and divide the resulting color values by the resulting alpha value before storing the color values and discarding the alpha value.The accuracy of the results depends on the manner in which pixels are stored in the destination.An image format that provides at least 8 bits of storage per color and alpha component is at least adequate for use as a destination for a sequence of a few to a dozen compositing operations.An image format with fewer than 8 bits of storage per component is of limited use for just one or two compositing operations before the rounding errors dominate the results.An image format that does not separately store color components is not a good candidate for any type of translucent blending.TYPE_BYTE_INDEXED should not be used as a destination for a blending operation because every operation can introduce large errors, due to the need to choose a pixel from a limited palette to match the results of the blending equations.The implementation can either scale the integer pixel values into floating point values in the range 0.0 to 1.0 or use slightly modified versions of the equations that operate entirely in the integer domain and yet produce analogous results to the reference equations.Typically the integer values are related to the floating point values in such a way that the integer 0 is equated to the floating point value 0.0 and the integer 2^n-1 (where n is the number of bits in the representation) is equated to 1.0.For 8-bit representations, this means that 0x00 represents 0.0 and 0xff represents 1.0.The internal implementation can approximate some of the equations and it can also eliminate some steps to avoid unnecessary operations.For example, consider a discrete integer image with non-premultiplied alpha values that uses 8 bits per component for storage.The stored values for a nearly transparent darkened red might be: (A, R, G, B) =If integer math were being used and this value were being composited in SRC mode with no extra alpha, then the math would indicate that the results were (in integer format): (A, R, G, B) =Note that the intermediate values, which are always in premultiplied form, would only allow the integer red component to be either 0x00 or 0x01.When we try to store this result back into a destination that is not premultiplied, dividing out the alpha will give us very few choices for the non-premultiplied red value.In this case an implementation that performs the math in integer space without shortcuts is likely to end up with the final pixel values of: (A, R, G, B) =(Note that 0x01 divided by 0x01 gives you 1.0, which is equivalent to the value 0xff in an 8-bit storage format.)Alternately, an implementation that uses floating point math might produce more accurate results and end up returning to the original pixel value with little, if any, roundoff error.Or, an implementation using integer math might decide that since the equations boil down to a virtual NOP on the color values if performed in a floating point space, it can transfer the pixel untouched to the destination and avoid all the math entirely.These implementations all attempt to honor the same equations, but use different tradeoffs of integer and floating point math and reduced or full equations.To account for such differences, it is probably best to expect only that the premultiplied form of the results to match between implementations and image formats.In this case both answers, expressed in premultiplied form would equate to: (A, R, G, B) =Because of the technique of simplifying the equations for calculation efficiency, some implementations might perform differently when encountering result alpha values of 0.0 on a non-premultiplied destination.Note that the simplification of removing the divide by alpha in the case of the SRC rule is technically not valid if the denominator (alpha) is 0.But, since the results should only be expected to be accurate when viewed in premultiplied form, a resulting alpha of 0 essentially renders the resulting color components irrelevant and so exact behavior in this case should not be expected."},
{"description": "This interface contains no methods or constants.Its only purpose is to group (and provide type safety for) all parameter specifications.All parameter specifications must implement this interface."},
{"description": "This class defines the Service Provider Interface (SPI) for the AlgorithmParameters class, which is used to manage algorithm parameters.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply parameter management for a particular algorithm."},
{"description": "This class defines the Service Provider Interface (SPI) for the AlgorithmParameterGenerator class, which is used to generate a set of parameters to be used with a certain algorithm.All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a parameter generator for a particular algorithm.In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an engineInit method), each provider must supply (and document) a default initialization.For example, the Sun provider uses a default modulus prime size of 1024 bits for the generation of DSA parameters."},
{"description": "Unchecked exception thrown when an attempt is made to bind the socket a network oriented channel that is already bound."},
{"description": "This class is used as an opaque representation of cryptographic parameters.An AlgorithmParameters object for managing the parameters for a particular algorithm can be obtained by calling one of the getInstance factory methods (static methods that return instances of a given class).Once an AlgorithmParameters object is obtained, it must be initialized via a call to init, using an appropriate parameter specification or parameter encoding.A transparent parameter specification is obtained from an AlgorithmParameters object via a call to getParameterSpec, and a byte encoding of the parameters is obtained via a call to getEncoded.Every implementation of the Java platform is required to support the following standard AlgorithmParameters algorithms:These algorithms are described in the AlgorithmParameters section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other algorithms are supported."},
{"description": "The AllPermission is a permission that implies all other permissions.Note: Granting AllPermission should be done with extreme care, as it implies all other permissions.Thus, it grants code the ability to run with security disabled.Extreme caution should be taken before granting such a permission to code.This permission should be used only during testing, or in extremely rare cases where an application or applet is completely trusted and adding the necessary permissions to the policy is prohibitively cumbersome."},
{"description": "Subclasses represent specific types of XML security algorithms, such as a Transform."},
{"description": "The AlgorithmParameterGenerator class is used to generate a set of parameters to be used with a certain algorithm.Parameter generators are constructed using the getInstance factory methods (static methods that return instances of a given class).The object that will generate the parameters can be initialized in two different ways: in an algorithm-independent manner, or in an algorithm-specific manner: The algorithm-independent approach uses the fact that all parameter generators share the concept of a \"size\" and a source of randomness.The measure of size is universally shared by all algorithm parameters, though it is interpreted differently for different algorithms.For example, in the case of parameters for the DSA algorithm, \"size\" corresponds to the size of the prime modulus (in bits).When using this approach, algorithm-specific parameter generation values - if any - default to some standard values, unless they can be derived from the specified size.The other approach initializes a parameter generator object using algorithm-specific semantics, which are represented by a set of algorithm-specific parameter generation values.To generate Diffie-Hellman system parameters, for example, the parameter generation values usually consist of the size of the prime modulus and the size of the random exponent, both specified in number of bits.In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an init method), each provider must supply (and document) a default initialization.For example, the Sun provider uses a default modulus prime size of 1024 bits for the generation of DSA parameters.Every implementation of the Java platform is required to support the following standard AlgorithmParameterGenerator algorithms and keysizes in parentheses: DiffieHellman (1024)These algorithms are described in the AlgorithmParameterGenerator section of the Java Cryptography Architecture Standard Algorithm Name Documentation.Consult the release documentation for your implementation to see if any other algorithms are supported."},
{"description": "This exception is thrown when a Cipher operating in an AEAD mode (such as GCM/CCM) is unable to verify the supplied authentication tag."},
{"description": "A class that can be used to compute the Adler-32 checksum of a data stream.An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed much faster.Passing a null argument to a method in this class will cause a NullPointerException to be thrown."},
{"description": "This class uses an affine transform to perform a linear mapping from 2D coordinates in the source image or Raster to 2D coordinates in the destination image or Raster.The type of interpolation that is used is specified through a constructor, either by a RenderingHints object or by one of the integer interpolation types defined in this class.If a RenderingHints object is specified in the constructor, the interpolation hint and the rendering quality hint are used to set the interpolation type for this operation.For Raster objects, the number of bands in the source must be equal to the number of bands in the destination."},
{"description": "This interface specifies constraints for cryptographic algorithms, keys (key sizes), and other algorithm parameters.An implementation of this interface should not provide methods that can change the state of an instance once it has been created.Note that AlgorithmConstraints can be used to represent the restrictions described by the security properties jdk.certpath.disabledAlgorithms and jdk.tls.disabledAlgorithms, or could be used by a concrete PKIXCertPathChecker to check whether a specified certificate in the certification path contains the required algorithm constraints."},
{"description": "The AffineTransform class represents a 2D affine transform that performs a linear mapping from 2D coordinates to other 2D coordinates that preserves the \"straightness\" and \"parallelness\" of lines.Affine transformations can be constructed using sequences of translations, scales, flips, rotations, and shears.Such a coordinate transformation can be represented by a 3 row by 3 column matrix with an implied last row of [ 0 0 1 ].This matrix transforms source coordinates (x,y) into destination coordinates (x',y') by considering them to be a column vector and multiplying the coordinate vector by the matrix according to the following process: [ x'] [ m00 m01 m02 ]In some variations of the rotate methods in the AffineTransform class, a double-precision argument specifies the angle of rotation in radians.These methods have special handling for rotations of approximately 90 degrees (including multiples such as 180, 270, and 360 degrees), so that the common case of quadrant rotation is handled more efficiently.This special handling can cause angles very close to multiples of 90 degrees to be treated as if they were exact multiples of 90 degrees.For small multiples of 90 degrees the range of angles treated as a quadrant rotation is approximately 0.00000121 degrees wide.Since 90 degrees is represented as PI/2 in radians, and since PI is a transcendental (and therefore irrational) number, it is not possible to exactly represent a multiple of 90 degrees as an exact double precision value measured in radians.As a result it is theoretically impossible to describe quadrant rotations (90, 180, 270 or 360 degrees) using these values.Double precision floating point values can get very close to non-zero multiples of PI/2 but never close enough for the sine or cosine to be exactly 0.0, 1.0 or -1.0.The implementations of Math.sin() and Math.cos() correspondingly never return 0.0 for any case other than Math.sin(0.0).These same implementations do, however, return exactly 1.0 and -1.0 for some range of numbers around each multiple of 90 degrees since the correct answer is so close to 1.0 or -1.0 that the double precision significand cannot represent the difference as accurately as it can for numbers that are near 0.0.The net result of these issues is that if the Math.sin() and Math.cos() methods are used to directly generate the values for the matrix modifications during these radian-based rotation operations then the resulting transform is never strictly classifiable as a quadrant rotation even for a simple case like rotate(Math.If these transforms are not classified as quadrant rotations then subsequent code which attempts to optimize further operations based upon the type of the transform will be relegated to its most general implementation.Because quadrant rotations are fairly common, this class should handle these cases reasonably quickly, both in applying the rotations to the transform and in applying the resulting transform to the coordinates.To facilitate this optimal handling, the methods which take an angle of rotation measured in radians attempt to detect angles that are intended to be quadrant rotations and treat them as such.These methods therefore treat an angle theta as a quadrant rotation if either Math.sin(theta) or Math.cos(theta) returns exactly 1.0 or -1.0.As a rule of thumb, this property holds true for a range of approximately 0.0000000211 radians (or 0.00000121 degrees) around small multiples of Math."},
{"description": "When the user changes the value of the scrolling component, it receives an instance of AdjustmentEvent.An unspecified behavior will be caused if the id parameter of any particular AdjustmentEvent instance is not in the range from ADJUSTMENT_FIRST to ADJUSTMENT_LAST.The type of any AdjustmentEvent instance takes one of the following values:Assigning the value different from listed above will cause an unspecified behavior."},
{"description": "The interface for objects which have an adjustable numeric value contained within a bounded range of values."},
{"description": "If addressing is enabled, this property determines if endpoint requires the use of only anonymous responses, or only non-anonymous responses, or all.ALL supports all response types and this is the default value.ANONYMOUS requires the use of only anonymous responses.It will result into wsam:AnonymousResponses nested assertion as specified in 3.1.2 AnonymousResponses Assertion in the generated WSDL.NON_ANONYMOUS requires the use of only non-anonymous responses.It will result into wsam:NonAnonymousResponses nested assertion as specified in 3.1.3 NonAnonymousResponses Assertion in the generated WSDL."},
{"description": "AddressingFeature represents the use of WS-Addressing with either the SOAP 1.1/HTTP or SOAP 1.2/HTTP binding.Using this feature with any other binding is undefined.This feature can be used during the creation of SEI proxy, and Dispatch instances on the client side and Endpoint instances on the server side.This feature cannot be used for Service instance creation on the client side.The following describes the effects of this feature with respect to be enabled or disabled: ENABLED:In this Mode, WS-Addressing will be enabled.It means the endpoint supports WS-Addressing but does not require its use.A sender could send messages with WS-Addressing headers or without WS-Addressing headers.But a receiver MUST consume both types of messages.In this Mode, WS-Addressing will be disabled.At runtime, WS-Addressing headers MUST NOT be used by a sender or receiver.If the feature is enabled, the required property determines whether the endpoint requires WS-Addressing.If it is set true, WS-Addressing headers MUST be present on incoming and outgoing messages.By default the required property is false.If the web service developer has not explicitly enabled this feature, WSDL's wsam:Addressing policy assertion is used to find the use of WS-Addressing.By using the feature explicitly, an application overrides WSDL's indication of the use of WS-Addressing.In some cases, this is really required.For example, if an application has implemented WS-Addressing itself, it can use this feature to disable addressing.That means a JAX-WS implementation doesn't consume or produce WS-Addressing headers.If addressing is enabled, a corresponding wsam:Addressing policy assertion must be generated in the WSDL as per 3.1 WS-Policy Assertions Example 1:Possible Policy Assertion in the generated WSDL for @Addressing(required=true)"},
{"description": "This annotation represents the use of WS-Addressing with either the SOAP 1.1/HTTP or SOAP 1.2/HTTP binding.Using this annotation with any other binding is undefined.This annotation MUST only be used in conjunction with the WebService, WebServiceProvider, and WebServiceRef annotations.When used with a javax.jws.WebService annotation, this annotation MUST only be used on the service endpoint implementation class.When used with a WebServiceRef annotation, this annotation MUST only be used when a proxy instance is created.The injected SEI proxy, and endpoint MUST honor the values of the Addressing annotation.This annotation's behaviour is defined by the corresponding feature AddressingFeature."},
{"description": "Address is the Host and Port information represented as a String."},
{"description": "State changes are reported either to the object adapter or to the adapter manager."},
{"description": "This is unique only within the scope of the ORB that created the object adapter."},
{"description": "Every object adapter has an adapter manager, indicated in this API only through the ID.A group of object adapter instances may share the same adapter manager, in which case state transitions reported for the adapter manager are observed by all object adapters with the same adapter manager ID."},
{"description": "An adapter activator supplies a POA with the ability to create child POAs on demand, as a side-effect of receiving a request that names the child POA (or one of its children), or when find_POA is called with an activate parameter value of TRUE."},
{"description": "An adapter activator supplies a POA with the ability to create child POAs on demand, as a side-effect of receiving a request that names the child POA (or one of its children), or when find_POA is called with an activate parameter value of TRUE."},
{"description": "The ACTIVITY_REQUIRED system exception may be raised on any method for which an Activity context is required.It indicates that an Activity context was necessary to perform the invoked operation, but one was not found associated with the calling thread."},
{"description": "An interface for events that know how to dispatch themselves.By implementing this interface an event can be placed upon the event queue and its dispatch() method will be called when the event is dispatched, using the EventDispatchThread.This is a very useful mechanism for avoiding deadlocks.If a thread is executing in a critical section (i.e., it has entered one or more monitors), calling other synchronized code may cause deadlocks.To avoid the potential deadlocks, an ActiveEvent can be created to run the second section of code at later time.If there is contention on the monitor, the second thread will simply block until the first thread has finished its work and exited its monitors.For security reasons, it is often desirable to use an ActiveEvent to avoid calling untrusted code from a critical thread.For instance, peer implementations can use this facility to avoid making calls into user code from a system thread."},
{"description": "The Activator facilitates remote object activation.A \"faulting\" remote reference calls the activator's activate method to obtain a \"live\" reference to a \"activatable\" remote object.Upon receiving a request for activation, the activator looks up the activation descriptor for the activation identifier, id, determines the group in which the object should be activated initiates object re-creation via the group's ActivationInstantiator (via a call to the newInstance method).The activator initiates the execution of activation groups as necessary.For example, if an activation group for a specific group identifier is not already executing, the activator initiates the execution of a VM for the group.The Activator works closely with ActivationSystem, which provides a means for registering groups and objects within those groups, and ActivationMonitor, which recives information about active and inactive objects and inactive groups.The activator is responsible for monitoring and detecting when activation groups fail so that it can remove stale remote references to groups and active object's within those groups."},
{"description": "This exception is thrown by a container if Activity context is not received on a method for which Activity context is mandatory.This exception indicates a deployment or application configuration error.This exception will be propagated across ORB boundaries via an org.omg.CORBA.ACTIVITY_REQUIRED system exception."},
{"description": "This exception may be thrown on any method for which Activity context is accessed and indicates that ongoing work within the Activity is not possible.This may be because the Activity has been instructed to complete with CompletionStatusFailOnly or has ended as a result of a timeout.This exception will be propagated across ORB boundaries via an org.omg.CORBA.ACTIVITY_COMPLETED system exception.An application should handle this error by attempting to complete the Activity."},
{"description": "The ACTIVITY_COMPLETED system exception may be raised on any method for which Activity context is accessed.It indicates that the Activity context in which the method call was made has been completed due to a timeout of either the Activity itself or a transaction that encompasses the Activity, or that the Activity completed in a manner other than that originally requested."},
{"description": "The ActivationSystem provides a means for registering groups and \"activatable\" objects to be activated within those groups.The ActivationSystem works closely with the Activator, which activates objects registered via the ActivationSystem, and the ActivationMonitor, which obtains information about active and inactive objects, and inactive groups."},
{"description": "An ActivationMonitor is specific to an ActivationGroup and is obtained when a group is reported active via a call to ActivationSystem.activeGroup (this is done internally).An activation group is responsible for informing its ActivationMonitor when either: its objects become active or inactive, or the group as a whole becomes inactive."},
{"description": "Activation makes use of special identifiers to denote remote objects that can be activated over time.An activation identifier (an instance of the class ActivationID) contains several pieces of information needed for activating an object: a remote reference to the object's activator (a RemoteRef instance), and a unique identifier (a UID instance) for the object.An activation identifier for an object can be obtained by registering an object with the activation system.Registration is accomplished in a few ways: via the Activatable.register method via the first Activatable constructor (that takes three arguments and both registers and exports the object, and via the first Activatable.exportObject method that takes the activation descriptor, object and port as arguments; this method both registers and exports the object."},
{"description": "An ActivationInstantiator is responsible for creating instances of \"activatable\" objects.A concrete subclass of ActivationGroup implements the newInstance method to handle creating objects within the group."},
{"description": "This class allows overriding default system properties and specifying implementation-defined options for ActivationGroups."},
{"description": "The identifier for a registered activation group serves several purposes: identifies the group uniquely within the activation system, and contains a reference to the group's activation system so that the group can contact its activation system when necessary.The ActivationGroupID is returned from the call to ActivationSystem.registerGroup and is used to identify the group within the activation system.This group id is passed as one of the arguments to the activation group's special constructor when an activation group is created/recreated."},
{"description": "ActivationGroup_Stub is a stub class for the subclasses of java.rmi.activation.ActivationGroup that are exported as a java.rmi.server.UnicastRemoteObject."},
{"description": "An activation group descriptor contains the information necessary to create/recreate an activation group in which to activate objects.Such a descriptor contains: the group's class name, the group's code location (the location of the group's class), and a \"marshalled\" object that can contain group specific initialization data.The group's class must be a concrete subclass of ActivationGroup.A subclass of ActivationGroup is created/recreated via the ActivationGroup.createGroup static method that invokes a special constructor that takes two arguments: the group's ActivationGroupID, and the group's initialization data (in a java.rmi.MarshalledObject)"},
{"description": "As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.The \"detail exception\" that may be provided at construction time and accessed via the public detail field is now known as the cause, and may be accessed via the Throwable.getCause() method, as well as the aforementioned \"legacy field.\"Invoking the method Throwable.initCause(Throwable) on an instance of ActivationException always throws IllegalStateException."},
{"description": "An ActivationGroup is responsible for creating new instances of \"activatable\" objects in its group, informing its ActivationMonitor when either: its object's become active or inactive, or the group as a whole becomes inactive.An ActivationGroup is initially created in one of several ways: as a side-effect of creating an ActivationDesc without an explicit ActivationGroupID for the first activatable object in the group, or via the ActivationGroup.createGroup method as a side-effect of activating the first object in a group whose ActivationGroupDesc was only registered.Only the activator can recreate an ActivationGroup.The activator spawns, as needed, a separate VM (as a child process, for example) for each registered activation group and directs activation requests to the appropriate group.An activation group is created via the ActivationGroup.createGroup static method.The createGroup method has two requirements on the group to be created: 1)the group must be a concrete subclass of ActivationGroup, and 2)the group must have a constructor that takes two arguments: the group's ActivationGroupID, and the group's initialization data (in a java.rmi.MarshalledObject)When created, the default implementation of ActivationGroup will override the system properties with the properties requested when its ActivationGroupDesc was created, and will set a SecurityManager as the default system security manager.If your application requires specific properties to be set when objects are activated in the group, the application should create a special Properties object containing these properties, then create an ActivationGroupDesc with the Properties object, and use ActivationGroup.createGroup before creating any ActivationDescs (before the default ActivationGroupDesc is created).If your application requires the use of a security manager other than SecurityManager, in the ActivativationGroupDescriptor properties list you can set java.security.manager property to the name of the security manager you would like to install."},
{"description": "An activation descriptor contains the information necessary to activate an object: the object's group identifier, the object's fully-qualified class name, the object's code location (the location of the class), a codebase URL path, the object's restart \"mode\", and, a \"marshalled\" object that can contain object specific initialization data.A descriptor registered with the activation system can be used to recreate/activate the object specified by the descriptor.The MarshalledObject in the object's descriptor is passed as the second argument to the remote object's constructor for object to use during reinitialization/activation."},
{"description": "The Activatable class provides support for remote objects that require persistent access over time and that can be activated by the system.For the constructors and static exportObject methods, the stub for a remote object being exported is obtained as described in UnicastRemoteObject.An attempt to serialize explicitly an instance of this class will fail."},
{"description": "A subclass of javax.swing.ActionMap that implements UIResource.UI classes which provide an ActionMap should use this class."},
{"description": "ActionMap provides mappings from Objects (called keys or Action names) to Actions.An ActionMap is usually used with an InputMap to locate a particular action when a key is pressed.As with InputMap, an ActionMap can have a parent that is searched for keys not defined in the ActionMap.As with InputMap if you create a cycle, eg: ActionMap am = new ActionMap(); ActionMap bm = new ActionMap(): am.setParent(bm); bm.setParent(am); some of the methods will cause a StackOverflowError to be thrown."},
{"description": "The ActivationDataFlavor class is a special subclass of java.awt.datatransfer.DataFlavor.It allows the JAF to set all three values stored by the DataFlavor class via a new constructor.It also contains improved MIME parsing in the equals method.Except for the improved parsing, its semantics are identical to that of the JDK's DataFlavor class."},
{"description": "This exception is thrown by the RMI runtime when activation fails during a remote call to an activatable object."},
{"description": "The class that is interested in processing an action event implements this interface, and the object created with that class is registered with a component, using the component's addActionListener method."},
{"description": "This is an exception that is thrown whenever a reference is made to a non-existent ACL (Access Control List)."},
{"description": "The Action interface provides a useful extension to the ActionListener interface in cases where the same functionality may be accessed by several controls.In addition to the actionPerformed method defined by the ActionListener interface, this interface allows the application to define, in a single place: One or more text strings that describe the function.These strings can be used, for example, to display the flyover text for a button or to set the text in a menu item.One or more icons that depict the function.These icons can be used for the images in a menu control, or for composite entries in a more sophisticated user interface.Instead of having to separately disable the menu item and the toolbar button, the application can disable the function that implements this interface.All components which are registered as listeners for the state change then know to disable event generation for that item and to modify the display accordingly.This interface can be added to an existing class or used to create an adapter (typically, by subclassing AbstractAction).The Action object can then be added to multiple Action-aware containers and connected to Action-capable components.The GUI controls can then be activated or deactivated all at once by invoking the Action object's setEnabled method.Note that Action implementations tend to be more expensive in terms of storage than a typical ActionListener, which does not offer the benefits of centralized control of functionality and broadcast of property changes.For this reason, you should take care to only use Actions where their benefits are desired, and use simple ActionListeners elsewhere.Many of Swing's components have an Action property.When an Action is set on a component, the following things happen: The Action is added as an ActionListener to the component.The component configures some of its properties to match the Action.The component installs a PropertyChangeListener on the Action so that the component can change its properties to reflect changes in the Action's properties.The following table describes the properties used by Swing components that support Actions.In the table, button refers to any AbstractButton subclass, which includes not only JButton but also classes such as JMenuItem.Unless otherwise stated, a null property value in an Action (or a Action that is null) results in the button's corresponding property being set to null.Component Property Components Action Key Notes enabled All The isEnabled method \u00a0 toolTipTextIf you do not want the text of the button to mirror that of the Action, set the property hideActionText to true.If hideActionText is true, setting the Action changes the text of the button to null and any changes to NAME are ignored.hideActionText is useful for tool bar buttons that typically only show an Icon. JToolBar.add(Action) sets the property to true if the Action has a non-null value for LARGE_ICON_KEY or SMALL_ICON.If the value of DISPLAYED_MNEMONIC_INDEX_KEY is beyond the bounds of the text, it is ignored.When setAction is called, if the value from the Action is null, the displayed mnemonic index is not updated.In any subsequent changes to DISPLAYED_MNEMONIC_INDEX_KEY, null is treated as -1.either LARGE_ICON_KEY or SMALL_ICON The JMenuItem subclasses only use SMALL_ICON.All other buttons will use LARGE_ICON_KEY; if the value is null they use SMALL_ICON.ACCELERATOR_KEY \u00a0 selected JToggleButton, JCheckBox, JRadioButton, JCheckBoxMenuItem and JRadioButtonMenuItem SELECTED_KEY Components that honor this property only use the value if it is non-null.For example, if you set an Action that has a null value for SELECTED_KEY on a JToggleButton, the JToggleButton will not update it's selected state in any way.Similarly, any time the JToggleButton's selected state changes it will only set the value back on the Action if the Action has a non-null value for SELECTED_KEY.Components that honor this property keep their selected state in sync with this property.When the same Action is used with multiple components, all the components keep their selected state in sync with this property.Mutually exclusive buttons, such as JToggleButtons in a ButtonGroup, force only one of the buttons to be selected.As such, do not use the same Action that defines a value for the SELECTED_KEY property with multiple mutually exclusive buttons.JPopupMenu, JToolBar and JMenu all provide convenience methods for creating a component and setting the Action on the corresponding component.Action uses PropertyChangeListener to inform listeners the Action has changed.By default Swing components that take an Action do not handle such a change.To indicate that Swing should treat null according to the beans specification set the system property swing.actions.reconfigureOnNull to the String value true."},
{"description": "This high-level event is generated by a component (such as a Button) when the component-specific action occurs (such as being pressed).The event is passed to every ActionListener object that registered to receive such events using the component's addActionListener method.The object that implements the ActionListener interface gets this ActionEvent when the event occurs.The listener is therefore spared the details of processing individual mouse movements and mouse clicks, and can instead process a \"meaningful\" (semantic) event like \"button pressed\".An unspecified behavior will be caused if the id parameter of any particular ActionEvent instance is not in the range from ACTION_FIRST to ACTION_LAST."},
{"description": "The Action annotation allows explicit association of a WS-Addressing Action message addressing property with input, output, and fault messages of the mapped WSDL operation.This annotation can be specified on each method of a service endpoint interface.For such a method, the mapped operation in the generated WSDL's wsam:Action attribute on the WSDL input, output and fault messages of the WSDL operation is based upon which attributes of the Action annotation have been specified.For the exact computation of wsam:Action values for the messages, refer to the algorithm in the JAX-WS specification.Example 1: Specify explicit values for Action message addressing property for input and output messages.Example 2: Specify explicit value for Action message addressing property for only the input message.The wsam:Action values for the WSDL output message are computed using the algorithm in the JAX-WS specification.It is legitimate to specify an explicit value for Action message addressing property for output message only.In this case, wsam:Action value for the WSDL input message is computed using the algorithm in the JAX-WS specification.See FaultAction annotation for an example of how to specify an explicit value for Action message addressing property for the fault message."},
{"description": "A file attribute view that supports reading or updating a file's Access Control Lists (ACL) or file owner attributes.ACLs are used to specify access rights to file system objects.An ACL is an ordered list of access-control-entries, each specifying a UserPrincipal and the level of access for that user principal.This file attribute view defines the getAcl, and setAcl methods to read and write ACLs based on the ACL model specified in RFC\u00a03530:This file attribute view is intended for file system implementations that support the NFSv4 ACL model or have a well-defined mapping between the NFSv4 ACL model and the ACL model used by the file system.The details of such mapping are implementation dependent and are therefore unspecified.This class also extends FileOwnerAttributeView so as to define methods to get and set the file owner.When a file system provides access to a set of file-systems that are not homogeneous then only some of the file systems may support ACLs.The supportsFileAttributeView method can be used to test if a file system supports ACLs.Interoperability RFC\u00a03530 allows for special user identities to be used on platforms that support the POSIX defined access permissions.The special user identities are \"OWNER@\", \"GROUP@\", and \"EVERYONE@\".When both the AclFileAttributeView and the PosixFileAttributeView are supported then these special user identities may be included in ACL entries that are read or written.The file system's UserPrincipalLookupService may be used to obtain a UserPrincipal to represent these special identities by invoking the lookupPrincipalByName method.Usage Example: Suppose we wish to add an entry to an existing ACL to grant \"joe\" access: // lookup \"joe\" UserPrincipal joe =// insert before any DENY entries view.setAcl(acl); Dynamic Access Where dynamic access to file attributes is required, the attributes supported by this attribute view are as follows: Name Type \"acl\" List<AclEntry> \"owner\"The getAttribute method may be used to read the ACL or owner attributes as if by invoking the getAcl or getOwner methods.The setAttribute method may be used to update the ACL or owner attributes as if by invoking the setAcl or setOwner methods.Setting the ACL when creating a file Implementations supporting this attribute view may also support setting the initial ACL when creating a file or directory.The initial ACL may be provided to methods such as createFile or createDirectory as an FileAttribute with name \"acl:acl\" and a value that is the list of AclEntry objects.Where an implementation supports an ACL model that differs from the NFSv4 defined ACL model then setting the initial ACL when creating the file must translate the ACL to the model supported by the file system.Methods that create a file should reject (by throwing IOException)any attempt to create a file that would be less secure as a result of the translation."},
{"description": "This is the interface used for representing one entry in an Access Control List (ACL).An ACL can be thought of as a data structure with multiple ACL entry objects.Each ACL entry object contains a set of permissions associated with a particular principal.(A principal represents an entity such as an individual user or a group).If positive, the permissions are to be granted to the associated principal.Each principal can have at most one positive ACL entry and one negative entry; that is, multiple positive or negative ACL entries are not allowed for any principal.Note: ACL entries are by default positive.An entry becomes a negative entry only if the setNegativePermissions method is called on it."},
{"description": "In this release, this class does not define flags related to AclEntryType."},
{"description": "The ACL entry represented by this class is based on the ACL model specified in RFC\u00a03530:Each entry has four components as follows: The type component determines if the entry grants or denies access.The principal component, sometimes called the \"who\" component, is a UserPrincipal corresponding to the identity that the entry grants or denies accessThe permissions component is a set of permissions The flags component is a set of flags to indicate how entries are inherited and propagated ACL entries are created using an associated AclEntry.Builder object by invoking its build method.ACL entries are immutable and are safe for use by multiple concurrent threads."},
{"description": "This exception may be thrown by a LoginModule if it is unable to locate an account necessary to perform authentication."},
{"description": "Class AccessibleRelationSet determines a component's relation set.The relation set of a component is a set of AccessibleRelation objects that describe the component's relationships with other components."},
{"description": "Class AccessibleRelation describes a relation between the object that implements the AccessibleRelation and one or more other objects.The actual relations that an object has with other objects are defined as an AccessibleRelationSet, which is a composed set of AccessibleRelations.The toDisplayString method allows you to obtain the localized string for a locale independent key from a predefined ResourceBundle for the keys defined in this class.The constants in this class present a strongly typed enumeration of common object roles.If the constants in this class are not sufficient to describe the role of an object, a subclass should be generated from this class and it should provide constants in a similar manner."},
{"description": "A Builder object is obtained by invoking one of the newBuilder methods defined by the AclEntry class.Builder objects are mutable and are not safe for use by multiple concurrent threads without appropriate synchronization."},
{"description": "An Access Control List is a data structure used to guard access to resources.An ACL can be thought of as a data structure with multiple ACL entries.Each ACL entry, of interface type AclEntry, contains a set of permissions associated with a particular principal.(A principal represents an entity such as an individual user or a group).If positive, the permissions are to be granted to the associated principal.The ACL Entries in each ACL observe the following rules: Each principal can have at most one positive ACL entry and one negative entry; that is, multiple positive or negative ACL entries are not allowed for any principal.Each entry specifies the set of permissions that are to be granted (if positive) or denied (if negative).If there is no entry for a particular principal, then the principal is considered to have a null (empty) permission set.If there is a positive entry that grants a principal a particular permission, and a negative entry that denies the principal the same permission, the result is as though the permission was never granted or denied.Individual permissions always override permissions of the group(s) to which the individual belongs.That is, individual negative permissions (specific denial of permissions) override the groups' positive permissions.And individual positive permissions override the groups' negative permissions.The java.security.acl package provides the interfaces to the ACL and related data structures (ACL entries, groups, permissions, etc.), and the sun.security.acl classes provide a default implementation of the interfaces.For example, java.security.acl.Acl provides the interface to an ACL and the sun.security.acl.AclImpl class provides the default implementation of the interface.The java.security.acl.Acl interface extends the java.security.acl.Owner interface.The Owner interface is used to maintain a list of owners for each ACL.Only owners are allowed to modify an ACL.For example, only an owner can call the ACL's addEntry method to add a new ACL entry to the ACL."},
{"description": "The AccessibleObject class is the base class for Field, Method and Constructor objects.It provides the ability to flag a reflected object as suppressing default Java language access control checks when it is used.The access checks--for public, default (package) access, protected, and private members--are performed when Fields, Methods or Constructors are used to set or get fields, to invoke methods, or to create and initialize new instances of classes, respectively.Setting the accessible flag in a reflected object permits sophisticated applications with sufficient privilege, such as Java Object Serialization or other persistence mechanisms, to manipulate objects in a manner that would normally be prohibited.By default, a reflected object is not accessible."},
{"description": "The AccessibleKeyBinding interface should be supported by any object that has a keyboard bindings such as a keyboard mnemonic and/or keyboard shortcut which can be used to select the object.This interface provides the standard mechanism for an assistive technology to determine the key bindings which exist for this object.Any object that has such key bindings should support this interface."},
{"description": "The AccessibleIcon interface should be supported by any object that has an associated icon (e.g., buttons).This interface provides the standard mechanism for an assistive technology to get descriptive information about icons.Applications can determine if an object supports the AccessibleIcon interface by first obtaining its AccessibleContext (see Accessible) and then calling the AccessibleContext.getAccessibleIcon() method.If the return value is not null, the object supports this interface."},
{"description": "The AccessibleHypertext class is the base class for all classes that present hypertext information on the display.This class provides the standard mechanism for an assistive technology to access that text via its content, attributes, and spatial location.It also provides standard mechanisms for manipulating hyperlinks.Applications can determine if an object supports the AccessibleHypertext interface by first obtaining its AccessibleContext (see Accessible) and then calling the AccessibleContext.getAccessibleText() method of AccessibleContext.If the return value is a class which extends AccessibleHypertext, then that object supports AccessibleHypertext."},
{"description": "The AccessibleExtendedText interface contains additional methods not provided by the AccessibleText interface Applications can determine if an object supports the AccessibleExtendedText interface by first obtaining its AccessibleContext (see Accessible) and then calling the AccessibleContext.getAccessibleText() method of AccessibleContext.If the return value is an instance of AccessibleExtendedText, the object supports this interface."},
{"description": "The AccessibleExtendedComponent interface should be supported by any object that is rendered on the screen.This interface provides the standard mechanism for an assistive technology to determine the extended graphical representation of an object.Applications can determine if an object supports the AccessibleExtendedComponent interface by first obtaining its AccessibleContext and then calling the AccessibleContext.getAccessibleComponent() method.If the return value is not null and the type of the return value isAccessibleExtendedComponent, the object supports this interface."},
{"description": "Class AccessibleExtendedTable provides extended information about a user-interface component that presents data in a two-dimensional table format.Applications can determine if an object supports the AccessibleExtendedTable interface by first obtaining its AccessibleContext and then calling the AccessibleContext.getAccessibleTable() method.If the return value is not null and the type of the return value is AccessibleExtendedTable, the object supports this interface."},
{"description": "The AccessibleEditableText interface should be implemented by all classes that present editable textual information on the display.Along with the AccessibleText interface, this interface provides the standard mechanism for an assistive technology to access that text via its content, attributes, and spatial location.Applications can determine if an object supports the AccessibleEditableText interface by first obtaining its AccessibleContext (see Accessible) and then calling the AccessibleContext.getAccessibleEditableText() method of AccessibleContext.If the return value is not null, the object supports this interface."},
{"description": "The AccessibleComponent interface should be supported by any object that is rendered on the screen.This interface provides the standard mechanism for an assistive technology to determine and set the graphical representation of an object.Applications can determine if an object supports the AccessibleComponent interface by first obtaining its AccessibleContext and then calling the AccessibleContext.getAccessibleComponent() method.If the return value is not null, the object supports this interface."},
{"description": "AccessibleContext represents the minimum informationThis information includes the accessible name, description, role, and state of the object, as well as information about its parent and children.AccessibleContext also contains methods for obtaining more specific accessibility information about a component.If the component supports them, these methods will return an object that implements one or more of the following interfaces:AccessibleAction - the object can perform one or more actions.This interface provides the standard mechanism for an assistive technology to determine what those actions are and tell the object to perform them.Any object that can be manipulated should support this interface.AccessibleComponent - the object has a graphical representation.This interface provides the standard mechanism for an assistive technology to determine and set the graphical representation of the object.Any object that is rendered on the screen should support this interface.This interface provides the standard mechanism for an assistive technology to determine the currently selected children of the object as well as modify its selection set.Any object that has children that can be selected should support this interface.AccessibleText - the object presents editable textual information on the display.This interface provides the standard mechanism for an assistive technology to access that text via its content, attributes, and spatial location.Any object that contains editable text should support this interface.AccessibleValue - the object supports a numerical value.This interface provides the standard mechanism for an assistive technology to determine and set the current value of the object, as well as obtain its minimum and maximum values.Any object that supports a numerical value should support this interface."},
{"description": "This class collects together the span of text that share the same contiguous set of attributes, along with that set of attributes.It is used by implementors of the class"},
{"description": "Interface Accessible is the main interface for the accessibility package.All components that support the accessibility package must implement this interface.It contains a single method, getAccessibleContext(), which returns an instance of the class AccessibleContext."},
{"description": "Base class used to maintain a strongly typed enumeration.This is the superclass of AccessibleState and AccessibleRole.The toDisplayString method allows you to obtain the localized string for a locale independent key from a predefined ResourceBundle for the keys defined in this class.This localized string is intended to be readable by humans."},
{"description": "An AccessException is thrown by certain methods of the java.rmi.Naming class (specifically bind, rebind, and unbind) and methods of the java.rmi.activation.ActivationSystem interface to indicate that the caller does not have permission to perform the action requested by the method call.If the method was invoked from a non-local host, then an AccessException is thrown."},
{"description": "The AccessibleAction interface should be supported by any object that can perform one or more actions.This interface provides the standard mechanism for an assistive technology to determine what those actions are as well as tell the object to perform them.Any object that can be manipulated should support this interface.Applications can determine if an object supports the AccessibleAction interface by first obtaining its AccessibleContext (see Accessible) and then calling the AccessibleContext.getAccessibleAction() method.If the return value is not null, the object supports this interface."},
{"description": "Checked exception thrown when a file system operation is denied, typically due to a file permission or other access check.This exception is not related to the AccessControlException or SecurityException thrown by access controllers or security managers when access to a file is denied."},
{"description": "The AccessController class is used for access control operations and decisions.More specifically, the AccessController class is used for three purposes: to decide whether an access to a critical system resource is to be allowed or denied, based on the security policy currently in effect, to mark code as being \"privileged\", thus affecting subsequent access determinations, and to obtain a \"snapshot\" of the current calling context so access-control decisions from a different context can be made with respect to the saved context.The checkPermission method determines whether the access request indicated by a specified permission should be granted or denied.In this example, checkPermission will determine whether or not to grant \"read\" access to the file named \"testFile\" in the \"/temp\" directory.AccessControlException can also be thrown if the requested permission is of an incorrect type or contains an invalid value.Suppose the current thread traversed m callers, in the order of caller 1 to caller 2 to caller m.Then caller m invoked the checkPermission method.The checkPermission method determines whether access is granted or denied based on the following algorithm: for (int i = m; i > 0; i--) { if (caller i's domain does not have the permission) throw AccessControlException else if (caller i is marked as privileged) { if (a context was specified in the call to doPrivileged) context.checkPermission(permission) if (limited permissions were specified in the call to doPrivileged) { for (each limited permission) { if (the limited permission implies the requested permission) return; } } else return; } } //Next, check the context inherited when the thread was created.Whenever a new thread is created, the AccessControlContext at // that time is stored and associated with the new thread, as the // \"inherited\" context.When making access control decisions, the checkPermission method stops checking if it reaches a caller that was marked as \"privileged\" via a doPrivileged call without a context argument (see below for information about a context argument).If that caller's domain has the specified permission and at least one limiting permission argument (if any) implies the requested permission, no further checking is done and checkPermission returns quietly, indicating that the requested access is allowed.If that domain does not have the specified permission, an exception is thrown, as usual.If the caller's domain had the specified permission but it was not implied by any limiting permission arguments given in the call to doPrivileged then the permission checking continues until there are no more callers or another doPrivileged call matches the requested permission and returns normally.The normal use of the \"privileged\" feature is as follows.If you don't need to return a value from within the \"privileged\" block, do the following: somemethod() { ...normal code here...// privileged code goes here, for example: System.loadLibrary(\"awt\"); return null; // nothing to return } }); ...} PrivilegedAction is an interface with a single method, named run.The above example shows creation of an implementation of that interface; a concrete implementation of the run method is supplied.When the call to doPrivileged is made, an instance of the PrivilegedAction implementation is passed to it.The doPrivileged method calls the run method from the PrivilegedAction implementation after enabling privileges, and returns the run method's return value as the doPrivileged return value (which is ignored in this example).If you need to return a value, you can do something like the following: somemethod() { ...normal code here...( new PrivilegedAction<String>() { public String run() { return} }); ...normal code here... } If the action performed in your run method could throw a \"checked\" exception (those listed in the throws clause of a method), then you need to use the PrivilegedExceptionAction interface instead of the PrivilegedAction interface: somemethod() throws FileNotFoundException { ...normal code here... try { FileInputStream fis = AccessController.doPrivileged( new PrivilegedExceptionAction<FileInputStream>() { public FileInputStream run() throws FileNotFoundException { return new FileInputStream(\"someFile\"); } }); } catch (PrivilegedActionException e) { //e.getException() should be an instance of FileNotFoundException, // as only \"checked\" exceptions will be \"wrapped\" in a // PrivilegedActionException.You can pass Permission arguments to further limit the scope of the \"privilege\" (see below).Note that checkPermission always performs security checks within the context of the currently executing thread.Sometimes a security check that should be made within a given context will actually need to be done from within a different context (for example, from within a worker thread).The getContext method and AccessControlContext class are provided for this situation.The getContext method takes a \"snapshot\" of the current calling context, and places it in an AccessControlContext object, which it returns.A sample call is the following:AccessControlContext acc = AccessController.getContext() AccessControlContext itself has a checkPermission method that makes access decisions based on the context it encapsulates, rather than that of the current execution thread.Code within a different context can thus call that method on the previously-saved AccessControlContext object.A sample call is the following: acc.checkPermission(permission)There are also times where you don't know a priori which permissions to check the context against.In these cases you can use the doPrivileged method that takes a context.You can also limit the scope of the privileged code by passing additional Permission parameters.Any permission checks within this // run method will require that the intersection of the // caller's protection domain and the snapshot's //context have the desired permission.If a requested // permission is not implied by the limiting FilePermission // argument then checking of the thread continues beyond the // caller of doPrivileged. } },Passing a limiting Permission argument of an instance of AllPermission is equivalent to calling the equivalent doPrivileged method without limiting Permission arguments.Passing a zero length array of Permission disables the code privileges so that checking always continues beyond the caller of that doPrivileged method."},
{"description": "This exception is thrown by the AccessController to indicate that a requested access (to a critical system resource such as the file system or the network) is denied.The reason to deny access can vary.For example, the requested permission might be of an incorrect type, contain an invalid value, or request access that is not allowed according to the security policy.Such information should be given whenever possible at the time the exception is thrown."},
{"description": "Unchecked exception thrown when an attempt is made to initiate an accept operation on a channel and a previous accept operation has not completed."},
{"description": "AbstractWriter is an abstract class that actually does the work of writing out the element tree including the attributes.In terms of how much is written out per line, the writer defaults to 100.But this value can be set by subclasses."},
{"description": "An AccessControlContext is used to make system resource access decisions based on the context it encapsulates.More specifically, it encapsulates a context and has a single method, checkPermission, that is equivalent to the checkPermission method in the AccessController class, with one difference:The AccessControlContext checkPermission method makes access decisions based on the context it encapsulates, rather than that of the current execution thread.Thus, the purpose of AccessControlContext is for those situations where a security check that should be made within a given context actually needs to be done from within a different context (for example, from within a worker thread).An AccessControlContext is created by calling the AccessController.getContext method.The getContext method takes a \"snapshot\" of the current calling context, and places it in an AccessControlContext object, which it returns.A sample call is the following:AccessController.getContext() Code within a different context can subsequently call the checkPermission method on the previously-saved AccessControlContext object.A sample call is the following: acc.checkPermission(permission)"},
{"description": "This class provides a partial default implementation for the Unmarshallerinterface.A JAXB Provider has to implement five methods (getUnmarshallerHandler, unmarshal(Node), unmarshal(XMLReader,InputSource), unmarshal(XMLStreamReader), and unmarshal(XMLEventReader)."},
{"description": "A base interface that all views shall derive from."},
{"description": "The TypeVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new abstract type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "The TypeVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new abstract type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "This class provides the ChangeListener part of the SpinnerModel interface that should be suitable for most concrete SpinnerModel implementations.Subclasses must provide an implementation of the setValue, getValue, getNextValue and getPreviousValue methods."},
{"description": "This class provides a skeletal implementation of the List interface to minimize the effort required to implement this interface backed by a \"sequential access\" data store (such as a linked list).For random access data (such as an array), AbstractList should be used in preference to this class.This class is the opposite of the AbstractList class in the sense that it implements the \"random access\" methods (get(int index), set(int index, E element), add(int index, E element) and remove(int index)) on top of the list's list iterator, instead of the other way around.To implement a list the programmer needs only to extend this class and provide implementations for the listIterator and size methods.For an unmodifiable list, the programmer need only implement the list iterator's hasNext, next, hasPrevious, previous and index methods.For a modifiable list the programmer should additionally implement the list iterator's set method.For a variable-size list the programmer should additionally implement the list iterator's remove and add methods.The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the Collection interface specification.This class is a member of the Java Collections Framework."},
{"description": "This class provides a skeletal implementation of the Set interface to minimize the effort required to implement this interface.The process of implementing a set by extending this class is identical to that of implementing a Collection by extending AbstractCollection, except that all of the methods and constructors in subclasses of this class must obey the additional constraints imposed by the Set interface (for instance, the add method must not permit addition of multiple instances of an object to a set).Note that this class does not override any of the implementations from the AbstractCollection class.It merely adds implementations for equals and hashCode.This class is a member of the Java Collections Framework."},
{"description": "This abstract class provides default implementations for most of the methods in the TableModel interface.It takes care of the management of listeners and provides some conveniences for generating TableModelEvents and dispatching them to the listeners.To create a concrete TableModel as a subclass of AbstractTableModel you need only provide implementations for the following three methods: public int getRowCount(); public int getColumnCount(); public Object getValueAt(int row, int column); Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The TypeVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new abstract type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "This class encapsulates the low-level machinery required to implement the interruption of selection operations.A concrete selector class must invoke the begin and end methods before and after, respectively, invoking an I/O operation that might block indefinitely.In order to ensure that the end method is always invoked, these methods should be used within a try\u00a0...\u00a0finally block: try { begin(); // Perform blocking I/O operation here ... } finally { end(); } This class also defines methods for maintaining a selector's cancelled-key set and for removing a key from its channel's key set, and declares the abstract register method that is invoked by a selectable channel's register method in order to perform the actual work of registering a channel."},
{"description": "This class tracks the validity of the key and implements cancellation."},
{"description": "Generally, instances of this class are created once, and reused for each paint request without modification.This class contains values useful when hinting the cache engine, and when decoding control points and bezier curve anchors."},
{"description": "Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues.This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state.Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released.Given these, the other methods in this class carry out all queuing and blocking mechanics.Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState(), setState(int) and compareAndSetState(int, int) is tracked with respect to synchronization.Subclasses should be defined as non-public internal helper classes that are used to implement the synchronization properties of their enclosing class.Class AbstractQueuedSynchronizer does not implement any synchronization interface.Instead it defines methods such as acquireInterruptibly(int) that can be invoked as appropriate by concrete locks and related synchronizers to implement their public methods.This class supports either or both a default exclusive mode and a shared mode.When acquired in exclusive mode, attempted acquires by other threads cannot succeed.Shared mode acquires by multiple threadsThis class does not \"understand\" these differences except in the mechanical sense that when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as well.Threads waiting in the different modes share the same FIFO queue.Usually, implementation subclasses support only one of these modes, but both can come into play for example in a ReadWriteLock.Subclasses that support only exclusive or only shared modes need not define the methods supporting the unused mode.This class defines a nested AbstractQueuedSynchronizer.ConditionObject class that can be used as a Condition implementation by subclasses supporting exclusive mode for which method isHeldExclusively() reports whether synchronization is exclusively held with respect to the current thread, method release(int) invoked with the current getState() value fully releases this object, and acquire(int), given this saved state value, eventually restores this object to its previous acquired state.No AbstractQueuedSynchronizer method otherwise creates such a condition, so if this constraint cannot be met, do not use it.ConditionObject depends of course on the semantics of its synchronizer implementation.This class provides inspection, instrumentation, and monitoring methods for the internal queue, as well as similar methods for condition objects.These can be exported as desired into classes using an AbstractQueuedSynchronizer for their synchronization mechanics.Serialization of this class stores only the underlying atomic integer maintaining state, so deserialized objects have empty thread queues.Typical subclasses requiring serializability will define a readObject method that restores this to a known initial state upon deserialization.Usage To use this class as the basis of a synchronizer, redefine the following methods, as applicable, by inspecting and/or modifying the synchronization state using getState(), setState(int) and/orisHeldExclusively() Each of these methods by default throws UnsupportedOperationException.Implementations of these methods must be internally thread-safe, and should in general be short and not block.Defining these methods is the only supported means of using this class.You may also find the inherited methods from AbstractOwnableSynchronizer useful to keep track of the thread owning an exclusive synchronizer.You are encouraged to use them -- this enables monitoring and diagnostic tools to assist users in determining which threads hold locks.Even though this class is based on an internal FIFO queue, it does not automatically enforce FIFO acquisition policies.The core of exclusive synchronization takes the form:; possibly block current thread; } Release: if (tryRelease(arg)) unblock the first queued thread; (Shared mode is similar but may involve cascading signals.)Because checks in acquire are invoked before enqueuing, a newly acquiring thread may barge ahead of others that are blocked and queued.However, you can, if desired, define tryAcquire and/or tryAcquireShared to disable barging by internally invoking one or more of the inspection methods, thereby providing a fair FIFO acquisition order.In particular, most fair synchronizers can define tryAcquire to return false if hasQueuedPredecessors()(a method specifically designed to be used by fair synchronizers) returns true.Throughput and scalability are generally highest for the default barging (also known as greedy, renouncement, and convoy-avoidance) strategy.While this is not guaranteed to be fair or starvation-free, earlier queued threads are allowed to recontend before later queued threads, and each recontention has an unbiased chance to succeed against incoming threads.Also, while acquires do not \"spin\" in the usual sense, they may perform multiple invocations of tryAcquire interspersed with other computations before blocking.This gives most of the benefits of spins when exclusive synchronization is only briefly held, without most of the liabilities when it isn't.If so desired, you can augment this by preceding calls to acquire methods with \"fast-path\" checks, possibly prechecking hasContended() and/or hasQueuedThreads() to only do so if the synchronizer is likely not to be contended.This class provides an efficient and scalable basis for synchronization in part by specializing its range of use to synchronizers that can rely on int state, acquire, and release parameters, and an internal FIFO wait queue.When this does not suffice, you can build synchronizers from a lower level using atomic classes, your own custom Queue classes, and LockSupport blocking support.Usage Examples Here is a non-reentrant mutual exclusion lock class that uses the value zero to represent the unlocked state, and one to represent the locked state.While a non-reentrant lock does not strictly require recording of the current owner thread, this class does so anyway to make usage easier to monitor.It also supports conditions and exposes one of the instrumentation methods: class Mutex implements Lock, java.io.Serializable { //Our internal helper class private static class Sync extends AbstractQueuedSynchronizer{ // Reports whether in locked state protected boolean isHeldExclusivelyAcquires the lock if state is zero public boolean tryAcquire(int acquires) { assert acquires ={ setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } // Releases the lock by setting state to zero protected boolean tryRelease(int releases) { assert releases == 1; //Deserializes properly private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); setState(0); // reset to unlocked state } } //The sync object does all the hard work.We just forward to it.new Sync(); public void lock() { sync.acquire(1); } public boolean tryLock() { return sync.tryAcquire(1); } public void unlock() { sync.release(1); } public Condition newCondition() { return sync.newCondition(); } public boolean isLocked() { return sync.isHeldExclusively(); } public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); } public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(timeout)); } } Here is a latch class that is like a CountDownLatch except that it only requires a single signal to fire.Because a latch is non-exclusive, it uses the shared acquire and release methods.Sync extends AbstractQueuedSynchronizer { boolean isSignalled() { return getState() != 0; } protected int tryAcquireShared(int ignore) { return isSignalled() ?sync.isSignalled(); } public void signal() { sync.releaseShared(1); } public void await() throws InterruptedException { sync.acquireSharedInterruptibly(1); } }"},
{"description": "This class defines methods that handle the mechanics of channel registration, deregistration, and closing.It maintains the current blocking mode of this channel as well as its current set of selection keys.It performs all of the synchronization required to implement the SelectableChannel specification.Implementations of the abstract protected methods defined in this class need not synchronize against other threads that might be engaged in the same operations."},
{"description": "eval(String, Bindings)eval(Reader, Bindings) are implemented using the abstract methods eval(Reader,ScriptContext) or eval(String, ScriptContext) with a SimpleScriptContext.A SimpleScriptContext is used as the default ScriptContext of the AbstractScriptEngine.."},
{"description": "This class provides skeletal implementations of some Queue operations.The implementations in this class are appropriate when the base implementation does not allow null elements.Methods add, remove, and element are based on offer, poll, and peek, respectively, but throw exceptions instead of indicating failure via false or null returns.A Queue implementation that extends this class must minimally define a method Queue.offer(E) which does not permit insertion of null elements, along with methods Queue.peek(), Queue.poll(),If these requirements cannot be met, consider instead subclassing AbstractCollection.This class is a member of the Java Collections Framework."},
{"description": "A synchronizer that may be exclusively owned by a thread.This class provides a basis for creating locks and related synchronizers that may entail a notion of ownership.The AbstractOwnableSynchronizer class itself does not manage or use this information.However, subclasses and tools may use appropriately maintained values to help control and monitor access and provide diagnostics."},
{"description": "Thrown when an application tries to call an abstract method.Normally, this error is caught by the compiler; this error can only occur at run time if the definition of some class has incompatibly changed since the currently executing method was last compiled."},
{"description": "This class provides a partial default implementation for the Marshaller interface.The only methods that a JAXB Provider has to implement are marshal(Object, javax.xml.transform.Result), marshal(Object, javax.xml.stream.XMLStreamWriter), and marshal(Object, javax.xml.stream.XMLEventWriter)."},
{"description": "This class does not support method setValue.This class may be convenient in methods that return thread-safe snapshots of key-value mappings."},
{"description": "A version of AbstractQueuedSynchronizer in which synchronization state is maintained as a long.This class has exactly the same structure, properties, and methods as AbstractQueuedSynchronizer with the exception that all state-related parameters and results are defined as long rather than int.This class may be useful when creating synchronizers such as multilevel locks and barriers that require 64 bits of state."},
{"description": "This class examines annotation values to compute the options, annotation types, and source version supported by its subtypes.The getter methods may issue warnings about noteworthy conditions using the facilities available after the processor has been initialized.Subclasses are free to override the implementation and specification of any of the methods in this class as long as the general Processor contract for that method is obeyed."},
{"description": "This class provides a skeletal implementation of the Preferences class, greatly easing the task of implementing it.This class is for Preferences implementers only.Normal users of the Preferences facility should have no need to consult this documentation.Implementors must override the nine abstract service-provider interface (SPI) methods: getSpi(String), putSpi(String,String), removeSpi(String), childSpi(String), removeNodeSpi(), keysSpi(), childrenNamesSpi(), syncSpi() and flushSpi().All of the concrete methods specify precisely how they are implemented atop these SPI methods.The implementor may, at his discretion, override one or more of the concrete methods if the default implementation is unsatisfactory for any reason, such as performance.The SPI methods fall into three groups concerning exception behavior.The getSpi method should never throw exceptions, but it doesn't really matter, as any exception thrown by this method will be intercepted by get(String,String), which will return the specified default value to the caller.The removeNodeSpi, keysSpi, childrenNamesSpi, syncSpi and flushSpi methods are specified to throw BackingStoreException, and the implementation is required to throw this checked exception if it is unable to perform the operation.The remaining SPI methods putSpi(String,String), removeSpi(String) and childSpi(String) have more complicated exception behavior.They are not specified to throw BackingStoreException, as they can generally obey their contracts even if the backing store is unavailable.This is true because they return no information and their effects are not required to become permanent until a subsequent call to Preferences.flush() or Preferences.sync().Generally speaking, these SPI methods should not throw exceptions.In some implementations, there may be circumstances under which these calls cannot even enqueue the requested operation for later processing.Even under these circumstances it is generally better to simply ignore the invocation and return, rather than throwing an exception.Under these circumstances, however, all subsequent invocations of flush() and sync should return false, as returning true would imply that all previous operations had successfully been made permanent.There is one circumstance under which putSpi, removeSpi and childSpi should throw an exception: if the caller lacks sufficient privileges on the underlying operating system to perform the requested operation.This will, for instance, occur on most systems if a non-privileged user attempts to modify system preferences.(The required privileges will vary from implementation to implementation.On some implementations, they are the right to modify the contents of some directory in the file system; on others they are the right to modify contents of some key in a registry.)Under any of these circumstances, it would generally be undesirable to let the program continue executing as if these operations would become permanent at a later time.While implementations are not required to throw an exception under these circumstances, they are encouraged to do so.Most of the SPI methods require the implementation to read or write information at a preferences node.The implementor should beware of the fact that another VM may have concurrently deleted this node from the backing store.It is the implementation's responsibility to recreate the node if it has been deleted.Implementation note: In Sun's default Preferences implementations, the user's identity is inherited from the underlying operating system and does not change for the lifetime of the virtual machine.It is recognized that server-side Preferences implementations may have the user identity change from request to request, implicitly passed to Preferences methods via the use of a static ThreadLocal instance.Authors of such implementations are strongly encouraged to determine the user at the time preferences are accessed (for example by the get(String,String) or put(String,String) method) rather than permanently associating a user with each Preferences instance."},
{"description": "The value may be changed using the setValue method.This class facilitates the process of building custom map implementations.For example, it may be convenient to return arrays of SimpleEntry instances in method Map.entrySet().toArray."},
{"description": "This class provides a skeletal implementation of the List interface to minimize the effort required to implement this interface backed by a \"random access\" data store (such as an array).For sequential access data (such as a linked list), AbstractSequentialList should be used in preference to this class.To implement an unmodifiable list, the programmer needs only to extend this class and provide implementations for the get(int) and size() methods.To implement a modifiable list, the programmer must additionally override the set(int, E) method (which otherwise throws an UnsupportedOperationException).If the list is variable-size the programmer must additionally override the add(int, E) and remove(int) methods.The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the Collection interface specification.Unlike the other abstract collection implementations, the programmer does not have to provide an iterator implementation; the iterator and list iterator are implemented by this class, on top of the \"random access\" methods: get(int), set(int, E), add(int, E) and remove(int).The documentation for each non-abstract method in this class describes its implementation in detail.Each of these methods may be overridden if the collection being implemented admits a more efficient implementation.This class is a member of the Java Collections Framework."},
{"description": "This class implements the submit, invokeAny and invokeAll methods using a RunnableFuture returned by newTaskFor, which defaults to the FutureTask class provided in this package.For example, the implementation of submit(Runnable) creates an associated RunnableFuture that is executed and returned.Subclasses may override the newTaskFor methods to return RunnableFuture implementations other than FutureTask.Here is a sketch of a class that customizes ThreadPoolExecutor to use a CustomTask class instead of the default FutureTask: public class CustomThreadPoolExecutor extends ThreadPoolExecutor { static class CustomTask<V> implements RunnableFuture<V> {...} protected <V> RunnableFuture<V> newTaskFor(Callable<V> c) { return new CustomTask<V>(c); } protected <V> RunnableFuture<V>newTaskFor(Runnable r, V v) { return new CustomTask<V>(r, v); } // ... add constructors, etc. }"},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "This class encapsulates the low-level machinery required to implement the asynchronous closing and interruption of channels.A concrete channel class must invoke the begin and end methods before and after, respectively, invoking an I/O operation that might block indefinitely.In order to ensure that the end method is always invoked, these methods should be used within a try\u00a0...\u00a0finally block: boolean completed = false; try { begin(); completed = ...;// Perform blocking I/O operation return ...; // Return result } finally { end(completed); } The completed argument to the end method tells whether or not the I/O operation actually completed, that is, whether it had any effect that would be visible to the invoker.In the case of an operation that reads bytes, for example, this argument should be true if, and only if, some bytes were actually transferred into the invoker's target buffer.A concrete channel class must also implement the implCloseChannel method in such a way that if it is invoked while another thread is blocked in a native I/O operation upon the channel then that operation will immediately return, either by throwing an exception or by returning normally.If a thread is interrupted or the channel upon which it is blocked is asynchronously closed then the channel's end method will throw the appropriate exception.This class performs the synchronization required to implement the Channel specification.Implementations of the implCloseChannel method need not synchronize against other threads that might be attempting to close the channel."},
{"description": "This class provides a skeletal implementation of the Map interface, to minimize the effort required to implement this interface.To implement an unmodifiable map, the programmer needs only to extend this class and provide an implementation for the entrySet method, which returns a set-view of the map's mappings.Typically, the returned set will, in turn, be implemented atop AbstractSet.This set should not support the add or remove methods, and its iterator should not support the remove method.To implement a modifiable map, the programmer must additionally override this class's put method (which otherwise throws an UnsupportedOperationException), and the iterator returned by entrySet().iterator() must additionally implement its remove method.The programmer should generally provide a void (no argument) and map constructor, as per the recommendation in the Map interface specification.The documentation for each non-abstract method in this class describes its implementation in detail.Each of these methods may be overridden if the map being implemented admits a more efficient implementation.This class is a member of the Java Collections Framework."},
{"description": "The abstract definition for the data model that provides a List with its contents.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The ElementVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new abstract element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "The ElementVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new abstract element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "The ElementVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new abstract element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "At this level there is very little policy, so there is a corresponding increase in difficulty of use.This class implements a locking mechanism for the document.It allows multiple readers or one writer, and writers must wait until all observers of the document have been notified of a previous change before beginning another mutation to the document.The read lock is acquired and released using the render method.A write lock is acquired by the methods that mutate the document, and are held for the duration of the method call.Notification is done on the thread that produced the mutation, and the thread has full read access to the document for the duration of the notification, but other readers are kept out until the notification has finished.The notification is a beans event notification which does not allow any further mutations until all listeners have been notified.Any models subclassed from this class and used in conjunction with a text component that has a look and feel implementation that is derived from BasicTextUI may be safely updated asynchronously, because all access to the View hierarchy is serialized by BasicTextUI if the document is of type AbstractDocument.The locking assumes that an independent thread will access the View hierarchy only from the DocumentListener methods, and that there will be only one event thread active at a time.If concurrency support is desired, there are the following additional implications.The code path for any DocumentListener implementation and any UndoListener implementation must be threadsafe, and not access the component lock if trying to be safe from deadlocks.The repaint and revalidate methods on JComponent are safe.Among other things this allows you to position the caret after the last character.As a result of this, getLength returns one less than the length of the Content.If you create your own Content, be sure and initialize it to have an additional character.Another implication of this is that Elements that model the implied end character will have an endOffset ==Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "An implementation of ElementChange that can be added to the document event."},
{"description": "Interface to describe a sequence of character content that can be edited.Implementations may or may not support a history mechanism which will be reflected by whether or not mutations return an UndoableEdit implementation."},
{"description": "An interface that can be used to allow MutableAttributeSet implementations to use pluggable attribute compression techniques.Each mutation of the attribute set can be used to exchange a previous AttributeSet instance with another, preserving the possibility of the AttributeSet remaining immutable.An implementation is provided by the StyleContext class.The Element implementations provided by this class use this interface to provide their MutableAttributeSet implementations, so that different AttributeSet compression techniques can be employed.The method getAttributeContext should be implemented to return the object responsible for implementing the desired compression technique."},
{"description": "This is the abstract superclass for color choosers.If you want to add a new color chooser panel into a JColorChooser, subclass this class.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The AnnotationValueVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new abstract annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "This class provides a skeletal implementation of the Collection interface, to minimize the effort required to implement this interface.To implement an unmodifiable collection, the programmer needs only to extend this class and provide implementations for the iterator and size methods.(The iterator returned by the iterator method must implement hasNext and next.)To implement a modifiable collection, the programmer must additionally override this class's add method (which otherwise throws an UnsupportedOperationException), and the iterator returned by the iterator method must additionally implement its remove method.The programmer should generally provide a void (no argument) and Collection constructor, as per the recommendation in the Collection interface specification.The documentation for each non-abstract method in this class describes its implementation in detail.Each of these methods may be overridden if the collection being implemented admits a more efficient implementation.This class is a member of the Java Collections Framework."},
{"description": "The main date and time API is built on the ISO calendar system.The chronology operates behind the scenes to represent the general concept of a calendar system."},
{"description": "The AnnotationValueVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new abstract annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "Buttons can be configured, and to some degree controlled, by Actions.Using an Action with a button has many benefits beyond directly configuring a button.Refer to Swing Components Supporting Action for more details, and you can find more information in How to Use Actions, a section in The Java Tutorial.For further information see How to Use Buttons, Check Boxes, and Radio Buttons, a section in The Java Tutorial.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "A class that implements an empty border with no size.This provides a convenient base class from which other border classes can be easily derived.Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."},
{"description": "The AnnotationValueVisitor interface implemented by this class may have methods added to it in the future to accommodate new, currently unknown, language structures added to future versions of the Java\u2122 programming language.Therefore, methods whose names begin with \"visit\" may be added to this class in the future; to avoid incompatibilities, classes which extend this class should not declare any instance methods with names beginning with \"visit\".When such a new visit method is added, the default implementation in this class will be to call the visitUnknown method.A new abstract annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question.When the new visitor is introduced, all or portions of this visitor may be deprecated.Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a default method directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations.Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation."},
{"description": "Warning: Serialized objects of this class will not be compatible with future Swing releases.The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing.As of 1.4, support for long term storage of all JavaBeans\u2122 has been added to the java.beans package."}
]